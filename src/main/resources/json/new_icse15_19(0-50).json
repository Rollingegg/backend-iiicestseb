{"title": "Statistical Errors in Software Engineering Experiments: A Preliminary Literature Review", "authors": [{"name": "Rolando P. Reyes Ch.", "affiliation": "Univ. Politec. de Madrid, Madrid, Spain", "firstName": "Rolando P.", "lastName": "Reyes Ch."}, {"name": "Oscar Dieste", "affiliation": "Univ. Politec. de Madrid, Madrid, Spain", "firstName": "Oscar", "lastName": "Dieste"}, {"name": "Efra\u00edn R. Fonseca C.", "affiliation": "", "firstName": "Efra\u00edn R.", "lastName": "Fonseca C."}, {"name": "Natalia Juristo", "affiliation": "Univ. Politec. de Madrid, Madrid, Spain", "firstName": "Natalia", "lastName": "Juristo"}], "abstract": "Background: Statistical concepts and techniques are often applied incorrectly, even in mature disciplines such as medicine or psychology. Surprisingly, there are very few works that study statistical problems in software engineering (SE). Aim: Assess the existence of statistical errors in SE experiments. Method: Compile the most common statistical errors in experimental disciplines. Survey experiments published in ICSE to assess whether errors occur in high quality SE publications. Results: The same errors as identified in others disciplines were found in ICSE experiments, where 30 of the reviewed papers included several error types such as: a) missing statistical hypotheses, b) missing sample size calculation, c) failure to assess statistical test assumptions, and d) uncorrected multiple testing. This rather large error rate is greater for research papers where experiments are confined to the validation section. The origin of the errors can be traced back to: a) researchers not having sufficient statistical training, and b) a profusion of exploratory research. Conclusions: This paper provides preliminary evidence that SE research suffers from the same statistical problems as other experimental disciplines. However, the SE community appears to be unaware of any shortcomings in its experiments, whereas other disciplines work hard to avoid these threats. Further research is necessary to find the underlying causes and set up corrective measures, but there are some potentially effective actions and are a priori easy to implement: a) improve the statistical training of SE researchers, and b) enforce quality assessment and reporting guidelines in SE publications.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software engineering", "Bibliographies", "Training", "Guidelines", "Error analysis", "Back"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["psychology", "research and development", "software engineering", "statistical testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["software engineering experiments", "SE experiments", "high quality SE publications", "ICSE experiments", "statistical hypotheses", "statistical test assumptions", "SE community", "SE researchers", "quality assessment", "statistical errors", "statistical training", "SE research"]}, {"type": "Author Keywords ", "kwd": ["Literature review", "Survey", "Prevalence", "Statistical errors"]}], "publication": "2018 IEEE/ACM 40th International Conference on Software Engineering (ICSE)", "doi": "10.1145/3180155.3180161", "ref": [], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8453201", "articleId": "8453201", "startPage": "1195", "endPage": "1206", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8452039/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8453044", "publisher": "IEEE", "confLoc": "Gothenburg, Sweden", "chronDate": "May 27 2018-June 3 2018", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 84}}
{"title": "3rd FME Workshop on Formal Methods in Software Engineering (FormaliSE 2015)", "authors": [{"name": "Stefania Gnesi", "affiliation": "", "firstName": "Stefania", "lastName": "Gnesi", "id": "37282428500"}, {"name": "Nico Plat", "affiliation": "", "firstName": "Nico", "lastName": "Plat", "id": "37622184000"}], "abstract": "Despite their significant advantages, formal methods are not widely used in industrial software development. Following the successful workshops we organized at ICSE 2103 in San Francisco, and ICSE 2014 in Hyderabad, we organize a third edition of the FormaliSE workshop with the main goal to promote the integration between the formal methods and the software engineering communities.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software", "Conferences", "Software engineering", "Security", "Committees", "Industries", "Collaboration"]}, {"type": "Author Keywords ", "kwd": ["Formal methods", "Software engineering"]}], "publication": "2015 IEEE/ACM 37th IEEE International Conference on Software Engineering", "doi": "10.1109/ICSE.2015.313", "ref": [], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7203136", "articleId": "7203136", "startPage": "977", "endPage": "978", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7174815/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7202933", "publisher": "IEEE", "confLoc": "Florence, Italy", "chronDate": "16-24 May 2015", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 92}}
{"title": "A Novel Neural Source Code Representation Based on Abstract Syntax Tree", "authors": [{"name": "Jian Zhang", "affiliation": "Beihang University, China; Beijing Advanced Innovation Center for Big Data and Brain Computing, China", "firstName": "Jian", "lastName": "Zhang", "id": "37086950750"}, {"name": "Xu Wang", "affiliation": "Beihang University, China; Beijing Advanced Innovation Center for Big Data and Brain Computing, China", "firstName": "Xu", "lastName": "Wang", "id": "37601040400"}, {"name": "Hongyu Zhang", "affiliation": "The University of Newcastle, Australia", "firstName": "Hongyu", "lastName": "Zhang", "id": "37085471743"}, {"name": "Hailong Sun", "affiliation": "Beihang University, China; Beijing Advanced Innovation Center for Big Data and Brain Computing, China", "firstName": "Hailong", "lastName": "Sun", "id": "37277693100"}, {"name": "Kaixuan Wang", "affiliation": "Beihang University, China; Beijing Advanced Innovation Center for Big Data and Brain Computing, China", "firstName": "Kaixuan", "lastName": "Wang", "id": "37086947467"}, {"name": "Xudong Liu", "affiliation": "Beihang University, China; Beijing Advanced Innovation Center for Big Data and Brain Computing, China", "firstName": "Xudong", "lastName": "Liu", "id": "37292955400"}], "abstract": "Exploiting machine learning techniques for analyzing programs has attracted much attention. One key problem is how to represent code fragments well for follow-up analysis. Traditional information retrieval based methods often treat programs as natural language texts, which could miss important semantic information of source code. Recently, state-of-the-art studies demonstrate that abstract syntax tree (AST) based neural models can better represent source code. However, the sizes of ASTs are usually large and the existing models are prone to the long-term dependency problem. In this paper, we propose a novel AST-based Neural Network (ASTNN) for source code representation. Unlike existing models that work on entire ASTs, ASTNN splits each large AST into a sequence of small statement trees, and encodes the statement trees to vectors by capturing the lexical and syntactical knowledge of statements. Based on the sequence of statement vectors, a bidirectional RNN model is used to leverage the naturalness of statements and finally produce the vector representation of a code fragment. We have applied our neural network based source code representation method to two common program comprehension tasks: source code classification and code clone detection. Experimental results on the two tasks indicate that our model is superior to state-of-the-art approaches.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Syntactics", "Cloning", "Semantics", "Neural networks", "Task analysis", "Binary trees", "Natural languages"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["information retrieval", "learning (artificial intelligence)", "natural language processing", "program diagnostics", "recurrent neural nets", "text analysis", "tree data structures"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["abstract syntax tree", "code fragment", "natural language texts", "ASTNN", "statement trees", "statement vectors", "bidirectional RNN model", "vector representation", "source code representation method", "source code classification", "code clone detection", "program analysis", "program comprehension tasks", "AST-based Neural Network", "neural source code representation", "information retrieval", "machine learning"]}, {"type": "Author Keywords ", "kwd": ["Abstract Syntax Tree, source code representation, neural network, code classification, code clone detection"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00086", "ref": [{"order": "1", "text": "G. Frantzeskou, S. MacDonell, E. Stamatatos, S. Gritzalis, \"Exam-ining the significance of high-level programming features in source code author classification\", <em>Journal of Systems and Software</em>, vol. 81, no. 3, pp. 447-460, 2008.", "title": "Exam-ining the significance of high-level programming features in source code author classification", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec1", "text": " For example, programs are represented by token sequences or bag of tokens for code clone detection [3], [4], bug localization[11], and code authorship classification [1].", "part": "1"}, {"sec": "sec6a", "text": " Based on the statistical and machine learning methods, the n-gram model [1] and SVM [45] are used for classifying source code authorship and domains.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2007.03.004", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exam-ining+the+significance+of+high-level+programming+features+in+source+code+author+classification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "L. Mou, G. Li, L. Zhang, T. Wang, Z. Jin, \"Convolutional neural networks over tree structures for programming language processing\", <em>AAAI</em>, vol. 2, no. 3, pp. 4, 2016.", "title": "Convolutional neural networks over tree structures for programming language processing", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec1", "text": " Even though code fragments have something in common with plain texts, they should not be simply dealt with text-based or token-based methods due to their richer and more explicit structural information [2], [18].", "part": "1"}, {"sec": "sec1", "text": "Recent work [2], [5], [6] provides the strong evidence that syntactic knowledge contributes more in modeling source code and can obtain better representation than traditional token-based methods.", "part": "1"}, {"sec": "sec1", "text": " These approaches combine Abstract Syntax Tree (AST)and Recursive Neural Network (RvNN)[5], Tree-based CNN [2] or Tree-LSTM [6] to capture both the lexical (i.e., the leaf nodes of ASTs such as identifiers)and syntactical (i.e., the non-leaf nodes of ASTs like the grammar construct WhileStatement) information.", "part": "1"}, {"sec": "sec1", "text": " As a result, traversing and encoding entire ASTs in a bottom-up way [5], [6] or using the sliding window technique [2] may lose long-term context information [19], [22]; Second, these approaches either transform ASTs to or directly view ASTs as full binary trees for simplification and efficiency, which destroys the original syntactic structure of source code and even make ASTs much deeper.", "part": "1"}, {"sec": "sec2b2", "text": "TBCNN performs convolution computation over tree structures for supervised learning such as source code classification [2].", "part": "1"}, {"sec": "sec3b2", "text": " However, generally batch processing on multiway ST-trees makes it difficult since the number of children nodes varies for the parent nodes in the same position of one batch [2], [6].", "part": "1"}, {"sec": "sec4", "text": "This task aims to classify code fragments by their functionalities, which is useful for program understanding and maintenance [2], [44], [45].", "part": "1"}, {"sec": "sec5a", "text": " [2]. 22https://sites.google.com/site/treebasedcnn/.", "part": "1"}, {"sec": "sec5c1", "text": " Apart from the state-of-the-art model TBCNN [2], we also take into account of traditional and other neural network based approaches including SVMs with statistical features, TextCNN [50], LSTM [51], LSCNN [52] and PDG-based Graph embedding approaches [25], [26] as follows:\n\n\n\u2022\nSVMs.", "part": "1"}, {"sec": "sec6a", "text": " TBCNN [2] uses custom convolutional neural network on ASTs to learn vector representations of code snippets.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Convolutional+neural+networks+over+tree+structures+for+programming+language+processing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "T. Kamiya, S. Kusumoto, K. Inoue, \"CCFinder: a multilinguistic token-based code clone detection system for large scale source code\", <em>IEEE Transactions on Software Engineering</em>, vol. 28, no. 7, pp. 654-670, 2002.", "title": "CCFinder: a multilinguistic token-based code clone detection system for large scale source code", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec1", "text": " For example, programs are represented by token sequences or bag of tokens for code clone detection [3], [4], bug localization[11], and code authorship classification [1].", "part": "1"}, {"sec": "sec4", "text": "Detecting code clones is widely studied in software engineering research [3]\u2013[26], which is to detect whether two code fragments implement the same functionality.", "part": "1"}, {"sec": "sec6a", "text": " Programs are transformed to regularized token sequences for code clone detection [3].", "part": "1"}], "links": {"documentLink": "/document/1019480", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1019480", "abstract": "A code clone is a code portion in source files that is identical or similar to another. Since code clones are believed to reduce the maintainability of software, several code clone detection techniques and tools have been proposed. This paper proposes a new clone detection technique, which consists of the transformation of input source text and a token-by-token comparison. For its implementation with several useful optimization techniques, we have developed a tool, named CCFinder (Code Clone Fin...", "pdfSize": "4706KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CCFinder%3A+a+multilinguistic+token-based+code+clone+detection+system+for+large+scale+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "H. Sajnani, V. Saini, J. Svajlenko, C. K. Roy, C. V. Lopes, \"SourcererCC: Scaling code clone detection to big-code\", <em>Software Engineering (ICSE) 2016 IEEE/ACM 38th International Conference</em>, pp. 1157-1168, 2016.", "title": "SourcererCC: Scaling code clone detection to big-code", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[4][6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec1", "text": " For example, programs are represented by token sequences or bag of tokens for code clone detection [3], [4], bug localization[11], and code authorship classification [1].", "part": "1"}, {"sec": "sec4", "text": "Detecting code clones is widely studied in software engineering research [3]\u2013[4][26], which is to detect whether two code fragments implement the same functionality.", "part": "1"}, {"sec": "sec6a", "text": " SourcererCC [4] has an improvement by exploiting token ordering along with an optimized inverted-index technique.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884877", "abstract": "Despite a decade of active research, there has been a marked lack in clone detection techniques that scale to large repositories for detecting near-miss clones. In this paper, we present a token-based clone detector, SourcererCC, that can detect both exact and near-miss clones from large inter-project repositories using a standard workstation. It exploits an optimized inverted-index to quickly query the potential clones of a given code block. Filtering heuristics based on token ordering are used...", "pdfSize": "479KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SourcererCC%3A+Scaling+code+clone+detection+to+big-code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "M. White, M. Tufano, C. Vendome, D. Poshyvanyk, \"Deep learning code fragments for code clone detection\", <em>Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 87-98, 2016.", "title": "Deep learning code fragments for code clone detection", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[5][6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec1", "text": "Recent work [2], [5], [6] provides the strong evidence that syntactic knowledge contributes more in modeling source code and can obtain better representation than traditional token-based methods.", "part": "1"}, {"sec": "sec1", "text": " These approaches combine Abstract Syntax Tree (AST)and Recursive Neural Network (RvNN)[5], Tree-based CNN [2] or Tree-LSTM [6] to capture both the lexical (i.e., the leaf nodes of ASTs such as identifiers)and syntactical (i.e., the non-leaf nodes of ASTs like the grammar construct WhileStatement) information.", "part": "1"}, {"sec": "sec1", "text": " As a result, traversing and encoding entire ASTs in a bottom-up way [5], [6] or using the sliding window technique [2] may lose long-term context information [19], [22]; Second, these approaches either transform ASTs to or directly view ASTs as full binary trees for simplification and efficiency, which destroys the original syntactic structure of source code and even make ASTs much deeper.", "part": "1"}, {"sec": "sec2b1", "text": " Based on RvNN, a recursive autoencoder (RAE)is incorporated for automatically encoding ASTs to detect code clones [5], where ASTs are transformed to full binary trees due to the fixed-size inputs for simplification.", "part": "1"}, {"sec": "sec3a", "text": " If the size of selected granularity is too large (e.g., the full AST), similar to the related work [5], [6], we may also experience the gradient vanishing problem mentioned in Section II.", "part": "1"}, {"sec": "sec3b1", "text": " If we transform the ST-tree to one binary tree as described in [5], [6], for example, moving the node of readText to one child node or descendant of the FormalParameter node, the original semantics may be destroyed.", "part": "1"}, {"sec": "sec4", "text": "Detecting code clones is widely studied in software engineering research [3]\u2013[5][26], which is to detect whether two code fragments implement the same functionality.", "part": "1"}, {"sec": "sec5a", "text": " As benchmarks, the two datasets have been used by many researchers concerning on code similarity [48], [49] and clone detection [5], [6].", "part": "1"}, {"sec": "sec5c2", "text": " We compare our approach with existing state-of-the-art neural models for clone detection including RAE [5] and CDLH [6].", "part": "1"}, {"sec": "sec6a", "text": " [5] exploits a recursive auto-encoder over the ASTs with pre-trained token embeddings.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970326", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+learning+code+fragments+for+code+clone+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "H.-H. Wei, M. Li, \"Supervised deep features for software functional clone detection by exploiting lexical and syntactical information in source code\", <em>Proceedings of the 26th International Joint Conference on Artificial Intelligence</em>, pp. 3034-3040, 2017.", "title": "Supervised deep features for software functional clone detection by exploiting lexical and syntactical information in source code", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec1", "text": "Recent work [2], [5], [6] provides the strong evidence that syntactic knowledge contributes more in modeling source code and can obtain better representation than traditional token-based methods.", "part": "1"}, {"sec": "sec1", "text": " These approaches combine Abstract Syntax Tree (AST)and Recursive Neural Network (RvNN)[5], Tree-based CNN [2] or Tree-LSTM [6] to capture both the lexical (i.e., the leaf nodes of ASTs such as identifiers)and syntactical (i.e., the non-leaf nodes of ASTs like the grammar construct WhileStatement) information.", "part": "1"}, {"sec": "sec1", "text": " As a result, traversing and encoding entire ASTs in a bottom-up way [5], [6] or using the sliding window technique [2] may lose long-term context information [19], [22]; Second, these approaches either transform ASTs to or directly view ASTs as full binary trees for simplification and efficiency, which destroys the original syntactic structure of source code and even make ASTs much deeper.", "part": "1"}, {"sec": "sec2b3", "text": " CDLH [6] uses Tree-Lstm to learn representations of code fragments for clone detection where code fragments are parsed to ASTs.", "part": "1"}, {"sec": "sec2c", "text": " For example, CDLH [6] can only have the F1 value of 57% in one public benchmark for clone detection, and the studies in NLP [23], [41], [21] show that the tree size and depth do matter and have significant impact on the performance.", "part": "1"}, {"sec": "sec3a", "text": " If the size of selected granularity is too large (e.g., the full AST), similar to the related work [5], [6], we may also experience the gradient vanishing problem mentioned in Section II.", "part": "1"}, {"sec": "sec3b1", "text": " If we transform the ST-tree to one binary tree as described in [5], [6], for example, moving the node of readText to one child node or descendant of the FormalParameter node, the original semantics may be destroyed.", "part": "1"}, {"sec": "sec3b2", "text": " However, generally batch processing on multiway ST-trees makes it difficult since the number of children nodes varies for the parent nodes in the same position of one batch [2], [6].", "part": "1"}, {"sec": "sec4", "text": "Detecting code clones is widely studied in software engineering research [3]\u2013[6][26], which is to detect whether two code fragments implement the same functionality.", "part": "1"}, {"sec": "sec5a", "text": " As benchmarks, the two datasets have been used by many researchers concerning on code similarity [48], [49] and clone detection [5], [6].", "part": "1"}, {"sec": "sec5c2", "text": "As Table I shows, similar to the previous work [6], we choose 500 programs from each of the first 15 programming problems in OJ, namely OJClone.", "part": "1"}, {"sec": "sec5c2", "text": " We compare our approach with existing state-of-the-art neural models for clone detection including RAE [5] and CDLH [6].", "part": "1"}, {"sec": "sec5d", "text": " In Table III, as mentioned before, we cite the results of CDLH from [6].", "part": "1"}, {"sec": "sec5d", "text": " The BCB-ALL is a weighted sum result according to the percentage of various clone types [6].", "part": "1"}, {"sec": "sec6a", "text": " CDLH [6] incorporates Tree-LSTM to represent the functionality semantics of code fragments.", "part": "1"}, {"sec": "sec7", "text": " This leads to the uncertainty about whether they are true clone pairs, although similar practice has been done by previous work [6].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.24963/ijcai.2017/423", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supervised+deep+features+for+software+functional+clone+detection+by+exploiting+lexical+and+syntactical+information+in+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "M. Dambros, M. Lanza, R. Robbes, \"Evaluating defect prediction approaches: a benchmark and an extensive comparison\", <em>Empirical Software Engineering</em>, vol. 17, no. 4-5, pp. 531-577, 2012.", "title": "Evaluating defect prediction approaches: a benchmark and an extensive comparison", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-011-9173-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+defect+prediction+approaches%3A+a+benchmark+and+an+extensive+comparison&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "C. Tantithamthavorn, S. McIntosh, A. E. Hassan, K. Matsumoto, \"An empirical comparison of model validation techniques for defect prediction models\", <em>IEEE Transactions on Software Engineering</em>, vol. 43, no. 1, pp. 1-18, 2017.", "title": "An empirical comparison of model validation techniques for defect prediction models", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}], "links": {"documentLink": "/document/7497471", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7497471", "abstract": "Defect prediction models help software quality assurance teams to allocate their limited resources to the most defect-prone modules. Model validation techniques, such as $k$ -fold cross-validation, use historical data to estimate how well a model will perform in the future. However, little is known about how accurate the estimates of model validation techniques tend to be. In this paper, we investigate the bias and variance of model validation techniques in the domain of defect prediction. Analy...", "pdfSize": "2074KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+comparison+of+model+validation+techniques+for+defect+prediction+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "S. Haiduc, J. Aponte, A. Marcus, \"Supporting program comprehension with source code summarization\", <em>Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering-Volume 2</em>, pp. 223-226, 2010.", "title": "Supporting program comprehension with source code summarization", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1810295.1810335", "abstract": "One of the main challenges faced by today&#39;s developers is keeping up with the staggering amount of source code that needs to be read and understood. In order to help developers with this problem and reduce the costs associated with it, one solution is to use simple textual descriptions of source code entities that developers can grasp easily, while capturing the code semantics precisely. We propose an approach to automatically determine such descriptions, based on automated text summarization te...", "pdfSize": "166KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+program+comprehension+with+source+code+summarization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S. Jiang, A. Armaly, C. McMillan, \"Automatically generating commit messages from diffs using neural machine translation\", <em>Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 135-146, 2017.", "title": "Automatically generating commit messages from diffs using neural machine translation", "context": [{"sec": "sec1", "text": "Many software engineering methods, such as source code classification [1], [2], code clone detection [3]\u2013[6], defect prediction [7], [8] and code summarization [9], [10] have been proposed to improve software development and maintenance.", "part": "1"}, {"sec": "sec6b", "text": " The neural machine translation is used to automatically generate commit messages [10].", "part": "1"}], "links": {"documentLink": "/document/8115626", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115626", "abstract": "Commit messages are a valuable resource in comprehension of software evolution, since they provide a record of changes such as feature additions and bug repairs. Unfortunately, programmers often neglect to write good commit messages. Different techniques have been proposed to help programmers by automatically writing these messages. These techniques are effective at describing what changed, but are often verbose and lack context for understanding the rationale behind a change. In contrast, human...", "pdfSize": "732KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+generating+commit+messages+from+diffs+using+neural+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "J. Zhou, H. Zhang, D. Lo, \"Where should the bugs be fixed? more accurate information retrieval-based bug localization based on bug reports\", <em>2012 34th International Conference on Software Engineering (ICSE)</em>, pp. 14-24, June 2012.", "title": "Where should the bugs be fixed? more accurate information retrieval-based bug localization based on bug reports", "context": [{"sec": "sec1", "text": " For example, programs are represented by token sequences or bag of tokens for code clone detection [3], [4], bug localization[11], and code authorship classification [1].", "part": "1"}], "links": {"documentLink": "/document/6227210", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227210", "abstract": "For a large and evolving software system, the project team could receive a large number of bug reports. Locating the source code files that need to be changed in order to fix the bugs is a challenging task. Once a bug report is received, it is desirable to automatically point out to the files that developers should change in order to fix the bug. In this paper, we propose BugLocator, an information retrieval based method for locating the relevant files for fixing a bug. BugLocator ranks all file...", "pdfSize": "343KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Where+should+the+bugs+be+fixed%3F+more+accurate+information+retrieval-based+bug+localization+based+on+bug+reports&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "S. Deerwester, S. T. Dumais, G. W. Furnas, T. K. Landauer, R. Harshman, \"Indexing by latent semantic analysis\", <em>Journal of the American society for information science</em>, vol. 41, no. 6, pp. 391, 1990.", "title": "Indexing by latent semantic analysis", "context": [{"sec": "sec1", "text": " In addition, a number of researchers use Latent Semantic Indexing (LSI)[12] and Latent Dirichlet Allocation (LDA)[13] to analyze source code [14]\u2013[16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/(SICI)1097-4571(199009)41:6&lt;391::AID-ASI1&gt;3.0.CO;2-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Indexing+by+latent+semantic+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "D. M. Blei, A. Y. Ng, M. I. Jordan, \"Latent dirichlet allocation\", <em>Journal of machine Learning research</em>, vol. 3, no. Jan, pp. 993-1022, 2003.", "title": "Latent dirichlet allocation", "context": [{"sec": "sec1", "text": " In addition, a number of researchers use Latent Semantic Indexing (LSI)[12] and Latent Dirichlet Allocation (LDA)[13] to analyze source code [14]\u2013[16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Latent+dirichlet+allocation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "R. Tairas, J. Gray, \"An information retrieval process to aid in the analysis of code clones\", <em>Empirical Software Engineering</em>, vol. 14, no. 1, pp. 33-56, 2009.", "title": "An information retrieval process to aid in the analysis of code clones", "context": [{"sec": "sec1", "text": " In addition, a number of researchers use Latent Semantic Indexing (LSI)[12] and Latent Dirichlet Allocation (LDA)[13] to analyze source code [14]\u2013[16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-008-9089-1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+information+retrieval+process+to+aid+in+the+analysis+of+code+clones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Y. Liu, D. Poshyvanyk, R. Ferenc, T. Gyim\u00f3thy, N. Chrisochoides, \"Modeling class cohesion as mixtures of latent topics\", <em>Software Maintenance 2009. ICSM 2009. IEEE International Conference</em>, pp. 233-242, 2009.", "title": "Modeling class cohesion as mixtures of latent topics", "context": [{"sec": "sec1", "text": " In addition, a number of researchers use Latent Semantic Indexing (LSI)[12] and Latent Dirichlet Allocation (LDA)[13] to analyze source code [14]\u2013[15][16].", "part": "1"}, {"sec": "sec6a", "text": " Maletic et al. [56] adopts LSI to identify semantic similarities of code fragments, and the cohesion of classes in software is evaluated by LDA [15].", "part": "1"}], "links": {"documentLink": "/document/5306318", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5306318", "abstract": "The paper proposes a new measure for the cohesion of classes in object-oriented software systems. It is based on the analysis of latent topics embedded in comments and identifiers in source code. The measure, named as maximal weighted entropy, utilizes the latent Dirichlet allocation technique and information entropy measures to quantitatively evaluate the cohesion of classes in software. This paper presents the principles and the technology that stand behind the proposed measure. Two case studi...", "pdfSize": "420KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+class+cohesion+as+mixtures+of+latent+topics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "A. De Lucia, M. Di Penta, R. Oliveto, A. Panichella, S. Panichella, \"Using IR methods for labeling source code artifacts: Is it worthwhile?\", <em>Program Comprehension (ICPC) 2012 IEEE 20th International Conference</em>, pp. 193-202, 2012.", "title": "Using IR methods for labeling source code artifacts: Is it worthwhile?", "context": [{"sec": "sec1", "text": " In addition, a number of researchers use Latent Semantic Indexing (LSI)[12] and Latent Dirichlet Allocation (LDA)[13] to analyze source code [14]\u2013[16].", "part": "1"}], "links": {"documentLink": "/document/6240488", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6240488", "abstract": "Information Retrieval (IR) techniques have been used for various software engineering tasks, including the labeling of software artifacts by extracting \u201ckeywords\u201d from them. Such techniques include Vector Space Models, Latent Semantic Indexing, Latent Dirichlet Allocation, as well as customized heuristics extracting words from specific source code elements. This paper investigates how source code artifact labeling performed by IR techniques would overlap (and differ) from labeling performed by h...", "pdfSize": "595KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+IR+methods+for+labeling+source+code+artifacts%3A+Is+it+worthwhile%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "A. Panichella, B. Dit, R. Oliveto, M. Di Penta, D. Poshynanyk, A. De Lucia, \"How to effectively use topic models for software engineering tasks? an approach based on genetic algorithms\", <em>Software Engineering (ICSE) 2013 35th International Conference</em>, pp. 522-531, 2013.", "title": "How to effectively use topic models for software engineering tasks? an approach based on genetic algorithms", "context": [{"sec": "sec1", "text": " However, according to [17], the common problem of these approaches is that they assume the underlying corpus (i.e., the source code)is composed of natural language texts.", "part": "1"}, {"sec": "sec2a", "text": " Due to the limitation of token-based approaches [17], these methods can catch little syntactical information of source code.", "part": "1"}], "links": {"documentLink": "/document/6606598", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6606598", "abstract": "Information Retrieval (IR) methods, and in particular topic models, have recently been used to support essential software engineering (SE) tasks, by enabling software textual retrieval and analysis. In all these approaches, topic models have been used on software artifacts in a similar manner as they were used on natural language documents (e.g., using the same settings and parameters) because the underlying assumption was that source code and natural language documents are similar. However, app...", "pdfSize": "392KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+effectively+use+topic+models+for+software+engineering+tasks%3F+an+approach+based+on+genetic+algorithms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "J. F. Pane, B. A. Myers et al., \"Studying the language and structure in non-programmers' solutions to programming problems\", <em>International Journal of Human-Computer Studies</em>, vol. 54, no. 2, pp. 237-264, 2001.", "title": "Studying the language and structure in non-programmers' solutions to programming problems", "context": [{"sec": "sec1", "text": " Even though code fragments have something in common with plain texts, they should not be simply dealt with text-based or token-based methods due to their richer and more explicit structural information [2], [18].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1006/ijhc.2000.0410", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Studying+the+language+and+structure+in+non-programmers%27+solutions+to+programming+problems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "Y. Bengio, P. Simard, P. Frasconi, \"Learning long-term dependencies with gradient descent is difficult\", <em>IEEE transactions on neural networks</em>, vol. 5, no. 2, pp. 157-166, 1994.", "title": "Learning long-term dependencies with gradient descent is difficult", "context": [{"sec": "sec1", "text": " First, similar to long texts in NLP, these tree-based neural models are also vulnerable to the gradient vanishing problem that the gradient becomes vanishingly small during training, especially when the tree is very large and deep [19]\u2013[21].", "part": "1"}, {"sec": "sec1", "text": " As a result, traversing and encoding entire ASTs in a bottom-up way [5], [6] or using the sliding window technique [2] may lose long-term context information [19], [22]; Second, these approaches either transform ASTs to or directly view ASTs as full binary trees for simplification and efficiency, which destroys the original syntactic structure of source code and even make ASTs much deeper.", "part": "1"}, {"sec": "sec2c", "text": " Thus the bottom-up computations from the leaf nodes to the root nodes may experience the gradient vanishing problem and are difficult to capture long-range dependencies [19], [22], which will miss some of the semantics carried by distant nodes from the root nodes such as identifiers in the leaf nodes.", "part": "1"}], "links": {"documentLink": "/document/279181", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=279181", "abstract": "Recurrent neural networks can be used to map input sequences to output sequences, such as for recognition, production or prediction problems. However, practical difficulties have been reported in training recurrent neural networks to perform tasks in which the temporal contingencies present in the input/output sequences span long intervals. We show why gradient based learning algorithms face an increasingly difficult problem as the duration of the dependencies to be captured increases. These res...", "pdfSize": "1180KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+long-term+dependencies+with+gradient+descent+is+difficult&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "S. Hochreiter, \"The vanishing gradient problem during learning recurrent neural nets and problem solutions\", <em>Int. J. Uncertain Fuzziness Knowl.-Based Syst.</em>, vol. 6, no. 2, pp. 107-116, Apr. 1998.", "title": "The vanishing gradient problem during learning recurrent neural nets and problem solutions", "context": [{"sec": "sec1", "text": " First, similar to long texts in NLP, these tree-based neural models are also vulnerable to the gradient vanishing problem that the gradient becomes vanishingly small during training, especially when the tree is very large and deep [19]\u2013[20][21].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1142/S0218488598000094", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+vanishing+gradient+problem+during+learning+recurrent+neural+nets+and+problem+solutions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "P. Le, W. H. Zuidema, \"Quantifying the vanishing gradient and long distance dependency problem in recursive neural networks and recursive LSTMs\", <em>Proceedings of the 1st Workshop on Representation Learning for NLP</em>, 2016.", "title": "Quantifying the vanishing gradient and long distance dependency problem in recursive neural networks and recursive LSTMs", "context": [{"sec": "sec1", "text": " First, similar to long texts in NLP, these tree-based neural models are also vulnerable to the gradient vanishing problem that the gradient becomes vanishingly small during training, especially when the tree is very large and deep [19]\u2013[21].", "part": "1"}, {"sec": "sec2c", "text": " For example, CDLH [6] can only have the F1 value of 57% in one public benchmark for clone detection, and the studies in NLP [23], [41], [21] show that the tree size and depth do matter and have significant impact on the performance.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18653/v1/W16-1610", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quantifying+the+vanishing+gradient+and+long+distance+dependency+problem+in+recursive+neural+networks+and+recursive+LSTMs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "S.-Y. Cho, Z. Chi, W.-C. Siu, A. C. Tsoi, \"An improved algorithm for learning long-term dependency problems in adaptive processing of data structures\", <em>IEEE Transactions on Neural Networks</em>, vol. 14, no. 4, pp. 781-793, 2003.", "title": "An improved algorithm for learning long-term dependency problems in adaptive processing of data structures", "context": [{"sec": "sec1", "text": " As a result, traversing and encoding entire ASTs in a bottom-up way [5], [6] or using the sliding window technique [2] may lose long-term context information [19], [22]; Second, these approaches either transform ASTs to or directly view ASTs as full binary trees for simplification and efficiency, which destroys the original syntactic structure of source code and even make ASTs much deeper.", "part": "1"}, {"sec": "sec2c", "text": " Thus the bottom-up computations from the leaf nodes to the root nodes may experience the gradient vanishing problem and are difficult to capture long-range dependencies [19], [22], which will miss some of the semantics carried by distant nodes from the root nodes such as identifiers in the leaf nodes.", "part": "1"}], "links": {"documentLink": "/document/1215396", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1215396", "abstract": "Many researchers have explored the use of neural-network representations for the adaptive processing of data structures. One of the most popular learning formulations of data structure processing is backpropagation through structure (BPTS). The BPTS algorithm has been successful applied to a number of learning tasks that involve structural patterns such as logo and natural scene classification. The main limitations of the BPTS algorithm are attributed to slow convergence speed and the long-term ...", "pdfSize": "1001KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+improved+algorithm+for+learning+long-term+dependency+problems+in+adaptive+processing+of+data+structures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "X. Zhu, P. Sobhani, H. Guo, \"Long short-term memory over recursive structures\", <em>Proceedings of the 32Nd International Conference on International Conference on Machine Learning</em>, vol. 37, pp. 1604-1612, 2015.", "title": "Long short-term memory over recursive structures", "context": [{"sec": "sec1", "text": " The transformed and deeper ASTs further weaken the capability of neural models to capture more real and complex semantics [23].", "part": "1"}, {"sec": "sec2c", "text": " First, during gradient-based training of tree topologies, the gradients are calculated via backpropagation over structures [41], [23].", "part": "1"}, {"sec": "sec2c", "text": " For example, CDLH [6] can only have the F1 value of 57% in one public benchmark for clone detection, and the studies in NLP [23], [41], [21] show that the tree size and depth do matter and have significant impact on the performance.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Long+short-term+memory+over+recursive+structures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "M. Ou, P. Cui, J. Pei, Z. Zhang, W. Zhu, \"Asymmetric transitivity preserving graph embedding\", <em>Proceedings of the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining</em>, pp. 1105-1114, 2016.", "title": "Asymmetric transitivity preserving graph embedding", "context": [{"sec": "sec1", "text": "In order to overcome the limitations of the above AST-based neural networks, one solution is to introduce explicit (long-term)control flow and data dependencies graphs and employ a Graph Embedding technique [24] to represent source code.", "part": "1"}, {"sec": "sec5c1", "text": " Most recently some studies [25], [26] construct program graphs by considering control flow and data flow dependencies, and adopt graph embedding techniques such as HOPE [24] and Gated Graph Neural Network (GGNN) [53] for code representation.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2939672.2939751", "abstract": "Graph embedding algorithms embed a graph into a vector space where the structure and the inherent properties of the graph are preserved. The existing graph embedding methods cannot preserve the asymmetric transitivity well, which is a critical property of directed graphs. Asymmetric transitivity depicts the correlation among directed edges, that is, if there is a directed path from u to v, then there is likely a directed edge from u to v. Asymmetric transitivity can help in capturing structures ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Asymmetric+transitivity+preserving+graph+embedding&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "M. Allamanis, M. Brockschmidt, M. Khademi, \"Learning to represent programs with graphs\", <em>International Conference on Learning Representations</em>, 2018,  [online]  Available: https://openreview.net/forum?id=BJOFETxR-.", "title": "Learning to represent programs with graphs", "context": [{"sec": "sec1", "text": " For instance, one recent study considers the long-range dependencies induced by the same variable or function in distant locations [25].", "part": "1"}, {"sec": "sec5c1", "text": " Apart from the state-of-the-art model TBCNN [2], we also take into account of traditional and other neural network based approaches including SVMs with statistical features, TextCNN [50], LSTM [51], LSCNN [52] and PDG-based Graph embedding approaches [25], [26] as follows:\n\n\n\u2022\nSVMs.", "part": "1"}, {"sec": "sec5c1", "text": " Most recently some studies [25], [26] construct program graphs by considering control flow and data flow dependencies, and adopt graph embedding techniques such as HOPE [24] and Gated Graph Neural Network (GGNN) [53] for code representation.", "part": "1"}, {"sec": "sec5c1", "text": " Based on the PDGs, we represents nodes of PDGs by the numerical ID of statements in HOPE [26], and average the embeddings of all tokens in each PDG node as its initial embedding [25] in GGNN66https://github.com/Microsoft/gated-graph-neural-network-samples.", "part": "1"}, {"sec": "sec5c1", "text": " Most recently some studies [25], [26] construct program graphs by considering control flow and data flow dependencies, and adopt graph embedding techniques such as HOPE [24] and Gated Graph Neural Network (GGNN) [53] for code representation.", "part": "1"}, {"sec": "sec5c1", "text": " Based on the PDGs, we represents nodes of PDGs by the numerical ID of statements in HOPE [26], and average the embeddings of all tokens in each PDG node as its initial embedding [25] in GGNN66https://github.com/Microsoft/gated-graph-neural-network-samples.", "part": "1"}, {"sec": "sec6a", "text": " [25] performs Gated Graph Neural Networks on program graphs which track the dependencies of the same variables and functions to predict variable names and detect variable misuses.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+to+represent+programs+with+graphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "G. B. M. D. P. M. W. Michele Tufano, Cody Watson, D. Poshyvanyk, \"Deep learning similarities from different representations of source code\", <em>15th International Conference on Mining Software Repositories</em>, 2018.", "title": "Deep learning similarities from different representations of source code", "context": [{"sec": "sec1", "text": " Another study directly constructs control flow graphs (CFGs)of code fragments [26].", "part": "1"}, {"sec": "sec4", "text": "Detecting code clones is widely studied in software engineering research [3]\u2013[26], which is to detect whether two code fragments implement the same functionality.", "part": "1"}, {"sec": "sec5c1", "text": " Apart from the state-of-the-art model TBCNN [2], we also take into account of traditional and other neural network based approaches including SVMs with statistical features, TextCNN [50], LSTM [51], LSCNN [52] and PDG-based Graph embedding approaches [25], [26] as follows:\n\n\n\u2022\nSVMs.", "part": "1"}, {"sec": "sec5c1", "text": " Most recently some studies [25], [26] construct program graphs by considering control flow and data flow dependencies, and adopt graph embedding techniques such as HOPE [24] and Gated Graph Neural Network (GGNN) [53] for code representation.", "part": "1"}, {"sec": "sec5c1", "text": " Based on the PDGs, we represents nodes of PDGs by the numerical ID of statements in HOPE [26], and average the embeddings of all tokens in each PDG node as its initial embedding [25] in GGNN66https://github.com/Microsoft/gated-graph-neural-network-samples.", "part": "1"}, {"sec": "sec5c1", "text": " Most recently some studies [25], [26] construct program graphs by considering control flow and data flow dependencies, and adopt graph embedding techniques such as HOPE [24] and Gated Graph Neural Network (GGNN) [53] for code representation.", "part": "1"}, {"sec": "sec5c1", "text": " Based on the PDGs, we represents nodes of PDGs by the numerical ID of statements in HOPE [26], and average the embeddings of all tokens in each PDG node as its initial embedding [25] in GGNN66https://github.com/Microsoft/gated-graph-neural-network-samples.", "part": "1"}, {"sec": "sec5d", "text": " In particular, PDG with HOPE gets an accuracy of only 4.2%, because the nodes of PDGs are represented by their numerical ID which miss lexical knowledge and only focuses on the explicit dependency information in a high abstraction level [26].", "part": "1"}, {"sec": "sec6a", "text": " Multiple different code representations such as identifiers, CFGs and bytecodes can also be integrated by the ensemble learning technique [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3196398.3196431", "abstract": "Assessing the similarity between code components plays a pivotal role in a number of Software Engineering (SE) tasks, such as clone detection, impact analysis, refactoring, etc. Code similarity is generally measured by relying on manually defined or hand-crafted features, e.g., by analyzing the overlap among identifiers or comparing the Abstract Syntax Trees of two code components. These features represent a best guess at what SE researchers can utilize to exploit and reliably assess code simila...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+learning+similarities+from+different+representations+of+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "J. Ferrante, K. J. Ottenstein, J. D. Warren, \"The program dependence graph and its use in optimization\", <em>ACM Trans. Program. Lang. Syst.</em>, vol. 9, no. 3, pp. 319-349, Jul. 1987.", "title": "The program dependence graph and its use in optimization", "context": [{"sec": "sec1", "text": " However, as depicted in the above work, precise and inter-procedural program dependency graphs (PDGs)(i.e. control flow and data flow dependencies)[27] usually rely on compiled intermediate representations or bytecodes [28], [29], and are not applicable to uncompilable and incomplete code fragments.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-12925-1_33", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+program+dependence+graph+and+its+use+in+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "E. M. Myers, \"A precise inter-procedural data flow algorithm\", <em>Proceedings of the 8th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, pp. 219-230, 1981.", "title": "A precise inter-procedural data flow algorithm", "context": [{"sec": "sec1", "text": " However, as depicted in the above work, precise and inter-procedural program dependency graphs (PDGs)(i.e. control flow and data flow dependencies)[27] usually rely on compiled intermediate representations or bytecodes [28], [29], and are not applicable to uncompilable and incomplete code fragments.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/567532.567556", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+precise+inter-procedural+data+flow+algorithm&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "\"Llvms analysis and transform passes\",  [online]  Available: https://llvm.org/docs/Passes.html.", "title": "Llvms analysis and transform passes", "context": [{"sec": "sec1", "text": " However, as depicted in the above work, precise and inter-procedural program dependency graphs (PDGs)(i.e. control flow and data flow dependencies)[27] usually rely on compiled intermediate representations or bytecodes [28], [29], and are not applicable to uncompilable and incomplete code fragments.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Llvms+analysis+and+transform+passes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "J. Gosling, B. Joy, G. L. Steele, G. Bracha, A. Buckley, The Java Language Specification Java SE 8 Edition, Addison-Wesley Professional, 2014.", "title": "The Java Language Specification, Java SE 8 Edition", "context": [{"sec": "sec1", "text": " Here statements refer to the Statement AST nodes defined in program language specification [30].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Java+Language+Specification%2C+Java+SE+8+Edition&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "T. Mikolov, M. Karafi\u00e1t, L. Burget, J. \u010cernock\u00fd, S. Khudanpur, \"Recurrent neural network based language model\", <em>Eleventh Annual Conference of the International Speech Communication Association</em>, 2010.", "title": "Recurrent neural network based language model", "context": [{"sec": "sec1", "text": " We use Recurrent Neural Network (RNN)[31] to encode statements and the sequential dependency between the statements into a vector.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Recurrent+neural+network+based+language+model&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "A. Hindle, E. T. Barr, Z. Su, M. Gabel, P. Devanbu, \"On the naturalness of software\", <em>Software Engineering (ICSE) 2012 34th International Conference</em>, pp. 837-847, 2012.", "title": "On the naturalness of software", "context": [{"sec": "sec1", "text": " Such a vector captures the naturalness of source code [32], [33] and can serve as a neural source code representation.", "part": "1"}], "links": {"documentLink": "/document/6227135", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227135", "abstract": "Natural languages like English are rich, complex, and powerful. The highly creative and graceful use of languages like English and Tamil, by masters like Shakespeare and Avvaiyar, can certainly delight and inspire. But in practice, given cognitive constraints and the exigencies of daily life, most human utterances are far simpler and much more repetitive and predictable. In fact, these utterances can be very usefully modeled using modern statistical methods. This fact has led to the phenomenal s...", "pdfSize": "383KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+naturalness+of+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "B. Ray, V. Hellendoorn, S. Godhane, Z. Tu, A. Bacchelli, P. Devanbu, \"On the \u201cnaturalness\u201d of buggy code\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 428-439, 2016.", "title": "On the \u201cnaturalness\u201d of buggy code", "context": [{"sec": "sec1", "text": " Such a vector captures the naturalness of source code [32], [33] and can serve as a neural source code representation.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884848", "abstract": "Real software, the kind working programmers produce by the kLOC to solve real-world problems, tends to be \u201cnatural\u201d, like speech or natural language; it tends to be highly repetitive and predictable. Researchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines, porting tools, coding standards checkers, and idiom miners. This suggests that code that appears improbable, or surprising, to a good statistical language model is \u201cu...", "pdfSize": "629KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+%E2%80%9Cnaturalness%E2%80%9D+of+buggy+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "D. Bahdanau, K. Cho, Y. Bengio, Neural machine translation by jointly learning to align and translate, 2014.", "title": "Neural machine translation by jointly learning to align and translate", "context": [{"sec": "sec1", "text": " Third, based on the sequence of statement vectors, we use bidirectional Gated Recurrent Unit (GRU)[34], [35], one type of recurrent neural network, to leverage the sequential naturalness of statements and finally obtain the vector representation of an entire code fragment.", "part": "1"}, {"sec": "sec3c", "text": "Based on the sequences of ST-tree vectors, we exploit GRU [34] to track the naturalness of statements.", "part": "1"}, {"sec": "sec3c", "text": "In order to further enhance the capability of the recurrent layer for capturing the dependency information, we adopt a bidirectional GRU [34], where the hidden states of both directions are concatenated to form the new states as follows:.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Neural+machine+translation+by+jointly+learning+to+align+and+translate&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "D. Tang, B. Qin, T. Liu, \"Document modeling with gated recurrent neural network for sentiment classification\", <em>Proceedings of the 2015 conference on empirical methods in natural language processing</em>, pp. 1422-1432, 2015.", "title": "Document modeling with gated recurrent neural network for sentiment classification", "context": [{"sec": "sec1", "text": " Third, based on the sequence of statement vectors, we use bidirectional Gated Recurrent Unit (GRU)[34], [35], one type of recurrent neural network, to leverage the sequential naturalness of statements and finally obtain the vector representation of an entire code fragment.", "part": "1"}, {"sec": "sec3", "text": " We then use Bidirectional Gated Recurrent Unit [35] (Bi-GRU), to model the naturalness of the statements.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18653/v1/D15-1167", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Document+modeling+with+gated+recurrent+neural+network+for+sentiment+classification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "I. D. Baxter, A. Yahin, L. Moura, M. Sant'Anna, L. Bier, \"Clone detection using abstract syntax trees\", <em>Software Maintenance 1998. Proceedings. International Conference</em>, pp. 368-377, 1998.", "title": "Clone detection using abstract syntax trees", "context": [{"sec": "sec2a", "text": "Abstract Syntax Tree (AST) is a kind of tree aimed at representing the abstract syntactic structure of the source code [36].", "part": "1"}], "links": {"documentLink": "/document/738528", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=738528", "abstract": "Existing research suggests that a considerable fraction (5-10%) of the source code of large scale computer programs is duplicate code (&#34;clones&#34;). Detection and removal of such clones promises decreased software maintenance costs of possibly the same magnitude. Previous work was limited to detection of either near misses differing only in single lexems, or near misses only between complete functions. The paper presents simple and practical methods for detecting exact and near miss clones over arb...", "pdfSize": "75KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Clone+detection+using+abstract+syntax+trees&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "S. Paul, A. Prakash, \"A framework for source code search using program patterns\", <em>IEEE Transactions on Software Engineering</em>, vol. 20, no. 6, pp. 463-475, 1994.", "title": "A framework for source code search using program patterns", "context": [{"sec": "sec2a", "text": "Some studies directly use ASTs in token-based methods for source code search [37], program repair [38] and source code differencing [39].", "part": "1"}], "links": {"documentLink": "/document/295894", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=295894", "abstract": "For maintainers involved in understanding and reengineering large software, locating source code fragments that match certain patterns is a critical task. Existing solutions to the problem are few, and they either involve manual, painstaking scans of the source code using tools based on regular expressions, or the use of large, integrated software engineering environments that include simple pattern-based query processors in their toolkits. We present a framework in which pattern languages are u...", "pdfSize": "1097KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+framework+for+source+code+search+using+program+patterns&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "W. Weimer, T. Nguyen, C. Le Goues, S. Forrest, \"Automatically finding patches using genetic programming\", <em>Proceedings of the 31 st International Conference on Software Engineering</em>, pp. 364-374, 2009.", "title": "Automatically finding patches using genetic programming", "context": [{"sec": "sec2a", "text": "Some studies directly use ASTs in token-based methods for source code search [37], program repair [38] and source code differencing [39].", "part": "1"}], "links": {"documentLink": "/document/5070536", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070536", "abstract": "Automatic program repair has been a longstanding goal in software engineering, yet debugging remains a largely manual process. We introduce a fully automated method for locating and repairing bugs in software. The approach works on off-the-shelf legacy applications and does not require formal specifications, program annotations or special coding practices. Once a program fault is discovered, an extended form of genetic programming is used to evolve program variants until one is found that both r...", "pdfSize": "264KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+finding+patches+using+genetic+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "J.-R. Falleri, F. Morandat, X. Blanc, M. Martinez, M. Monperrus, \"Fine-grained and accurate source code differencing\", <em>Proceedings of the 29th ACM/IEEE international conference on Automated software engineering</em>, pp. 313-324, 2014.", "title": "Fine-grained and accurate source code differencing", "context": [{"sec": "sec2a", "text": "Some studies directly use ASTs in token-based methods for source code search [37], program repair [38] and source code differencing [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2642937.2642982", "abstract": "At the heart of software evolution is a sequence of edit actions, called an edit script, made to a source code file. Since software systems are stored version by version, the edit script has to be computed from these versions, which is known as a complex task. Existing approaches usually compute edit scripts at the text granularity with only add line and delete line actions. However, inferring syntactic changes from such an edit script is hard. Since moving code is a frequent action performed wh...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fine-grained+and+accurate+source+code+differencing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "R. Socher, C. C. Lin, C. Manning, A. Y. Ng, \"Parsing natural scenes and natural language with recursive neural networks\", <em>Proceedings of the 28th international conference on machine learning (ICML-11)</em>, pp. 129-136, 2011.", "title": "Parsing natural scenes and natural language with recursive neural networks", "context": [{"sec": "sec2b1", "text": "RvNN was first proposed for the recursive structure in natural language and image parsing [40].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Parsing+natural+scenes+and+natural+language+with+recursive+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "K. S. Tai, R. Socher, C. D. Manning, \"Improved semantic representations from tree-structured long short-term memory networks\", <em>Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers)</em>, vol. 1, pp. 1556-1566, 2015.", "title": "Improved semantic representations from tree-structured long short-term memory networks", "context": [{"sec": "sec2b3", "text": " Different from standard LSTM, Child-Sum Tree-LSTM [41] recursively combines current input with its children states for state updating across the tree structure.", "part": "1"}, {"sec": "sec2c", "text": " First, during gradient-based training of tree topologies, the gradients are calculated via backpropagation over structures [41], [23].", "part": "1"}, {"sec": "sec2c", "text": " For example, CDLH [6] can only have the F1 value of 57% in one public benchmark for clone detection, and the studies in NLP [23], [41], [21] show that the tree size and depth do matter and have significant impact on the performance.", "part": "1"}, {"sec": "sec4", "text": " Suppose there are code fragment vectors \\$r_{1}\\$ and \\$r_{2}\\$, and their distance is measured by \\$r=\\vert r_{1}-r_{2}\\vert\\$ for semantic relatedness [41].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3115/v1/P15-1150", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improved+semantic+representations+from+tree-structured+long+short-term+memory+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, J. Dean, \"Distributed representations of words and phrases and their compositionality\", <em>Advances in neural information processing systems</em>, pp. 3111-3119, 2013.", "title": "Distributed representations of words and phrases and their compositionality", "context": [{"sec": "sec3b1", "text": " The word2vec [42] is used to learn unsupervised vectors of the symbols, and the trained embeddings of symbols are served as initial parameters in the statement encoder.", "part": "1"}, {"sec": "sec5b", "text": " For both tasks, we trained embeddings of symbols using word2vec [42] with Skip-gram algorithm and set the embedding size to be 128.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Distributed+representations+of+words+and+phrases+and+their+compositionality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "X. Gu, H. Zhang, D. Zhang, S. Kim, \"Deep API learning\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 631-642, 2016.", "title": "Deep API learning", "context": [{"sec": "sec3c", "text": " Considering the importance of different statements are intuitively not equal, for example, API calls in the MethodInvocation statements may contain more functional information [43], thus we use max pooling for capturing the most important semantics by default.", "part": "1"}, {"sec": "sec6b", "text": " DeepAPI [43] uses a sequence-to-sequence neural network to learn representations of natural language queries and predict relevant API sequences.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950334", "abstract": "Developers often wonder how to implement a certain functionality (e.g., how to parse XML files) using APIs. Obtaining an API usage sequence based on an API-related natural language query is very helpful in this regard. Given a query, existing approaches utilize information retrieval models to search for matching API sequences. These approaches treat queries and APIs as bags-of-words and lack a deep understanding of the semantics of the query. We propose DeepAPI, a deep learning based approach to...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+API+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "S. Kawaguchi, P. K. Garg, M. Matsushita, K. Inoue, \"Mudablue: An automatic categorization system for open source repositories\", <em>Journal of Systems and Software</em>, vol. 79, no. 7, pp. 939-953, 2006.", "title": "Mudablue: An automatic categorization system for open source repositories", "context": [{"sec": "sec4", "text": "This task aims to classify code fragments by their functionalities, which is useful for program understanding and maintenance [2], [44], [45].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2005.06.044", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mudablue%3A+An+automatic+categorization+system+for+open+source+repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "M. Linares-V\u00e1squez, C. McMillan, D. Poshyvanyk, M. Grechanik, \"On using machine learning to automatically classify software applications into domain categories\", <em>Empirical Software Engineering</em>, vol. 19, no. 3, pp. 582-618, 2014.", "title": "On using machine learning to automatically classify software applications into domain categories", "context": [{"sec": "sec4", "text": "This task aims to classify code fragments by their functionalities, which is useful for program understanding and maintenance [2], [44], [45].", "part": "1"}, {"sec": "sec6a", "text": " Based on the statistical and machine learning methods, the n-gram model [1] and SVM [45] are used for classifying source code authorship and domains.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-012-9230-z", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+using+machine+learning+to+automatically+classify+software+applications+into+domain+categories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "D. P. Kingma, J. Ba, Adam: A method for stochastic optimization, 2014.", "title": "Adam: A method for stochastic optimization", "context": [{"sec": "sec4", "text": " We use AdaMax [46] in this paper because it is computationally efficient.", "part": "1"}, {"sec": "sec5b", "text": " We use the optimizer AdaMax [46] with learning rate 0.002 for training.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adam%3A+A+method+for+stochastic+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "J. Svajlenko, J. F. Islam, I. Keivanloo, C. K. Roy, M. M. Mia, \"Towards a big data curated benchmark of inter-project code clones\", <em>Software Maintenance and Evolution (ICSME) 2014 IEEE International Conference</em>, pp. 476-480, 2014.", "title": "Towards a big data curated benchmark of inter-project code clones", "context": [{"sec": "sec5a", "text": " [47] for evaluating code clone detection tools.", "part": "1"}, {"sec": "sec5c2", "text": " For BCB, the similarity of clone pairs is defined as the average result of line-based and token-based metrics [47].", "part": "1"}, {"sec": "sec5d", "text": " In BCB Type-4, false clone pairs share syntactical similarity as well, which is validated to be coincidental [47] and is challenging to be distinguished.", "part": "1"}, {"sec": "sec7", "text": " However, BigCloneBench includes code snippets of real-world Java repositories from SourceForge [47], which reduces this threat.", "part": "1"}], "links": {"documentLink": "/document/6976121", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6976121", "abstract": "Recently, new applications of code clone detection and search have emerged that rely upon clones detected across thousands of software systems. Big data clone detection and search algorithms have been proposed as an embedded part of these new applications. However, there exists no previous benchmark data for evaluating the recall and precision of these emerging techniques. In this paper, we present a Big Data clone detection benchmark that consists of known true and false positive clones in a Bi...", "pdfSize": "383KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+a+big+data+curated+benchmark+of+inter-project+code+clones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "A. Charpentier, J.-R. Falleri, D. Lo, L. R\u00e9veill\u00e8re, \"An empirical assessment of bellon's clone benchmark\", <em>Proceedings of the 19th International Conference on Evaluation and Assessment in Software Engineering</em>, pp. 20, 2015.", "title": "An empirical assessment of bellon's clone benchmark", "context": [{"sec": "sec5a", "text": " As benchmarks, the two datasets have been used by many researchers concerning on code similarity [48], [49] and clone detection [5], [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2745802.2745821", "abstract": "Context: Clone benchmarks are essential to the assessment and improvement of clone detection tools and algorithms. Among existing benchmarks, Bellon&#39;s benchmark is widely used by the research community. However, a serious threat to the validity of this benchmark is that reference clones it contains have been manually validated by Bellon alone. Other persons may disagree with Bellon&#39;s judgment. Objective: In this paper, we perform an empirical assessment of Bellon&#39;s benchmark. Method: We seek the...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+assessment+of+bellon%27s+clone+benchmark&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "P. Accioly, P. Borba, G. Cavalcanti, \"Understanding semi-structured merge conflict characteristics in open-source java projects\", <em>Empirical Software Engineering</em>, pp. 1-35, 2017.", "title": "Understanding semi-structured merge conflict characteristics in open-source java projects", "context": [{"sec": "sec5a", "text": " As benchmarks, the two datasets have been used by many researchers concerning on code similarity [48], [49] and clone detection [5], [6].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+semi-structured+merge+conflict+characteristics+in+open-source+java+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "Y. Kim, \"Convolutional neural networks for sentence classification\", <em>Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</em>, pp. 1746-1751, 2014.", "title": "Convolutional neural networks for sentence classification", "context": [{"sec": "sec5c1", "text": " Apart from the state-of-the-art model TBCNN [2], we also take into account of traditional and other neural network based approaches including SVMs with statistical features, TextCNN [50], LSTM [51], LSCNN [52] and PDG-based Graph embedding approaches [25], [26] as follows:\n\n\n\u2022\nSVMs.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3115/v1/D14-1181", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Convolutional+neural+networks+for+sentence+classification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "W. Zaremba, I. Sutskever, Learning to execute, 2014.", "title": "Learning to execute", "context": [{"sec": "sec5c1", "text": " Apart from the state-of-the-art model TBCNN [2], we also take into account of traditional and other neural network based approaches including SVMs with statistical features, TextCNN [50], LSTM [51], LSCNN [52] and PDG-based Graph embedding approaches [25], [26] as follows:\n\n\n\u2022\nSVMs.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+to+execute&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "X. Huo, M. Li, \"Enhancing the unified features to locate buggy files by exploiting the sequential nature of source code\", <em>Proceedings of the 26th International Joint Conference on Artificial Intelligence</em>, pp. 1909-1915, 2017.", "title": "Enhancing the unified features to locate buggy files by exploiting the sequential nature of source code", "context": [{"sec": "sec5c1", "text": " Apart from the state-of-the-art model TBCNN [2], we also take into account of traditional and other neural network based approaches including SVMs with statistical features, TextCNN [50], LSTM [51], LSCNN [52] and PDG-based Graph embedding approaches [25], [26] as follows:\n\n\n\u2022\nSVMs.", "part": "1"}, {"sec": "sec5c1", "text": " Originally proposed for bug location [52], LSCNN extracts program features with CNN for statement embedding and uses LSTM for statement sequences.\n\n\n\u2022\nPDG based Graph Embedding.", "part": "1"}, {"sec": "sec5c1", "text": " Originally proposed for bug location [52], LSCNN extracts program features with CNN for statement embedding and uses LSTM for statement sequences.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.24963/ijcai.2017/265", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enhancing+the+unified+features+to+locate+buggy+files+by+exploiting+the+sequential+nature+of+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "Y. Li, D. Tarlow, M. Brockschmidt, R. Zemel, Gated graph sequence neural networks, 2015.", "title": "Gated graph sequence neural networks", "context": [{"sec": "sec5c1", "text": " Most recently some studies [25], [26] construct program graphs by considering control flow and data flow dependencies, and adopt graph embedding techniques such as HOPE [24] and Gated Graph Neural Network (GGNN) [53] for code representation.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gated+graph+sequence+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "C. K. Roy, J. R. Cordy, \"A survey on software clone detection research\", <em>Queens School of Computing TR</em>, vol. 541, no. 115, pp. 64-68, 2007.", "title": "A survey on software clone detection research", "context": [{"sec": "sec5c2", "text": "There are generally four different types of code clones [54].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+on+software+clone+detection+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "L. Jiang, G. Misherghi, Z. Su, S. Glondu, \"DECKARD: Scalable and accurate tree-based detection of code clones\", <em>Proceedings of the 29th International Conference on Software Engineering</em>, pp. 96-105, 2007.", "title": "DECKARD: Scalable and accurate tree-based detection of code clones", "context": [{"sec": "sec5c2", "text": " Since other traditional clone detection methods like DECKARD [55] and common neural models such as doc2Vec88https://radimrehurek.com/gensim/models/doc2vec.html. have been compared in RAE and CDLH, we omit them in our experiment.", "part": "1"}, {"sec": "sec6a", "text": " Besides the lexical information, Deckard [55] enriches programs with some syntax-structured information for clone detection as well.", "part": "1"}], "links": {"documentLink": "/document/4222572", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222572", "abstract": "Detecting code clones has many software engineering applications. Existing approaches either do not scale to large code bases or are not robust against minor code modifications. In this paper, we present an efficient algorithm for identifying similar subtrees and apply it to tree representations of source code. Our algorithm is based on a novel characterization of subtrees with numerical vectors in the Euclidean space Rnmiddot and an efficient algorithm to cluster these vectors w.r.t. the Euclid...", "pdfSize": "824KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DECKARD%3A+Scalable+and+accurate+tree-based+detection+of+code+clones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "J. I. Maletic, A. Marcus, \"Supporting program comprehension using semantic and structural information\", <em>Proceedings of the 23rd International Conference on Software Engineering</em>, pp. 103-112, 2001.", "title": "Supporting program comprehension using semantic and structural information", "context": [{"sec": "sec6a", "text": " [56] adopts LSI to identify semantic similarities of code fragments, and the cohesion of classes in software is evaluated by LDA [15].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+program+comprehension+using+semantic+and+structural+information&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "M. Allamanis, E. T. Barr, P. Devanbu, C. Sutton, A survey of machine learning for big code and naturalness, 2017.", "title": "A survey of machine learning for big code and naturalness", "context": [{"sec": "sec6a", "text": "Recently deep learning based approaches have attracted much attention to learn distributed representation of source code [57].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+of+machine+learning+for+big+code+and+naturalness&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "V. Raychev, M. Vechev, E. Yahav, \"Code completion with statistical language models\", <em>Acm Sigplan Notices</em>, vol. 49, no. 6, pp. 419-428, 2014.", "title": "Code completion with statistical language models", "context": [{"sec": "sec6a", "text": " [58] adopts RNN and n-gram model for code completion.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+completion+with+statistical+language+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "M. Allamanis, E. T. Barr, C. Bird, C. Sutton, \"Suggesting accurate method and class names\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, pp. 38-49, 2015.", "title": "Suggesting accurate method and class names", "context": [{"sec": "sec6a", "text": " [59] uses a neural context model to suggest method and class names.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786849", "abstract": "Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names. However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilisti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Suggesting+accurate+method+and+class+names&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "S. Wang, T. Liu, L. Tan, \"Automatically learning semantic features for defect prediction\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 297-308, 2016.", "title": "Automatically learning semantic features for defect prediction", "context": [{"sec": "sec6a", "text": " For defect prediction, semantic features are extracted from source code by a deep belief network [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884804", "abstract": "Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the ...", "pdfSize": "1876KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+learning+semantic+features+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "M. Pradel, K. Sen, \"DeepBugs: A learning approach to name-based bug detection\", <em>Proc. ACM Program. Lang.</em>, vol. 2, no. OOPSLA, pp. 147:1-147:25, Oct. 2018.", "title": "DeepBugs: A learning approach to name-based bug detection", "context": [{"sec": "sec6a", "text": " DeepBugs [61] represents code via word2vec for detecting name-based bugs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3276517", "abstract": "Natural language elements in source code, e.g., the names of variables and functions, convey useful information. However, most existing bug detection tools ignore this information and therefore miss some classes of bugs. The few existing name-based bug detection approaches reason about names on a syntactic level and rely on manually designed and tuned algorithms to detect bugs. This paper presents DeepBugs, a learning approach to name-based bug detection, which reasons about names based on a sem...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DeepBugs%3A+A+learning+approach+to+name-based+bug+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "G. Zhao, J. Huang, \"DeepSim: Deep learning code functional similarity\", <em>Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, pp. 141-151, 2018.", "title": "DeepSim: Deep learning code functional similarity", "context": [{"sec": "sec6a", "text": " DeepSim [62] encodes code control flow and data flow into a semantic matrix for measuring code functional similarity.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3236068", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DeepSim%3A+Deep+learning+code+functional+similarity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "A. N. Lam, A. T. Nguyen, H. A. Nguyen, T. N. Nguyen, \"Combining deep learning with information retrieval to localize buggy files for bug reports (n)\", <em>Automated Software Engineering (ASE) 2015 30th IEEE/ACM International Conference</em>, pp. 476-481, 2015.", "title": "Combining deep learning with information retrieval to localize buggy files for bug reports (n)", "context": [{"sec": "sec6b", "text": " [63] combines deep neural network with IR technique to recommend potential buggy files.", "part": "1"}], "links": {"documentLink": "/document/7372035", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372035", "abstract": "Bug localization refers to the automated process of locating the potential buggy files for a given bug report. To help developers focus their attention to those files is crucial. Several existing automated approaches for bug localization from a bug report face a key challenge, called lexical mismatch, in which the terms used in bug reports to describe a bug are different from the terms and code tokens used in source files. This paper presents a novel approach that uses deep neural network (DNN) ...", "pdfSize": "258KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combining+deep+learning+with+information+retrieval+to+localize+buggy+files+for+bug+reports+%28n%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "B. Xu, D. Ye, Z. Xing, X. Xia, G. Chen, S. Li, \"Predicting semantically linkable knowledge in developer online forums via convolutional neural network\", <em>Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 51-62, 2016.", "title": "Predicting semantically linkable knowledge in developer online forums via convolutional neural network", "context": [{"sec": "sec6b", "text": " [64] adopts word embeddings and convolutional neural network to predict the related questions in StackOverflow.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970357", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+semantically+linkable+knowledge+in+developer+online+forums+via+convolutional+neural+network&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "J. Guo, J. Cheng, J. Cleland-Huang, \"Semantically enhanced software traceability using deep learning techniques\", <em>Proceedings of the 39th International Conference on Software Engineering</em>, pp. 3-14, 2017.", "title": "Semantically enhanced software traceability using deep learning techniques", "context": [{"sec": "sec6b", "text": " [65] proposes a RNN based neural network to generate trace links.", "part": "1"}], "links": {"documentLink": "/document/7985645", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985645", "abstract": "In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts, however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links, however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into th...", "pdfSize": "1398KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semantically+enhanced+software+traceability+using+deep+learning+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "X. Gu, H. Zhang, S. Kim, \"Deep code search\", <em>Proceedings of the 2018 40th International Conference on Software Engineering (ICSE 2018)</em>, 2018.", "title": "Deep code search", "context": [{"sec": "sec6b", "text": " A joint embedding model is used in code search to map source code and natural language descriptions into a unified vector space for evaluating semantics similarity [66].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180167", "abstract": "To implement a program functionality, developers can reuse previously written code snippets by searching through a large-scale codebase. Over the years, many code search tools have been proposed to help developers. The existing approaches often treat source code as textual documents and utilize information retrieval models to retrieve relevant code snippets that match a given query. These approaches mainly rely on the textual similarity between source code and natural language query. They lack a...", "pdfSize": "677KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+code+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812062", "articleId": "8812062", "startPage": "783", "endPage": "794", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 390}}
{"title": "Balancing Soundness and Efficiency for Practical Testing of Configurable Systems", "authors": [{"name": "Sabrina Souto", "affiliation": "State Univ. of Paraiba, Para\u00edba, Brazil", "firstName": "Sabrina", "lastName": "Souto", "id": "37086185515"}, {"name": "Marcelo D'Amorim", "affiliation": "Fed. Univ. of Pernambuco, Recife, Brazil", "firstName": "Marcelo", "lastName": "D'Amorim", "id": "37831778900"}, {"name": "Rohit Gheyi", "affiliation": "Fed. Univ. of Campina Grande, Campina Grande, Brazil", "firstName": "Rohit", "lastName": "Gheyi", "id": "37391828700"}], "abstract": "Testing configurable systems is important and challenging due to the enormous space of configurations where errors can hide. Existing approaches to test these systems are often costly or unreliable. This paper proposes S-SPLat, a technique that combines heuristic sampling with symbolic search to obtain both breadth and depth in the exploration of the configuration space. S-SPLat builds on SPLat, our previously developed technique, that explores all reachable configurations from tests. In contrast to its predecessor, S-SPLat sacrifices soundness in favor of efficiency. We evaluated our technique on eight software product lines of various sizes and on a large configurable system - GCC. Considering the results for GCC, S-SPLat was able to reproduce all five bugs that we previously found in a previous study with SPLat but much faster and it was able to find two new bugs in a recent release of GCC. Results suggest that it is preferable to use a combination of simple heuristics to drive the symbolic search as opposed to a single heuristic. S-SPLat and our experimental infrastructure are publicly available.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Testing", "Computer bugs", "Software product lines", "Complexity theory", "Reliability", "Space exploration"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["program testing", "software product lines"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["configurable system testing", "S-SPLat technique", "heuristic sampling", "symbolic search", "configuration space", "software product lines", "GCC"]}, {"type": "Author Keywords ", "kwd": ["sampling", "testing", "configuration"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.64", "ref": [{"order": "1", "text": "<em>Configuration error brings down the Azure cloud platform</em>,  [online]  Available: http://www.evolven.com/blog/configuration-error-brings-down-the-azure-cloud-platform.html.", "title": "Configuration error brings down the Azure cloud platform", "context": [{"sec": "sec1", "text": " Some of these errors have been widely publicized in the media given the volume of users or data they affected [1], [3], [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Configuration+error+brings+down+the+Azure+cloud+platform&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>DejaGnu</em>,  [online]  Available: http://www.gnu.org/software/dejagnu/.", "title": "DejaGnu", "context": [{"sec": "sec5b1a", "text": "GCC uses DejaGnu [2] as testing framework.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DejaGnu&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>DNS misconfiguration</em>,  [online]  Available: http://www.circleid.com/posts/misconfiguration_brings_down_entire_se_domain_in_sweden.", "title": "DNS misconfiguration", "context": [{"sec": "sec1", "text": " Some of these errors have been widely publicized in the media given the volume of users or data they affected [1], [3], [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DNS+misconfiguration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Firefox web browser</em>,  [online]  Available: http://hg.mozilla.org.", "title": "Firefox web browser", "context": [{"sec": "sec1", "text": " The Firefox web browser [4], the Linux kernel [9], the GCC compiler infrastructure [5], and the deals-recommendation web service Groupon [8] are some well-known examples of configurable systems.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Firefox+web+browser&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>GCC compiler infrastructure</em>,  [online]  Available: http://gcc.gnu.org.", "title": "GCC compiler infrastructure", "context": [{"sec": "sec1", "text": " The Firefox web browser [4], the Linux kernel [9], the GCC compiler infrastructure [5], and the deals-recommendation web service Groupon [8] are some well-known examples of configurable systems.", "part": "1"}, {"sec": "sec5", "text": " In the second scenario, we evaluated the techniques on a large configurable system (GCC [5]) manifesting different characteristics compared to SPLs.", "part": "1"}, {"sec": "sec5b", "text": "We also evaluated S-SPLat against the GNU Compiler Collection (GCC) [5], a large configurable system with hundreds of options [6].", "part": "1"}, {"sec": "sec5d", "text": " One limitation of the study relates to the fact that SPLat currently only supports systems with dynamically bound feature variables (e.g., Groupon web [8], [29], and GCC [5]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=GCC+compiler+infrastructure&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>GCC Options</em>,  [online]  Available: https://gcc.gnu.org/onlinedocs/gcc/Option-Summary.html.", "title": "GCC Options", "context": [{"sec": "sec5b", "text": "We also evaluated S-SPLat against the GNU Compiler Collection (GCC) [5], a large configurable system with hundreds of options [6].", "part": "1"}, {"sec": "sec5b1b", "text": "We limited the number of options to analyze (see [6]) given the long execution times found in some test cases.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=GCC+Options&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>GCC releases</em>,  [online]  Available: https://gcc.gnu.org/releases.html.", "title": "GCC releases", "context": [{"sec": "sec5b", "text": " In one setup we measured ability to find test failures in the GCC release 6.1 [7] (Section V-B1).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=GCC+releases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Groupon</em>,  [online]  Available: http://groupon.com.", "title": "Groupon", "context": [{"sec": "sec1", "text": " The Firefox web browser [4], the Linux kernel [9], the GCC compiler infrastructure [5], and the deals-recommendation web service Groupon [8] are some well-known examples of configurable systems.", "part": "1"}, {"sec": "sec5d", "text": " One limitation of the study relates to the fact that SPLat currently only supports systems with dynamically bound feature variables (e.g., Groupon web [8], [29], and GCC [5]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Groupon&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "<em>Linux kernel</em>,  [online]  Available: http://www.kernel.org.", "title": "Linux kernel", "context": [{"sec": "sec1", "text": " The Firefox web browser [4], the Linux kernel [9], the GCC compiler infrastructure [5], and the deals-recommendation web service Groupon [8] are some well-known examples of configurable systems.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Linux+kernel&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "<em>Soundiness webpage</em>,  [online]  Available: http://soundiness.org/.", "title": "Soundiness webpage", "context": [{"sec": "sec3", "text": " The intuition is that the use of heuristics can provide a better balance between cost and reliability and that balance is essential for practicality in this domain [10], [34], [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Soundiness+webpage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "Iago Abal, Claus Brabrand, Andrzej Wasowski, \"42 variability bugs in the Linux kernel: A qualitative analysis\", <em>Proceedings of the Automated Software Engineering</em>, pp. 421-432, 2014.", "title": "42 variability bugs in the Linux kernel: A qualitative analysis", "context": [{"sec": "sec1", "text": " Unfortunately, configuration-related errors are not rare [11], [19], [25], [39].", "part": "1"}, {"sec": "sec1", "text": "We analyzed S-SPLat with five basic heuristics that have demonstrated promising results in different studies [11], [38] and eleven combinations of these basic heuristics.", "part": "1"}, {"sec": "sec1", "text": " Overall, considering our experimental setup, results suggest that it is preferable to combine some heuristics that demand a relatively low number of test requirements (e.g., one-enabled and one-disabled [11]) than using heuristics that solicit more test requirements (e.g., pairwise [52]).", "part": "1"}, {"sec": "sec2b", "text": "Among the various sampling heuristics proposed in the literature related to testing configurable systems, we considered those that have been recently evaluated and are applicable in our context [11], [38].", "part": "1"}, {"sec": "sec5b4", "text": " These results confirm previous observations that configuration-related errors are often manifested in configurations involving a small number of input options [11], [19], [31], [39].", "part": "1"}, {"sec": "sec6a1b", "text": " [11] analyze the Linux kernel software repository to study configuration-related faults fixed by developers.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2642937.2642990", "abstract": "Feature-sensitive verification pursues effective analysis of the exponentially many variants of a program family. However, researchers lack examples of concrete bugs induced by variability, occurring in real large-scale systems. Such a collection of bugs is a requirement for goal-oriented research, serving to evaluate tool implementations of feature-sensitive analyses by testing them on real bugs. We present a qualitative study of 42 variability bugs collected from bug-fixing commits to the Linu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=42+variability+bugs+in+the+Linux+kernel%3A+A+qualitative+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "Sven Apel, Don Batory, Christian K\u00e4stner, Gunter Saake, Feature-Oriented Software Product Lines: Concepts and Implementation, Springer-Verlag, 2013.", "title": "Feature-Oriented Software Product Lines: Concepts and Implementation", "context": [{"sec": "sec2a", "text": " We make no distinction between Software Product Lines (SPLs) [12], [15] and other kinds of configurable systems.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-37521-7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature-Oriented+Software+Product+Lines%3A+Concepts+and+Implementation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "Sven Apel, Dirk Beyer, \"Feature cohesion in software product lines: An exploratory study\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 421-430, 2011.", "title": "Feature cohesion in software product lines: An exploratory study", "context": [{"sec": "sec5a1a", "text": "We selected eight SPLs previously used in other studies [13], [26], [32], [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985851", "abstract": "Software product lines gain momentum in research and industry. Many product-line approaches use features as a central abstraction mechanism. Feature-oriented software development aims at encapsulating features in cohesive units to support program comprehension, variability, and reuse. Surprisingly, not much is known about the characteristics of cohesion in feature-oriented product lines, although proper cohesion is of special interest in product-line engineering due to its focus on variability a...", "pdfSize": "630KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+cohesion+in+software+product+lines%3A+An+exploratory+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "Sven Apel, Alexander von Rhein, Philipp Wendler, Armin Groblinger, Dirk Beyer, \"Strategies for product-line verification: case studies and experiments\", <em>Proceedings of the InternationalConference on Software Engineering</em>, pp. 482-491, 2013.", "title": "Strategies for product-line verification: case studies and experiments", "context": [{"sec": "sec6a1b", "text": " [14] have developed a model-checking tool for C and Java product lines.", "part": "1"}], "links": {"abstract": "Product-line technology is increasingly used in mission-critical and safety-critical applications. Hence, researchers are developing verification approaches that follow different strategies to cope with the specific properties of product lines. While the research community is discussing the mutual strengths and weaknesses of the different strategies\u2014mostly at a conceptual level\u2014there is a lack of evidence in terms of case studies, tool implementations, and experiments. We have collected and prep...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Strategies+for+product-line+verification%3A+case+studies+and+experiments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Don Batory, Clay Johnson, Bob MacDonald, Dale von Heeder, \"Achieving extensibility through product-lines and domain-specific languages: A case study\", <em>ACM Transactions on Software Engineering and Methodology (TOSEM)</em>, vol. 11, no. 2, pp. 191-214, 2002.", "title": "Achieving extensibility through product-lines and domain-specific languages: A case study", "context": [{"sec": "sec2a", "text": " We make no distinction between Software Product Lines (SPLs) [12], [15] and other kinds of configurable systems.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/505145.505147", "abstract": "This is a case study in the use of product-line architectures (PLAs) and domain-specific languages (DSLs) to design an extensible command-and-control simulator for Army fire support. The reusable components of our PLA are layers or &#34;aspects&#34; whose addition or removal simultaneously impacts the source code of multiple objects in multiple, distributed programs. The complexity of our component specifications is substantially reduced by using a DSL for defining and refining state machines, abstracti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Achieving+extensibility+through+product-lines+and+domain-specific+languages%3A+A+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "Abu Syed Md Masud Ching-Lai Hwang, Multiple Objective Decision Making \u2014 Methods and Applications: a state-of-the-art survey, Springer-Verlag, vol. 164, 1979.", "title": "Multiple Objective Decision Making \u2014 Methods and Applications: a state-of-the-art survey", "context": [{"sec": "sec5a4", "text": " To facilitate visualization, the plots show the Pareto fronts [16] of measurements as solid circles.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multiple+Objective+Decision+Making+%E2%80%94+Methods+and+Applications%3A+a+state-of-the-art+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Myra B. Cohen, Peter B. Gibbons, Warwick B. Mugridge, Charles J. Colbourn, \"Constructing test suites for interaction testing\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 38-48, 2003.", "title": "Constructing test suites for interaction testing", "context": [{"sec": "sec1", "text": "Combinatorial Interaction Testing (CIT) [51] has been popularized to balance probability of finding configuration errors (i.e., efficacy) and efficiency [17], [30], [31], [38], [42].", "part": "1"}], "links": {"documentLink": "/document/1201186", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1201186", "abstract": "Software system faults are often caused by unexpected interactions among components. Yet the size of a test suite required to test all possible combinations of interactions can be prohibitive in even a moderately sized project. Instead, we may use pairwise or t-way testing to provide a guarantee that all pairs or t-way combinations of components are tested together This concept draws on methods used in statistical testing for manufacturing and has been extended to software system testing. A cove...", "pdfSize": "371KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Constructing+test+suites+for+interaction+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Marcelo d'Amorim, Steven Lauterburg, Darko Marinov, \"Delta execution for efficient state-space exploration of object-oriented programs\", <em>IEEE Transactions on Software Engineering</em>, vol. 34, no. 5, pp. 597-613, 2008.", "title": "Delta execution for efficient state-space exploration of object-oriented programs", "context": [{"sec": "sec6a1a", "text": " Multi-execution approaches, such as DeltaExecution [18], SharedExecution [28] and Varex [41], execute a given test simultaneously against sets of configurations; they leverage the similarities that exist across configurations to reduce the total number of paths explored in a test and the overall amount of computation.", "part": "1"}, {"sec": "sec6a1a", "text": " On the one hand, building (and maintaining) such interpreters is challenging, especially for statically-typed languages [18], [28], [45].", "part": "1"}], "links": {"documentLink": "/document/4528965", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4528965", "abstract": "We present Delta execution, a technique that speeds up state-space exploration of object-oriented programs. State-space exploration is the essence of model checking and an increasingly popular approach for automating test generation. A key issue in exploration of object-oriented programs is handling the program state, in particular the heap. We exploit the fact that many execution paths in state-space exploration partially overlap. Delta execution simultaneously operates on several states/heaps ...", "pdfSize": "4878KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Delta+execution+for+efficient+state-space+exploration+of+object-oriented+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "Brady J. Garvin, Myra B. Cohen, \"Feature interaction faults revisited: An exploratory study\", <em>Proceedings of the InternationalSymposium on Software Reliability Engineering</em>, pp. 90-99, 2011.", "title": "Feature interaction faults revisited: An exploratory study", "context": [{"sec": "sec1", "text": " Unfortunately, configuration-related errors are not rare [11], [19], [25], [39].", "part": "1"}, {"sec": "sec5b4", "text": " These results confirm previous observations that configuration-related errors are often manifested in configurations involving a small number of input options [11], [19], [31], [39].", "part": "1"}], "links": {"abstract": "While a large body of research is dedicated to testing for feature interactions in configurable software, there has been little work that examines what constitutes such a fault at the code level. In consequence, we do not know how prevalent real interaction faults are in practice, what a typical interaction fault looks like in code, how to seed interaction faults, or whether current interaction testing techniques are effective at finding the faults they aim to detect. We make a first step in thi...", "pdfSize": "205KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+interaction+faults+revisited%3A+An+exploratory+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "\"Preparing Testcases\", <em>HowToPrepare ATestcase</em>,  [online]  Available: http://gcc.gnu.org/wiki/.", "title": "Preparing Testcases", "context": [{"sec": "sec5b1a", "text": " For example, compilation tasks include preprocessing, compiling, assembling, linking, and running code [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Preparing+Testcases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>GrammaTech. Hybrid concolic execution</em>,  [online]  Available: http://blogs.grammatech.com/hybrid-concolic-execution-part-l.", "title": "GrammaTech. Hybrid concolic execution", "context": [{"sec": "sec1", "text": " Our approach is similar in spirit to hybrid concolic execution [21], [36]; (implementation) we implemented S-SPLat, a variant of our previously-developed technique SPLat [29].", "part": "1"}, {"sec": "sec6a1d", "text": " Hybrid concolic execution [21], [36] is a variant of concolic execution that aims to explore the state space more broadly and deeply compared to a regular concolic execution, which conceptually can get stuck (e.g., as observed with saturation in coverage) in dense branches of the symbolic tree.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=GrammaTech.+Hybrid+concolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Michaela Greiler, Arie van Deursen, Margaret-Anne Storey, \"Test confessions: A study of testing practices for plug-in systems\", <em>Proceedings of the InternationalConference on Software Engineering</em>, pp. 244-254, 2012.", "title": "Test confessions: A study of testing practices for plug-in systems", "context": [{"sec": "sec1", "text": " In another limit, testing against one (default) configuration, albeit popular, leads to high chances of escaped defects [22], [35].", "part": "1"}], "links": {"documentLink": "/document/6227189", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227189", "abstract": "Testing plug-in-based systems is challenging due to complex interactions among many different plug-ins, and variations in version and configuration. The objective of this paper is to increase our understanding of what testers and developers think and do when it comes to testing plug-in-based systems. To that end, we conduct a qualitative (grounded theory) study, in which we interview 25 senior practitioners about how they test plug-in applications based on the Eclipse plug-in architecture. The o...", "pdfSize": "715KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+confessions%3A+A+study+of+testing+practices+for+plug-in+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "Robert Johnson, <em>More details on today's outage</em>,  [online]  Available: https://www.facebook.comlnotes/facebook-engineering/more-details-on-todaysoutage/431441338919.", "title": "More details on today's outage", "context": [{"sec": "sec1", "text": " Some of these errors have been widely publicized in the media given the volume of users or data they affected [1], [3], [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=More+details+on+today%27s+outage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "Kyo Kang, Sholom Cohen, James Hess, William Nowak, Spencer Peterson, \"Feature-Oriented Domain Analysis (FODA) Feasibility Study\", <em>Technical Report CMU/SEI-90-TR-21</em>, 1990.", "title": "Feature-Oriented Domain Analysis (FODA) Feasibility Study", "context": [{"sec": "sec2a", "text": "A feature model (FM) [24] distinguishes which combinations of variables are legal from those that are not.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.21236/ADA235785", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature-Oriented+Domain+Analysis+%28FODA%29+Feasibility+Study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "Christian K\u00e4stner, Paolo G. Giarrusso, Tillmann Rendel, Sebastian Erdweg, Klaus Ostermann, Thorsten Berger, \"Variability-aware parsing in the presence of lexical macros and conditional compilation\", <em>Proceedings of the Object-Oriented Programing Systems Languages and Applications</em>, pp. 805-824, 2011.", "title": "Variability-aware parsing in the presence of lexical macros and conditional compilation", "context": [{"sec": "sec1", "text": " Unfortunately, configuration-related errors are not rare [11], [19], [25], [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2048066.2048128", "abstract": "In many projects, lexical preprocessors are used to manage different variants of the project (using conditional compilation) and to define compile-time code transformations (using macros). Unfortunately, while being a simple way to implement variability, conditional compilation and lexical macros hinder automatic analysis, even though such analysis is urgently needed to combat variability-induced complexity. To analyze code with its variability, we need to parse it without preprocessing it. Howe...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Variability-aware+parsing+in+the+presence+of+lexical+macros+and+conditional+compilation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "Chang Hwan Peter Kim, Don S. Batory, Sarfraz Khurshid, \"Reducing combinatorics in testing product lines\", <em>Proceedings of the Aspect-Oriented Software Development</em>, pp. 57-68, 2011.", "title": "Reducing combinatorics in testing product lines", "context": [{"sec": "sec2b", "text": "Notepad is a visual text editor, implemented as a configurable system, that has been previously used in related studies [26], [27], [29].", "part": "1"}, {"sec": "sec5a1a", "text": "We selected eight SPLs previously used in other studies [13], [26], [32], [40].", "part": "1"}, {"sec": "sec5a2", "text": " To note that previous studies used similar metrics for similar reasons [26], [38].", "part": "1"}, {"sec": "sec6a1c", "text": " [26] previously developed a static analysis to determine which features are relevant to the outcome of a test.", "part": "1"}, {"sec": "sec6a1c", "text": " [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reducing+combinatorics+in+testing+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "Chang Hwan Peter Kim, Eric Bodden, Don S. Batory, Sarfraz Khurshid, \"Reducing configurations to monitor in a software product line\", <em>Proceedings of the Runtime Verification</em>, pp. 285-299, 2010.", "title": "Reducing configurations to monitor in a software product line", "context": [{"sec": "sec2b", "text": "Notepad is a visual text editor, implemented as a configurable system, that has been previously used in related studies [26], [27], [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reducing+configurations+to+monitor+in+a+software+product+line&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "Chang Hwan Peter Kim, Sarfraz Khurshid, Don Batory, \"Shared execution for efficiently testing product lines\", <em>Proceedings of the International Symposium on Software Reliability Engineering</em>, pp. 221-230, 2012.", "title": "Shared execution for efficiently testing product lines", "context": [{"sec": "sec1", "text": "More recently, sound testing techniques have been proposed [28], [29], [33], [41]; they assure that all configuration errors that can be captured with a given test will be captured.", "part": "1"}, {"sec": "sec6a1a", "text": " Multi-execution approaches, such as DeltaExecution [18], SharedExecution [28] and Varex [41], execute a given test simultaneously against sets of configurations; they leverage the similarities that exist across configurations to reduce the total number of paths explored in a test and the overall amount of computation.", "part": "1"}, {"sec": "sec6a1a", "text": " On the one hand, building (and maintaining) such interpreters is challenging, especially for statically-typed languages [18], [28], [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Shared+execution+for+efficiently+testing+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Chang Hwan Peter Kim, Darko Marinov, Sarfraz Khurshid, Don Batory, Sabrina Souto, Paulo Barros, Marcelo d'Amorim, \"SPLat: Lightweight dynamic analysis for reducing combinatorics in testing configurable systems\", <em>Proceedings of the Foundations of Software Engineering</em>, pp. 257-267, 2013.", "title": "SPLat: Lightweight dynamic analysis for reducing combinatorics in testing configurable systems", "context": [{"sec": "sec1", "text": "More recently, sound testing techniques have been proposed [28], [29], [33], [41]; they assure that all configuration errors that can be captured with a given test will be captured.", "part": "1"}, {"sec": "sec1", "text": " This is the case, for example, when test execution dynamically accesses a relatively small number of configuration variables [29].", "part": "1"}, {"sec": "sec1", "text": " In this study, we used SPLat [29], [47], [49], a sound technique, previously developed by the authors, that monitors variable accesses in one execution and, based on that, decides which configurations should be executed next.", "part": "1"}, {"sec": "sec1", "text": " Our approach is similar in spirit to hybrid concolic execution [21], [36]; (implementation) we implemented S-SPLat, a variant of our previously-developed technique SPLat [29].", "part": "1"}, {"sec": "sec2b", "text": "Notepad is a visual text editor, implemented as a configurable system, that has been previously used in related studies [26], [27], [29].", "part": "1"}, {"sec": "sec2c", "text": "In a nutshell, SPLat [29] works as follows.", "part": "1"}, {"sec": "sec4", "text": "This section describes S-SPLat (for Sampling with SPLat), a modified version of the SPLat algorithm [29].", "part": "1"}, {"sec": "sec4", "text": " A complete version of SPLat can be found elsewhere [29].", "part": "1"}, {"sec": "sec5d", "text": " One limitation of the study relates to the fact that SPLat currently only supports systems with dynamically bound feature variables (e.g., Groupon web [8], [29], and GCC [5]).", "part": "1"}, {"sec": "sec6a1a", "text": " Single-execution approaches, such as SPLat [29], [49], in contrast, execute a test once for each reachable configuration that they discover while building a decision tree from configuration variables accessed during execution.", "part": "1"}, {"sec": "sec6a1c", "text": " It is important to note that obtaining dynamic reachability information efficiently is the key feature of SPLat [29], which built upon the ideas of Kim et al. [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SPLat%3A+Lightweight+dynamic+analysis+for+reducing+combinatorics+in+testing+configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "D. Richard Kuhn, Raghu N. Kacker, Yu Lei, \"Practical combinatorial testing\", <em>Technical Report SP 800-142</em>, 2010.", "title": "Practical combinatorial testing", "context": [{"sec": "sec1", "text": "Combinatorial Interaction Testing (CIT) [51] has been popularized to balance probability of finding configuration errors (i.e., efficacy) and efficiency [17], [30], [31], [38], [42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+combinatorial+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "D. Richard Kuhn, Dolores R. Wallace, Albert M. Gallo, \"Software fault interactions and implications for software testing\", <em>IEEE Transactions on Software Engineering</em>, vol. 30, no. 6, pp. 418-421, 2004.", "title": "Software fault interactions and implications for software testing", "context": [{"sec": "sec1", "text": "Combinatorial Interaction Testing (CIT) [51] has been popularized to balance probability of finding configuration errors (i.e., efficacy) and efficiency [17], [30], [31], [38], [42].", "part": "1"}, {"sec": "sec5b4", "text": " These results confirm previous observations that configuration-related errors are often manifested in configurations involving a small number of input options [11], [19], [31], [39].", "part": "1"}], "links": {"documentLink": "/document/1321063", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1321063", "abstract": "Exhaustive testing of computer software is intractable, but empirical studies of software failures suggest that testing can in some cases be effectively exhaustive. We show that software failures in a variety of domains were caused by combinations of relatively few conditions. These results have important implications for testing. If all faults in a system can be triggered by a combination of n or fewer parameters, then testing all n-tuples of parameters is effectively equivalent to exhaustive t...", "pdfSize": "362KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+fault+interactions+and+implications+for+software+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "Philipp Lengauer, Verena Bitto, Florian Angerer, Paul Gr\u00fcnbacher, Hanspeter Mossenb\u00f6ck, \"Where has all my memory gone?: Determining memory characteristics of product variants using virtual-machine-level monitoring\", <em>Proceedings of the Variability Modelling of Software-Intensive Systems</em>, pp. 13:1-13:8, 2013.", "title": "Where has all my memory gone?: Determining memory characteristics of product variants using virtual-machine-level monitoring", "context": [{"sec": "sec5a1a", "text": "We selected eight SPLs previously used in other studies [13], [26], [32], [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2556624.2556628", "abstract": "Non-functional properties such as memory footprint have recently gained importance in software product line research. However, determining the memory characteristics of individual features and product variants is extremely challenging. We present an approach that supports the monitoring of memory characteristics of individual features at the level of Java virtual machines. Our approach provides extensions to Java virtual machines to track memory allocations and deal-locations of individual featu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Where+has+all+my+memory+gone%3F%3A+Determining+memory+characteristics+of+product+variants+using+virtual-machine-level+monitoring&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "J\u00f6rg Liebig, Alexander von Rhein, Christian K\u00e4stner, Sven Apel, Jens D\u00f6rre, Christian Lengauer, \"Scalable analysis of variable software\", <em>Proceedings of the Foundations of Software Engineering</em>, pp. 81-91, 2013.", "title": "Scalable analysis of variable software", "context": [{"sec": "sec1", "text": "More recently, sound testing techniques have been proposed [28], [29], [33], [41]; they assure that all configuration errors that can be captured with a given test will be captured.", "part": "1"}, {"sec": "sec6a1b", "text": " [33] perform studies to detect the strengths and weaknesses of variability-aware and sampling-based analyses (single configuration, pair-wise and code-coverage).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491437", "abstract": "The advent of variability management and generator technology enables users to derive individual variants from a variable code base based on a selection of desired configuration options. This approach gives rise to the generation of possibly billions of variants that, however, cannot be efficiently analyzed for errors with classic analysis techniques. To address this issue, researchers and practitioners usually apply sampling heuristics. While sampling reduces the analysis effort significantly, ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+analysis+of+variable+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "Benjamin Livshits, Manu Sridharan, Yannis Smaragdakis, Ond\u0159ej Lhot\u00e1k, J. Nelson Amaral, Bor-Yuh Evan Chang, Samuel Z. Guyer, Uday P. Khedker, Anders M\u00f8ller, Dimitrios Vardoulakis, \"In defense of soundiness: A manifesto\" in Communications of the ACM, vol. 58, no. 2, pp. 44-46, 2015.", "title": "In defense of soundiness: A manifesto", "context": [{"sec": "sec1", "text": " Recently, the static analysis community acknowledged the importance of making (and documenting) conscious unsound design choices in favor of practical soundy solutions [34].", "part": "1"}, {"sec": "sec3", "text": " The intuition is that the use of heuristics can provide a better balance between cost and reliability and that balance is essential for practicality in this domain [10], [34], [36].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2644805", "abstract": "Soundy is the new sound.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=In+defense+of+soundiness%3A+A+manifesto&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "Ivan do Carmo Machado, John D. Mcgregor, Yguarata Cerqueira Cavalcanti, Eduardo Santana de Almeida, \"On strategies for testing software product lines: A systematic literature review\", <em>Information and Software Technology</em>, vol. 56, no. 10, pp. 1183-1199, 2014.", "title": "On strategies for testing software product lines: A systematic literature review", "context": [{"sec": "sec1", "text": " In another limit, testing against one (default) configuration, albeit popular, leads to high chances of escaped defects [22], [35].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2014.04.002", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+strategies+for+testing+software+product+lines%3A+A+systematic+literature+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "Rupak Majumdar, Koushik Sen, \"Hybrid concolic testing\", <em>Proceedings of the InternationalConference on Software Engineering</em>, pp. 416-426, 2007.", "title": "Hybrid concolic testing", "context": [{"sec": "sec1", "text": " Our approach is similar in spirit to hybrid concolic execution [21], [36]; (implementation) we implemented S-SPLat, a variant of our previously-developed technique SPLat [29].", "part": "1"}, {"sec": "sec3", "text": " The intuition is that the use of heuristics can provide a better balance between cost and reliability and that balance is essential for practicality in this domain [10], [34], [36].", "part": "1"}, {"sec": "sec6a1d", "text": " Hybrid concolic execution [21], [36] is a variant of concolic execution that aims to explore the state space more broadly and deeply compared to a regular concolic execution, which conceptually can get stuck (e.g., as observed with saturation in coverage) in dense branches of the symbolic tree.", "part": "1"}], "links": {"documentLink": "/document/4222603", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222603", "abstract": "We present hybrid concolic testing, an algorithm that interleaves random testing with concolic execution to obtain both a deep and a wide exploration of program state space. Our algorithm generates test inputs automatically by interleaving random testing until saturation with bounded exhaustive symbolic exploration of program points. It thus combines the ability of random search to reach deep program states quickly together with the ability of concolic testing to explore states in a neighborhood...", "pdfSize": "153KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hybrid+concolic+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "Dusica Marijan, Arnaud Gotlieb, Sagar Sen, Aymeric Hervieu, \"Practical pairwise testing for software product lines\", <em>Proceedings of the Software Product Line Conference</em>, pp. 227-235, 2013.", "title": "Practical pairwise testing for software product lines", "context": [{"sec": "sec6a1b", "text": " [37] use the t-wise sampling algorithm to cover all t configuration option combinations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491627.2491646", "abstract": "One key challenge for software product lines is efficiently managing variability throughout their lifecycle. In this paper, we address the problem of variability in software product lines testing. We (1) identify a set of issues that must be addressed to make software product line testing work in practice and (2) provide a framework that combines a set of techniques to solve these issues. The framework integrates feature modelling, combinatorial interaction testing and constraint programming tec...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+pairwise+testing+for+software+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "Fl\u00e1vio Medeiros, Christian K\u00e4stner, M\u00e1rcie Ribeiro, Rohit Gheyi, Sven Apel, \"A comparison of 10 sampling algorithms for configurable systems\", <em>Proceedings of the InternationalConference on Software Engineering</em>, pp. 643-654, 2016.", "title": "A comparison of 10 sampling algorithms for configurable systems", "context": [{"sec": "sec1", "text": "Combinatorial Interaction Testing (CIT) [51] has been popularized to balance probability of finding configuration errors (i.e., efficacy) and efficiency [17], [30], [31], [38], [42].", "part": "1"}, {"sec": "sec1", "text": "We analyzed S-SPLat with five basic heuristics that have demonstrated promising results in different studies [11], [38] and eleven combinations of these basic heuristics.", "part": "1"}, {"sec": "sec2b", "text": "Among the various sampling heuristics proposed in the literature related to testing configurable systems, we considered those that have been recently evaluated and are applicable in our context [11], [38].", "part": "1"}, {"sec": "sec5a2", "text": " To note that previous studies used similar metrics for similar reasons [26], [38].", "part": "1"}, {"sec": "sec5e", "text": " [38] showing the superior performance of this combination.", "part": "1"}, {"sec": "sec6a1b", "text": " [38] conducted an extensive comparative study of 10 sampling algorithms (5 variations of \\$t\\$-wise, statement-coverage, random, one-disabled, one-enabled, and most-enabled-disabled) regarding their fault-detection ability and size of sample sets in the Linux kernel, Apache, and other real C program families.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884793", "abstract": "Almost every software system provides configuration options to tailor the system to the target platform and application scenario. Often, this configurability renders the analysis of every individual system configuration infeasible. To address this problem, researchers have proposed a diverse set of sampling algorithms. We present a comparative study of 10 state-of-the-art sampling algorithms regarding their fault-detection capability and size of sample sets. The former is important to improve so...", "pdfSize": "346KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+comparison+of+10+sampling+algorithms+for+configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "Fl\u00e1vio Medeiros, M\u00e1rcio Ribeiro, Rohit Gheyi, \"Investigating preprocessor-based syntax errors\", <em>Proceedings of the Generative Programming: Concepts and Experiences</em>, pp. 75-84, 2013.", "title": "Investigating preprocessor-based syntax errors", "context": [{"sec": "sec1", "text": " Unfortunately, configuration-related errors are not rare [11], [19], [25], [39].", "part": "1"}, {"sec": "sec5b4", "text": " These results confirm previous observations that configuration-related errors are often manifested in configurations involving a small number of input options [11], [19], [31], [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2517208.2517221", "abstract": "The C preprocessor is commonly used to implement variability in program families. Despite the widespread usage, some studies indicate that the C preprocessor makes variability implementation difficult and error-prone. However, we still lack studies to investigate preprocessor-based syntax errors and quantify to what extent they occur in practice. In this paper, we define a technique based on a variability-aware parser to find syntax errors in releases and commits of program families. To investig...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Investigating+preprocessor-based+syntax+errors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "Jens Meinicke, Chu-Pan Wong, Christian K\u00e4stner, Thomas Th\u00fcm, Gunter Saake, \"On essential configuration complexity: Measuring interactions in highly-configurable systems\", <em>Proceedings of the Automated Software Engineering</em>, pp. 483-494, 2016.", "title": "On essential configuration complexity: Measuring interactions in highly-configurable systems", "context": [{"sec": "sec1", "text": " Recent empirical studies indicate that scalability depends on many factors including the subjects and tests used [40], [47], [49].", "part": "1"}, {"sec": "sec5a1a", "text": "We selected eight SPLs previously used in other studies [13], [26], [32], [40].", "part": "1"}, {"sec": "sec6a1d", "text": "Recent empirical study found evidence that practical configuration complexity is often much lower compared to theoretical configuration complexity [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970322", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+essential+configuration+complexity%3A+Measuring+interactions+in+highly-configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "Hung Viet Nguyen, Christian K\u00e4stner, Tien N. Nguyen, \"Exploring variability-aware execution for testing plugin-based web applications\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 907-918, 2014.", "title": "Exploring variability-aware execution for testing plugin-based web applications", "context": [{"sec": "sec1", "text": "More recently, sound testing techniques have been proposed [28], [29], [33], [41]; they assure that all configuration errors that can be captured with a given test will be captured.", "part": "1"}, {"sec": "sec6a1a", "text": " Multi-execution approaches, such as DeltaExecution [18], SharedExecution [28] and Varex [41], execute a given test simultaneously against sets of configurations; they leverage the similarities that exist across configurations to reduce the total number of paths explored in a test and the overall amount of computation.", "part": "1"}, {"sec": "sec6a1a", "text": " [41]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+variability-aware+execution+for+testing+plugin-based+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Changhai Nie, Hareton Leung, \"A survey of combinatorial testing\", <em>ACM Computing Surveys</em>, vol. 43, no. 2, pp. 11:1-11:29, 2011.", "title": "A survey of combinatorial testing", "context": [{"sec": "sec1", "text": "Combinatorial Interaction Testing (CIT) [51] has been popularized to balance probability of finding configuration errors (i.e., efficacy) and efficiency [17], [30], [31], [38], [42].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1883612.1883618", "abstract": "Combinatorial Testing (CT) can detect failures triggered by interactions of parameters in the Software Under Test (SUT) with a covering array test suite generated by some sampling mechanisms. It has been an active field of research in the last twenty years. This article aims to review previous work on CT, highlights the evolution of CT, and identifies important issues, methods, and applications of CT, with the goal of supporting and directing future practice and research in this area. First, we ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+of+combinatorial+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "Thomas J. Ostrand, Marc J. Balcer, \"The category-partition method for specifying and generating functional tests\", <em>Communications of ACM</em>, vol. 31, no. 6, pp. 676-686, 1988.", "title": "The category-partition method for specifying and generating functional tests", "context": [{"sec": "sec4c", "text": " Instead, we applied the Ostrand and Barcer's category partitioning method [43], treating range types as boolean types.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/62959.62964", "abstract": "A method for creating functional test suites has been developed in which a test engineer analyzes the system specification, writes a series of formal test specifications, and then uses a generator tool to produce test descriptions from which test scripts are written. The advantages of this method are that the tester can easily modify the test specification when necessary, and can control the complexity and number of the tests by annotating the tests specification with constraints.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+category-partition+method+for+specifying+and+generating+functional+tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "Gilles Perrouin, Sagar Sen, Jacques Klein, Benoit Baudry, Yves le Traon, \"Automated and scalable t-wise test case generation strategies for software product lines\", <em>Proceedings of the International Conference on Software Testing Verification and Validation</em>, pp. 459-468, 2010.", "title": "Automated and scalable t-wise test case generation strategies for software product lines", "context": [{"sec": "sec6a1b", "text": " [44] and Marijan et al. [37] use the t-wise sampling algorithm to cover all t configuration option combinations.", "part": "1"}], "links": {"abstract": "Software Product Lines (SPL) are difficult to validate due to combinatorics induced by variability across their features. This leads to combinatorial explosion of the number of derivable products. Exhaustive testing in such a large space of products is infeasible. One possible option is to test SPLs by generating test cases that cover all possible T feature interactions (T-wise). T-wise dramatically reduces the number of test products while ensuring reasonable SPL coverage. However, automatic ge...", "pdfSize": "1417KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+and+scalable+t-wise+test+case+generation+strategies+for+software+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "Koushik Sen, George Necula, Liang Gong, Wontae Choi, \"MultiSE: Multi-path symbolic execution using value summaries\", <em>Proceedings of the Foundations of Software Engineering</em>, pp. 842-853, 2015.", "title": "MultiSE: Multi-path symbolic execution using value summaries", "context": [{"sec": "sec6a1a", "text": " On the one hand, building (and maintaining) such interpreters is challenging, especially for statically-typed languages [18], [28], [45].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786830", "abstract": "Dynamic symbolic execution (DSE) has been proposed to effectively generate test inputs for real-world programs. Unfortunately, DSE techniques do not scale well for large realistic programs, because often the number of feasible execution paths of a program increases exponentially with the increase in the length of an execution path. In this paper, we propose MultiSE, a new technique for merging states incrementally during symbolic execution, without using auxiliary variables. The key idea of Mult...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=MultiSE%3A+Multi-path+symbolic+execution+using+value+summaries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "Charles Song, Adam Porter, Jeffrey S. Foster, \"iTree: Efficiently discovering high-coverage configurations using interaction trees\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 903-913, 2012.", "title": "iTree: Efficiently discovering high-coverage configurations using interaction trees", "context": [{"sec": "sec6a1b", "text": " [46] propose interaction tree discovery algorithm (iTree) to support the testing of highly configurable systems. iTree selects a subset of configurations in which the execution of the system's test suite will achieve high coverage.", "part": "1"}], "links": {"documentLink": "/document/6227129", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227129", "abstract": "Software configurability has many benefits, but it also makes programs much harder to test, as in the worst case the program must be tested under every possible configuration. One potential remedy to this problem is combinatorial interaction testing (CIT), in which typically the developer selects a strength t and then computes a covering array containing all t-way configuration option combinations. However, in a prior study we showed that several programs have important high-strength interaction...", "pdfSize": "491KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=iTree%3A+Efficiently+discovering+high-coverage+configurations+using+interaction+trees&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "Sabrina Souto, Marcelo d'Amorim, <em>Time-Space Efficient Regression Testing for Configurable Systems</em>.", "title": "Time-Space Efficient Regression Testing for Configurable Systems", "context": [{"sec": "sec1", "text": " Recent empirical studies indicate that scalability depends on many factors including the subjects and tests used [40], [47], [49].", "part": "1"}, {"sec": "sec1", "text": " In this study, we used SPLat [29], [47], [49], a sound technique, previously developed by the authors, that monitors variable accesses in one execution and, based on that, decides which configurations should be executed next.", "part": "1"}, {"sec": "sec3", "text": " Unfortunately, we observed that, for a large system, such as GCC, with hundreds of configuration options, exploring all reachable configurations is impractical for several tests [47], [49].", "part": "1"}, {"sec": "sec6a1c", "text": " Despite the positive results reported by Kim et al. (caveat: evaluation involved large subjects but tests cover only a small fraction of the code), it is important to note that obtaining reachability information for these systems per test is challenging as: (i) the analysis needs to (re)run for each test, (ii) the analysis needs to run whenever the program changes, and (iii) often tests are designed to statically reach the entire codebase (e.g., system tests) \u2014 i.e., only the test input data can discriminate which parts of the code will be actually executed [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Time-Space+Efficient+Regression+Testing+for+Configurable+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "Sabrina Souto, Marcelo d'Amorim, Rohit Gheyi, <em>S-SP Lat: Balancing soundness and efficiency for practical testing of configurable systems (Artifact)</em>,  [online]  Available: https://sabrinadfs.github.io/s-splat/.", "title": "S-SP Lat: Balancing soundness and efficiency for practical testing of configurable systems (Artifact)", "context": [{"sec": "sec1", "text": " The code, datasets, containers, and scripts are all accessible from our website [48].", "part": "1"}, {"sec": "sec5d", "text": " Our datasets and implementations are publicly available [48].", "part": "1"}, {"sec": "sec5e", "text": " Additional results can be found on our website [48].", "part": "1"}, {"sec": "sec7", "text": " Implementation and experimental infrastructure can be found on our website [48].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=S-SP+Lat%3A+Balancing+soundness+and+efficiency+for+practical+testing+of+configurable+systems+%28Artifact%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "Sabrina Souto, Divya Gopinath, Marcelo d'Amorim, Darko Marinov, Sarfraz Khurshid, Don Batory, \"Faster bug detection for software product lines with incomplete feature models\", <em>Proceedings of the Software Product Line Conference</em>, pp. 151-160, 2015.", "title": "Faster bug detection for software product lines with incomplete feature models", "context": [{"sec": "sec1", "text": " Recent empirical studies indicate that scalability depends on many factors including the subjects and tests used [40], [47], [49].", "part": "1"}, {"sec": "sec1", "text": " In this study, we used SPLat [29], [47], [49], a sound technique, previously developed by the authors, that monitors variable accesses in one execution and, based on that, decides which configurations should be executed next.", "part": "1"}, {"sec": "sec1", "text": " The heuristic variants of S-SPLat were able to find all five crashes that we previously-documented [49] on GCC release 4.8.2 and uncovered two new crashes on release 6.1, one of which was reported to the GCC team and was already fixed.", "part": "1"}, {"sec": "sec3", "text": " Unfortunately, we observed that, for a large system, such as GCC, with hundreds of configuration options, exploring all reachable configurations is impractical for several tests [47], [49].", "part": "1"}, {"sec": "sec5b", "text": " We focused on crashes that the authors found in a previous study [49].", "part": "1"}, {"sec": "sec5b1a", "text": " We focused on that suite because previous study has shown a higher incidence of bugs found with it [49].", "part": "1"}, {"sec": "sec5b4", "text": "Next we evaluated the techniques on bugs found in a study, previously conducted by some of the authors of this paper, on release 4.8.2 of GCC [49].", "part": "1"}, {"sec": "sec5c", "text": " Considering the crash scenarios of GCC, we observed that all crashes found manifested in valid configurations, indicating that the use of validation is not beneficial. (We used GCC constraints documented in a previous study we conducted [49].) Considering the scenarios of failures of GCC, we also observed that the techniques performed consistently with and without feature constraints.", "part": "1"}, {"sec": "sec6a1a", "text": " Single-execution approaches, such as SPLat [29], [49], in contrast, execute a test once for each reachable configuration that they discover while building a decision tree from configuration variables accessed during execution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2791060.2791093", "abstract": "A software product line (SPL) is a family of programs that are differentiated by features --- increments in functionality. Systematically testing an SPL is challenging because it requires running each test of a test suite against a combinatorial number of programs. Feature models capture dependencies among features and can (1) reduce the space of programs to test and (2) enable accurate categorization of failing tests as failures of programs or the tests themselves, not as failures due to illega...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Faster+bug+detection+for+software+product+lines+with+incomplete+feature+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "Reinhard Tartler, Daniel Lohmann, Christian Dietrich, Christoph Egger, Julio Sincero, \"Configuration coverage in the analysis of large-scale system software\", <em>Proceedings of the Programming Languages and Operating Systems</em>, pp. 2:1-2:5, 2011.", "title": "Configuration coverage in the analysis of large-scale system software", "context": [{"sec": "sec6a1b", "text": " [50] propose the statement-coverage sampling algorithm and applied a per-file analysis to detect bugs in the Linux kernel.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2039239.2039242", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Configuration+coverage+in+the+analysis+of+large-scale+system+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "<em>Lincoln University of Nebraska. Combinatorial interaction testing (CIT) portal</em>,  [online]  Available: http://cse.unl.edu/-citportal/.", "title": "Lincoln University of Nebraska. Combinatorial interaction testing (CIT) portal", "context": [{"sec": "sec1", "text": "Combinatorial Interaction Testing (CIT) [51] has been popularized to balance probability of finding configuration errors (i.e., efficacy) and efficiency [17], [30], [31], [38], [42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lincoln+University+of+Nebraska.+Combinatorial+interaction+testing+%28CIT%29+portal&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "Alan W. Williams, Robert L. Probert, \"A practical strategy for testing pair-wise coverage of network interfaces\", <em>Proceedings of the InternationalSymposium on Software Reliability Engineering</em>, pp. 246-254, 1996.", "title": "A practical strategy for testing pair-wise coverage of network interfaces", "context": [{"sec": "sec1", "text": " For example, pairwise testing adequacy [52] is obtained when the sample set of selected configurations covers all possible pairs of input options.", "part": "1"}, {"sec": "sec1", "text": " Overall, considering our experimental setup, results suggest that it is preferable to combine some heuristics that demand a relatively low number of test requirements (e.g., one-enabled and one-disabled [11]) than using heuristics that solicit more test requirements (e.g., pairwise [52]).", "part": "1"}, {"sec": "sec2b", "text": " Finally, \\$t\\$-wise [52] samples all combinations of \\$t\\$ configuration options.", "part": "1"}], "links": {"abstract": "Distributed systems consist of a number of network elements that interact with each other. As the number of network elements and interchangeable components for each network element increases, the trade-off that the system tester faces is the thoroughness of test configuration coverage vs. limited resources of time and expense that are available. An approach to resolving this trade-off is to determine a set of test configurations that test each pair-wise combination of network components. This go...", "pdfSize": "743KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+practical+strategy+for+testing+pair-wise+coverage+of+network+interfaces&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985700", "articleId": "7985700", "startPage": "632", "endPage": "642", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 178}}
{"title": "Stochastic Optimization of Program Obfuscation", "authors": [{"name": "Han Liu", "affiliation": "Sch. of Software, Tsinghua Univ., Beijing, China", "firstName": "Han", "lastName": "Liu", "id": "37085952777"}, {"name": "Chengnian Sun", "affiliation": "Univ. of California, Davis, Davis, CA, USA", "firstName": "Chengnian", "lastName": "Sun", "id": "37085881013"}, {"name": "Zhendong Su", "affiliation": "Univ. of California, Davis, Davis, CA, USA", "firstName": "Zhendong", "lastName": "Su", "id": "37086131381"}, {"name": "Yu Jiang", "affiliation": "Sch. of Software, Tsinghua Univ., Beijing, China", "firstName": "Yu", "lastName": "Jiang", "id": "37085432243"}, {"name": "Ming Gu", "affiliation": "Sch. of Software, Tsinghua Univ., Beijing, China", "firstName": "Ming", "lastName": "Gu", "id": "37085365607"}, {"name": "Jiaguang Sun", "affiliation": "Sch. of Software, Tsinghua Univ., Beijing, China", "firstName": "Jiaguang", "lastName": "Sun", "id": "37086130954"}], "abstract": "Program obfuscation is a common practice in software development to obscure source code or binary code, in order to prevent humans from understanding the purpose or logic of software. It protects intellectual property and deters malicious attacks. While tremendous efforts have been devoted to the development of various obfuscation techniques, we have relatively little knowledge on how to most effectively use them together. The biggest challenge lies in identifying the most effective combination of obfuscation techniques. This paper presents a unified framework to optimize program obfuscation. Given an input program P and a set T of obfuscation transformations, our technique can automatically identify a sequence seq = \u3008t\n<sub xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">1</sub>\n, t\n<sub xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">2</sub>\n, ..., t\n<sub xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">n</sub>\n\u3009 (\u2200i \u2208 [1, n]. t\n<sub xmlns:mml=\"http://www.w3.org/1998/Math/MathML\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">i</sub>\n \u2208 T), such that applying ti in order on P yields the optimal obfuscation performance. We model the process of searching for seq as a mathematical optimization problem. The key technical contributions of this paper are: (1) an obscurity language model to assess obfuscation effectiveness/optimality, and (2) a guided stochastic algorithm based on Markov chain Monte Carlo methods to search for the optimal solution seq. We have realized the framework in a tool Closure* for JavaScript, and evaluated it on 25 most starred JavaScript projects on GitHub (19K lines of code). Our machinery study shows that Closure* outperforms the well-known Google Closure Compiler by defending 26% of the attacks initiated by JSNice. Our human study also reveals that Closure* is practical and can reduce the human attack success rate by 30%.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Optimization", "Mathematical model", "Reactive power", "Markov processes", "Google", "Lenses", "Software"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Java", "Markov processes", "Monte Carlo methods", "software engineering"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["stochastic optimization", "program obfuscation", "software development", "source code", "binary code", "mathematical optimization problem", "guided stochastic algorithm", "obscurity language model", "Markov chain Monte Carlo methods", "JavaScript"]}, {"type": "Author Keywords ", "kwd": ["program obfuscation", "obscurity language model", "markov chain monte carlo methods"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.28", "ref": [{"order": "1", "text": "C. Collberg, C. Thomborson, D. Low, \"Manufacturing cheap resilient and stealthy opaque constructs\", <em>Proceedings of the 25th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, pp. 184-196, 1998.", "title": "Manufacturing cheap, resilient, and stealthy opaque constructs", "context": [{"sec": "sec1", "text": "To defend against potential adversaries, decades of research has been devoted to developing various obfuscation techniques [1]\u2013[6].", "part": "1"}, {"sec": "sec2a3", "text": " Typical operations include inserting opaque predicates [1] whose value is hard to infer, flattening [11] and function inlining which can complicate the control flow and delay human understanding.", "part": "1"}, {"sec": "sec7a", "text": " For practical software use, Collberg proposed the opaque predicate to obfuscate the program by inserting boolean valued expressions whose values are known to obfuscators but difficult to analyze for automatic tools [1].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/268946.268962", "abstract": "It has become common to distribute software in forms that are isomorphic to the original source code. An important example is Java bytecode. Since such codes are easy to decompile, they increase the risk of malicious reverse engineering attacks.In this paper we describe the design of a Java code obfuscator, a tool which - through the application of code transformations - converts a Java program into an equivalent one that is more difficult to reverse engineer.We describe a number of transformati...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Manufacturing+cheap%2C+resilient%2C+and+stealthy+opaque+constructs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "M. Sharif, A. Lanzi, J. Giffin, W. Lee, \"Impeding malware analysis using conditional code obfuscation\", <em>NDSS</em>, 2008.", "title": "Impeding malware analysis using conditional code obfuscation", "context": [{"sec": "sec1", "text": "To defend against potential adversaries, decades of research has been devoted to developing various obfuscation techniques [1]\u2013[2][6].", "part": "1"}, {"sec": "sec7a", "text": " Sharif employed the conditional code obfuscation at compilation phase to transform input dependent branch conditions and encrypt the body [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Impeding+malware+analysis+using+conditional+code+obfuscation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "M. Dalla Preda, I. Mastroeni, R. Giacobazzi, \"A formal framework for property-driven obfuscation strategies\" in Fundamentals of Computation Theory, Berlin Heidelberg:Springer, vol. 8070, pp. 133-144, 2013.", "title": "A formal framework for property-driven obfuscation strategies", "context": [{"sec": "sec1", "text": "To defend against potential adversaries, decades of research has been devoted to developing various obfuscation techniques [1]\u2013[3][6].", "part": "1"}, {"sec": "sec7a", "text": " On the other side, Preda investigated the concrete program semantics instead of abstract semantics to guide the obfuscation process [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+formal+framework+for+property-driven+obfuscation+strategies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "P. Ananth, D. Gupta, Y. Ishai, A. Sahai, \"Optimizing obfuscation: Avoiding barrington's theorem\", <em>Proceedings of the 2014 ACM SIGSAC Conference on Computerand Communications Security</em>, pp. 646-658, 2014.", "title": "Optimizing obfuscation: Avoiding barrington's theorem", "context": [{"sec": "sec1", "text": "To defend against potential adversaries, decades of research has been devoted to developing various obfuscation techniques [1]\u2013[4][6].", "part": "1"}, {"sec": "sec7a", "text": " Other works were advanced in pursuit of better efficiency [4], [35].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660342", "abstract": "In this work, we seek to optimize the efficiency of secure general-purpose obfuscation schemes. We focus on the problem of optimizing the obfuscation of Boolean formulas and branching programs -- this corresponds to optimizing the &#34;core obfuscator&#34; from the work of Garg, Gentry, Halevi, Raykova, Sahai, and Waters (FOCS 2013), and all subsequent works constructing general-purpose obfuscators. This core obfuscator builds upon approximate multilinear maps, where efficiency in proposed instantiation...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Optimizing+obfuscation%3A+Avoiding+barrington%27s+theorem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "R. Giacobazzi, N.D. Jones, I. Mastroeni, \"Obfuscation by partial evaluation of distorted interpreters\", <em>Proceedings of the ACM SIGPLAN 2012 Workshop on Partial Evaluation and Program Manipulation</em>, pp. 63-72, 2012.", "title": "Obfuscation by partial evaluation of distorted interpreters", "context": [{"sec": "sec1", "text": "To defend against potential adversaries, decades of research has been devoted to developing various obfuscation techniques [1]\u2013[5][6].", "part": "1"}, {"sec": "sec7a", "text": " Regarding abstract interpretation [38], Giacobazzi leveraged interpreter distortion to generate obfuscated code [5] with the notion of incompleteness [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2103746.2103761", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Obfuscation+by+partial+evaluation+of+distorted+interpreters&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "C. Linn, S. Debray, \"Obfuscation of executable code to improve resistance to static disassembly\", <em>Proceedings of the 10th ACM Conference on Computerand Communications Security</em>, pp. 290-299, 2003.", "title": "Obfuscation of executable code to improve resistance to static disassembly", "context": [{"sec": "sec1", "text": "To defend against potential adversaries, decades of research has been devoted to developing various obfuscation techniques [1]\u2013[6].", "part": "1"}, {"sec": "sec7a", "text": " Differently, Linn presented a complement to thwart disassembling process which translates machine code to assembly code [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/948148.948149", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Obfuscation+of+executable+code+to+improve+resistance+to+static+disassembly&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "V. Raychev, M. Vechev, A. Krause, \"Predicting program properties from \u201cbig code\u201d\", <em>Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, pp. 111-124, 2015.", "title": "Predicting program properties from \u201cbig code\u201d", "context": [{"sec": "sec1", "text": " These adversaries [7], [8] leverage coding features mined from a large corpus of source code to recover useful information (e.g., identifier names, types) from obfuscated programs.", "part": "1"}, {"sec": "sec1a3", "text": " The evaluation on real-world popular open-source projects (over 19K lines of code) demonstrates the ability of Closure* at combating the state-of-the-art deobfuscator JSNice [7].", "part": "1"}, {"sec": "sec2b", "text": "We take JSNice [7] as a powerful instance.", "part": "1"}, {"sec": "sec2b", "text": " For name obfuscation as in \u00a7II-A, JSNice can correctly predict 63.4% of the obfuscated names [7], making the obfuscation greatly compromised.", "part": "1"}, {"sec": "sec2b", "text": " Even for complex large programs, JSNice can recover sensitive code elements within an acceptable time bound [7].", "part": "1"}, {"sec": "sec4b1", "text": " Using JSNice [7] as an automatic adversary to attack the two code snippets also confirms this.", "part": "1"}, {"sec": "sec6b", "text": " As for the adversary to Closure*, we use the UnuglifyJS front-end [19] and the Nice2Predict underlying machine learning engine [20], which are both from JSNice [7].", "part": "1"}, {"sec": "sec6b1", "text": " While featured as an optimizer for JavaScript [9], such tools are characterized as a form of obfuscators by JSNice [7] (They used UglifyJS, which is similar to Closure).", "part": "1"}, {"sec": "sec7b", "text": " Towards the application of suggesting names, Allamanis [41] and Raychev [7] addressed the naming for variables while Allamanis handled methods and classes as well [8].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2676726.2677009", "abstract": "We present a new approach for predicting program properties from massive codebases (aka &#34;Big Code&#34;). Our approach first learns a probabilistic model from existing data and then uses this model to predict properties of new, unseen programs. The key idea of our work is to transform the input program into a representation which allows us to phrase the problem of inferring program properties as structured prediction in machine learning. This formulation enables us to leverage powerful probabilistic ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+program+properties+from+%E2%80%9Cbig+code%E2%80%9D&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "M. Allamanis, E.T. Barr, C. Bird, C. Sutton, \"Suggesting accurate method and class names\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, pp. 38-49, 2015.", "title": "Suggesting accurate method and class names", "context": [{"sec": "sec1", "text": " These adversaries [7], [8] leverage coding features mined from a large corpus of source code to recover useful information (e.g., identifier names, types) from obfuscated programs.", "part": "1"}, {"sec": "sec7b", "text": " Towards the application of suggesting names, Allamanis [41] and Raychev [7] addressed the naming for variables while Allamanis handled methods and classes as well [8].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786849", "abstract": "Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names. However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilisti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Suggesting+accurate+method+and+class+names&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "<em>The Google Closure Compiler</em>,  [online]  Available: https://developers.google.com/closure/compiler/.", "title": "The Google Closure Compiler", "context": [{"sec": "sec1", "text": " The state-of-the-art obfuscators, such as Google Closure Compiler [9], specify a fixed order of obfuscation transformations for all programs.", "part": "1"}, {"sec": "sec6b1", "text": " While featured as an optimizer for JavaScript [9], such tools are characterized as a form of obfuscators by JSNice [7] (They used UglifyJS, which is similar to Closure).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Google+Closure+Compiler&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "C. Andrieu, N. de Freitas, A. Doucet, M. Jordan, \"An introduction to mcmc for machine learning\", <em>Machine Learning</em>, vol. 50, no. 1\u20132, pp. 5-43, 2003.", "title": "An introduction to mcmc for machine learning", "context": [{"sec": "sec1a2", "text": "Second, we realize the optimization process by using Markov chain Monte Carlo (MCMC) [10] methods to search for the optimal configuration of obfuscation transformations.", "part": "1"}, {"sec": "sec5a", "text": "In this paper, we employ MCMC sampling [10] to find seq*.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/A:1020281327116", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+introduction+to+mcmc+for+machine+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "T. L\u00e1szl\u00f3, \u00c1. Kiss, \"Obfuscating c++ programs via control flow flattening\", <em>Annales Universitatis Scientarum Budapestinensis de Rolando E\u00f6tv\u00f6s Nominatae Sectio Computatorica</em>, vol. 30, pp. 3-19, 2009.", "title": "Obfuscating c++ programs via control flow flattening", "context": [{"sec": "sec2a3", "text": " Typical operations include inserting opaque predicates [1] whose value is hard to infer, flattening [11] and function inlining which can complicate the control flow and delay human understanding.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Obfuscating+c%2B%2B+programs+via+control+flow+flattening&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "A. Hindle, E.T. Barr, Z. Su, M. Gabel, P. Devanbu, \"On the naturalness of software\", <em>Proceedings of the 34th International Conference on Software Engineering</em>, pp. 837-847, 2012.", "title": "On the naturalness of software", "context": [{"sec": "sec2c", "text": " In the context of programming languages, researchers have investigated such probabilistic nature (called naturalness) of programs [12] and highlighted its promising potential in handling traditional software engineering tasks [13]\u2013[15], e.g., for code completion, given code snippet for{, the LM can predict for{int i=0; i< is the most possible code to follow.", "part": "1"}, {"sec": "sec4a", "text": "As stated in [12], building a general language model for source code aims at capturing the statistical regularities of code.", "part": "1"}, {"sec": "sec4b", "text": "Different from a traditional language model for software engineering tasks at unobfuscated source code level (e.g., code completion) [12], [14], [15], our OLM aims to capture the remaining regularities of software after obfuscation.", "part": "1"}, {"sec": "sec7b", "text": " Based on the classical n-gram model, Hindle exploited the naturalness of software, which proved code to be predictable and led to a programming suggestion engine [12].", "part": "1"}], "links": {"documentLink": "/document/6227135", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227135", "abstract": "Natural languages like English are rich, complex, and powerful. The highly creative and graceful use of languages like English and Tamil, by masters like Shakespeare and Avvaiyar, can certainly delight and inspire. But in practice, given cognitive constraints and the exigencies of daily life, most human utterances are far simpler and much more repetitive and predictable. In fact, these utterances can be very usefully modeled using modern statistical methods. This fact has led to the phenomenal s...", "pdfSize": "383KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+naturalness+of+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "V. Raychev, M. Vechev, E. Yahav, \"Code completion with statistical language models\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 419-428, 2014.", "title": "Code completion with statistical language models", "context": [{"sec": "sec2c", "text": " In the context of programming languages, researchers have investigated such probabilistic nature (called naturalness) of programs [12] and highlighted its promising potential in handling traditional software engineering tasks [13]\u2013[15], e.g., for code completion, given code snippet for{, the LM can predict for{int i=0; i< is the most possible code to follow.", "part": "1"}, {"sec": "sec7b", "text": " In terms of method sequence, Raychev built the language models on call sequences [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+completion+with+statistical+language+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "T.T. Nguyen, A.T. Nguyen, H.A. Nguyen, T.N. Nguyen, \"A statistical semantic language model for source code\", <em>Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering</em>, pp. 532-542, 2013.", "title": "A statistical semantic language model for source code", "context": [{"sec": "sec2c", "text": " In the context of programming languages, researchers have investigated such probabilistic nature (called naturalness) of programs [12] and highlighted its promising potential in handling traditional software engineering tasks [13]\u2013[14][15], e.g., for code completion, given code snippet for{, the LM can predict for{int i=0; i< is the most possible code to follow.", "part": "1"}, {"sec": "sec4a", "text": "Recent techniques [14], [15] can build better language models to capture the regularities of programs, by either associating the lexemes with semantic information or taking the localness of lexemes into account during the model training phase.", "part": "1"}, {"sec": "sec4b", "text": "Different from a traditional language model for software engineering tasks at unobfuscated source code level (e.g., code completion) [12], [14], [15], our OLM aims to capture the remaining regularities of software after obfuscation.", "part": "1"}, {"sec": "sec7b", "text": " Nguyen extended the model with sememes to involve semantic information other than lexemes [14].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491458", "abstract": "Recent research has successfully applied the statistical n-gram language model to show that source code exhibits a good level of repetition. The n-gram model is shown to have good predictability in supporting code suggestion and completion. However, the state-of-the-art n-gram approach to capture source code regularities/patterns is based only on the lexical information in a local context of the code units. To improve predictability, we introduce SLAMC, a novel statistical semantic language mode...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+statistical+semantic+language+model+for+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Z. Tu, Z. Su, P. Devanbu, \"On the localness of software\", <em>Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 269-280, 2014.", "title": "On the localness of software", "context": [{"sec": "sec2c", "text": " In the context of programming languages, researchers have investigated such probabilistic nature (called naturalness) of programs [12] and highlighted its promising potential in handling traditional software engineering tasks [13]\u2013[15], e.g., for code completion, given code snippet for{, the LM can predict for{int i=0; i< is the most possible code to follow.", "part": "1"}, {"sec": "sec4a", "text": "Recent techniques [14], [15] can build better language models to capture the regularities of programs, by either associating the lexemes with semantic information or taking the localness of lexemes into account during the model training phase.", "part": "1"}, {"sec": "sec4b", "text": "Different from a traditional language model for software engineering tasks at unobfuscated source code level (e.g., code completion) [12], [14], [15], our OLM aims to capture the remaining regularities of software after obfuscation.", "part": "1"}, {"sec": "sec7b", "text": " Moreover, the localness is further enriched by Tu via proposing a cache language model to absorb local constructs for predicting programs [15].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635875", "abstract": "The n-gram language model, which has its roots in statistical natural language processing, has been shown to successfully capture the repetitive and predictable regularities (\u201cnaturalness&#34;) of source code, and help with tasks such as code suggestion, porting, and designing assistive coding devices. However, we show in this paper that this natural-language-based model fails to exploit a special property of source code: localness. We find that human-written programs are localized: they have useful...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+localness+of+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "C.D. Manning, H. Sch\u00fctze, Foundations of statistical natural language processing, MIT Press, vol. 999, 1999.", "title": "Foundations of statistical natural language processing", "context": [{"sec": "sec2c", "text": "Given a program \\$s=t_{1}t_{2}\\cdots t_{n}\\$, to better interpret its naturalness based on an LM \\$\\mathcal{M}\\$, we use the measurement perplexity or its log-transformed version cross-entropy [16], defined as \\$H_{\\mathcal{M}}(s)=-\\frac{1}{n}\\log p_{\\mathcal{M}}(t_{1}\\cdots t_{n})\\$.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Foundations+of+statistical+natural+language+processing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "E. Schkufza, R. Sharma, A. Aiken, \"Stochastic superoptimization\", <em>Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages and Operating Systems</em>, pp. 305-316, 2013.", "title": "Stochastic superoptimization", "context": [{"sec": "sec5a", "text": "As described in [17], \\$\\sigma\\$ is a constant and \\$Z\\$ is a partition function that normalizes the target distribution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2451116.2451150", "abstract": "We formulate the loop-free binary superoptimization task as a stochastic search problem. The competing constraints of transformation correctness and performance improvement are encoded as terms in a cost function, and a Markov Chain Monte Carlo sampler is used to rapidly explore the space of all possible programs to find one that is an optimization of a given target program. Although our method sacrifices completeness, the scope of programs we are able to consider, and the resulting quality of t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Stochastic+superoptimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>KenLM</em>,  [online]  Available: https://github.com/kpu/kenlm.", "title": "KenLM", "context": [{"sec": "sec6b", "text": " In evaluation, the obscurity LM is configured to be 5-gram using KenLM [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=KenLM&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>UnuglifyJS</em>,  [online]  Available: https://github.com/eth-srl/UnuglifyJS.", "title": "UnuglifyJS", "context": [{"sec": "sec6b", "text": " As for the adversary to Closure*, we use the UnuglifyJS front-end [19] and the Nice2Predict underlying machine learning engine [20], which are both from JSNice [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=UnuglifyJS&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "<em>Nice2Predict</em>,  [online]  Available: https://github.com/eth-srl/Nice2Predict.", "title": "Nice2Predict", "context": [{"sec": "sec6b", "text": " As for the adversary to Closure*, we use the UnuglifyJS front-end [19] and the Nice2Predict underlying machine learning engine [20], which are both from JSNice [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Nice2Predict&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>angular.js</em>,  [online]  Available: https://github.com/angular/angular.", "title": "angular.js", "context": [{"sec": "sec6d", "text": " We also listed results for top three popular projects: angular [21], meteor [22] and react [23], which have 20,000 GitHub stars on average.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=angular.js&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>meteor</em>,  [online]  Available: https://github.com/meteor/meteor.", "title": "meteor", "context": [{"sec": "sec6d", "text": " We also listed results for top three popular projects: angular [21], meteor [22] and react [23], which have 20,000 GitHub stars on average.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=meteor&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>react</em>,  [online]  Available: https://github.com/facebook/react.", "title": "react", "context": [{"sec": "sec6d", "text": " We also listed results for top three popular projects: angular [21], meteor [22] and react [23], which have 20,000 GitHub stars on average.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=react&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "S. Siegel, N.J.J. Castellan, Nonparametric statistics for the behavioral sciences, New York, St. Louis:McGraw-Hill, 1988.", "title": "Nonparametric statistics for the behavioral sciences", "context": [{"sec": "sec6d", "text": " We also conduct the Wilcoxon Signed-Rank Test [24] over obfuscation results from Closure and Closure* to validate the statistical significance.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Nonparametric+statistics+for+the+behavioral+sciences&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "R. Lowry, <em>Concepts and applications of inferential statistics</em>,  [online]  Available: http://vassarstats.net/textbook/ch12a.html.", "title": "Concepts and applications of inferential statistics", "context": [{"sec": "sec6d", "text": " With the 1.783 \\$z\\$-score which does not exceed the critical value 1.960 according to [25], the optimization is statistically significant.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Concepts+and+applications+of+inferential+statistics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "C. Collberg, C. Thomborson, D. Low, \"A taxonomy of obfuscating transformations\", <em>Technical report 148</em>, 1997.", "title": "A taxonomy of obfuscating transformations", "context": [{"sec": "sec7a", "text": "Program obfuscation has been exensively studied to make reverse engineering or human understanding harder [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+taxonomy+of+obfuscating+transformations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai, S. Vadhan, K. Yang, J. Kilian, \"On the (im)possibility of obfuscating programs\", <em>CRYPTO 2001</em>, vol. 2139, pp. 1-18, 2001.", "title": "On the (im)possibility of obfuscating programs", "context": [{"sec": "sec7a", "text": " Theoretically, it is claimed that no \u201cperfect\u201d obfuscation exists [27], [28].", "part": "1"}, {"sec": "sec7a", "text": " Despite of the impossibility, Barak suggested indistinguishability obfuscation [27], [29].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-44647-8_1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+%28im%29possibility+of+obfuscating+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "S. Goldwasser, Y. Kalai, \"On the impossibility of obfuscation with auxiliary input\", <em>Foundations of Computer Science 2005. FOCS 2005. 46th Annual IEEE Symposium on</em>, pp. 553-562, Oct 2005.", "title": "On the impossibility of obfuscation with auxiliary input", "context": [{"sec": "sec7a", "text": " Theoretically, it is claimed that no \u201cperfect\u201d obfuscation exists [27], [28].", "part": "1"}], "links": {"abstract": "Barak et al. formalized the notion of obfuscation, and showed that there exist (contrived) classes of functions that cannot be obfuscated. In contrast, Canetti and Wee showed how to obfuscate point functions, under various complexity assumptions. Thus, it would seem possible that most programs of interest can be obfuscated even though in principle general purpose obfuscators do not exist. We show that this is unlikely to be the case. In particular; we consider the notion of obfuscation w.r.t. au...", "pdfSize": "348KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+impossibility+of+obfuscation+with+auxiliary+input&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "B. Barak, O. Goldreich, R. Impagliazzo, S. Rudich, A. Sahai, S. Vadhan, K. Yang, \"On the (im) possibility of obfuscating programs\", <em>Journal of the ACM (JACM)</em>, vol. 59, no. 2, pp. 6, 2012.", "title": "On the (im) possibility of obfuscating programs", "context": [{"sec": "sec7a", "text": " Despite of the impossibility, Barak suggested indistinguishability obfuscation [27], [29].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2160158.2160159", "abstract": "Informally, an obfuscator O is an (efficient, probabilistic) \u201ccompiler\u201d that takes as input a program (or circuit) P and produces a new program O(P) that has the same functionality as P yet is \u201cunintelligible\u201d in some sense. Obfuscators, if they exist, would have a wide variety of cryptographic and complexity-theoretic applications, ranging from software protection to homomorphic encryption to complexity-theoretic analogues of Rice&#39;s theorem. Most of these applications are based on an interpreta...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+%28im%29+possibility+of+obfuscating+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "S. Garg, C. Gentry, S. Halevi, M. Raykova, A. Sahai, B. Waters, \"Candidate indistinguishability obfuscation and functional encryption for all circuits\", <em>Foundations of Computer Science(FOCS) 2013 IEEE 54th Annual Symposium on</em>, pp. 40-49, 2013.", "title": "Candidate indistinguishability obfuscation and functional encryption for all circuits", "context": [{"sec": "sec7a", "text": " Garg and Brakerski further presented obfuscators for polynomial-size circuits [30], [31].", "part": "1"}], "links": {"abstract": "In this work, we study indistinguishability obfuscation and functional encryption for general circuits: Indistinguishability obfuscation requires that given any two equivalent circuits C0 and C1 of similar size, the obfuscations of C0 and C1 should be computationally indistinguishable. In functional encryption, cipher texts encrypt inputs x and keys are issued for circuits C. Using the key SKC to decrypt a cipher text CTx = Enc(x), yields the value C(x) but does not reveal anything else about x....", "pdfSize": "251KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Candidate+indistinguishability+obfuscation+and+functional+encryption+for+all+circuits&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "Z. Brakerski, G.N. Rothblum, \"Virtual black-box obfuscation for all circuits via generic graded encoding\", <em>Theory of Cryptography</em>, pp. 1-25, 2014.", "title": "Virtual black-box obfuscation for all circuits via generic graded encoding", "context": [{"sec": "sec7a", "text": " Garg and Brakerski further presented obfuscators for polynomial-size circuits [30], [31].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Virtual+black-box+obfuscation+for+all+circuits+via+generic+graded+encoding&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "B. Barak, S. Garg, Y.T. Kalai, O. Paneth, A. Sahai, \"Protecting obfuscation against algebraic attacks\", <em>Advances in Cryptology-EUROCRYPT 2014</em>, pp. 221-238, 2014.", "title": "Protecting obfuscation against algebraic attacks", "context": [{"sec": "sec7a", "text": " Barak described a simplified variant to achieve protection against algebra attacks [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Protecting+obfuscation+against+algebraic+attacks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "A. Sahai, B. Waters, \"How to use indistinguishability obfuscation: deniable encryption and more\", <em>Proceedings of the 46th Annual ACM Symposium on Theory of Computing</em>, pp. 475-484, 2014.", "title": "How to use indistinguishability obfuscation: deniable encryption, and more", "context": [{"sec": "sec7a", "text": " Sahai proposed punctured programs for cryptographic problems [33].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2591796.2591825", "abstract": "We introduce a new technique, that we call punctured programs, to apply indistinguishability obfuscation towards cryptographic problems. We use this technique to carry out a systematic study of the applicability of indistinguishability obfuscation to a variety of cryptographic goals. Along the way, we resolve the 16-year-old open question of Deniable Encryption, posed by Canetti, Dwork, Naor, and Ostrovsky in 1997: In deniable encryption, a sender who is forced to reveal to an adversary both her...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+use+indistinguishability+obfuscation%3A+deniable+encryption%2C+and+more&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "S. Goldwasser, G.N. Rothblum, \"On best-possible obfuscation\", <em>Theory of Cryptography</em>, pp. 194-213, 2007.", "title": "On best-possible obfuscation", "context": [{"sec": "sec7a", "text": " Goldwasser proposed to identify the best possible obfuscation which leaks as little information as other programs with the same functionality [34].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-70936-7_11", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+best-possible+obfuscation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "J. Zimmerman, \"How to obfuscate programs directly\", <em>Advances in Cryptology-EUROCRYPT 2015</em>, pp. 439-467, 2015.", "title": "How to obfuscate programs directly", "context": [{"sec": "sec7a", "text": " Other works were advanced in pursuit of better efficiency [4], [35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+obfuscate+programs+directly&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "W. Mark, \"Program slicing\", <em>Proceedings of the 5th International Conference on Software Engineering</em>, pp. 439-449, 1981.", "title": "Program slicing", "context": [{"sec": "sec7a", "text": " Regarding program slicing [36] as the adversary, Drape transformed code so that the orphaned slices \u2014 code left after the slicing \u2014 are minimized [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "D.S., M.A., T.C., \"Slicing aided design of obfuscating transforms\", <em>Computer and Information Science 2007. ICIS 2007. 6th IEEE/ACIS International Conference on</em>, pp. 1019-1024, 2007.", "title": "Slicing aided design of obfuscating transforms", "context": [{"sec": "sec7a", "text": " Regarding program slicing [36] as the adversary, Drape transformed code so that the orphaned slices \u2014 code left after the slicing \u2014 are minimized [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Slicing+aided+design+of+obfuscating+transforms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "P. Cousot, R. Cousot, \"Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints\", <em>Proceedings of the 4th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages</em>, pp. 238-252, 1977.", "title": "Abstract interpretation: A unified lattice model for static analysis of programs by construction or approximation of fixpoints", "context": [{"sec": "sec7a", "text": " Regarding abstract interpretation [38], Giacobazzi leveraged interpreter distortion to generate obfuscated code [5] with the notion of incompleteness [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/512950.512973", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Abstract+interpretation%3A+A+unified+lattice+model+for+static+analysis+of+programs+by+construction+or+approximation+of+fixpoints&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "R. Giacobazzi, I. Mastroeni, \"Making abstract interpretation incomplete: Modeling the potency of obfuscation\" in Static Analysis, Berlin Heidelberg:Springer, vol. 7460, pp. 129-145, 2012.", "title": "Making abstract interpretation incomplete: Modeling the potency of obfuscation", "context": [{"sec": "sec7a", "text": " Regarding abstract interpretation [38], Giacobazzi leveraged interpreter distortion to generate obfuscated code [5] with the notion of incompleteness [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Making+abstract+interpretation+incomplete%3A+Modeling+the+potency+of+obfuscation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "M. Gabel, Z. Su, \"A study of the uniqueness of source code\", <em>Proceedings of the Eighteenth ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 147-156, 2010.", "title": "A study of the uniqueness of source code", "context": [{"sec": "sec7b", "text": "Due to the fact that software is repetitive and not unique [40], language models can be built for source code to capture regularities.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1882291.1882315", "abstract": "This paper presents the results of the first study of the uniqueness of source code. We define the uniqueness of a unit of source code with respect to the entire body of written software, which we approximate with a corpus of 420 million lines of source code. Our high-level methodology consists of examining a collection of 6,000 software projects and measuring the degree to which each project can be `assembled&#39; solely from portions of this corpus, thus providing a precise measure of `uniqueness&#39;...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+study+of+the+uniqueness+of+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "M. Allamanis, E.T. Barr, C. Bird, C. Sutton, \"Learning natural coding conventions\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 281-293, 2014.", "title": "Learning natural coding conventions", "context": [{"sec": "sec7b", "text": " Towards the application of suggesting names, Allamanis [41] and Raychev [7] addressed the naming for variables while Allamanis handled methods and classes as well [8].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635883", "abstract": "Every programmer has a characteristic style, ranging from preferences about identifier naming to preferences about object relationships and design patterns. Coding conventions define a consistent syntactic style, fostering readability and hence maintainability. When collaborating, programmers strive to obey a project\u2019s coding conventions. However, one third of reviews of changes contain feedback about coding conventions, indicating that programmers do not always follow them and that project memb...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+natural+coding+conventions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985664", "articleId": "7985664", "startPage": "221", "endPage": "231", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 3, "citationCountPatent": 0, "totalDownloads": 363}}
{"title": "Search-Based Energy Testing of Android", "authors": [{"name": "Reyhaneh Jabbarvand", "affiliation": "University of California, Irvine", "firstName": "Reyhaneh", "lastName": "Jabbarvand", "id": "37085561927"}, {"name": "Jun-Wei Lin", "affiliation": "University of California, Irvine", "firstName": "Jun-Wei", "lastName": "Lin", "id": "37086948326"}, {"name": "Sam Malek", "affiliation": "University of California, Irvine", "firstName": "Sam", "lastName": "Malek", "id": "37314429800"}], "abstract": "The utility of a smartphone is limited by its battery capacity and the ability of its hardware and software to efficiently use the device's battery. To properly characterize the energy consumption of an app and identify energy defects, it is critical that apps are properly tested, i.e., analyzed dynamically to assess the app's energy properties. However, currently there is a lack of testing tools for evaluating the energy properties of apps. We present COBWEB, a search-based energy testing technique for Android. By leveraging a set of novel models, representing both the functional behavior of an app as well as the contextual conditions affecting the app's energy behavior, COBWEB generates a test suite that can effectively find energy defects. Our experimental results using real-world apps demonstrate not only its ability to effectively and efficiently test energy behavior of apps, but also its superiority over prior techniques by finding a wider and more diverse set of energy defects.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Testing", "Hardware", "Global Positioning System", "Graphical user interfaces", "Smart phones", "Receivers", "Batteries"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "mobile computing", "program testing", "search problems", "smart phones"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["battery capacity", "energy consumption", "energy defects", "energy properties", "search-based energy testing technique", "test suite", "energy behavior", "Android", "COBWEB"]}, {"type": "Author Keywords ", "kwd": ["Energy Testing", "Android", "Software Testing"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00115", "ref": [{"order": "1", "text": "C. Wilke, S. Richly, S. Gotz, C. Piechnick, U. Abmann, \"Energy consumption and efficiency in mobile applications: A user feedback study\", <em>The Internation Conf. on Green Computing and Communications</em>.", "title": "Energy consumption and efficiency in mobile applications: A user feedback study", "context": [{"sec": "sec1", "text": " Recent studies have shown energy to be a major concern for both users [1] and developers [2].", "part": "1"}], "links": {"documentLink": "/document/6682059", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6682059", "abstract": "The energy efficiency of mobile applications has been a highly tackled research problem within the last years. Many research groups have focused on optimizing the hardware of mobile devices, as well as their middleware and applications, increasing both the devices&#39; uptime and their users&#39; satisfaction. However, only scarce work has analyzed whether users notice and care about energy-efficiency problems in mobile applications. Thus, in this paper, we address these questions by evaluating a large ...", "pdfSize": "219KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Energy+consumption+and+efficiency+in+mobile+applications%3A+A+user+feedback+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "I. Manotas, C. Bird, R. Zhang, D. Shepherd, C. Jaspan, C. Sadowski, L. Pollock, J. Clause, \"An empirical study of practitioners' perspectives on green software engineering\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 237-248, 2016.", "title": "An empirical study of practitioners' perspectives on green software engineering", "context": [{"sec": "sec1", "text": " Recent studies have shown energy to be a major concern for both users [1] and developers [2].", "part": "1"}, {"sec": "sec1", "text": " This can be attributed to the lack of tools and methodologies for energy testing [2].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884810", "abstract": "The energy consumption of software is an increasing concern as the use of mobile applications, embedded systems, and data center-based services expands. While research in green software engineering is correspondingly increasing, little is known about the current practices and perspectives of software engineers in the field. This paper describes the first empirical study of how practitioners think about energy when they write requirements, design, construct, test, and maintain their software. We ...", "pdfSize": "509KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+practitioners%27+perspectives+on+green+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "R. Jabbarvand, S. Malek, \"\u03bcdroid: an energy-aware mutation testing framework for android\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, pp. 208-219, 2017.", "title": "\u03bcdroid: an energy-aware mutation testing framework for android", "context": [{"sec": "sec1", "text": " Recent advancements in mobile app testing have mostly focused on testing functional correctness of programs, which may not be suitable for revealing energy defects [3].", "part": "1"}, {"sec": "sec1", "text": " [3] proposed a technique based on mutation testing to identify the properties of proper tests for energy testing.", "part": "1"}, {"sec": "sec1", "text": "None of the prior automated Android testing techniques properly consider these contextual factors in test generation [4], [3], thereby are not able to effectively test the energy behavior of apps.", "part": "1"}, {"sec": "sec2", "text": "Fail to check connectivity energy defect [3] occurs when an app fails to check for connectivity before performing a network operation.", "part": "1"}, {"sec": "sec5b2", "text": "Many energy defects manifest themselves under specific hardware settings [3], making it important to test an app under different hardware states.", "part": "1"}, {"sec": "sec6c", "text": " Similar to prior work [3], if the energy traces obtained during the fault reproduction and test execution matched, we determined that the test suite was able to detect the corresponding fault.", "part": "1"}, {"sec": "sec6e", "text": " To that end, we used a recently published energy defect model for Android [3], consisting of 28 energy defect types, categorized into seven groups, namely bluetooth, display, location, network, recurring callback, sensor, and wakelock.", "part": "1"}, {"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106244", "abstract": "The rising popularity of mobile apps deployed on battery-constrained devices underlines the need for effectively evaluating their energy properties. However, currently there is a lack of testing tools for evaluating the energy properties of apps. As a result, for energy testing, developers are relying on tests intended for evaluating the functional correctness of apps. Such tests may not be adequate for revealing energy defects and inefficiencies in apps. This paper presents an energy-aware muta...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=%CE%BCdroid%3A+an+energy-aware+mutation+testing+framework+for+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "S. R. Choudhary, A. Gorla, A. Orso, \"Automated test input generation for android: Are we there yet?(e)\", <em>Automated Software Engineering (ASE) 2015 30th IEEE/ACM International Conference</em>, pp. 429-440, 2015.", "title": "Automated test input generation for android: Are we there yet?(e)", "context": [{"sec": "sec1", "text": "None of the prior automated Android testing techniques properly consider these contextual factors in test generation [4], [3], thereby are not able to effectively test the energy behavior of apps.", "part": "1"}, {"sec": "sec6a", "text": " We compare Cobweb against Monkey [39], since (1) it is arguably the most widely used automated testing tool for Android, and (2) in practice, it has shown To outperform other academic test generation tools [4].", "part": "1"}, {"sec": "sec6b", "text": " Monkey is shown To converge very close to its highest coverage at around 10 minutes [4].", "part": "1"}, {"sec": "sec7", "text": "Test input generation techniques for Android apps mainly focus on either fuzzing to generate Intents or exercising an Android app through its GUI [4].", "part": "1"}], "links": {"documentLink": "/document/7372031", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372031", "abstract": "Like all software, mobile applications (&#34;apps&#34;) must be adequately tested to gain confidence that they behave correctly. Therefore, in recent years, researchers and practitioners alike have begun to investigate ways to automate apps testing. In particular, because of Android&#39;s open source nature and its large share of the market, a great deal of research has been performed on input generation techniques for apps that run on the Android operating systems. At this point in time, there are in fact ...", "pdfSize": "289KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+test+input+generation+for+android%3A+Are+we+there+yet%3F%28e%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "D. Amalfitano, A. R. Fasolino, P. Tramontana, S. De Carmine, A. M. Memon, \"Using gui ripping for automated testing of android applications\", <em>Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 258-261, 2012.", "title": "Using gui ripping for automated testing of android applications", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2351676.2351717", "abstract": "We present AndroidRipper, an automated technique that tests Android apps via their Graphical User Interface (GUI). AndroidRipper is based on a user-interface driven ripper that automatically explores the app&#39;s GUI with the aim of exercising the application in a structured manner. We evaluate AndroidRipper on an open-source Android app. Our results show that our GUI-based test cases are able to detect severe, previously unknown, faults in the underlying code, and the structured exploration outper...", "pdfSize": "474KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+gui+ripping+for+automated+testing+of+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "T. Azim, I. Neamtiu, \"Targeted and depth-first exploration for systematic testing of android apps\", <em>Acm Sigplan Notices</em>, vol. 48, no. 10, pp. 641-660, 2013.", "title": "Targeted and depth-first exploration for systematic testing of android apps", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[6][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Targeted+and+depth-first+exploration+for+systematic+testing+of+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "W. Choi, G. Necula, K. Sen, \"Guided gui testing of android apps with minimal restart and approximate learning\", <em>Acm Sigplan Notices</em>, vol. 48, no. 10, pp. 623-640, 2013.", "title": "Guided gui testing of android apps with minimal restart and approximate learning", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[7][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guided+gui+testing+of+android+apps+with+minimal+restart+and+approximate+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "W. Yang, M. R. Prasad, T. Xie, \"A grey-box approach for automated gui-model generation of mobile applications\", <em>International Conference on Fundamental Approaches to Software Engineering</em>, pp. 250-265, 2013.", "title": "A grey-box approach for automated gui-model generation of mobile applications", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[8][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+grey-box+approach+for+automated+gui-model+generation+of+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "S. Hao, B. Liu, S. Nath, \"Puma: programmable ui-automation for large-scale dynamic analysis of mobile apps\", <em>Proceedings of the 12th annual international conference on Mobile systems applications and services</em>, pp. 204-217, 2014.", "title": "Puma: programmable ui-automation for large-scale dynamic analysis of mobile apps", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[9][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2594368.2594390", "abstract": "Mobile app ecosystems have experienced tremendous growth in the last six years. This has triggered research on dynamic analysis of performance, security, and correctness properties of the mobile apps in the ecosystem. Exploration of app execution using automated UI actions has emerged as an important tool for this research. However, existing research has largely developed analysis-specific UI automation techniques, wherein the logic for exploring app execution is intertwined with the logic for a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Puma%3A+programmable+ui-automation+for+large-scale+dynamic+analysis+of+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "R. Mahmood, N. Mirzaei, S. Malek, \"Evodroid: Segmented evolutionary testing of android apps\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 599-609, 2014.", "title": "Evodroid: Segmented evolutionary testing of android apps", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[10][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}, {"sec": "sec7", "text": " Another set of techniques employ systematic exploration of an app in the construction of test cases: EvoDroid [10] and Sapienz [12] employ an evolutionary algorithm; ACTEve [34], JPF-Android [35], Collider [36], and SIG-Droid [37] utilize symbolic execution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635896", "abstract": "Proliferation of Android devices and apps has created a demand for applicable automated software testing techniques. Prior research has primarily focused on either unit or GUI testing of Android apps, but not their end-to-end system testing in a systematic manner. We present EvoDroid, an evolutionary approach for system testing of Android apps. EvoDroid overcomes a key shortcoming of using evolutionary techniques for system testing, i.e., the inability to pass on genetic makeup of good individua...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evodroid%3A+Segmented+evolutionary+testing+of+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "N. Mirzaei, J. Garcia, H. Bagheri, A. Sadeghi, S. Malek, \"Reducing combinatorics in gui testing of android applications\", <em>Software Engineering (ICSE) 2016 IEEE/ACM 38th International Conference</em>, pp. 559-570, 2016.", "title": "Reducing combinatorics in gui testing of android applications", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[11][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}, {"sec": "sec4a", "text": " Cobweb builds on top of TrimDroid [11] to infer such transitions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884853", "abstract": "The rising popularity of Android and the GUI-driven nature of its apps have motivated the need for applicable automated GUI testing techniques. Although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing, it is often infeasible, due to the combinatorial explosion of test cases. This paper presents TrimDroid, a framework for GUI testing of Android apps that uses a novel strategy to generate tests in a combinatorial, yet scalable, fashion. It is backe...", "pdfSize": "967KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reducing+combinatorics+in+gui+testing+of+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "K. Mao, M. Harman, Y. Jia, \"Sapienz: Multi-objective automated testing for android applications\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis</em>, pp. 94-105, 2016.", "title": "Sapienz: Multi-objective automated testing for android applications", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[12][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}, {"sec": "sec5a", "text": "For input fields, Cobweb follows an approach similar to Sapienz [12] and extracts statically-defined values from the source code and layout files.", "part": "1"}, {"sec": "sec7", "text": " Another set of techniques employ systematic exploration of an app in the construction of test cases: EvoDroid [10] and Sapienz [12] employ an evolutionary algorithm; ACTEve [34], JPF-Android [35], Collider [36], and SIG-Droid [37] utilize symbolic execution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931054", "abstract": "We introduce Sapienz, an approach to Android testing that uses multi-objective search-based testing to automatically explore and optimise test sequences, minimising length, while simultaneously maximising coverage and fault revelation. Sapienz combines random fuzzing, systematic and search-based exploration, exploiting seeding and multi-level instrumentation. Sapienz significantly outperforms (with large effect size) both the state-of-the-art technique Dynodroid and the widely-used tool, Android...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sapienz%3A+Multi-objective+automated+testing+for+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "T. Su, G. Meng, Y. Chen, K. Wu, W. Yang, Y. Yao, G. Pu, Y. Liu, Z. Su, \"Guided stochastic model-based gui testing of android apps\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, pp. 245-256, 2017.", "title": "Guided, stochastic model-based gui testing of android apps", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[13][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}, {"sec": "sec6a", "text": " We also compare against the most recent publicly available Android testing tool, Stoat [13], shown to be superior to prior testing tools.", "part": "1"}, {"sec": "sec6b", "text": " We ran Stoat for 3 hours, similar to the configuration used by its authors [13].", "part": "1"}, {"sec": "sec7", "text": " Several techniques [52]\u2013[56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106298", "abstract": "Mobile apps are ubiquitous, operate in complex environments and are developed under the time-to-market pressure. Ensuring their correctness and reliability thus becomes an important challenge. This paper introduces Stoat, a novel guided approach to perform stochastic model-based testing on Android apps. Stoat operates in two phases: (1) Given an app as input, it uses dynamic analysis enhanced by a weighted UI exploration strategy and static analysis to reverse engineer a stochastic model of the ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guided%2C+stochastic+model-based+gui+testing+of+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "C. Zhang, H. Cheng, E. Tang, X. Chen, L. Bu, X. Li, \"Sketch-guided gui test generation for mobile applications\", <em>Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 38-43, 2017.", "title": "Sketch-guided gui test generation for mobile applications", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[14][15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}, {"sec": "sec7", "text": " Several techniques [52]\u2013[56], [13]\u2013[14][15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "links": {"documentLink": "/document/8115616", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115616", "abstract": "Mobile applications with complex GUIs are very popular today. However, generating test cases for these applications is often tedious professional work. On the one hand, manually designing and writing elaborate GUI scripts requires expertise. On the other hand, generating GUI scripts with record and playback techniques usually depends on repetitive work that testers need to interact with the application over and over again, because only one path is recorded in an execution. Automatic GUI testing ...", "pdfSize": "1784KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sketch-guided+gui+test+generation+for+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "W. Song, X. Qian, J. Huang, \"Ehbdroid: beyond gui testing for android applications\", <em>Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 27-37, 2017.", "title": "Ehbdroid: beyond gui testing for android applications", "context": [{"sec": "sec1", "text": " That is, majority of the state-of-the-art Android testing tools [5]\u2013[15] are aimed for GUI testing, which only considers the inputs directly generated by user, e.g., clicking on a button.", "part": "1"}, {"sec": "sec7", "text": " Several techniques [52]\u2013[56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "links": {"documentLink": "/document/8115615", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115615", "abstract": "With the prevalence of Android-based mobile devices, automated testing for Android apps has received increasing attention. However, owing to the large variety of events that Android supports, test input generation is a challenging task. In this paper, we present a novel approach and an open source tool called EHBDroid for testing Android apps. In contrast to conventional GUI testing approaches, a key novelty of EHBDroid is that it does not generate events from the GUI, but directly invokes callb...", "pdfSize": "256KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ehbdroid%3A+beyond+gui+testing+for+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "A. Machiry, R. Tahiliani, M. Naik, \"Dynodroid: An input generation system for android apps\", <em>Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering</em>, pp. 224-234, 2013.", "title": "Dynodroid: An input generation system for android apps", "context": [{"sec": "sec1", "text": " Even among the techniques that go beyond GUI testing [16], [17], there is no systematic approach for altering the lifecycle of components and state of hardware elements to properly evaluate the energy behavior of apps.", "part": "1"}, {"sec": "sec7", "text": " Dynodroid [16] and Monkey [39] generate test inputs using random input values.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491450", "abstract": "We present a system Dynodroid for generating relevant inputs to unmodified Android apps. Dynodroid views an app as an event-driven program that interacts with its environment by means of a sequence of events through the Android framework. By instrumenting the framework once and for all, Dynodroid monitors the reaction of an app upon each event in a lightweight manner, using it to guide the generation of the next event to the app. Dynodroid also allows interleaving events from machines, which are...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynodroid%3A+An+input+generation+system+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "L. L. Zhang, C.-J. M. Liang, Y. Liu, E. Chen, \"Systematically testing background services of mobile apps\", <em>Automated Software Engineering (ASE) 2017 32nd IEEE/ACM International Conference</em>, pp. 4-15, 2017.", "title": "Systematically testing background services of mobile apps", "context": [{"sec": "sec1", "text": " Even among the techniques that go beyond GUI testing [16], [17], there is no systematic approach for altering the lifecycle of components and state of hardware elements to properly evaluate the energy behavior of apps.", "part": "1"}, {"sec": "sec7", "text": " Another group of techniques focus on testing for specific defects [58], [59], [17].", "part": "1"}], "links": {"documentLink": "/document/8115613", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115613", "abstract": "Contrary to popular belief, mobile apps can spend a large fraction of time running &#34;hidden&#34; as background services. And, bugs in services can translate into crashes, energy depletion, device slow-down, etc. Unfortunately, without necessary testing tools, developers can only resort to telemetries from user devices in the wild. To this end, Snowdrop is a testing framework that systematically identifies and automates background services in Android apps. Snowdrop realizes a service-oriented approach...", "pdfSize": "375KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Systematically+testing+background+services+of+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>MyTracker Android App</em>, 2017,  [online]  Available: https://github.com/ReyhanJB/MyTracker.", "title": "MyTracker Android App", "context": [{"sec": "sec2", "text": "As an illustrative example, we use an Android app called MyTracker [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=MyTracker+Android+App&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>Location manager strategies</em>, 2017,  [online]  Available: https://developer.android.com/guide/topics/location/strategies.html.", "title": "Location manager strategies", "context": [{"sec": "sec2", "text": " However, when user puts the app in the Paused state, i.e., MyTracker is sent to background, it does not unregister the location listener, thereby, unnecessarily updates a GUI that is not visible to the user [19], [20].", "part": "1"}, {"sec": "sec4c", "text": " For instance, per Android developer guidelines [19], a location listener should be unregistered when user is stationary, or the frequency of location update should be lowered when user is walking rather than driving.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Location+manager+strategies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Y. Liu, C. Xu, S.-C. Cheung, J. L\u00fc, \"Greendroid: Automated diagnosis of energy inefficiency for smartphone applications\", <em>IEEE Transactions on Software Engineering</em>, vol. 40, no. 9, pp. 911-940, 2014.", "title": "Greendroid: Automated diagnosis of energy inefficiency for smartphone applications", "context": [{"sec": "sec2", "text": " However, when user puts the app in the Paused state, i.e., MyTracker is sent to background, it does not unregister the location listener, thereby, unnecessarily updates a GUI that is not visible to the user [19], [20].", "part": "1"}, {"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}, {"sec": "sec7", "text": "The closest approaches to Cobweb are that of Banerjee et al. [46], GreenDroid [20], and EnergyPatch [43].", "part": "1"}], "links": {"documentLink": "/document/6815752", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6815752", "abstract": "Smartphone applications&#39; energy efficiency is vital, but many Android applications suffer from serious energy inefficiency problems. Locating these problems is labor-intensive and automated diagnosis is highly desirable. However, a key challenge is the lack of a decidable criterion that facilitates automated judgment of such energy problems. Our work aims to address this challenge. We conducted an in-depth study of 173 open-source and 229 commercial Android applications, and observed two common ...", "pdfSize": "3186KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Greendroid%3A+Automated+diagnosis+of+energy+inefficiency+for+smartphone+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "M. Harman, P. McMinn, \"A theoretical and empirical study of search-based testing: Local global and hybrid search\", <em>IEEE Transactions on Software Engineering</em>, vol. 36, no. 2, pp. 226-247, 2010.", "title": "A theoretical and empirical study of search-based testing: Local, global, and hybrid search", "context": [], "links": {"documentLink": "/document/5342440", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5342440", "abstract": "Search-based optimization techniques have been applied to structural software test data generation since 1992, with a recent upsurge in interest and activity within this area. However, despite the large number of recent studies on the applicability of different search-based optimization approaches, there has been very little theoretical analysis of the types of testing problem for which these techniques are well suited. There are also few empirical studies that present results for larger program...", "pdfSize": "5290KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+theoretical+and+empirical+study+of+search-based+testing%3A+Local%2C+global%2C+and+hybrid+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "M. Harman, P. McMinn, J. T. De Souza, S. Yoo, \"Search based software engineering: Techniques taxonomy tutorial\" in Empirical software engineering and verification, Springer, pp. 1-59, 2012.", "title": "Search based software engineering: Techniques, taxonomy, tutorial", "context": [], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-25231-0_1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Search+based+software+engineering%3A+Techniques%2C+taxonomy%2C+tutorial&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "E. Cantu-Paz, D. E. Goldberg, \"Efficient parallel genetic algorithms: theory and practice\", <em>Computer methods in applied mechanics and engineering</em>, vol. 186, no. 2\u20134, pp. 221-238, 2000.", "title": "Efficient parallel genetic algorithms: theory and practice", "context": [], "links": {"crossRefLink": "https://doi.org/10.1016/S0045-7825(99)00385-0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+parallel+genetic+algorithms%3A+theory+and+practice&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "F. Asadi, G. Antoniol, Y.-G. Gueheneuc, \"Concept location with genetic algorithms: A comparison of four distributed architectures\", <em>Search Based Software Engineering (SSBSE) 2010 Second International Symposium</em>, pp. 153-162, 2010.", "title": "Concept location with genetic algorithms: A comparison of four distributed architectures", "context": [], "links": {"documentLink": "/document/5635157", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5635157", "abstract": "Genetic algorithms are attractive to solve many search-based software engineering problems because they allow the easy parallelization of computations, which improves scalability and reduces computation time. In this paper, we present our experience in applying different distributed architectures to parallelize a genetic algorithm used to solve the concept identification problem. We developed an approach to identify concepts in execution traces by finding cohesive and decoupled fragments of the ...", "pdfSize": "665KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Concept+location+with+genetic+algorithms%3A+A+comparison+of+four+distributed+architectures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "<em>Robolectric</em>, 2017,  [online]  Available: http://robolectric.org/.", "title": "Robolectric", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Robolectric&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "<em>Android testing support library: Espresso</em>, 2017,  [online]  Available: https://google.github.io/android-testing-support-library/docs/espressol.", "title": "Android testing support library: Espresso", "context": [{"sec": "sec5a", "text": " It takes the app along with LSM and HSM models as inputs and generates a set of Espresso [26] tests-\\$T_{E}\\$.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+testing+support+library%3A+Espresso&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "R. Vall\u00e9e-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, V. Sundaresan, \"Soot-a java bytecode optimization framework\", <em>Proceedings of the 1999 conference of the Centre for Advanced Studies on Collaborative research</em>, pp. 13, 1999.", "title": "Soot-a java bytecode optimization framework", "context": [{"sec": "sec4a", "text": " The call graph obtained from running the state-of-the-art static analysis tools, such as Soot [27], does not model any particular order for the execution of entry points.", "part": "1"}, {"sec": "sec4a", "text": "Call transition: These intra-component transitions are inferred from the basic call graph generated for the app under test using Soot [27].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Soot-a+java+bytecode+optimization+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "D. Octeau, D. Luchaup, M. Dering, S. Jha, P. McDaniel, \"Composite constant propagation: Application to android inter-component communication analysis\", <em>Proceedings of the 37th International Conference on Software Engineering-Volume 1</em>, pp. 77-88, 2015.", "title": "Composite constant propagation: Application to android inter-component communication analysis", "context": [{"sec": "sec4a", "text": " Cobweb uses IC3 [28] to infer Intent transitions.", "part": "1"}], "links": {"documentLink": "/document/7194563", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194563", "abstract": "Many program analyses require statically inferring the possible values of composite types. However, current approaches either do not account for correlations between object fields or do so in an ad hoc manner. In this paper, we introduce the problem of composite constant propagation. We develop the first generic solver that infers all possible values of complex objects in an interprocedural, flow and context-sensitive manner, taking field correlations into account. Composite constant propagation...", "pdfSize": "918KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Composite+constant+propagation%3A+Application+to+android+inter-component+communication+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Y. Liu, C. Xu, S.-C. Cheung, V. Terragni, <em>Understanding and detecting wake lock misuses for android applications</em>, pp. 396-409, 2016.", "title": "Understanding and detecting wake lock misuses for android applications", "context": [{"sec": "sec4b", "text": "Wakelocks and other resources, such as GPS, are commonly acquired and released in lifecycle event handlers [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+and+detecting+wake+lock+misuses+for+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "A. Pathak, Y. C. Hu, M. Zhang, \"Where is the energy spent inside my app?: fine grained energy accounting on smartphones with eprof\", <em>Proceedings of the 7th ACM european conference on Computer Systems</em>, pp. 29-42, 2012.", "title": "Where is the energy spent inside my app?: fine grained energy accounting on smartphones with eprof", "context": [{"sec": "sec4c", "text": "Identifying different states of hardware elements for energy testing is crucial, since apps consume different amounts of energy in different states [30].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2168836.2168841", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Where+is+the+energy+spent+inside+my+app%3F%3A+fine+grained+energy+accounting+on+smartphones+with+eprof&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "<em>Android api reference</em>, 2017,  [online]  Available: https://developer.android.com/reference/packages.html.", "title": "Android api reference", "context": [{"sec": "sec4c", "text": "To find a thorough list of such libraries, we started by automatically crawling Android API reference [31] using Crawler4J [32] to search for classes, where description of their public methods or fields contained at least two of the following keywords: location, lock, gps, network, connect, radio, cellular, bluetooth, display, sensor, cpu, battery, power, consume, drain, charge, discharge, monitor, hardware, state, and telephone.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+api+reference&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "<em>crawler4j</em>, 2017,  [online]  Available: https://github.com/yasserg/crawler4j.", "title": "crawler4j", "context": [{"sec": "sec4c", "text": "To find a thorough list of such libraries, we started by automatically crawling Android API reference [31] using Crawler4J [32] to search for classes, where description of their public methods or fields contained at least two of the following keywords: location, lock, gps, network, connect, radio, cellular, bluetooth, display, sensor, cpu, battery, power, consume, drain, charge, discharge, monitor, hardware, state, and telephone.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=crawler4j&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "<em>Cobweb website</em>, 2018,  [online]  Available: https://sites.google.com/view/icse-cobweb.", "title": "Cobweb website", "context": [{"sec": "sec4c", "text": " We have made the HSM models of other hardware elements publicly available [33].", "part": "1"}, {"sec": "sec8", "text": " Cobweb and research artifacts are available publicly [33].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cobweb+website&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "S. Anand, M. Naik, M. J. Harrold, H. Yang, \"Automated concolic testing of smartphone apps\", <em>Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering ser. FSE '12</em>, pp. 59:1-59:11, 2012.", "title": "Automated concolic testing of smartphone apps", "context": [{"sec": "sec5a", "text": " Alternatively, the input values can be provided to Cobweb through symbolic execution of the app, using one of the many tools available for this purpose (e.g., [34]\u2013[37]).", "part": "1"}, {"sec": "sec7", "text": " Another set of techniques employ systematic exploration of an app in the construction of test cases: EvoDroid [10] and Sapienz [12] employ an evolutionary algorithm; ACTEve [34], JPF-Android [35], Collider [36], and SIG-Droid [37] utilize symbolic execution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2393596.2393666", "abstract": "We present an algorithm and a system for generating input events to exercise smartphone apps. Our approach is based on concolic testing and generates sequences of events automatically and systematically. It alleviates the path-explosion problem by checking a condition on program executions that identifies subsumption between different event sequences. We also describe our implementation of the approach for Android, the most popular smartphone app platform, and the results of an evaluation that d...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+concolic+testing+of+smartphone+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "H. Van der Merwe, B. Van der Merwe, W. Visser, \"Execution and property specifications for jpf-android\", <em>SIGSOFT Softw. Eng. Notes</em>, vol. 39, no. 1, pp. 1-5, Feb. 2014.", "title": "Execution and property specifications for jpf-android", "context": [{"sec": "sec5a", "text": " Alternatively, the input values can be provided to Cobweb through symbolic execution of the app, using one of the many tools available for this purpose (e.g., [34]\u2013[35][37]).", "part": "1"}, {"sec": "sec7", "text": " Another set of techniques employ systematic exploration of an app in the construction of test cases: EvoDroid [10] and Sapienz [12] employ an evolutionary algorithm; ACTEve [34], JPF-Android [35], Collider [36], and SIG-Droid [37] utilize symbolic execution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2557833.2560576", "abstract": "JPF-Android is a model checking tool for Android applications allowing them to be verified outside of an emulator on Java PathFinder (JPF). The Android applications are executed on a model of the Android software stack and their execution driven by simulating user and system input events. This paper follows from our previous work describing the design decisions and implementation of JPF-Android. Here we discuss the syntax and implementation of the scripting environment which is used to drive the...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Execution+and+property+specifications+for+jpf-android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "C. S. Jensen, M. R. Prasad, A. M\u00d8ller, \"Automated testing with targeted event sequence generation\", <em>Proceedings of the 2013 International Symposium on Software Testing and Analysis ser. ISSTA 2013</em>, pp. 67-77, 2013.", "title": "Automated testing with targeted event sequence generation", "context": [{"sec": "sec5a", "text": " Alternatively, the input values can be provided to Cobweb through symbolic execution of the app, using one of the many tools available for this purpose (e.g., [34]\u2013[36][37]).", "part": "1"}, {"sec": "sec7", "text": " Another set of techniques employ systematic exploration of an app in the construction of test cases: EvoDroid [10] and Sapienz [12] employ an evolutionary algorithm; ACTEve [34], JPF-Android [35], Collider [36], and SIG-Droid [37] utilize symbolic execution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2483760.2483777", "abstract": "Automated software testing aims to detect errors by producing test inputs that cover as much of the application source code as possible. Applications for mobile devices are typically event-driven, which raises the challenge of automatically producing event sequences that result in high coverage. Some existing approaches use random or model-based testing that largely treats the application as a black box. Other approaches use symbolic execution, either starting from the entry points of the applic...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+testing+with+targeted+event+sequence+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "N. Mirzaei, H. Bagheri, R. Mahmood, S. Malek, \"Sig-droid: Automated system input generation for android applications\", <em>Software Reliability Engineering (ISSRE) 2015 IEEE 26th International Symposium</em>, pp. 461-471, 2015.", "title": "Sig-droid: Automated system input generation for android applications", "context": [{"sec": "sec5a", "text": " Alternatively, the input values can be provided to Cobweb through symbolic execution of the app, using one of the many tools available for this purpose (e.g., [34]\u2013[37]).", "part": "1"}, {"sec": "sec7", "text": " Another set of techniques employ systematic exploration of an app in the construction of test cases: EvoDroid [10] and Sapienz [12] employ an evolutionary algorithm; ACTEve [34], JPF-Android [35], Collider [36], and SIG-Droid [37] utilize symbolic execution.", "part": "1"}], "links": {"documentLink": "/document/7381839", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7381839", "abstract": "Pervasiveness of smartphones and the vast number of corresponding apps have underlined the need for applicable automated software testing techniques. A wealth of research has been focused on either unit or GUI testing of smartphone apps, but little on automated support for end-to-end system testing. This paper presents SIG-Droid, a framework for system testing of Android apps, backed with automated program analysis to extract app models and symbolic execution of source code guided by such models...", "pdfSize": "677KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sig-droid%3A+Automated+system+input+generation+for+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "M. Linares-V\u00e1squez, G. Bavota, C. Bernal-C\u00e1rdenas, R. Oliveto, M. Di Penta, D. Poshyvanyk, \"Mining energy-greedy api usage patterns in android apps: an empirical study\", <em>Proceedings of the 11 th Working Conference on Mining Software Repositories</em>, pp. 2-11, 2014.", "title": "Mining energy-greedy api usage patterns in android apps: an empirical study", "context": [{"sec": "sec5b3", "text": " To obtain the weight of each energy-greedy API, Cobweb relies on a prior study [38] that has ranked energy-greedy APIs based on their energy-greediness to compute \\$w_{k}\\$ in Equation 2.", "part": "1"}, {"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2597073.2597085", "abstract": "Energy consumption of mobile applications is nowadays a hot topic, given the widespread use of mobile devices. The high demand for features and improved user experience, given the available powerful hardware, tend to increase the apps\u2019 energy consumption. However, excessive energy consumption in mobile apps could also be a consequence of energy greedy hardware, bad programming practices, or particular API usage patterns. We present the largest to date quantitative and qualitative empirical inves...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+energy-greedy+api+usage+patterns+in+android+apps%3A+an+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "<em>UI/Application Excersizer Monkey</em>, 2017,  [online]  Available: http://developer.android.com/tools/help/monkey.html.", "title": "UI/Application Excersizer Monkey", "context": [{"sec": "sec6a", "text": " We compare Cobweb against Monkey [39], since (1) it is arguably the most widely used automated testing tool for Android, and (2) in practice, it has shown To outperform other academic test generation tools [4].", "part": "1"}, {"sec": "sec7", "text": " Dynodroid [16] and Monkey [39] generate test inputs using random input values.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=UI%2FApplication+Excersizer+Monkey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "L. Ben-Zur, <em>Using Trepn Profiler for Power-Efficient Apps</em>, 2017,  [online]  Available: https://developer.qualcomm.com/blog/developer-tool-spotlight-using-trepn-profiler-power-efficient-apps.", "title": "Using Trepn Profiler for Power-Efficient Apps", "context": [{"sec": "sec6a", "text": " We profiled the state of hardware elements during and after execution of the app using Trepn [40].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+Trepn+Profiler+for+Power-Efficient+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "<em>EMMA: a free Java code coverage tool</em>,  [online]  Available: http://emma.sourceforge.net.", "title": "EMMA: a free Java code coverage tool", "context": [{"sec": "sec6b", "text": " We collected coverage information of the subjects using EMMA [41] during test execution.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=EMMA%3A+a+free+Java+code+coverage+tool&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Y. Lyu, D. Li, W. G. Halfond, \"Remove rats from your code: automated optimization of resource inefficient database writes for mobile applications\", <em>Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis</em>, pp. 310-321, 2018.", "title": "Remove rats from your code: automated optimization of resource inefficient database writes for mobile applications", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3213846.3213865", "abstract": "Developers strive to build feature-filled apps that are responsive and consume as few resources as possible. Most of these apps make use of local databases to store and access data locally. Prior work has found that local database services have become one of the major drivers of a mobile device&#39;s resource consumption. In this paper we propose an approach to reduce the energy consumption and improve runtime performance of database operations in Android apps by optimizing inefficient database writ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Remove+rats+from+your+code%3A+automated+optimization+of+resource+inefficient+database+writes+for+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "A. Banerjee, L. K. Chong, C. Ballabriga, A. Roychoudhury, \"En-ergypatch: Repairing resource leaks to improve energy-efficiency of android apps\", <em>IEEE Transactions on Software Engineering</em>, vol. 44, no. 5, pp. 470-490, 2018.", "title": "En-ergypatch: Repairing resource leaks to improve energy-efficiency of android apps", "context": [{"sec": "sec7", "text": "The closest approaches to Cobweb are that of Banerjee et al. [46], GreenDroid [20], and EnergyPatch [43].", "part": "1"}, {"sec": "sec7", "text": " EnergyPatch [43] fixes the scalability issue of the prior work [46] by using abstract interpretation-based program analysis to detect resource leaks instead of power trace oracle.", "part": "1"}], "links": {"documentLink": "/document/7889026", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7889026", "abstract": "Increased usage of mobile devices, such as smartphones and tablets, has led to widespread popularity and usage of mobile apps. If not carefully developed, such apps may demonstrate energy-inefficient behaviour, where one or more energy-intensive hardware components (such as Wifi, GPS, etc) are left in a high-power state, even when no apps are using these components. We refer to such kind of energy-inefficiencies as energy bugs. Executing an app with an energy bug causes the mobile device to exhi...", "pdfSize": "2023KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=En-ergypatch%3A+Repairing+resource+leaks+to+improve+energy-efficiency+of+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "T. Wu, J. Liu, Z. Xu, C. Guo, Y. Zhang, J. Yan, J. Zhang, \"Light-weight inter-procedural and callback-aware resource leak detection for android apps\", <em>IEEE Trans. Software Eng.</em>, vol. 42, no. 11, pp. 1054-1076, 2016.", "title": "Light-weight, inter-procedural and callback-aware resource leak detection for android apps", "context": [], "links": {"documentLink": "/document/7442579", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7442579", "abstract": "Android devices include many embedded resources such as Camera, Media Player and Sensors. These resources require programmers to explicitly request and release them. Missing release operations might cause serious problems such as performance degradation or system crash. This kind of defects is called resource leak. Despite a large body of existing works on testing and analyzing Android apps, there still remain several challenging problems. In this work, we present Relda2, a light-weight and prec...", "pdfSize": "1631KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Light-weight%2C+inter-procedural+and+callback-aware+resource+leak+detection+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "M. Linares-V\u00e1squez, G. Bavota, C. E. B. C\u00e1rdenas, R. Oliveto, M. Di Penta, D. Poshyvanyk, \"Optimizing energy consumption of guis in android apps: a multi-objective approach\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering</em>, pp. 143-154, 2015.", "title": "Optimizing energy consumption of guis in android apps: a multi-objective approach", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786847", "abstract": "The wide diffusion of mobile devices has motivated research towards optimizing energy consumption of software systems\u2014 including apps\u2014targeting such devices. Besides efforts aimed at dealing with various kinds of energy bugs, the adoption of Organic Light-Emitting Diode (OLED) screens has motivated research towards reducing energy consumption by choosing an appropriate color palette. Whilst past research in this area aimed at optimizing energy while keeping an acceptable level of contrast, this ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Optimizing+energy+consumption+of+guis+in+android+apps%3A+a+multi-objective+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "A. Banerjee, L. K. Chong, S. Chattopadhyay, A. Roychoudhury, \"Detecting energy bugs and hotspots in mobile apps\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 588-598, 2014.", "title": "Detecting energy bugs and hotspots in mobile apps", "context": [{"sec": "sec6e", "text": " Furthermore, it appears that dynamic analysis solutions, such as Cobweb and [46], are able To detect a wider variety of energy defects compared to static analysis solutions.", "part": "1"}, {"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}, {"sec": "sec7", "text": " [46], GreenDroid [20], and EnergyPatch [43].", "part": "1"}, {"sec": "sec7", "text": " [46] present a search-based profiling strategy with the goal of identifying energy defects in an app.", "part": "1"}, {"sec": "sec7", "text": " EnergyPatch [43] fixes the scalability issue of the prior work [46] by using abstract interpretation-based program analysis to detect resource leaks instead of power trace oracle.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635871", "abstract": "Over the recent years, the popularity of smartphones has increased dramatically. This has lead to a widespread availability of smartphone applications. Since smartphones operate on a limited amount of battery power, it is important to develop tools and techniques that aid in energy-efficient application development. Energy inefficiencies in smartphone applications can broadly be categorized into energy hotspots and energy bugs. An energy hotspot can be described as a scenario where executing an ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+energy+bugs+and+hotspots+in+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "D. Li, A. H. Tran, W. G. Halfond, \"Making web applications more energy efficient for oled smartphones\", <em>Proceedings of the 36th International Conference on Software Engineering</em>, pp. 527-538, 2014.", "title": "Making web applications more energy efficient for oled smartphones", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568321", "abstract": "A smartphone\u2019s display is one of its most energy consuming components. Modern smartphones use OLED displays that consume more energy when displaying light colors as op- posed to dark colors. This is problematic as many popular mobile web applications use large light colored backgrounds. To address this problem we developed an approach for auto- matically rewriting web applications so that they generate more energy efficient web pages. Our approach is based on program analysis of the structure of...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Making+web+applications+more+energy+efficient+for+oled+smartphones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "H. Ye, S. Cheng, L. Zhang, F. Jiang, \"DroidFuzzer: Fuzzing the Android Apps with Intent-Filter Tag\", <em>Proceedings of International Conference on Advances in Mobile Computing & Multimedia ser. MoMM '13</em>, pp. 68:68-68:74, 2013.", "title": "DroidFuzzer: Fuzzing the Android Apps with Intent-Filter Tag", "context": [{"sec": "sec7", "text": " Several approaches generate Intents with null payloads or by randomly generating payloads for Intents [48]\u2013[51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidFuzzer%3A+Fuzzing+the+Android+Apps+with+Intent-Filter+Tag&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "K. Yang, J. Zhuge, Y. Wang, L. Zhou, H. Duan, \"IntentFuzzer: Detecting Capability Leaks of Android Applications\", <em>Proceedings of the 9th ACM Symposium on Information Computer and Communications Security ser. ASIA CCS '14</em>, pp. 531-536, 2014.", "title": "IntentFuzzer: Detecting Capability Leaks of Android Applications", "context": [{"sec": "sec7", "text": " Several approaches generate Intents with null payloads or by randomly generating payloads for Intents [48]\u2013[49][51].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2590296.2590316", "abstract": "Capability leak is a vulnerability in Android applications, which violates the enforcement of permission model and threatens the secure usage of Android phone users. Malicious applications can launch permission escalation attacks with this vulnerability. In this paper, we propose a dynamic Intent fuzzing mechanism to uncover vulnerable applications in both Android markets and closed source ROMs. We built a prototype called IntentFuzzer. With it, we analyzed more than 2000 Android applications in...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=IntentFuzzer%3A+Detecting+Capability+Leaks+of+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "R. Sasnauskas, J. Regehr, \"Intent Fuzzer: Crafting Intents of Death\", <em>Proceedings of the 2014 Joint International Workshop on Dynamic Analysis (WODA) and Software and System Performance Testing Debugging and Analytics (PERTEA) ser. WODA+PERTEA 2014</em>, pp. 1-5, 2014.", "title": "Intent Fuzzer: Crafting Intents of Death", "context": [{"sec": "sec7", "text": " Several approaches generate Intents with null payloads or by randomly generating payloads for Intents [48]\u2013[50][51].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2632168.2632169", "abstract": "We present a fuzzing framework for Intents: the core IPC mechanism for intra- and inter-app communication in Android. Since intents lie at a trust boundary between apps, their correctness is important and thorough testing is warranted. The key challenge is to balance the tension between generating intents that applications expect, permitting deep penetration into application logic, and generating intents that trigger interesting bugs that have not been previously uncovered. Our work strikes this...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Intent+Fuzzer%3A+Crafting+Intents+of+Death&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "A. Maji, F. Arshad, S. Bagchi, J. Rellermeyer, \"An empirical study of the robustness of Inter-component Communication in Android\", <em>2012 42nd Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</em>, pp. 1-12, Jun. 2012.", "title": "An empirical study of the robustness of Inter-component Communication in Android", "context": [{"sec": "sec7", "text": " Several approaches generate Intents with null payloads or by randomly generating payloads for Intents [48]\u2013[51].", "part": "1"}], "links": {"documentLink": "/document/6263963", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6263963", "abstract": "Over the last three years, Android has established itself as the largest-selling operating system for smartphones. It boasts of a Linux-based robust kernel, a modular framework with multiple components in each application, and a security-conscious design where each application is isolated in its own virtual machine. However, all of these desirable properties would be rendered ineffectual if an application were to deliver erroneous messages to targeted applications and thus cause the target to be...", "pdfSize": "365KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+the+robustness+of+Inter-component+Communication+in+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "D. Amalfitano, A. R. Fasolino, P. Tramontana, S. De Carmine, A. M. Memon, \"Using gui ripping for automated testing of android applications\", <em>Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering ser. ASE 2012</em>, pp. 258-261, 2012.", "title": "Using gui ripping for automated testing of android applications", "context": [{"sec": "sec7", "text": " Several techniques [52]\u2013[56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2351676.2351717", "abstract": "We present AndroidRipper, an automated technique that tests Android apps via their Graphical User Interface (GUI). AndroidRipper is based on a user-interface driven ripper that automatically explores the app&#39;s GUI with the aim of exercising the application in a structured manner. We evaluate AndroidRipper on an open-source Android app. Our results show that our GUI-based test cases are able to detect severe, previously unknown, faults in the underlying code, and the structured exploration outper...", "pdfSize": "474KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+gui+ripping+for+automated+testing+of+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "D. Amalfitano, A. Fasolino, P. Tramontana, B. Ta, A. Memon, \"Mobiguitar: Automated model-based testing of mobile apps\", <em>Software IEEE</em>, vol. 32, no. 5, pp. 53-59, Sept 2015.", "title": "Mobiguitar: Automated model-based testing of mobile apps", "context": [{"sec": "sec7", "text": " Several techniques [52]\u2013[53][56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "links": {"documentLink": "/document/6786194", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6786194", "abstract": "As mobile devices become increasingly smarter and more powerful, so too must the engineering of their software. User-interface-driven system testing of these devices is gaining popularity, with each vendor releasing some automation tool. However, these tools are inappropriate for amateur programmers, an increasing portion of app developers. MobiGUITAR (Mobile GUI Testing Framework) provides automated GUI-driven testing of Android apps. It&#39;s based on observation, extraction, and abstraction of GU...", "pdfSize": "554KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mobiguitar%3A+Automated+model-based+testing+of+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "W. Yang, M. Prasad, T. Xie, V. Cortellessa, D. Varr\u00f3, \"A grey-box approach for automated gui-model generation of mobile applications\" in Fundamental Approaches to Software Engineering ser. Lecture Notes in Computer Science, Springer Berlin Heidelberg, vol. 7793, pp. 250-265, 2013.", "title": "A grey-box approach for automated gui-model generation of mobile applications", "context": [{"sec": "sec7", "text": " Several techniques [52]\u2013[54][56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+grey-box+approach+for+automated+gui-model+generation+of+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "T. Azim, I. Neamtiu, \"Targeted and depth-first exploration for systematic testing of android apps\", <em>SIGPLAN Not.</em>, vol. 48, no. 10, pp. 641-660, Oct. 2013.", "title": "Targeted and depth-first exploration for systematic testing of android apps", "context": [{"sec": "sec7", "text": " Several techniques [52]\u2013[55][56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Targeted+and+depth-first+exploration+for+systematic+testing+of+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "S. Hao, B. Liu, S. Nath, W. G. Halfond, R. Govindan, \"Puma: Programmable ui-automation for large-scale dynamic analysis of mobile apps\", <em>Proceedings of the 12th Annual International Conference on Mobile Systems Applications and Services ser. MobiSys '14</em>, pp. 204-217, 2014.", "title": "Puma: Programmable ui-automation for large-scale dynamic analysis of mobile apps", "context": [{"sec": "sec7", "text": " Several techniques [52]\u2013[56], [13]\u2013[15] rely on a model of the GUI, usually constructed dynamically and non-systematically, leading to unexplored program states.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2594368.2594390", "abstract": "Mobile app ecosystems have experienced tremendous growth in the last six years. This has triggered research on dynamic analysis of performance, security, and correctness properties of the mobile apps in the ecosystem. Exploration of app execution using automated UI actions has emerged as an important tool for this research. However, existing research has largely developed analysis-specific UI automation techniques, wherein the logic for exploring app execution is intertwined with the logic for a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Puma%3A+Programmable+ui-automation+for+large-scale+dynamic+analysis+of+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "K. Mao, M. Harman, Y. Jia, \"Crowd intelligence enhances automated mobile testing\", <em>Automated Software Engineering (ASE) 2017 32nd IEEE/ACM International Conference</em>, pp. 16-26, 2017.", "title": "Crowd intelligence enhances automated mobile testing", "context": [{"sec": "sec7", "text": " POLARIZ [57] uses information from crowd-based testing to enhance mobile test generation.", "part": "1"}], "links": {"documentLink": "/document/8115614", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115614", "abstract": "We show that information extracted from crowd-based testing can enhance automated mobile testing. We introduce Polariz, which generates replicable test scripts from crowd-based testing, extracting cross-app `motif&#39; events: automatically-inferred reusable higher-level event sequences composed of lower-level observed event actions. Our empirical study used 434 crowd workers from Mechanical Turk to perform 1,350 testing tasks on 9 popular Google Play apps, each with at least 1 million user installs...", "pdfSize": "1208KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Crowd+intelligence+enhances+automated+mobile+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "R. Hay, O. Tripp, M. Pistoia, \"Dynamic detection of interapplication communication vulnerabilities in android\", <em>Proceedings of the 2015 International Symposium on Software Testing and Analysis ser. ISSTA 2015</em>, pp. 118-128, 2015.", "title": "Dynamic detection of interapplication communication vulnerabilities in android", "context": [{"sec": "sec7", "text": " Another group of techniques focus on testing for specific defects [58], [59], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2771783.2771800", "abstract": "A main aspect of the Android platform is Inter-Application Communication (IAC), which enables reuse of functionality across apps and app components via message passing. While a powerful feature, IAC also constitutes a serious attack surface. A malicious app can embed a payload into an IAC message, thereby driving the recipient app into a potentially vulnerable behavior if the message is processed without its fields first being sanitized or validated. We present what to our knowledge is the first...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+detection+of+interapplication+communication+vulnerabilities+in+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "A. Sadeghi, R. Jabbarvand, S. Malek, \"Patdroid: permission-aware gui testing of android\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, pp. 220-232, 2017.", "title": "Patdroid: permission-aware gui testing of android", "context": [{"sec": "sec7", "text": " Another group of techniques focus on testing for specific defects [58], [59], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106250", "abstract": "Recent introduction of a dynamic permission system in Android, allowing the users to grant and revoke permissions after the installation of an app, has made it harder to properly test apps. Since an app&#39;s behavior may change depending on the granted permissions, it needs to be tested under a wide range of permission combinations. At the state-of-the-art, in the absence of any automated tool support, a developer needs to either manually determine the interaction of tests and app permissions, or e...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Patdroid%3A+permission-aware+gui+testing+of+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "C. Guo, J. Zhang, J. Yan, Z. Zhang, Y. Zhang, \"Characterizing and detecting resource leaks in android applications\", <em>Automated Software Engineering (ASE) 2013 IEEE/ACM 28th International Conference</em>, pp. 389-398, 2013.", "title": "Characterizing and detecting resource leaks in android applications", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"documentLink": "/document/6693097", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693097", "abstract": "Android phones come with a host of hardware components embedded in them, such as Camera, Media Player and Sensor. Most of these components are exclusive resources or resources consuming more memory/energy than general. And they should be explicitly released by developers. Missing release operations of these resources might cause serious problems such as performance degradation or system crash. These kinds of defects are called resource leaks. This paper focuses on resource leak problems in Andro...", "pdfSize": "374KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+and+detecting+resource+leaks+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "A. Gupta, T. Zimmermann, C. Bird, N. Nagappan, T. Bhat, S. Em-Ran, \"Mining energy traces to aid in software development: An empirical case study\", <em>Proceedings of the 8th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement</em>, pp. 40, 2014.", "title": "Mining energy traces to aid in software development: An empirical case study", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2652524.2652578", "abstract": "Context: With the advent of increased computing on mobile devices such as phones and tablets, it has become crucial to pay attention to the energy consumption of mobile applications. Goal: The software engineering field is now faced with a whole new spectrum of energy-related challenges, ranging from power budgeting to testing and debugging the energy consumption, for which exists only limited tool support. The goal of this work is to provide techniques to engineers to analyze power consumption ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+energy+traces+to+aid+in+software+development%3A+An+empirical+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "R. Jabbarvand, A. Sadeghi, J. Garcia, S. Malek, P. Ammann, \"Ecodroid: An approach for energy-based ranking of android apps\", <em>Proceedings of the Fourth International Workshop on Green and Sustainable Software</em>, pp. 8-14, 2015.", "title": "Ecodroid: An approach for energy-based ranking of android apps", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ecodroid%3A+An+approach+for+energy-based+ranking+of+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "H. Wu, S. Yang, A. Rountev, \"Static detection of energy defect patterns in android applications\", <em>Proceedings of the 25th International Conference on Compiler Construction</em>, pp. 185-195, 2016.", "title": "Static detection of energy defect patterns in android applications", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2892208.2892218", "abstract": "For static analysis researchers, Android software presents a wide variety of interesting challenges. The target of our work is static detection of energy-drain defects in Android applications. The management of energy-intensive resources (e.g., GPS) creates various opportunities for software defects. Our goal is to detect statically \u201cmissing deactivation\u201d energy-drain defects in the user interface of the application. First, we define precisely two patterns of run-time energy-drain behaviors, bas...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+detection+of+energy+defect+patterns+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "S. Chowdhury, S. Di Nardo, A. Hindle, Z. M. J. Jiang, \"An exploratory study on assessing the energy impact of logging on android applications\", <em>Empirical Software Engineering</em>, vol. 23, no. 3, pp. 1422-1456, 2018.", "title": "An exploratory study on assessing the energy impact of logging on android applications", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-017-9545-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+exploratory+study+on+assessing+the+energy+impact+of+logging+on+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "R. Jabbarvand, A. Sadeghi, H. Bagheri, S. Malek, \"Energy-aware test-suite minimization for android apps\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis</em>, pp. 425-436, 2016.", "title": "Energy-aware test-suite minimization for android apps", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Energy-aware+test-suite+minimization+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "H. Wu, Y. Wang, A. Rountev, \"S entinel: generating gui tests for android sensor leaks\", <em>Proceedings of the 13th International Workshop on Automation of Software Test</em>, pp. 27-33, 2018.", "title": "S entinel: generating gui tests for android sensor leaks", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=S+entinel%3A+generating+gui+tests+for+android+sensor+leaks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "I. Manotas, L. Pollock, J. Clause, \"Seeds: a software engineer's energy-optimization decision support framework\", <em>Proceedings of the 36th International Conference on Software Engineering</em>, pp. 503-514, 2014.", "title": "Seeds: a software engineer's energy-optimization decision support framework", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568297", "abstract": "Reducing the energy usage of software is becoming more important in many environments, in particular, battery-powered mobile devices, embedded systems and data centers. Recent empirical studies indicate that software engineers can support the goal of reducing energy usage by making design and implementation decisions in ways that take into consideration how such decisions impact the energy usage of an application. However, the large number of possible choices and the lack of feedback and informa...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Seeds%3A+a+software+engineer%27s+energy-optimization+decision+support+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "A. Banerjee, A. Roychoudhury, <em>Automated re-factoring of android apps to enhance energy-efficiency</em>, 2016.", "title": "Automated re-factoring of android apps to enhance energy-efficiency", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+re-factoring+of+android+apps+to+enhance+energy-efficiency&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "D. Li, Y. Lyu, J. Gui, W. G. Halfond, \"Automated energy optimization of http requests for mobile applications\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 249-260, 2016.", "title": "Automated energy optimization of http requests for mobile applications", "context": [{"sec": "sec7", "text": "In recent years, several auto-mated approaches for analysis [60], [47], [20], [38], [61], [62], [63], [64], [42], testing [46], [65], [3], [66], re-factoring [67], [68], and repair [69], [45] of mobile apps have been proposed to help developers produce more energy efficient apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884867", "abstract": "Energy is a critical resource for apps that run on mobile devices. Among all operations, making HTTP requests is one of the most energy consuming. Previous studies have shown that bundling smaller HTTP requests into a single larger HTTP request can be an effective way to improve energy efficiency of network communication, but have not defined an automated way to detect when apps can be bundled nor to transform the apps to do this bundling. In this paper we propose an approach to reduce the energ...", "pdfSize": "474KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+energy+optimization+of+http+requests+for+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812097", "articleId": "8812097", "startPage": "1119", "endPage": "1130", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 92}}
{"title": "Syntactic and Semantic Differencing for Combinatorial Models of Test Designs", "authors": [{"name": "Rachel Tzoref-Brill", "affiliation": "Sch. of Comput. Sci., Tel Aviv Univ., Tel Aviv, Israel", "firstName": "Rachel", "lastName": "Tzoref-Brill", "id": "38316207700"}, {"name": "Shahar Maoz", "affiliation": "Sch. of Comput. Sci., Tel Aviv Univ., Tel Aviv, Israel", "firstName": "Shahar", "lastName": "Maoz", "id": "37394976500"}], "abstract": "Combinatorial test design (CTD) is an effective test design technique, considered to be a testing best practice. CTD provides automatic test plan generation, but it requires a manual definition of the test space in the form of a combinatorial model. As the system under test evolves, e.g., due to iterative development processes and bug fixing, so does the test space, and thus, in the context of CTD, evolution translates into frequent manual model definition updates. Manually reasoning about the differences between versions of real-world models following such updates is infeasible due to their complexity and size. Moreover, representing the differences is challenging. In this work, we propose a first syntactic and semantic differencing technique for combinatorial models of test designs. We define a concise and canonical representation for differences between two models, and suggest a scalable algorithm for automatically computing and presenting it. We use our differencing technique to analyze the evolution of 42 real-world industrial models, demonstrating its applicability and scalability. Further, a user study with 16 CTD practitioners shows that comprehension of differences between real-world combinatorial model versions is challenging and that our differencing tool significantly improves the performance of less experienced practitioners. The analysis and user study provide evidence for the potential usefulness of our differencing approach. Our work advances the state-of-the-art in CTD with better capabilities for change comprehension and management.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Computational modeling", "Semantics", "Tools", "Syntactics", "Analytical models", "Data models", "Binary decision diagrams"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["program testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["combinatorial test design", "automatic test plan generation", "CTD practitioners"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.63", "ref": [{"order": "1", "text": "M. Acher, P. Heymans, P. Collet, C. Quinton, P. Lahire, P. Merle, \"Feature model differences\", <em>Advanced Inf. Sys. Eng.</em>, pp. 629-645, 2012.", "title": "Feature model differences", "context": [{"sec": "sec6", "text": " Other recent work considered semantic differencing for Feature Models [1], [32], in the context of software product lines.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-31095-9_41", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+model+differences&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Suplementary Material</em>,  [online]  Available: http://smlab.cs.tau.ac.il/ctd/.", "title": "Suplementary Material", "context": [{"sec": "sec5a1", "text": " Complete per model data as well as all versions data and differencing results are available from [2].", "part": "1"}, {"sec": "sec5b2", "text": "The complete study results are available from [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Suplementary+Material&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "R.E. Bryant, \"Graph-Based Algorithms for Boolean Function Manipulation\", <em>IEEE Trans. on Comp.</em>, vol. 35, no. 8, pp. 677-691, 1986.", "title": "Graph-Based Algorithms for Boolean Function Manipulation", "context": [{"sec": "sec1", "text": "To scale the computation to real-world model sizes, we use an efficient representation of the sets of valid tests and their differences, which is based on Binary Decision Diagrams [3], a compact data structure for representing and manipulating Boolean functions.", "part": "1"}, {"sec": "sec2a1b", "text": " BDDs [3] are a compact data structure for representing and manipulating Boolean functions, commonly used in formal verification [5] and in logic synthesis [21]. [30] utilizes the efficient computation of Boolean operations on BDDs such as negation, conjunction and disjunction, to compute the BDD representing the set of valid tests from the user-specified constraints.", "part": "1"}, {"sec": "sec4b", "text": " To achieve efficient computation of \\$SE\\$, we use a symbolic computation based on Binary Decision Diagrams (BDDs) [3] as our primary data structure for the set of valid tests as well as for all other computed artifacts.", "part": "1"}], "links": {"documentLink": "/document/1676819", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1676819", "abstract": "In this paper we present a new data structure for representing Boolean functions and an associated set of manipulation algorithms. Functions are represented by directed, acyclic graphs in a manner similar to the representations introduced by Lee [1] and Akers [2], but with further restrictions on the ordering of decision variables in the graph. Although a function requires, in the worst case, a graph of size exponential in the number of arguments, many of the functions encountered in typical app...", "pdfSize": "4062KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Graph-Based+Algorithms+for+Boolean+Function+Manipulation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "K. Burroughs, A. Jain, R. Erickson, \"Improved quality of protocol testing through techniques of experimental design\", <em>SUPER-COMM/ICC</em>, pp. 745-752, 1994.", "title": "Improved quality of protocol testing through techniques of experimental design", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}], "links": {"abstract": "This paper describes how both the quality and efficiency of protocol testing were improved by using a new Bellcore tool called the Automatic Efficient Test Generator (AETG). The AETG tool is based on ideas from experimental design and it creates a test set that contains all possible pairs of involved factors. Two examples are given to illustrate this technique and compare it with traditional approaches. The improved quality of testing leads to a faster detection of nonconformances and a higher q...", "pdfSize": "663KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improved+quality+of+protocol+testing+through+techniques+of+experimental+design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "E.M. Clarke, O. Grumberg, D.A. Peled, Model Checking, The MIT Press, 1999.", "title": "Model Checking", "context": [{"sec": "sec2a1b", "text": " BDDs [3] are a compact data structure for representing and manipulating Boolean functions, commonly used in formal verification [5] and in logic synthesis [21]. [30] utilizes the efficient computation of Boolean operations on BDDs such as negation, conjunction and disjunction, to compute the BDD representing the set of valid tests from the user-specified constraints.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Model+Checking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "D.M. Cohen, S.R. Dalal, M.L. Fredman, G.C. Patton, \"The AETG System: An Approach to Testing Based on Combinatorial Design\", <em>IEEE Trans. on Softw. Eng.</em>, vol. 23, no. 7, pp. 437-444, 1997.", "title": "The AETG System: An Approach to Testing Based on Combinatorial Design", "context": [{"sec": "sec1", "text": " Close to 40 CTD tools are listed in [27], e.g., PICT [9], ACTS [19], Jenny [16], and AETG [6], but to the best of our knowledge, none of these existing tools provides indication on the effect of change operations on the model, i.e., what is the relation between the original model and the new one, and how they differ.", "part": "1"}, {"sec": "sec6", "text": " Many CTD tools [6], [9], [16], [19], [27] exist, but to the best of our knowledge, they provide no support for model differencing.", "part": "1"}], "links": {"documentLink": "/document/605761", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=605761", "abstract": "This paper describes a new approach to testing that uses combinatorial designs to generate tests that cover the pairwise, triple, or n-way combinations of a system&#39;s test parameters. These are the parameters that determine the system&#39;s test scenarios. Examples are system configuration parameters, user inputs and other external events. We implemented this new method in the AETG system. The AETG system uses new combinatorial algorithms to generate test sets that cover all valid n-way parameter com...", "pdfSize": "357KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+AETG+System%3A+An+Approach+to+Testing+Based+on+Combinatorial+Design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "M.B. Cohen, M.B. Dwyer, J. Shi, \"Interaction testing of highly-configurable systems in the presence of constraints\", <em>ISSTA</em>, pp. 129-139, 2007.", "title": "Interaction testing of highly-configurable systems in the presence of constraints", "context": [{"sec": "sec6", "text": "Derived exclusions in combinatorial models, a.k.a. implicit constraints, have been discussed in previous works and were shown to complicate the solving of the CTD problem [20] and the modeling process [7]. [11] uses derived exclusions to review and debug the model constraints.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1273463.1273482", "abstract": "Combinatorial interaction testing (CIT) is a method to sample configurations of a software system systematically for testing. Many algorithms have been developed that create CIT samples, however few have considered the practical concerns that arise when adding constraints between combinations of options. In this paper, we survey constraint handling techniques in existing algorithms and discuss the challenges that they present. We examine two highly-configurable software systems to quantify the n...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Interaction+testing+of+highly-configurable+systems+in+the+presence+of+constraints&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "M.B. Cohen, J. Snyder, G. Rothermel, \"Testing across configurations: implications for combinatorial testing\", <em>SIGSOFT Softw. Eng. Notes</em>, vol. 31, no. 6, pp. 1-9, 2006.", "title": "Testing across configurations: implications for combinatorial testing", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1218776.1218785", "abstract": "User configurable software systems allow users to customize functionality at run time. In essence, each such system consists of a family of potentially thousands or millions of program instantiations. Testing methods cannot test all of these configurations, therefore some sampling mechanism must be applied. A common approach to providing such a mechanism has been to use combinatorial interaction testing. To date, however, little work has been done to quantify the effects of different configurati...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+across+configurations%3A+implications+for+combinatorial+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "J. Czerwonka, \"Pairwise testing in the real world: Practical extensions to test-case scenarios\", <em>PNSQC</em>, 2006.", "title": "Pairwise testing in the real world: Practical extensions to test-case scenarios", "context": [{"sec": "sec1", "text": " Close to 40 CTD tools are listed in [27], e.g., PICT [9], ACTS [19], Jenny [16], and AETG [6], but to the best of our knowledge, none of these existing tools provides indication on the effect of change operations on the model, i.e., what is the relation between the original model and the new one, and how they differ.", "part": "1"}, {"sec": "sec6", "text": " Many CTD tools [6], [9], [16], [19], [27] exist, but to the best of our knowledge, they provide no support for model differencing.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pairwise+testing+in+the+real+world%3A+Practical+extensions+to+test-case+scenarios&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S.R. Dalal, A. Jain, N. Karunanithi, J.M. Leaton, C.M. Lott, G.C. Patton, B.M. Horowitz, \"Model-Based Testing in Practice\", <em>ICSE</em>, pp. 285-294, 1999.", "title": "Model-Based Testing in Practice", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}, {"sec": "sec1", "text": " This systematic selection of tests is based on empirical data that shows that in most cases, the appearance of a bug depends on the interaction between a small number of features of the system under test [10], [18], [31].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/302405.302640", "abstract": "Model-based testing is a new and evolving technique for generating a suite of test cases from requirements. Testers using this approach concentrate on a data model and generation infrastructure instead of hand-crafting individual tests. Several relatively small studies have demonstrated how combinatorial test generation techniques allow testers to achieve broad coverage of the input domain with a small number of tests. We have conducted several relatively large projects in which we applied these...", "pdfSize": "1050KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Model-Based+Testing+in+Practice&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "E. Farchi, I. Segall, R. Tzoref-Brill, \"Using projections to debug large combinatorial models\", <em>ICSTW</em>, pp. 311-320, 2013.", "title": "Using projections to debug large combinatorial models", "context": [{"sec": "sec4b", "text": " For additional details about the computation of derived exclusions see [11].", "part": "1"}, {"sec": "sec6", "text": " [11] uses derived exclusions to review and debug the model constraints.", "part": "1"}], "links": {"abstract": "Combinatorial test design (CTD) is an effective test planning technique that reveals faults resulting from parameters interactions in a system. The test space is manually modeled by a set of parameters, their respective values, and restrictions on the value combinations - referred to as a CTD model. Each possible combination of values in the cross product of the parameters, that is not excluded by restrictions, represents a valid test. A subset of the test space is then automatically constructed...", "pdfSize": "250KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+projections+to+debug+large+combinatorial+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "B. Fluri, M. Wursch, M. Pinzger, H. Gall, \"Change distilling: Tree differencing for fine-grained source code change extraction\", <em>Software Engineering IEEE Transactions on</em>, vol. 33, no. 11, pp. 725-743, 2007.", "title": "Change distilling: Tree differencing for fine-grained source code change extraction", "context": [{"sec": "sec6", "text": " [12], [28], [37]).", "part": "1"}], "links": {"documentLink": "/document/4339230", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4339230", "abstract": "A key issue in software evolution analysis is the identification of particular changes that occur across several versions of a program. We present change distilling, a tree differencing algorithm for fine-grained source code change extraction. For that, we have improved the existing algorithm by Chawathe et al. for extracting changes in hierarchically structured data. Our algorithm extracts changes by finding both a match between the nodes of the compared two abstract syntax trees and a minimum ...", "pdfSize": "3149KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Change+distilling%3A+Tree+differencing+for+fine-grained+source+code+change+extraction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "M. Grindal, B. Lindstr\u00f6m, J. Offutt, S.F. Andler, \"An evaluation of combination strategies for test case selection\", <em>Empirical Softw. Eng.</em>, vol. 11, no. 4, pp. 583-611, 2006.", "title": "An evaluation of combination strategies for test case selection", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-006-9024-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+evaluation+of+combination+strategies+for+test+case+selection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "<em>IBM Functional coverage Unified Solution (IBM FOCUS)</em>,  [online]  Available: http://researcher.watson.ibm.com/researcher/view_group.php?id=1871.", "title": "IBM Functional coverage Unified Solution (IBM FOCUS)", "context": [{"sec": "sec1", "text": "We implemented the differencing technique within the industrial-strength commercial CTD tool IBM Functional Coverage Unified Solution (IBM FOCUS) [14], [30].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=IBM+Functional+coverage+Unified+Solution+%28IBM+FOCUS%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "<em>JDD</em>,  [online]  Available: http://javaddlib.sourceforge.net/jdd/.", "title": "JDD", "context": [{"sec": "sec5a1", "text": " The BDD package used was JDD [15].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=JDD&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>Jenny</em>,  [online]  Available: http://burtleburtle.net/bob/math/jenny.html.", "title": "Jenny", "context": [{"sec": "sec1", "text": " Close to 40 CTD tools are listed in [27], e.g., PICT [9], ACTS [19], Jenny [16], and AETG [6], but to the best of our knowledge, none of these existing tools provides indication on the effect of change operations on the model, i.e., what is the relation between the original model and the new one, and how they differ.", "part": "1"}, {"sec": "sec6", "text": " Many CTD tools [6], [9], [16], [19], [27] exist, but to the best of our knowledge, they provide no support for model differencing.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jenny&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "D.R. Kuhn, R.N. Kacker, Y. Lei, Introduction to Combinatorial Testing, Chapman & Hall/CRC, 2013.", "title": "Introduction to Combinatorial Testing", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introduction+to+Combinatorial+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "D.R. Kuhn, D.R. Wallace, A.M. Gallo, \"Software Fault Interactions and Implications for Software Testing\", <em>IEEE Trans. on Softw. Eng.</em>, vol. 30, no. 6, pp. 418-421, 2004.", "title": "Software Fault Interactions and Implications for Software Testing", "context": [{"sec": "sec1", "text": " This systematic selection of tests is based on empirical data that shows that in most cases, the appearance of a bug depends on the interaction between a small number of features of the system under test [10], [18], [31].", "part": "1"}], "links": {"documentLink": "/document/1321063", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1321063", "abstract": "Exhaustive testing of computer software is intractable, but empirical studies of software failures suggest that testing can in some cases be effectively exhaustive. We show that software failures in a variety of domains were caused by combinations of relatively few conditions. These results have important implications for testing. If all faults in a system can be triggered by a combination of n or fewer parameters, then testing all n-tuples of parameters is effectively equivalent to exhaustive t...", "pdfSize": "362KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+Fault+Interactions+and+Implications+for+Software+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "R. Kuhn, Y. Lei, R. Kacker, \"Practical Combinatorial Testing: Beyond Pairwise\", <em>IT Professional</em>, vol. 10, no. 3, pp. 19-23, 2008.", "title": "Practical Combinatorial Testing: Beyond Pairwise", "context": [{"sec": "sec1", "text": " Close to 40 CTD tools are listed in [27], e.g., PICT [9], ACTS [19], Jenny [16], and AETG [6], but to the best of our knowledge, none of these existing tools provides indication on the effect of change operations on the model, i.e., what is the relation between the original model and the new one, and how they differ.", "part": "1"}, {"sec": "sec6", "text": " Many CTD tools [6], [9], [16], [19], [27] exist, but to the best of our knowledge, they provide no support for model differencing.", "part": "1"}], "links": {"documentLink": "/document/4525537", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4525537", "abstract": "With new algorithms and tools, developers can apply high-strength combinatorial testing to detect elusive failures that occur only when multiple components interact. In pairwise testing, all possible pairs of parameter values are covered by at least one test, and good tools are available to generate arrays with the value pairs. In the past few years, advances in covering-array algorithms, integrated with model checking or other testing approaches, have made it practical to extend combinatorial t...", "pdfSize": "11426KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+Combinatorial+Testing%3A+Beyond+Pairwise&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "C. Lott, A. Jain, S. Dalal, \"Modeling requirements for combinatorial software testing\", <em>SIGSOFT Softw. Eng. Notes</em>, vol. 30, no. 4, pp. 1-7, 2005.", "title": "Modeling requirements for combinatorial software testing", "context": [{"sec": "sec6", "text": "Derived exclusions in combinatorial models, a.k.a. implicit constraints, have been discussed in previous works and were shown to complicate the solving of the CTD problem [20] and the modeling process [7]. [11] uses derived exclusions to review and debug the model constraints.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1082983.1083281", "abstract": "The combinatorial approach to software testing uses models to generate a minimal number of test inputs so that selected combinations of input values are covered. The most common coverage criteria is two-way, or pairwise coverage of value combinations, though for higher confidence three-way or higher coverage may be required. This paper presents example system requirements and corresponding models for applying the combinatorial approach to those requirements. These examples are intended to serve ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+requirements+for+combinatorial+software+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "S. Malik, A. Wang, R. Brayton, A. Sangiovanni-Vincentelli, \"Logic Verification Using Binary Decision Diagrams in a Logic Synthesis Environment\", <em>ICCAD'88</em>, pp. 6-9, 1988.", "title": "Logic Verification Using Binary Decision Diagrams in a Logic Synthesis Environment", "context": [{"sec": "sec2a1b", "text": " BDDs [3] are a compact data structure for representing and manipulating Boolean functions, commonly used in formal verification [5] and in logic synthesis [21]. [30] utilizes the efficient computation of Boolean operations on BDDs such as negation, conjunction and disjunction, to compute the BDD representing the set of valid tests from the user-specified constraints.", "part": "1"}], "links": {"abstract": "The results of a formal logic verification system implemented as part of the multilevel logic synthesis system MIS are discussed. Combinational logic verification involves checking two networks for functional equivalence. Techniques that flatten networks or use cube enumeration and simulation cannot be used with functions that have very large cube covers. Binary decision diagrams (BDDs) are canonical representations for Boolean functions and offer a technique for formal logic verification. Howev...", "pdfSize": "341KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Logic+Verification+Using+Binary+Decision+Diagrams+in+a+Logic+Synthesis+Environment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "S. Maoz, J.O. Ringert, \"A framework for relating syntactic and semantic model differences\", <em>MODELS</em>, pp. 24-33, 2015.", "title": "A framework for relating syntactic and semantic model differences", "context": [{"sec": "sec6", "text": " A framework for relating syntactic and semantic model differences has been presented in [22].", "part": "1"}], "links": {"documentLink": "/document/7338232", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7338232", "abstract": "Model differencing is an important activity in model-based development processes. Differences need to be detected, analyzed, and understood to evolve systems and explore alternatives. Two distinct approaches have been studied in the literature: syntactic differencing, which compares the concrete or abstract syntax of models, and semantic differencing, which compares models in terms of their meaning. Syntactic differencing identifies change operations that transform the syntactical representation...", "pdfSize": "676KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+framework+for+relating+syntactic+and+semantic+model+differences&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "S. Maoz, J.O. Ringert, B. Rumpe, \"ADDiff: semantic differencing for activity diagrams\", <em>ESEC/FSE</em>, pp. 179-189, 2011.", "title": "ADDiff: semantic differencing for activity diagrams", "context": [{"sec": "sec6", "text": "Most relevant to our present work is the work of Maoz et al. on semantic model differencing for Class Diagrams [24] (using SAT) and Activity Diagrams [23] (using BDD-based symbolic algorithm).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025140", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ADDiff%3A+semantic+differencing+for+activity+diagrams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "S. Maoz, J.O. Ringert, B. Rumpe, \"CDDiff: Semantic differencing for class diagrams\", <em>ECOOP</em>, pp. 230-254, 2011.", "title": "CDDiff: Semantic differencing for class diagrams", "context": [{"sec": "sec6", "text": "Most relevant to our present work is the work of Maoz et al. on semantic model differencing for Class Diagrams [24] (using SAT) and Activity Diagrams [23] (using BDD-based symbolic algorithm).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-22655-7_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CDDiff%3A+Semantic+differencing+for+class+diagrams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "S. Minato, Graph-Based Representations of Discrete Functions, Springer US, pp. 1-28, 1996.", "title": "Graph-Based Representations of Discrete Functions", "context": [{"sec": "sec2a1b", "text": " Multi-valued parameters are handled using standard Boolean encoding and reduction techniques to BDDs [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Graph-Based+Representations+of+Discrete+Functions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "C. Nie, H. Leung, \"A Survey of Combinatorial Testing\", <em>ACM Comput. Surv.</em>, vol. 43, no. 2, pp. 11:1-11:29, 2011.", "title": "A Survey of Combinatorial Testing", "context": [{"sec": "sec1", "text": " [26] reveals that only around 5% of the publications on CTD explore the crucial modeling process, and the topic of model maintenance is not even mentioned in [26].", "part": "1"}, {"sec": "sec6", "text": " [26] considers 93 academic papers on combinatorial testing but does not mention model evolution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1883612.1883618", "abstract": "Combinatorial Testing (CT) can detect failures triggered by interactions of parameters in the Software Under Test (SUT) with a covering array test suite generated by some sampling mechanisms. It has been an active field of research in the last twenty years. This article aims to review previous work on CT, highlights the evolution of CT, and identifies important issues, methods, and applications of CT, with the goal of supporting and directing future practice and research in this area. First, we ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Survey+of+Combinatorial+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>Pairwise testing website</em>,  [online]  Available: http://www.pairwise.org/tools.asp.", "title": "Pairwise testing website", "context": [{"sec": "sec1", "text": " Close to 40 CTD tools are listed in [27], e.g., PICT [9], ACTS [19], Jenny [16], and AETG [6], but to the best of our knowledge, none of these existing tools provides indication on the effect of change operations on the model, i.e., what is the relation between the original model and the new one, and how they differ.", "part": "1"}, {"sec": "sec2a1a", "text": "The semantics used in practice by CTD tools [27] is Boolean semantics.", "part": "1"}, {"sec": "sec6", "text": " Many CTD tools [6], [9], [16], [19], [27] exist, but to the best of our knowledge, they provide no support for model differencing.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pairwise+testing+website&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "S. Person, M.B. Dwyer, S.G. Elbaum, C.S. Pasareanu, \"Differential symbolic execution\", <em>SIGSOFT FSE</em>, pp. 226-237, 2008.", "title": "Differential symbolic execution", "context": [{"sec": "sec6", "text": "Much work has been published on syntactic and semantic differencing of programs and models within the more general field of Software Evolution (see, e.g. [12], [28], [37]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1453101.1453131", "abstract": "Detecting and characterizing the effects of software changes is a fundamental component of software maintenance. Version differencing information can be used to perform version merging, infer change characteristics, produce program documentation, and guide program re-validation. Existing techniques for characterizing code changes, however, are imprecise leading to unnecessary maintenance efforts. In this paper, we introduce a novel extension and application of symbolic execution techniques that ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Differential+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "X. Qu, M.B. Cohen, K.M. Woolf, \"Combinatorial interaction regression testing: A study of test case generation and prioritization\", <em>ICSM</em>, pp. 255-264, 2007.", "title": "Combinatorial interaction regression testing: A study of test case generation and prioritization", "context": [{"sec": "sec6", "text": " [29], which examines the effectiveness of combinatorial testing prioritization and re-generation strategies on regression testing in evolving programs with multiple versions.", "part": "1"}], "links": {"abstract": "Regression testing is an expensive part of the software maintenance process. Effective regression testing techniques select and order (or prioritize) test cases between successive releases of a program. However, selection and prioritization are dependent on the quality of the initial test suite. An effective and cost efficient test generation technique is combinatorial interaction testing, CIT, which systematically samples all t-way combinations of input parameters. Research on CIT, to date, has...", "pdfSize": "676KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combinatorial+interaction+regression+testing%3A+A+study+of+test+case+generation+and+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "I. Segall, R. Tzoref-Brill, E. Farchi, \"Using Binary Decision Diagrams for Combinatorial Test Design\", <em>ISSTA</em>, pp. 254-264, 2011.", "title": "Using Binary Decision Diagrams for Combinatorial Test Design", "context": [{"sec": "sec1", "text": "We implemented the differencing technique within the industrial-strength commercial CTD tool IBM Functional Coverage Unified Solution (IBM FOCUS) [14], [30].", "part": "1"}, {"sec": "sec2a1b", "text": "In [30], a compact representation of combinatorial models using Binary Decision Diagrams (BDDs) was presented.", "part": "1"}, {"sec": "sec2a1b", "text": " [30] utilizes the efficient computation of Boolean operations on BDDs such as negation, conjunction and disjunction, to compute the BDD representing the set of valid tests from the user-specified constraints.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2001420.2001451", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+Binary+Decision+Diagrams+for+Combinatorial+Test+Design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "K. Tai, Y. Lie, \"A Test Generation Strategy for Pairwise Testing\", <em>IEEE Trans. on Softw. Eng.</em>, vol. 28, no. 1, pp. 109-111, 2002.", "title": "A Test Generation Strategy for Pairwise Testing", "context": [{"sec": "sec1", "text": " This systematic selection of tests is based on empirical data that shows that in most cases, the appearance of a bug depends on the interaction between a small number of features of the system under test [10], [18], [31].", "part": "1"}], "links": {"documentLink": "/document/979992", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=979992", "abstract": "Pairwise testing is a specification-based testing criterion which requires that for each pair of input parameters of a system, every combination of valid values of these two parameters be covered by at least one test case. The authors propose a novel test generation strategy for pairwise testing.", "pdfSize": "97KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Test+Generation+Strategy+for+Pairwise+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "T. Thum, D. Batory, C. Kastner, \"Reasoning about edits to feature models\", <em>ICSE</em>, pp. 254-264, 2009.", "title": "Reasoning about edits to feature models", "context": [{"sec": "sec6", "text": " Other recent work considered semantic differencing for Feature Models [1], [32], in the context of software product lines.", "part": "1"}], "links": {"documentLink": "/document/5070526", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070526", "abstract": "Features express the variabilities and commonalities among programs in a software product line (SPL). A feature model defines the valid combinations of features, where each combination corresponds to a program in an SPL. SPLs and their feature models evolve over time. We classify the evolution of a feature model via modifications as refactorings, specializations, generalizations, or arbitrary edits. We present an algorithm to reason about feature model edits to help designers determine how the p...", "pdfSize": "491KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reasoning+about+edits+to+feature+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "R. Tzoref-Brill, S. Maoz, \"Lattice-based semantics for combinatorial model evolution\", <em>ATVA</em>, pp. 276-292, 2015.", "title": "Lattice-based semantics for combinatorial model evolution", "context": [{"sec": "sec6", "text": "In a recent work, we presented a lattice-based semantics for interpreting the evolution of combinatorial models [33].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lattice-based+semantics+for+combinatorial+model+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "R. Tzoref-Brill, P. Wojciak, S. Maoz, \"Visualization of Combinatorial Models and Test Plans\", <em>ASE</em>, pp. 144-154, 2016.", "title": "Visualization of Combinatorial Models and Test Plans", "context": [{"sec": "sec7", "text": " In a recent paper we presented the use of visualization for comprehension of combinatorial models and test plans [34].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970301", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Visualization+of+Combinatorial+Models+and+Test+Plans&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "A.W. Williams, \"Determination of test configurations for pair-wise interaction coverage\", <em>TestCom</em>, pp. 59-74, 2000.", "title": "Determination of test configurations for pair-wise interaction coverage", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Determination+of+test+configurations+for+pair-wise+interaction+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "P. Wojciak, R. Tzoref-Brill, \"System Level Combinatorial Testing in Practice- The Concurrent Maintenance Case Study\", <em>ICST</em>, pp. 103-112, 2014.", "title": "System Level Combinatorial Testing in Practice- The Concurrent Maintenance Case Study", "context": [{"sec": "sec1", "text": "One of the effective techniques for coping with the verification challenge of increasingly complex software systems is Combinatorial Test Design (CTD), a.k.a. combinatorial testing [4], [8], [10], [13], [17], [35], [36].", "part": "1"}, {"sec": "sec5b1", "text": " The first model, model \\$A\\$, describes a system test space for features of IBM\u00ae POWER7\u00ae [36].", "part": "1"}], "links": {"documentLink": "/document/6823872", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6823872", "abstract": "Combinatorial test design (CTD) is an effective test design technique that reveals faults resulting from parameter interactions in a system. CTD requires a test space definition in the form of a set of parameters, their respective values, and restrictions on the value combinations. Though CTD is considered an industry best practice, there is only a small body of work on the practical application of CTD to industrial systems, and some key elements of the CTD application process are under-explored...", "pdfSize": "244KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=System+Level+Combinatorial+Testing+in+Practice-+The+Concurrent+Maintenance+Case+Study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "Z. Xing, E. Stroulia, \"Differencing logical UML models\", <em>Autom. Softw. Eng.</em>, vol. 14, no. 2, pp. 215-259, 2007.", "title": "Differencing logical UML models", "context": [{"sec": "sec6", "text": "Much work has been published on syntactic and semantic differencing of programs and models within the more general field of Software Evolution (see, e.g. [12], [28], [37]).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-007-0007-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Differencing+logical+UML+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "C. Yilmaz, S. Fouch\u00e9, M.B. Cohen, A.A. Porter, G. Demir\u00f6z, U. Koc, \"Moving forward with combinatorial interaction testing\", <em>IEEE Computer</em>, vol. 47, no. 2, pp. 37-45, 2014.", "title": "Moving forward with combinatorial interaction testing", "context": [{"sec": "sec6", "text": "Finally, in a research roadmap presented in a recent review on combinatorial testing [38], Yilmaz et al. suggest the challenge \u201cto handle evolving [combinatorial] models as they change over time\u201d.", "part": "1"}], "links": {"abstract": "Combinatorial interaction testing (CIT) is an effective failure detection method for many types of software systems. This review discusses the current approaches CIT uses in detecting parameter interactions, the difficulties of applying it in practice, recent advances, and opportunities for future research.", "pdfSize": "1246KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Moving+forward+with+combinatorial+interaction+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985699", "articleId": "7985699", "startPage": "621", "endPage": "631", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 2, "citationCountPatent": 0, "totalDownloads": 193}}
{"title": "A Test-Suite Diagnosability Metric for Spectrum-Based Fault Localization Approaches", "authors": [{"name": "Alexandre Perez", "affiliation": "HASLab, Univ. of Porto, Porto, Portugal", "firstName": "Alexandre", "lastName": "Perez", "id": "38581165000"}, {"name": "Rui Abreu", "affiliation": "HASLab, Univ. of Porto, Porto, Portugal", "firstName": "Rui", "lastName": "Abreu", "id": "37297115200"}, {"name": "Arie van Deursen", "affiliation": "Delft Univ. of Technol., Delft, Netherlands", "firstName": "Arie", "lastName": "van Deursen", "id": "37271310500"}], "abstract": "Current metrics for assessing the adequacy of a test-suite plainly focus on the number of components (be it lines, branches, paths) covered by the suite, but do not explicitly check how the tests actually exercise these components and whether they provide enough information so that spectrum-based fault localization techniques can perform accurate fault isolation. We propose a metric, called DDU, aimed at complementing adequacy measurements by quantifying a test-suite's diagnosability, i.e., the effectiveness of applying spectrum-based fault localization to pinpoint faults in the code in the event of test failures. Our aim is to increase the value generated by creating thorough test-suites, so they are not only regarded as error detection mechanisms but also as effective diagnostic aids that help widely-used fault-localization techniques to accurately pinpoint the location of bugs in the system. Our experiments show that optimizing a test suite with respect to DDU yields a 34% gain in spectrum-based fault localization report accuracy when compared to the standard branch-coverage metric.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Cognition", "Density measurement", "Software", "Computer bugs", "Gain measurement", "Measurement uncertainty"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["error detection", "fault diagnosis", "program debugging", "program testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["test-suite diagnosability metric", "spectrum-based fault localization techniques", "fault isolation", "DDU", "error detection mechanisms", "bugs", "branch-coverage metric", "density-diversity-uniqueness"]}, {"type": "Author Keywords ", "kwd": ["Testing", "Coverage", "Diagnosability"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.66", "ref": [{"order": "1", "text": "J.C. Miller, C.J. Maloney, \"Systematic mistake analysis of digital computer programs\", <em>Communications of the ACM</em>, vol. 6, no. 2, pp. 58-63, 1963.", "title": "Systematic mistake analysis of digital computer programs", "context": [{"sec": "sec1", "text": " Examples of current metrics include branch and path coverage [1], modified decision/condition coverage [2], and mutation coverage [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/366246.366248", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Systematic+mistake+analysis+of+digital+computer+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "J.J. Chilenski, S.P. Miller, \"Applicability of modified condition/decision coverage to software testing\", <em>Software Engineering Journal</em>, vol. 9, no. 5, pp. 193-200, 1994.", "title": "Applicability of modified condition/decision coverage to software testing", "context": [{"sec": "sec1", "text": " Examples of current metrics include branch and path coverage [1], modified decision/condition coverage [2], and mutation coverage [3].", "part": "1"}], "links": {"documentLink": "/document/329068", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=329068", "abstract": "Modified condition/decision coverage is a structural coverage criterion requiring that each condition within a decision is shown by execution to independently and correctly affect the outcome of the decision. This criterion was developed to help meet the need for extensive testing of complex Boolean expressions in safety-critical applications. The paper describes the modified condition/decision coverage criterion, its properties and areas for further work.<>", "pdfSize": "624KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Applicability+of+modified+condition%2Fdecision+coverage+to+software+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "T.A. Budd, <em>Mutation analysis of program test data</em>, 1980.", "title": "Mutation analysis of program test data", "context": [{"sec": "sec1", "text": " Examples of current metrics include branch and path coverage [1], modified decision/condition coverage [2], and mutation coverage [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mutation+analysis+of+program+test+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "H. Zhu, P.A.V. Hall, J.H.R. May, \"Software unit test coverage and adequacy\", <em>ACM Computing Surveys</em>, vol. 29, no. 4, pp. 366-427, 1997.", "title": "Software unit test coverage and adequacy", "context": [{"sec": "sec1", "text": " According to Zhu et al., such measurements can act as generators, meaning that they provide an intuition on what components to exercise to improve the suite [4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/267580.267590", "abstract": "Objective measurement of test quality is one of the key issues in software testing. It has been a major research focus for the last two decades. Many test criteria have been proposed and studied for this purpose. Various kinds of rationales have been presented in support of one criterion or another. We survey the research work in this area. The notion of adequacy criteria is examined together with its role in software dynamic testing. A review of criteria classification is followed by a summary ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+unit+test+coverage+and+adequacy&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "M.J. Harrold, G. Rothermel, R. Wu, L. Yi, \"An empirical investigation of program spectra\", <em>Proceedings of the SIGPLAN/SIGSOFT Workshop on Program Analysis For Software Tools and Engineering (PASTE</em>, pp. 83-90, June 16, 1998.", "title": "An empirical investigation of program spectra", "context": [{"sec": "sec1", "text": " One measurement uses the density \\$(\\rho)\\$ of a test-coverage matrix \u2014 also known as spectrum [5]: input to all spectrum-based fault localization techniques [6], [7], which encodes what software components have been involved in each test.", "part": "1"}, {"sec": "sec3a", "text": " Components can be any source code artifact of arbitrary granularity such as a class, a method, a statement, or a branch [5];.", "part": "1"}, {"sec": "sec3a", "text": "The pair \\$(\\mathcal{A}, e)\\$ is commonly referred to as spectrum [5].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/277631.277647", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+investigation+of+program+spectra&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "J.A. Jones, M.J. Harrold, \"Empirical evaluation of the tarantula automatic fault-localization technique\", <em>20th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 273-282, 2005.", "title": "Empirical evaluation of the tarantula automatic fault-localization technique", "context": [{"sec": "sec1", "text": " One measurement uses the density \\$(\\rho)\\$ of a test-coverage matrix \u2014 also known as spectrum [5]: input to all spectrum-based fault localization techniques [6], [7], which encodes what software components have been involved in each test.", "part": "1"}, {"sec": "sec3a", "text": "N\\rangle)\\$ and the observed transaction outcomes encoded in error vector \\$e\\$ [6], [7], [10], [12], [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1101908.1101949", "abstract": "The high cost of locating faults in programs has motivated the development of techniques that assist in fault localization by automating part of the process of searching for faults. Empirical studies that compare these techniques have reported the relative effectiveness of four existing techniques on a set of subjects. These studies compare the rankings that the techniques compute for statements in the subject programs and the effectiveness of these rankings in locating the faults. However, it i...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Empirical+evaluation+of+the+tarantula+automatic+fault-localization+technique&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "R. Abreu, P. Zoeteweij, R. Golsteijn, A.J.C. van Gemund, \"A practical evaluation of spectrum-based fault localization\", <em>Journal of Systems and Software</em>, vol. 82, no. 11, pp. 1780-1792, 2009.", "title": "A practical evaluation of spectrum-based fault localization", "context": [{"sec": "sec1", "text": " One measurement uses the density \\$(\\rho)\\$ of a test-coverage matrix \u2014 also known as spectrum [5]: input to all spectrum-based fault localization techniques [6], [7], which encodes what software components have been involved in each test.", "part": "1"}, {"sec": "sec3a", "text": "N\\rangle)\\$ and the observed transaction outcomes encoded in error vector \\$e\\$ [6], [7], [10], [12], [13].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2009.06.035", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+practical+evaluation+of+spectrum-based+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "A. Gonz\u00e1lez-Sanchez, H. Gross, A.J.C. van Gemund, \"Modeling the diagnostic efficiency of regression test suites\", <em>4th IEEE International Conference on Software Testing Verification and Validation (ICST) Workshop Proceedings</em>, pp. 634-643, 2011.", "title": "Modeling the diagnostic efficiency of regression test suites", "context": [{"sec": "sec1", "text": " Gonz\u00e1lez-Sanchez et al. have shown that when spectrum density approaches the optimal values, the effectiveness of spectrum-based approaches is maximal [8].", "part": "1"}, {"sec": "sec3c", "text": "Previous work [8] has used matrix density \\$(\\rho)\\$ as a measure for diagnosability:\n.", "part": "1"}, {"sec": "sec3c", "text": " Thus, it can be said that \\$\\text{Pr}(e_{g}=1)=\\rho\\$, yielding \\$\\rho=0.5\\$ as the ideal value for diagnosis using SR approaches [8].", "part": "1"}, {"sec": "sec4b1", "text": " [8].", "part": "1"}, {"sec": "sec5a", "text": " The chosen value is a compromise between perfect error detection (i.e., oracle quality of 1) and essentially random error detection (oracle quality of 0.5) This fault injection approach is common practice among controlled, theoretical evaluations of spectrum-based diagnosis [8], [24].", "part": "1"}], "links": {"abstract": "Diagnostic performance, measured in terms of the manual effort developers have to spend after faults are detected, is not the only important quality of a diagnosis. Efficiency, i.e., the number of tests and the rate of convergence to the final diagnosis is a very important quality of a diagnosis as well. In this paper we present an analytical model and a simulation model to predict the diagnostic efficiency of test suites when prioritized with the information gain algorithm. We show that, beside...", "pdfSize": "400KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+the+diagnostic+efficiency+of+regression+test+suites&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "B. Baudry, F. Fleurey, Y.L. Traon, \"Improving test suites for efficient fault localization\", <em>28th International Conference on Software Engineering (ICSE 2006)</em>, pp. 82-91, May 20\u201328,2006.", "title": "Improving test suites for efficient fault localization", "context": [{"sec": "sec1", "text": " Another approach is one by Baudry et al., that proposed a test for diagnosis criterion that attempts to reduce the size of dynamic basic blocks to improve fault localization accuracy [9].", "part": "1"}, {"sec": "sec3d", "text": "Baudry et al. propose a diagnosability metric that tracks the number of dynamic basic blocks in a system [9].", "part": "1"}, {"sec": "sec4b3", "text": " Uniqueness is also used by Baudry et al. to measure diagnosability [9].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134299", "abstract": "The need for testing-for-diagnosis strategies has been identified for a long time, but the explicit link from testing to diagnosis (fault localization) is rare. Analyzing the type of information needed for efficient fault localization, we identify the attribute (called Dynamic Basic Block) that restricts the accuracy of a diagnosis algorithm. Based on this attribute, a test-for-diagnosis criterion is proposed and validated through rigorous case studies: it shows that a test suite can be improved...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+test+suites+for+efficient+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "W.E. Wong, R. Gao, Y. Li, R. Abreu, F. Wotawa, \"A survey of software fault localization\", <em>IEEE Transactions on Software Engineering</em>, 2016.", "title": "A survey of software fault localization", "context": [{"sec": "sec3", "text": " Namely, we cover the concept of Spectrum-based Reasoning (SR) \u2014 which is amongst the best performing spectrum-based fault localization approaches [10] \u2014and detail previous attempts to define a diagnosability metric.", "part": "1"}, {"sec": "sec3a", "text": "N\\rangle)\\$ and the observed transaction outcomes encoded in error vector \\$e\\$ [6], [7], [10], [12], [13].", "part": "1"}, {"sec": "sec3b", "text": "To measure the accuracy of fault-localization approaches, the cost of diagnosis \\$C_{d}\\$ metric is often used [10], [11], [17], [18].", "part": "1"}], "links": {"documentLink": "/document/7390282", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7390282", "abstract": "Software fault localization, the act of identifying the locations of faults in a program, is widely recognized to be one of the most tedious, time consuming, and expensive - yet equally critical - activities in program debugging. Due to the increasing scale and complexity of software today, manually locating faults when failures occur is rapidly becoming infeasible, and consequently, there is a strong demand for techniques that can guide software developers to the locations of faults in a progra...", "pdfSize": "722KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+of+software+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "R. Abreu, P. Zoeteweij, A.J.C. van Gemund, \"Spectrum-based multiple fault localization\", <em>24th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 88-99, 2009.", "title": "Spectrum-based multiple fault localization", "context": [{"sec": "sec3a", "text": "SR reasons about observed system executions and their outcomes to derive diagnoses that can explain faulty behavior in software [11].", "part": "1"}, {"sec": "sec3a", "text": " SR was also shown to outperform similarity-based approaches [11].", "part": "1"}, {"sec": "sec3a2", "text": " Typically, candidates of higher cardinality have a lower prior probability of being faulty, since conditional independence is assumed throughout the process [11].", "part": "1"}, {"sec": "sec3a2", "text": " Further details on the inner workings of the candidate ranking step are detailed in [11].", "part": "1"}, {"sec": "sec3b", "text": "To measure the accuracy of fault-localization approaches, the cost of diagnosis \\$C_{d}\\$ metric is often used [10], [11], [17], [18].", "part": "1"}], "links": {"abstract": "Fault diagnosis approaches can generally be categorized into spectrum-based fault localization (SFL, correlating failures with abstractions of program traces), and model-based diagnosis (MBD, logic reasoning over a behavioral model). Although MBD approaches are inherently more accurate than SFL, their high computational complexity prohibits application to large programs. We present a framework to combine the best of both worlds, coined BARINEL. The program is modeled using abstractions of progra...", "pdfSize": "590KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Spectrum-based+multiple+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "D. Lo Lucia, L. Jiang, F. Thung, A. Budi, \"Extended comprehensive study of associationmeasures for fault localization\", <em>Journal of Software: Evolution and Process</em>, vol. 26, no. 2, pp. 172-219, 2014.", "title": "Extended comprehensive study of associationmeasures for fault localization", "context": [{"sec": "sec3a", "text": "N\\rangle)\\$ and the observed transaction outcomes encoded in error vector \\$e\\$ [6], [7], [10], [12], [13].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/smr.1616", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Extended+comprehensive+study+of+associationmeasures+for+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "W.E. Wong, V. Debroy, R. Gao, Y. Li, \"The dstar method for effective software fault localization\", <em>IEEE Transactions on Reliability</em>, vol. 63, no. 1, pp. 290-308, 2014.", "title": "The dstar method for effective software fault localization", "context": [{"sec": "sec3a", "text": "N\\rangle)\\$ and the observed transaction outcomes encoded in error vector \\$e\\$ [6], [7], [10], [12], [13].", "part": "1"}], "links": {"documentLink": "/document/6651713", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6651713", "abstract": "Effective debugging is crucial to producing reliable software. Manual debugging is becoming prohibitively expensive, especially due to the growing size and complexity of programs. Given that fault localization is one of the most expensive activities in program debugging, there has been a great demand for fault localization techniques that can help guide programmers to the locations of faults. In this paper, a technique named DStar (D*) is proposed which can suggest suspicious locations for fault...", "pdfSize": "3092KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+dstar+method+for+effective+software+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "R. Abreu, A.J.C. van Gemund, \"A low-cost approximate minimal hitting set algorithm and its application to model-based diagnosis\", <em>8th Symposium on Abstraction Reformulation and Approximation (SARA)</em>, 2009.", "title": "A low-cost approximate minimal hitting set algorithm and its application to model-based diagnosis", "context": [{"sec": "sec3a1", "text": " Heuristic approaches to finding these minimal candidates, which is an instance of the minimal hitting set problem, thus NP-hard, include Staccato [14], Safari [15] and Mhs2 [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+low-cost+approximate+minimal+hitting+set+algorithm+and+its+application+to+model-based+diagnosis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "A. Feldman, G.M. Provan, A.J.C. van Gemund, \"Computing minimal diagnoses by greedy stochastic search\", <em>23rd AAAI Conference on Artificial Intelligence (AAAI)</em>, pp. 911-918, 2008.", "title": "Computing minimal diagnoses by greedy stochastic search", "context": [{"sec": "sec3a1", "text": " Heuristic approaches to finding these minimal candidates, which is an instance of the minimal hitting set problem, thus NP-hard, include Staccato [14], Safari [15] and Mhs2 [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Computing+minimal+diagnoses+by+greedy+stochastic+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "N. Cardoso, R. Abreu, \"MHS2: A map-reduce heuristic-driven minimal hitting set search algorithm\", <em>Multicore Software Engineering Performance and Tools ser. Lecture Notes in Computer Science</em>, vol. 8063, pp. 25-36, 2013.", "title": "MHS2: A map-reduce heuristic-driven minimal hitting set search algorithm", "context": [{"sec": "sec3a1", "text": " Heuristic approaches to finding these minimal candidates, which is an instance of the minimal hitting set problem, thus NP-hard, include Staccato [14], Safari [15] and Mhs2 [16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-39955-8_3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=MHS2%3A+A+map-reduce+heuristic-driven+minimal+hitting+set+search+algorithm&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "J. Campos, R. Abreu, G. Fraser, M. d'Amorim, \"Entropy-Based Test Generation for Improved Fault Localization\", <em>Proceedings of the 28th IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 257-267, 2013.", "title": "Entropy-Based Test Generation for Improved Fault Localization", "context": [{"sec": "sec3b", "text": "To measure the accuracy of fault-localization approaches, the cost of diagnosis \\$C_{d}\\$ metric is often used [10], [11], [17], [18].", "part": "1"}, {"sec": "sec3c", "text": " Density was also leveraged by Campos et al. to guide automated test generation [17].", "part": "1"}, {"sec": "sec5a", "text": " EvoSuite's maximum search time budget was set to 600 seconds, which follows the setup of previous studies also using the tool [17].", "part": "1"}, {"sec": "sec5b", "text": " We same set of subjects as empirical evaluations from related work [17].", "part": "1"}, {"sec": "sec7", "text": " The work of Campos et al., which generated tests that would converge towards coverage matrix densities of 0.5 [17], has paved the way for creating improved measurements like DDU.", "part": "1"}], "links": {"abstract": "Spectrum-based Bayesian reasoning can effectively rank candidate fault locations based on passing/failing test cases, but the diagnostic quality highly depends on the size and diversity of the underlying test suite. As test suites in practice often do not exhibit the necessary properties, we present a technique to extend existing test suites with new test cases that optimize the diagnostic quality. We apply probability theory concepts to guide test case generation using entropy, such that the am...", "pdfSize": "474KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Entropy-Based+Test+Generation+for+Improved+Fault+Localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "F. Steimann, M. Frenkel, R. Abreu, \"Threats to the validity and value of empirical assessments of the accuracy of coverage-based fault locators\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 314-324, 2013.", "title": "Threats to the validity and value of empirical assessments of the accuracy of coverage-based fault locators", "context": [{"sec": "sec3b", "text": "To measure the accuracy of fault-localization approaches, the cost of diagnosis \\$C_{d}\\$ metric is often used [10], [11], [17], [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2483760.2483767", "abstract": "Resuming past work on coverage-based fault localization, we find that empirical assessments of its accuracy are subject to so many imponderables that they are of limited value. To improve on this situation, we have compiled a comprehensive list of threats to be considered when attempting such assessments in the future. In addition, we propose the establishment of theoretical lower and upper bounds of fault localization accuracy that depend on properties of the subject programs (including their t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Threats+to+the+validity+and+value+of+empirical+assessments+of+the+accuracy+of+coverage-based+fault+locators&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "C. Parnin, A. Orso, \"Are automated debugging techniques actually helping programmers?\", <em>Proceedings of the 2011 International Symposium on Software Testing and Analysis</em>, pp. 199-209, 2011.", "title": "Are automated debugging techniques actually helping programmers?", "context": [{"sec": "sec3b", "text": " This assumption may not always hold [19], but there are approaches to mitigate it (e.g., [20]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2001420.2001445", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+automated+debugging+techniques+actually+helping+programmers%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "C. Gouveia, J. Campos, R. Abreu, \"Using HTML5 visualizations in software fault localization\", <em>Software Visualization (VISSOFT) 2013 First IEEE Working Conference on</em>, pp. 1-10, 2013.", "title": "Using HTML5 visualizations in software fault localization", "context": [{"sec": "sec3b", "text": " This assumption may not always hold [19], but there are approaches to mitigate it (e.g., [20]).", "part": "1"}], "links": {"documentLink": "/document/6650539", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6650539", "abstract": "Testing and debugging is the most expensive, error-prone phase in the software development life cycle. Automated software fault localization can drastically improve the efficiency of this phase, thus improving the overall quality of the software. Amongst the most well-known techniques, due to its efficiency and effectiveness, is spectrum-based fault localization. In this paper, we propose three dynamic graphical forms using HTML5 to display the diagnostic reports yielded by spectrum-based fault ...", "pdfSize": "968KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+HTML5+visualizations+in+software+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "A. Gonz\u00e1lez-Sanchez, R. Abreu, H. Gross, A.J.C. van Gemund, \"Prioritizing tests for fault localization through ambiguity group reduction\", <em>26th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 83-92, 2011.", "title": "Prioritizing tests for fault localization through ambiguity group reduction", "context": [{"sec": "sec3d", "text": " Dynamic basic blocks, which other authors also call ambiguity groups [21], correspond to sets of components that exhibit the same involvement pattern across the entire test-suite.", "part": "1"}], "links": {"documentLink": "/document/6100153", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6100153", "abstract": "In practically all development processes, regression tests are used to detect the presence of faults after a modification. If faults are detected, a fault localization algorithm can be used to reduce the manual inspection cost. However, while using test case prioritization to enhance the rate of fault detection of the test suite (e.g., statement coverage), the diagnostic information gain per test is not optimal, which results in needless inspection cost during diagnosis. We present RAPTOR, a tes...", "pdfSize": "382KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Prioritizing+tests+for+fault+localization+through+ambiguity+group+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "C.E. Shannon, \"A mathematical theory of communication\", <em>Mobile Computing and Communications Review</em>, vol. 5, no. 1, pp. 3-55, 2001.", "title": "A mathematical theory of communication", "context": [{"sec": "sec4a", "text": " Shannon Entropy [22] is given by\n in this context, \\$X\\$ is the set of unique transaction activities in the spectrum matrix. \\$P(x_{i})\\$ is the probability of selecting a transaction \\$t\\in \\mathcal{T}\\$ and it having the same activity pattern as \\$x_{i}\\$.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/584091.584093", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+mathematical+theory+of+communication&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "L. Jost, \"Entropy and diversity\", <em>Oikos</em>, vol. 113, no. 2, pp. 363-375, may 2006.", "title": "Entropy and diversity", "context": [{"sec": "sec4b2", "text": "We use the Gini-Simpson index to measure diversity \\$(\\mathcal{G})\\$ [23].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.2006.0030-1299.14714.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Entropy+and+diversity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "R. Abreu, P. Zoeteweij, A.J.C. van Gemund, \"A new bayesian approach to multiple intermittent fault diagnosis\", <em>IJCAI 2009 Proceedings of the 21st International Joint Conference on Artificial Intelligence</em>, pp. 653-658, July 11\u201317, 2009.", "title": "A new bayesian approach to multiple intermittent fault diagnosis", "context": [{"sec": "sec5a", "text": " The chosen value is a compromise between perfect error detection (i.e., oracle quality of 1) and essentially random error detection (oracle quality of 0.5) This fault injection approach is common practice among controlled, theoretical evaluations of spectrum-based diagnosis [8], [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+new+bayesian+approach+to+multiple+intermittent+fault+diagnosis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "R. Just, D. Jalali, M.D. Ernst, \"Defects4J: A Database of existing faults to enable controlled testing studies for Java programs\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 437-440, 2014.", "title": "Defects4J: A Database of existing faults to enable controlled testing studies for Java programs", "context": [{"sec": "sec5c", "text": "We used the Defects4J database [25] for sourcing the experimental subjects.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2628055", "abstract": "Empirical studies in software testing research may not be comparable, reproducible, or characteristic of practice. One reason is that real bugs are too infrequently used in software testing research. Extracting and reproducing real bugs is challenging and as a result hand-seeded faults or mutants are commonly used as a substitute. This paper presents Defects4J, a database and extensible framework providing real bugs to enable reproducible studies in software testing research. The initial version...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Defects4J%3A+A+Database+of+existing+faults+to+enable+controlled+testing+studies+for+Java+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "R. Binder, Testing Object-oriented Systems: Models Patterns and Tools, Addison-Wesley, 2000.", "title": "Testing Object-oriented Systems: Models, Patterns, and Tools", "context": [{"sec": "sec6a", "text": " For that, we envision that new test patterns that focus on optimizing diagnosability will need to be researched and incorporated in established test strategy corpora such as [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+Object-oriented+Systems%3A+Models%2C+Patterns%2C+and+Tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "B. Cornelissen, A. Zaidman, A. van Deursen, \"A controlled experiment for program comprehension through trace visualization\", <em>IEEE Trans. Software Eng.</em>, vol. 37, no. 3, pp. 341-355, 2011.", "title": "A controlled experiment for program comprehension through trace visualization", "context": [{"sec": "sec6a", "text": " Is there a way to visualize DDU analysis in a similar way? We envision that visualization approaches for program comprehension, such as Extravis [27] and Pangolin [28], will constitute a solid starting point for a study on visual, interactive and actionable ways to convey DDU information.", "part": "1"}], "links": {"documentLink": "/document/5441291", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5441291", "abstract": "Software maintenance activities require a sufficient level of understanding of the software at hand that unfortunately is not always readily available. Execution trace visualization is a common approach in gaining this understanding, and among our own efforts in this context is Extravis, a tool for the visualization of large traces. While many such tools have been evaluated through case studies, there have been no quantitative evaluations to the present day. This paper reports on the first contr...", "pdfSize": "2947KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+controlled+experiment+for+program+comprehension+through+trace+visualization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "A. Perez, R. Abreu, \"Framing program comprehension as fault localization\", <em>Journal of Software: Evolution and Process</em>, 2016.", "title": "Framing program comprehension as fault localization", "context": [{"sec": "sec6a", "text": " Is there a way to visualize DDU analysis in a similar way? We envision that visualization approaches for program comprehension, such as Extravis [27] and Pangolin [28], will constitute a solid starting point for a study on visual, interactive and actionable ways to convey DDU information.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/smr.1799", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Framing+program+comprehension+as+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "C. Pacheco, M.D. Ernst, \"Randoop: feedback-directed random testing for java\", <em>Companion to the 22nd Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems Languages and Applications OOPSLA 2007</em>, pp. 815-816, October 21\u201325, 2007.", "title": "Randoop: feedback-directed random testing for java", "context": [{"sec": "sec6b", "text": " Additional research is needed to see how the metric behaves both with different test-generation frameworks (such as Randoop [29]) and with hand-written test cases.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Randoop%3A+feedback-directed+random+testing+for+java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "Y. Yu, J.A. Jones, M.J. Harrold, \"An empirical study of the effects of test-suite reduction on fault localization\", <em>30th International Conference on Software Engineering (ICSE 2008)</em>, pp. 201-210, May 10\u201318, 2008.", "title": "An empirical study of the effects of test-suite reduction on fault localization", "context": [{"sec": "sec7", "text": "The topic of test-suite minimization is a prime candidate for our approach, since it has been shown that there is a tradeoff between reducing tests and the suite's fault localization effectiveness [30].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368116", "abstract": "Fault-localization techniques that utilize information about all test cases in a test suite have been presented. These techniques use various approaches to identify the likely faulty part(s) of a program, based on information about the execution of the program with the test suite. Researchers have begun to investigate the impact that the composition of the test suite has on the effectiveness of these fault-localization techniques. In this paper, we present the first experiment on one aspect of t...", "pdfSize": "226KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+the+effects+of+test-suite+reduction+on+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "L. Gong, D. Lo, L. Jiang, H. Zhang, \"Diversity maximization speedup for fault localization\", <em>IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 30-39, September 3\u20137, 2012.", "title": "Diversity maximization speedup for fault localization", "context": [{"sec": "sec7", "text": " Current minimization strategies can often improve the diversity score of a coverage matrix by removing tests with identical coverage patterns [31] at the cost of overlooking density and uniqueness, which we argue are of key importance to assess diagnosability.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2351676.2351682", "abstract": "Fault localization is useful for reducing debugging effort. However, many fault localization techniques require non-trivial number of test cases with oracles, which can determine whether a program behaves correctly for every test input. Test oracle creation is expensive because it can take much manual labeling effort. Given a number of test cases to be executed, it is challenging to minimize the number of test cases requiring manual labeling and in the meantime achieve good fault localization ac...", "pdfSize": "1081KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Diversity+maximization+speedup+for+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "J. Xuan, M. Monperrus, \"Test case purification for improving fault localization\", <em>Proceedings of the 22nd ACM SIGSOFT InternationalSymposium on Foundations of Software Engineering (FSE-22)</em>, pp. 52-63, November 16\u201322, 2014.", "title": "Test case purification for improving fault localization", "context": [{"sec": "sec7", "text": " The uniqueness property is also exploited by Xuan et al., with a test-case purification approach that separates a test-case into multiple smaller tests [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635906", "abstract": "Finding and fixing bugs are time-consuming activities in software development. Spectrum-based fault localization aims to identify the faulty position in source code based on the execution trace of test cases. Failing test cases and their assertions form test oracles for the failing behavior of the system under analysis. In this paper, we propose a novel concept of spectrum driven test case purification for improving fault localization. The goal of test case purification is to separate existing t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+case+purification+for+improving+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "S. Yoo, M. Harman, \"Using hybrid algorithm for pareto efficient multi-objective test suite minimisation\", <em>Journal of Systems and Software</em>, vol. 83, no. 4, pp. 689-701, 2010.", "title": "Using hybrid algorithm for pareto efficient multi-objective test suite minimisation", "context": [{"sec": "sec7", "text": "Current test-suite minimization frameworks that take adequacy criteria into account could also benefit from our approach to preserve diagnostic accuracy if a multi-objective optimization (such as, e.g., [33], [34]) to also account for DDU is employed.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2009.11.706", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+hybrid+algorithm+for+pareto+efficient+multi-objective+test+suite+minimisation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "M.A. Alipour, A. Shi, R. Gopinath, D. Marinov, A. Groce, \"Evaluating non-adequate test-case reduction\", <em>31st IEEE/ACM InternationalConference on Automated Software Engineering (ASE)</em>, 2016.", "title": "Evaluating non-adequate test-case reduction", "context": [{"sec": "sec7", "text": "Current test-suite minimization frameworks that take adequacy criteria into account could also benefit from our approach to preserve diagnostic accuracy if a multi-objective optimization (such as, e.g., [33], [34]) to also account for DDU is employed.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970361", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+non-adequate+test-case+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "S. Artzi, J. Dolby, F. Tip, M. Pistoia, \"Directed test generation for effective fault localization\", <em>Proceedings of the Nineteenth International Symposium on Software Testing and Analysis ISSTA 2010</em>, pp. 49-60, July 12\u201316, 2010.", "title": "Directed test generation for effective fault localization", "context": [{"sec": "sec7", "text": " Another approach to suite generation is one by Artzi et al., that proposes an online approach that leverages concolic analysis to generate tests that are similar to existing failing tests in a system [35].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1831708.1831715", "abstract": "Fault-localization techniques that apply statistical analyses to execution data gathered from multiple tests are quite effective when a large test suite is available. However, if no test suite is available, what is the best approach to generate one? This paper investigates the fault-localization effectiveness of test suites generated according to several test-generation techniques based on combined concrete and symbolic (concolic) execution. We evaluate these techniques by applying the Ochiai fa...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Directed+test+generation+for+effective+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "D. Schuler, A. Zeller, \"Assessing oracle quality with checked coverage\", <em>Fourth IEEE International Conference on Software Testing Verification and Validation ICST 2011</em>, pp. 90-99, March 21\u201325, 2011.", "title": "Assessing oracle quality with checked coverage", "context": [{"sec": "sec7", "text": " Schuler et al. propose checked coverage as a way of assessing oracle quality [36], [37].", "part": "1"}], "links": {"abstract": "A known problem of traditional coverage metrics is that they do not assess oracle quality - that is, whether the computation result is actually checked against expectations. In this paper, we introduce the concept of checked coverage - the dynamic slice of covered statements that actually influence an oracle. Our experiments on seven open-source projects show that checked coverage is a sure indicator for oracle quality - and even more sensitive than mutation testing, its much more demanding alte...", "pdfSize": "475KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Assessing+oracle+quality+with+checked+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "D. Schuler, \"Checked coverage: an indicator for oracle quality\", <em>Softw. Test. Verif. Reliab.</em>, vol. 23, no. 7, pp. 531-551, 2013.", "title": "Checked coverage: an indicator for oracle quality", "context": [{"sec": "sec7", "text": " Schuler et al. propose checked coverage as a way of assessing oracle quality [36], [37].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stvr.1497", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Checked+coverage%3A+an+indicator+for+oracle+quality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "X. Wang, S. Cheung, W.K. Chan, Z. Zhang, \"Taming coincidental correctness: Coverage refinement with context patterns to improve fault localization\", <em>31 st International Conference on Software Engineering ICSE 2009</em>, pp. 45-55, May 16\u201324, 2009.", "title": "Taming coincidental correctness: Coverage refinement with context patterns to improve fault localization", "context": [{"sec": "sec7", "text": " Wang et al. have proposed a way of addressing coincidental correctness \u2014 when a fault is executed but no failure is detected \u2014 by analyzing data and control-flow patterns [38].", "part": "1"}], "links": {"abstract": "Recent techniques for fault localization leverage code coverage to address the high cost problem of debugging. These techniques exploit the correlations between program failures and the coverage of program entities as the clue in locating faults. Experimental evidence shows that the effectiveness of these techniques can be affected adversely by coincidental correctness, which occurs when a fault is executed but no failure is detected. In this paper, we propose an approach to address this problem...", "pdfSize": "390KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Taming+coincidental+correctness%3A+Coverage+refinement+with+context+patterns+to+improve+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "R. Just, D. Jalali, L. Inozemtseva, M.D. Ernst, R. Holmes, G. Fraser, \"Are mutants a valid substitute for real faults in software testing?\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE-22)</em>, pp. 654-665, November 16\u201322, 2014.", "title": "Are mutants a valid substitute for real faults in software testing?", "context": [{"sec": "sec7", "text": " Just et al. investigated the use of mutants to estimate oracle quality, and compared their performance against the use of real faults [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635929", "abstract": "A good test suite is one that detects real faults. Because the set of faults in a program is usually unknowable, this definition is not useful to practitioners who are creating test suites, nor to researchers who are creating and evaluating tools that generate test suites. In place of real faults, testing research often uses mutants, which are artificial faults -- each one a simple syntactic variation -- that are systematically seeded throughout the program under test. Mutation analysis is appea...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+mutants+a+valid+substitute+for+real+faults+in+software+testing%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985702", "articleId": "7985702", "startPage": "654", "endPage": "664", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 7, "citationCountPatent": 0, "totalDownloads": 418}}
{"title": "Statically Checking Web API Requests in JavaScript", "authors": [{"name": "Erik Wittern", "affiliation": "IBM T. J. Watson Res. Center, Yorktown Heights, NY, USA", "firstName": "Erik", "lastName": "Wittern", "id": "37712307400"}, {"name": "Annie T.T. Ying", "affiliation": "IBM T. J. Watson Res. Center, Yorktown Heights, NY, USA", "firstName": "Annie T.T.", "lastName": "Ying", "id": "37086037660"}, {"name": "Yunhui Zheng", "affiliation": "IBM T. J. Watson Res. Center, Yorktown Heights, NY, USA", "firstName": "Yunhui", "lastName": "Zheng", "id": "37086034609"}, {"name": "Julian Dolby", "affiliation": "IBM T. J. Watson Res. Center, Yorktown Heights, NY, USA", "firstName": "Julian", "lastName": "Dolby", "id": "37312476300"}, {"name": "Jim A. Laredo", "affiliation": "IBM T. J. Watson Res. Center, Yorktown Heights, NY, USA", "firstName": "Jim A.", "lastName": "Laredo", "id": "37400839400"}], "abstract": "Many JavaScript applications perform HTTP requests to web APIs, relying on the request URL, HTTP method, and request data to be constructed correctly by string operations. Traditional compile-time error checking, such as calling a non-existent method in Java, are not available for checking whether such requests comply with the requirements of a web API. In this paper, we propose an approach to statically check web API requests in JavaScript. Our approach first extracts a request's URL string, HTTP method, and the corresponding request data using an inter-procedural string analysis, and then checks whether the request conforms to given web API specifications. We evaluated our approach by checking whether web API requests in JavaScript files mined from GitHub are consistent or inconsistent with publicly available API specifications. From the 6575 requests in scope, our approach determined whether the request's URL and HTTP method was consistent or inconsistent with web API specifications with a precision of 96.0%. Our approach also correctly determined whether extracted request data was consistent or inconsistent with the data requirements with a precision of 87.9% for payload data and 99.9% for query data. In a systematic analysis of the inconsistent cases, we found that many of them were due to errors in the client code. The here proposed checker can be integrated with code editors or with continuous integration tools to warn programmers about code containing potentially erroneous requests.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Uniform resource locators", "Data mining", "Reactive power", "Payloads", "Tools", "Media", "Writing"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["application program interfaces", "Java", "program diagnostics"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["Web API requests", "JavaScript", "HTTP requests", "compile-time error checking", "URL string", "interprocedural string analysis", "GitHub"]}, {"type": "Author Keywords ", "kwd": ["Static analysis", "JavaScript", "Web APIs"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.30", "ref": [{"order": "1", "text": "<em>IBM API Harmony</em>,  [online]  Available: https://apiharmony-open.mybluemix.net/.", "title": "IBM API Harmony", "context": [{"sec": "sec1", "text": " Catalogs such as IBM's API Harmony [1], [2], Mashape's PublicAPIs [3], or Programmable Web [4] list thousands of web Application Programming Interfaces (web APIs) exposed by these services.", "part": "1"}, {"sec": "sec8", "text": " As such, this approach can be integrated with existing tools that support developers in using web APIs [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=IBM+API+Harmony&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "E. Wittern, V. Muthusamy, J.A. Laredo, M. Vukovic, A. Slominski, S. Rajagopalan, H. Jamjoom, A. Natarajan, \"API Harmony: Graph-based search and selection of APIs in the cloud\", <em>IBM Journal of Researchand Development</em>, vol. 60, no. 2\u20133, pp. 12:1-12:11, March 2016.", "title": "API Harmony: Graph-based search and selection of APIs in the cloud", "context": [{"sec": "sec1", "text": " Catalogs such as IBM's API Harmony [1], [2], Mashape's PublicAPIs [3], or Programmable Web [4] list thousands of web Application Programming Interfaces (web APIs) exposed by these services.", "part": "1"}], "links": {"documentLink": "/document/7442611", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7442611", "abstract": "Cloud-enabled applications and services increasingly consume other services through web application programming interfaces (APIs). API ecosystems support both the production and the consumption of APIs. For service providers seeking to externalize their APIs, API ecosystems help publish, promote, and provision such APIs. For applications or services consuming APIs, API ecosystems unify how APIs are presented and composed. A key challenge for API ecosystems is the continuous collection of informa...", "pdfSize": "1288KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=API+Harmony%3A+Graph-based+search+and+selection+of+APIs+in+the+cloud&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>PublicAPIs \u2014 Directory of public APIs for web and mobile</em>,  [online]  Available: https://www.publicapis.com/.", "title": "PublicAPIs \u2014 Directory of public APIs for web and mobile", "context": [{"sec": "sec1", "text": " Catalogs such as IBM's API Harmony [1], [2], Mashape's PublicAPIs [3], or Programmable Web [4] list thousands of web Application Programming Interfaces (web APIs) exposed by these services.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=PublicAPIs+%E2%80%94+Directory+of+public+APIs+for+web+and+mobile&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>ProgrammableWeb \u2014 APIs Mashups and the Web as Platform</em>,  [online]  Available: http://www.programmableweb.com/.", "title": "ProgrammableWeb \u2014 APIs, Mashups and the Web as Platform", "context": [{"sec": "sec1", "text": " Catalogs such as IBM's API Harmony [1], [2], Mashape's PublicAPIs [3], or Programmable Web [4] list thousands of web Application Programming Interfaces (web APIs) exposed by these services.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ProgrammableWeb+%E2%80%94+APIs%2C+Mashups+and+the+Web+as+Platform&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "T. Espinha, A. Zaidman, H.-G. Gross, \"Web API Fragility: How Robust is Your Mobile Application?\", <em>Proceedings of the IEEE MOBILESoft</em>, pp. 12-21, 2015.", "title": "Web API Fragility: How Robust is Your Mobile Application?", "context": [{"sec": "sec1", "text": " A recent study found that a significant number of analyzed mobile applications will fail in light of changes to the web APIs they consume [5].", "part": "1"}], "links": {"documentLink": "/document/7283022", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7283022", "abstract": "Web APIs provide a systematic and extensible approach for application-to-application interaction. A large number of mobile applications makes use of Web APIs to integrate services into apps. Each Web API&#39;s evolution pace is determined by their respective developer and mobile application developers are forced to accompany the API providers in their software evolution tasks. In this paper we investigate whether and how mobile application developers deal with the added distress of Web APIs evolving...", "pdfSize": "206KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Web+API+Fragility%3A+How+Robust+is+Your+Mobile+Application%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Open API Initiative</em>,  [online]  Available: https://openapis.org/specification.", "title": "Open API Initiative", "context": [{"sec": "sec1", "text": " Such specifications, like the OpenAPI Specification [6] (formerly known as Swagger, the name we will use for the rest of the paper) can be created by API providers or third parties to document valid URLs, HTTP methods, as well as inputs and outputs that a web API expects.", "part": "1"}, {"sec": "sec2", "text": " The OpenAPI specification (Swagger) is one of these specifications, which enjoys broad industry support [6].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Open+API+Initiative&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "A. Feldthaus, M. Sch\u00e4fer, M. Sridharan, J. Dolby, F. Tip, \"Efficient Construction of Approximate Call Graphs for JavaScript IDE Services\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 752-761, 2013.", "title": "Efficient Construction of Approximate Call Graphs for JavaScript IDE Services", "context": [{"sec": "sec1", "text": " Our approach first extracts the URL string, HTTP method, and the corresponding data from a request, using an inter-procedural static program analysis capable of extracting strings [7], and then checks whether the request conforms to publicly available web API specifications.", "part": "1"}, {"sec": "sec1", "text": " The main contribution of our approach is in leveraging existing work in making static whole-program analysis possible for framework-based JavaScript web applications (i.e., [7], [9]\u2013[11]) and applying it to a new problem of checking whether a request is consistent with a web API specification.", "part": "1"}, {"sec": "sec3a", "text": " The analysis then translates the script into the intermediate representation and builds an approximate call graph, called a field-based call graph [7].", "part": "1"}], "links": {"abstract": "The rapid rise of JavaScript as one of the most popular programming languages of the present day has led to a demand for sophisticated IDE support similar to what is available for Java or C#. However, advanced tooling is hampered by the dynamic nature of the language, which makes any form of static analysis very difficult. We single out efficient call graph construction as a key problem to be solved in order to improve development tools for JavaScript. To address this problem, we present a scala...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+Construction+of+Approximate+Call+Graphs+for+JavaScript+IDE+Services&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Usage Statistics and Market Share of JavaScript Libraries for Websites</em>, August 2016,  [online]  Available: https://w3techs.com/technologies/overview/javascript_library/all/.", "title": "Usage Statistics and Market Share of JavaScript Libraries for Websites", "context": [{"sec": "sec1", "text": " For the initial implementation, we chose to handle requests written using the jQuery framework due to its popularity - reportedly, 70% of websites use the jQuery framework [8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Usage+Statistics+and+Market+Share+of+JavaScript+Libraries+for+Websites&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "M. Sch\u00e4fer, M. Sridharan, J. Dolby, F. Tip, \"Dynamic determinacy analysis\", <em>ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 165-174, 2013.", "title": "Dynamic determinacy analysis", "context": [{"sec": "sec1", "text": " The main contribution of our approach is in leveraging existing work in making static whole-program analysis possible for framework-based JavaScript web applications (i.e., [7], [9]\u2013[11]) and applying it to a new problem of checking whether a request is consistent with a web API specification.", "part": "1"}, {"sec": "sec3a", "text": " A field-based call graph is a statement-level call graph that uses one abstraction for all instances of each property used in the program, as opposed to one abstraction for each property of each abstract object as in traditional call graphs; this has been shown to scale well for framework-based JavaScript web applications even in the presence of JavaScript's dynamic features [9].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491956.2462168", "abstract": "We present an analysis for identifying determinate variables and expressions that always have the same value at a given program point. This information can be exploited by client analyses and tools to, e.g., identify dead code or specialize uses of dynamic language constructs such as eval, replacing them with equivalent static constructs. Our analysis is completely dynamic and only needs to observe a single execution of the program, yet the determinacy facts it infers hold for any execution. We ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+determinacy+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "E. Andreasen, A. M\u00f8ller, \"Determinacy in static analysis for jquery\", <em>Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages & Applications</em>, pp. 17-31, 2014.", "title": "Determinacy in static analysis for jquery", "context": [{"sec": "sec1", "text": " The main contribution of our approach is in leveraging existing work in making static whole-program analysis possible for framework-based JavaScript web applications (i.e., [7], [9]\u2013[10][11]) and applying it to a new problem of checking whether a request is consistent with a web API specification.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Determinacy+in+static+analysis+for+jquery&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "Y. Ko, H. Lee, J. Dolby, S. Ryu, \"Practically tunable static analysis framework for large-scale JavaScript applications (T)\", <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 541-551, 2015.", "title": "Practically tunable static analysis framework for large-scale JavaScript applications (T)", "context": [{"sec": "sec1", "text": " The main contribution of our approach is in leveraging existing work in making static whole-program analysis possible for framework-based JavaScript web applications (i.e., [7], [9]\u2013[11]) and applying it to a new problem of checking whether a request is consistent with a web API specification.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practically+tunable+static+analysis+framework+for+large-scale+JavaScript+applications+%28T%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "<em>APIs.guru \u2014 Wikipedia for Web APIs</em>,  [online]  Available: https://apis.guru/.", "title": "APIs.guru \u2014 Wikipedia for Web APIs", "context": [{"sec": "sec1", "text": "We evaluated our approach by checking whether web API requests from over 6000 JavaScript files on GitHub22https://github.com/ were consistent or inconsistent with publicly available web API specifications provided by the APIs Guru project [12].", "part": "1"}, {"sec": "sec5a1", "text": "For the Swagger specifications, we made use of a community-maintained collection of specifications from the APIs Guru repository [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=APIs.guru+%E2%80%94+Wikipedia+for+Web+APIs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "P. Suter, E. Wittern, \"Inferring Web API Descriptions From Usage Data\", <em>Proceedings of the 3rd IEEE Workshop on Hot Topics in Web Systems and Technologies</em>, 2015.", "title": "Inferring Web API Descriptions From Usage Data", "context": [{"sec": "sec2", "text": " Following previous work, we refer to the combination of a URL and HTTP method as an API endpoint [13].", "part": "1"}], "links": {"documentLink": "/document/7372275", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372275", "abstract": "We describe a set of techniques to infer structured descriptions of web APIs from usage examples. Using trained classifiers, we identify fixed and variable segments in paths, and tag parameters according to their types. We implemented our techniques and evaluated their precision on 10 APIs for which we obtained: 1) descriptions, manually written by the API maintainers, and 2) server logs of the API usage. Our experiments show that our system is able to reconstruct the structure of both simple an...", "pdfSize": "191KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inferring+Web+API+Descriptions+From+Usage+Data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "<em>JSON Schema and Hyper-Schema</em>,  [online]  Available: http://json-schema.org/.", "title": "JSON Schema and Hyper-Schema", "context": [{"sec": "sec2", "text": " Entries in the definitions property describe the structure of data to send to or receive from endpoints using JSONschema notation [14] or a XML Object notation that is specific to Swagger.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=JSON+Schema+and+Hyper-Schema&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "K. Sen, S. Kalasapur, T. Brutch, S. Gibbs, \"Jalangi: A selective record-replay and dynamic analysis framework for JavaScript\", <em>Proceedings of the 9th Joint Meeting on Foundations of Software Engineering and the Foundations of Software Engineering</em>, pp. 488-498, 2013.", "title": "Jalangi: A selective record-replay and dynamic analysis framework for JavaScript", "context": [{"sec": "sec2b", "text": "Another option to check whether a web API request is correct would be to perform a dynamic analysis [15].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491447", "abstract": "JavaScript is widely used for writing client-side web applications and is getting increasingly popular for writing mobile applications. However, unlike C, C++, and Java, there are not that many tools available for analysis and testing of JavaScript applications. In this paper, we present a simple yet powerful framework, called Jalangi, for writing heavy-weight dynamic analyses. Our framework incorporates two key techniques: 1) selective record-replay, a technique which enables to record and to f...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jalangi%3A+A+selective+record-replay+and+dynamic+analysis+framework+for+JavaScript&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>The T.J. Watson Libraries for Analysis (WALA)</em>,  [online]  Available: http://wala.sourceforge.net/.", "title": "The T.J. Watson Libraries for Analysis (WALA)", "context": [{"sec": "sec3a", "text": " In our implementation, we used the field-based call graph construction available in WALA [16].", "part": "1"}, {"sec": "sec3C", "text": " In our implementation, we used the WALA backward slicer [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+T.J.+Watson+Libraries+for+Analysis+%28WALA%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Y.N. Srikant, P. Shankar, The Compiler Design Handbook: Optimizations and Machine Code Generation, CRC Press Inc., 2007.", "title": "The Compiler Design Handbook: Optimizations and Machine Code Generation", "context": [{"sec": "sec3C", "text": " Starting from each request function call captured in the previous step, we apply standard inter-procedural backward slicing [17] to narrow down the subset of statements of the program that affect the statement containing the request.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1201/9781420043839", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Compiler+Design+Handbook%3A+Optimizations+and+Machine+Code+Generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Y. Zheng, X. Zhang, V. Ganesh, \"Z3-str: A z3-based string solver for web application analysis\", <em>Proceedings of the 9th Joint Meeting on Foundations of Software Engineering and the Foundations of Software Engineering</em>, pp. 114-124, 2013.", "title": "Z3-str: A z3-based string solver for web application analysis", "context": [{"sec": "sec3C", "text": " Currently, research on robust and scalable modeling of string operators with symbolic values is still ongoing [18]\u2013[21].", "part": "1"}, {"sec": "sec5b2", "text": " Currently, handling a more complete set of string library functions with symbolic values is an active research topic [18]\u2013[21].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491456", "abstract": "Analyzing web applications requires reasoning about strings and non-strings cohesively. Existing string solvers either ignore non-string program behavior or support limited set of string operations. In this paper, we develop a general purpose string solver, called Z3-str, as an extension of the Z3 SMT solver through its plug-in interface. Z3-str treats strings as a primitive type, thus avoiding the inherent limitations observed in many existing solvers that encode strings in terms of other primi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Z3-str%3A+A+z3-based+string+solver+for+web+application+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "T. Liang, A. Reynolds, C. Tinelli, C. Barrett, M. Deters, \"A DPLL(T) Theory Solver for a Theory of Strings and Regular Expressions\", <em>Proceedings of the 26th International Conference on Computer Aided Verification</em>, pp. 646-662, 2014.", "title": "A DPLL(T) Theory Solver for a Theory of Strings and Regular Expressions", "context": [{"sec": "sec3C", "text": " Currently, research on robust and scalable modeling of string operators with symbolic values is still ongoing [18]\u2013[19][21].", "part": "1"}, {"sec": "sec5b2", "text": " Currently, handling a more complete set of string library functions with symbolic values is an active research topic [18]\u2013[19][21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+DPLL%28T%29+Theory+Solver+for+a+Theory+of+Strings+and+Regular+Expressions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Y. Zheng, V. Ganesh, S. Subramanian, O. Tripp, J. Dolby, X. Zhang, \"Effective search-space pruning for solvers of string equations regular expressions and length constraints\", <em>Proceedings of the 27th International Conference on Computer Aided Verification</em>, pp. 235-254, 2015.", "title": "Effective search-space pruning for solvers of string equations, regular expressions and length constraints", "context": [{"sec": "sec3C", "text": " Currently, research on robust and scalable modeling of string operators with symbolic values is still ongoing [18]\u2013[20][21].", "part": "1"}, {"sec": "sec5b2", "text": " Currently, handling a more complete set of string library functions with symbolic values is an active research topic [18]\u2013[20][21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+search-space+pruning+for+solvers+of+string+equations%2C+regular+expressions+and+length+constraints&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "M.-T. Trinh, D.-H. Chu, J. Jaffar, S. Chaudhuri, A. Farzan, \"Progressive reasoning over recursively-defined strings\", <em>Proceedings of the 28th International Conference on Computer Aided Verification</em>, pp. 218-240, 2016.", "title": "Progressive reasoning over recursively-defined strings", "context": [{"sec": "sec3C", "text": " Currently, research on robust and scalable modeling of string operators with symbolic values is still ongoing [18]\u2013[21].", "part": "1"}, {"sec": "sec5b2", "text": " Currently, handling a more complete set of string library functions with symbolic values is an active research topic [18]\u2013[21].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-41528-4_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Progressive+reasoning+over+recursively-defined+strings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "C. Rodriguez, M. Baez, F. Daniel, F. Casati, J. Carlos, \"REST APIs: A Large-Scale Analysis of Compliance with Principles and Best Practices\", <em>Proceedings of the International Conference on Web Engineering</em>, 2016.", "title": "REST APIs: A Large-Scale Analysis of Compliance with Principles and Best Practices", "context": [{"sec": "sec4b1", "text": " As the static analysis focuses on JavaScript, and because its the prevalent data format in web APIs [22], we focus on data in the JavaScript Object Notation (JSON).", "part": "1"}, {"sec": "sec6", "text": "Multiple works have been proposed to check web APIs for compliance with best-practices [22], [31].", "part": "1"}, {"sec": "sec6", "text": " These works currently take as input observed web API requests [22] or human-readable documentations [31], but could be adapted to work on top of API specifications.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-38791-8_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=REST+APIs%3A+A+Large-Scale+Analysis+of+Compliance+with+Principles+and+Best+Practices&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>Selenium \u2014 Web Browser Automation</em>,  [online]  Available: http://www.seleniumhq.org/.", "title": "Selenium \u2014 Web Browser Automation", "context": [{"sec": "sec5a2", "text": " To automate the data collection, we used Selenium [23] to invoke the GitHub code search and crawled the search result to obtain links to JavaScript files.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Selenium+%E2%80%94+Web+Browser+Automation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "<em>TypeScript \u2014 JavaScript that scales</em>,  [online]  Available: https://www.typescriptlang.org/.", "title": "TypeScript \u2014 JavaScript that scales", "context": [{"sec": "sec6", "text": "Our work on checking JavaScript code with respect to web API specifications is similar in spirit to a range of work on checking and bug finding approaches, such as TypeScript [24] and JSHint [25], respectively.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=TypeScript+%E2%80%94+JavaScript+that+scales&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "<em>JSHint a JavaScript Code Quality Tool</em>,  [online]  Available: http://jshint.com/.", "title": "JSHint, a JavaScript Code Quality Tool", "context": [{"sec": "sec6", "text": "Our work on checking JavaScript code with respect to web API specifications is similar in spirit to a range of work on checking and bug finding approaches, such as TypeScript [24] and JSHint [25], respectively.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=JSHint%2C+a+JavaScript+Code+Quality+Tool&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "W.G.J. Halfond, A. Orso, \"Automated identification of parameter mismatches in web applications\", <em>Proceedings of the 16th ACM. SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 181-191, 2008.", "title": "Automated identification of parameter mismatches in web applications", "context": [{"sec": "sec6", "text": "Halfond et al. introduce static analysis techniques for understanding web API usage in Java applications [26], [27].", "part": "1"}, {"sec": "sec6", "text": " One technique focuses on how APIs are used in HTML code that is dynamically generated as part of a Java web application [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1453101.1453126", "abstract": "Quality assurance techniques for web applications have become increasingly important as web applications have gained in popularity and become an essential part of our daily lives. To integrate content and data from multiple sources, the components of a web application communicate extensively among themselves. Unlike traditional program modules, the components communicate through interfaces and invocations that are not explicitly declared. Because of this, the communication between two components...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+identification+of+parameter+mismatches+in+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "W.G. Halfond, S. Anand, A. Orso, \"Precise interface identification to improve testing and analysis of web applications\", <em>Proceedings of the Eighteenth InternationalSymposium on Software Testing and Analysis</em>, pp. 285-296, 2009.", "title": "Precise interface identification to improve testing and analysis of web applications", "context": [{"sec": "sec6", "text": "Halfond et al. introduce static analysis techniques for understanding web API usage in Java applications [26], [27].", "part": "1"}, {"sec": "sec6", "text": " Other work introduces symbolic execution to improve results, once again focusing on Java web application [27].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1572272.1572305", "abstract": "As web applications become more widespread, sophisticated, and complex, automated quality assurance techniques for such applications have grown in importance. Accurate interface identification is fundamental for many of these techniques, as the components of a web application communicate extensively via implicitly-defined interfaces to generate customized and dynamic content. However, current techniques for identifying web application interfaces can be incomplete or imprecise, which hinders the ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Precise+interface+identification+to+improve+testing+and+analysis+of+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "C.S. Jensen, A. M\u00f8ller, Z. Su, \"Server Interface Descriptions for Automated Testing of JavaScript Web Applications\", <em>Proceedings of the 9th Joint Meeting on Foundations of Software Engineering</em>, pp. 510-520, 2013.", "title": "Server Interface Descriptions for Automated Testing of JavaScript Web Applications", "context": [{"sec": "sec6", "text": "In the context of JavaScript, related work has shown that understanding API specifications can make dynamic testing more effective [28].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491421", "abstract": "Automated testing of JavaScript web applications is complicated by the communication with servers. Specifically, it is difficult to test the JavaScript code in isolation from the server code and database contents. We present a practical solution to this problem. First, we demonstrate that formal server interface descriptions are useful in automated testing of JavaScript web applications for separating the concerns of the client and the server. Second, to support the construction of server interf...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Server+Interface+Descriptions+for+Automated+Testing+of+JavaScript+Web+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "S. Bae, H. Cho, I. Lim, S. Ryu, \"SAFEWAPI: Web API Misuse Detector for Web Applications\", <em>Proceedings of the 22nd ACM SIGSOFT InternationalSymposium on Foundations of Software Engineering</em>, pp. 507-517, 2014.", "title": "SAFEWAPI: Web API Misuse Detector for Web Applications", "context": [{"sec": "sec6", "text": " SAFEWAPI [29] analyzes JavaScript and checks function calls against the web IDL specifications of those functions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635916", "abstract": "The evolution of Web 2.0 technologies makes web applications prevalent in various platforms including mobile devices and smart TVs. While one of the driving technologies of web applications is JavaScript, the extremely dynamic features of JavaScript make it very difficult to define and detect errors in JavaScript applications. The problem becomes more important and complicated for JavaScript web applications which may lead to severe security vulnerabilities. To help developers write safe JavaScr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SAFEWAPI%3A+Web+API+Misuse+Detector+for+Web+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "C. Park, S. Won, J. Jin, S. Ryu, \"Static Analysis of JavaScript Web Applications in the Wild via Practical DOM Modeling (T)\", <em>Proceedings of the 2015 30th IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 552-562, 2015.", "title": "Static Analysis of JavaScript Web Applications in the Wild via Practical DOM Modeling (T)", "context": [{"sec": "sec6", "text": " SAFEWapp [30] models the web application execution environment (e.g., DOM) and checks function invocations against ECMAScript rules.", "part": "1"}], "links": {"documentLink": "/document/7372043", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372043", "abstract": "We present SAFEWapp, an open-source static analysis framework for JavaScript web applications. It provides a faithful (partial) model of web application execution environments of various browsers, based on empirical data from the main web pages of the 9,465 most popular websites. A main feature of SAFEWapp is the configurability of DOM tree abstraction levels to allow users to adjust a trade-off between analysis performance and precision depending on their applications. We evaluate SAFEWapp on t...", "pdfSize": "494KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+Analysis+of+JavaScript+Web+Applications+in+the+Wild+via+Practical+DOM+Modeling+%28T%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "F. Palma, J. Gonzalez-Huerta, N. Moha, \"Are RESTful APIs Well-Designed? Detection of their Linguistic (Anti) Patterns\", <em>Proceedings of the International Conference on Service-Oriented Computing</em>, pp. 171-187, 2015.", "title": "Are RESTful APIs Well-Designed? Detection of their Linguistic (Anti) Patterns", "context": [{"sec": "sec6", "text": "Multiple works have been proposed to check web APIs for compliance with best-practices [22], [31].", "part": "1"}, {"sec": "sec6", "text": " These works currently take as input observed web API requests [22] or human-readable documentations [31], but could be adapted to work on top of API specifications.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+RESTful+APIs+Well-Designed%3F+Detection+of+their+Linguistic+%28Anti%29+Patterns&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985666", "articleId": "7985666", "startPage": "244", "endPage": "254", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 7, "citationCountPatent": 0, "totalDownloads": 426}}
{"title": "Repairing Event Race Errors by Controlling Nondeterminism", "authors": [{"name": "Christoffer Quist Adamsen", "affiliation": "Aarhus Univ., Aarhus, Denmark", "firstName": "Christoffer Quist", "lastName": "Adamsen", "id": "37086144079"}, {"name": "Anders M\u00f8ller", "affiliation": "Aarhus Univ., Aarhus, Denmark", "firstName": "Anders", "lastName": "M\u00f8ller", "id": "37271463200"}, {"name": "Rezwana Karim", "affiliation": "Samsung Res. America, Mountain View, CA, USA", "firstName": "Rezwana", "lastName": "Karim", "id": "37086143401"}, {"name": "Manu Sridharan", "affiliation": "Samsung Res. America, Mountain View, CA, USA", "firstName": "Manu", "lastName": "Sridharan", "id": "37433839300"}, {"name": "Frank Tip", "affiliation": "Northeastern Univ., Boston, MA, USA", "firstName": "Frank", "lastName": "Tip", "id": "37316196200"}, {"name": "Koushik Sen", "affiliation": "EECS Dept., UC Berkeley, Berkeley, CA, USA", "firstName": "Koushik", "lastName": "Sen", "id": "37271635100"}], "abstract": "Modern web applications are written in an event-driven style, in which event handlers execute asynchronously in response to user or system events. The nondeterminism arising from this programming style can lead to pernicious errors. Recent work focuses on detecting event races and classifying them as harmful or harmless. However, since modifying the source code to prevent harmful races can be a difficult and error-prone task, it may be preferable to steer away from the bad executions. In this paper, we present a technique for automated repair of event race errors in JavaScript web applications. Our approach relies on an event controller that restricts event handler scheduling in the browser according to a specified repair policy, by intercepting and carefully postponing or discarding selected events. We have implemented the technique in a tool called EventRaceCommander, which relies entirely on source code instrumentation, and evaluated it by repairing more than 100 event race errors that occur in the web applications from the largest 20 of the Fortune 500 companies. Our results show that application-independent repair policies usually suffice to repair event race errors without excessive negative impact on performance or user experience, though application-specific repair policies that target specific event races are sometimes desirable.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Maintenance engineering", "Thumb", "Tools", "Browsers", "Instruments", "Programming", "Schedules"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["high level languages", "Internet", "object-oriented programming", "online front-ends", "software maintenance"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["event race error repair", "JavaScript Web applications", "event handler scheduling", "browser", "EventRaceCommander", "source code instrumentation", "application-independent repair policies", "application-specific repair policies"]}, {"type": "Author Keywords ", "kwd": ["JavaScript", "event-driven programming", "automated repair"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.34", "ref": [{"order": "1", "text": "<em>W3C Document Object Model Level 2 Events Specification</em>,  [online]  Available: http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-flow.", "title": "W3C Document Object Model Level 2 Events Specification", "context": [{"sec": "sec6a", "text": " These event delegation mechanisms propagate events from the document root to the target node and back [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=W3C+Document+Object+Model+Level+2+Events+Specification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Chrome Debugging Protocol</em>,  [online]  Available: https://developer.chrome.com/devtools/docs/debugger-protocol.", "title": "Chrome Debugging Protocol", "context": [{"sec": "sec7a3", "text": " We use the Chrome Debugging Protocol [2] to measure: (i) parsing time (i.e., time to DOMContentLoaded), showing the cost for loading EventRaceCommander and instrumenting the source, and (ii) layout time (i.e., time to last layout event during initialization).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Chrome+Debugging+Protocol&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>mitmproxy</em>,  [online]  Available: https://mitmproxy.org/.", "title": "mitmproxy", "context": [{"sec": "sec6", "text": "Our implementation, named EventRaceCommander, instruments HTML and JavaScript source files of a given web application on-the-fly using mitmproxy [3].", "part": "1"}, {"sec": "sec7c", "text": " Therefore, we spent significant effort using mitmproxy [3] to record the server responses for an interaction with every site under consideration.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=mitmproxy&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>RequireJS</em>,  [online]  Available: http://requirejs.org/.", "title": "RequireJS", "context": [{"sec": "sec7b2", "text": " This is mostly a problem for \\$\\mathcal{P}_{init, user}^{+}\\$ in sites that extensively load code asynchronously (e.g., walmart.com, which uses RequireJS [4]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=RequireJS&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "P. Bielik, V. Raychev, M.T. Vechev, \"Scalable race detection for Android applications\", <em>Proc. 30th ACM SIGPLAN International Conference on Object-Oriented Programming Systems Languages and Applications (OOPSLA)</em>, 2015.", "title": "Scalable race detection for Android applications", "context": [{"sec": "sec8a", "text": "Event race detection algorithms have also been developed for Android, using similar techniques as those targeting JavaScript, but with more sophisticated happens-before relations [5], [9], [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+race+detection+for+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "L. Chew, D. Lie, \"Kivati: fast detection and prevention of atomicity violations\", <em>Proc. 5th European Conference on Computer Systems (EuroSys)</em>, 2010.", "title": "Kivati: fast detection and prevention of atomicity violations", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": " Kivati [6] uses static analysis and hardware watchpoints to detect atomicity violations and then dynamically reorders the relevant instructions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1755913.1755945", "abstract": "Bugs in concurrent programs are extremely difficult to find and fix during testing. In this paper, we propose Kivati, which can efficiently detect and prevent atomicity violation bugs. Kivati imposes an average run-time overhead of 19%, which makes it practical to deploy on software in production environments. The key attribute that allows Kivati to impose this low overhead is its use of hardware watchpoints, which can be found on most commodity processors. Kivati combines watchpoints with a sim...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Kivati%3A+fast+detection+and+prevention+of+atomicity+violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C. Flanagan, S.N. Freund, \"FastTrack: efficient and precise dynamic race detection\", <em>Commun. ACM</em>, vol. 53, no. 11, 2010.", "title": "FastTrack: efficient and precise dynamic race detection", "context": [{"sec": "sec8a", "text": " Inspired by successful techniques developed for multi-threaded programs [7], WebRacer and EventRacer instead use dynamic analysis and a happens-before relation [22], [25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1839676.1839699", "abstract": "Multithreaded programs are notoriously prone to race conditions. Prior work developed precise dynamic race detectors that never report false alarms. However, these checkers employ expensive data structures, such as vector clocks (VCs), that result in significant performance overhead. This paper exploits the insight that the full generality of VCs is not necessary in most cases. That is, we can replace VCs with an adaptive lightweight representation that, for almost all operations of the target p...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=FastTrack%3A+efficient+and+precise+dynamic+race+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "S. Hong, Y. Park, M. Kim, \"Detecting concurrency errors in client-side Java Script web applications\", <em>Proc. 7th IEEE International Conference on Software Testing Verification and Validation (ICST)</em>, 2014.", "title": "Detecting concurrency errors in client-side Java Script web applications", "context": [{"sec": "sec1", "text": " However, as studied in recent work [8], [11], [21], [22], [25], [34], this programming style can cause pernicious nondeterminism errors, which can lead to crashes, lost user data, and malfunctioning user interfaces.", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " This significantly improves precision, however, these tools cannot distinguish harmful from benign races, which has motivated techniques that explore whether races cause observable differences [8], [11], [21].", "part": "1"}], "links": {"documentLink": "/document/6823866", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6823866", "abstract": "As web technologies have evolved, the complexity of dynamic web applications has increased significantly and web applications suffer concurrency errors due to unexpected orders of interactions among web browsers, users, the network, and so forth. In this paper, we present WAVE (Web Applications Virtual Environment), a testing framework to detect concurrency errors in client-side web applications written in JavaScript. WAVE generates various sequences of operations as test cases for a web applica...", "pdfSize": "492KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+concurrency+errors+in+client-side+Java+Script+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "C. Hsiao, C. Pereira, J. Yu, G. Pokam, S. Narayanasamy, P.M. Chen, Z. Kong, J. Flinn, \"Race detection for event-driven mobile applications\", <em>Proc. 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, 2014.", "title": "Race detection for event-driven mobile applications", "context": [{"sec": "sec8a", "text": "Event race detection algorithms have also been developed for Android, using similar techniques as those targeting JavaScript, but with more sophisticated happens-before relations [5], [9], [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+detection+for+event-driven+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "J. Ide, R. Bodik, D. Kimelman, \"Concurrency concerns in rich internet applications\", <em>Proc. Workshop on Exploiting Concurrency Efficiently and Correctly</em>, 2009.", "title": "Concurrency concerns in rich internet applications", "context": [{"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " [10] pointed out that JavaScript programs can have data races despite being single-threaded and non-preemptive.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Concurrency+concerns+in+rich+internet+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "C.S. Jensen, A. M\u00f8ller, V. Raychev, D. Dimitrov, M.T. Vechev, \"Stateless model checking of event-driven applications\", <em>Proc. 30th ACM SIGPLAN International Conference on Object-Oriented Programming Systems Languages and Applications (OOPSLA)</em>, 2015.", "title": "Stateless model checking of event-driven applications", "context": [{"sec": "sec1", "text": " However, as studied in recent work [8], [11], [21], [22], [25], [34], this programming style can cause pernicious nondeterminism errors, which can lead to crashes, lost user data, and malfunctioning user interfaces.", "part": "1"}, {"sec": "sec1", "text": " Further, tools such as R4 [11] can filter away warnings about races that do not affect the external behavior of web applications.", "part": "1"}, {"sec": "sec3", "text": "Recent work has focused on classifying event races as either harmful or harmless [11], [20], [21], [25].", "part": "1"}, {"sec": "sec7a1", "text": "We use existing tools, such as, EventRacer [25] and \\$R^{4}\\$ [11], to identify candidate event races in the web applications of the 20 largest companies from the Fortune 500 list.", "part": "1"}, {"sec": "sec7c", "text": " We have attempted to address this concern by evaluating EventRaceCommander on the websites of the 20 largest companies from the Fortune 500 list, similar to previous work on event race detection [11], [25].", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " This significantly improves precision, however, these tools cannot distinguish harmful from benign races, which has motivated techniques that explore whether races cause observable differences [8], [11], [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Stateless+model+checking+of+event-driven+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "G. Jin, L. Song, W. Zhang, S. Lu, B. Liblit, \"Automated atomicity-violation fixing\", <em>Proc. 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, 2011.", "title": "Automated atomicity-violation fixing", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Some techniques patch the program code by inserting, e.g., locks and wait-signal operations, based on reports from race detectors and static analysis [12]\u2013[16], [29].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1993498.1993544", "abstract": "Fixing software bugs has always been an important and time-consuming process in software development. Fixing concurrency bugs has become especially critical in the multicore era. However, fixing concurrency bugs is challenging, in part due to non-deterministic failures and tricky parallel reasoning. Beyond correctly fixing the original problem in the software, a good patch should also avoid introducing new bugs, degrading performance unnecessarily, or damaging software readability. Existing tool...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+atomicity-violation+fixing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "G. Jin, W. Zhang, D. Deng, \"Automated concurrency-bug fixing\", <em>Proc. 10th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</em>, 2012.", "title": "Automated concurrency-bug fixing", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[13][18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Some techniques patch the program code by inserting, e.g., locks and wait-signal operations, based on reports from race detectors and static analysis [12]\u2013[13][16], [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+concurrency-bug+fixing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "S. Khoshnood, M. Kusano, C. Wang, \"ConcBugAssist: constraint solving for diagnosis and repair of concurrency bugs\", <em>Proc. International Symposium on Software Testing and Analysis (ISSTA)</em>, 2015.", "title": "ConcBugAssist: constraint solving for diagnosis and repair of concurrency bugs", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[14][18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Some techniques patch the program code by inserting, e.g., locks and wait-signal operations, based on reports from race detectors and static analysis [12]\u2013[14][16], [29].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2771783.2771798", "abstract": "Programmers often have to spend a significant amount of time in- specting the software code and execution traces to identify the cause of a bug. For a multithreaded program, debugging is even more challenging due to the subtle interactions between threads and the often astronomical number of interleavings. In this work, we pro- pose a logical constraint based symbolic analysis method to aid in the diagnosis of concurrency bugs and to recommend repairs. Both diagnosis and repair are formulated as...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ConcBugAssist%3A+constraint+solving+for+diagnosis+and+repair+of+concurrency+bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "B. Krena, Z. Letko, R. Tzoref, S. Ur, T. Vojnar, \"Healing data races on-the-fly\", <em>Proc. 5th Workshop on Parallel and Distributed Systems: Testing Analysis and Debugging (PADTAD)</em>, 2007.", "title": "Healing data races on-the-fly", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[15][18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Some techniques patch the program code by inserting, e.g., locks and wait-signal operations, based on reports from race detectors and static analysis [12]\u2013[15][16], [29].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1273647.1273658", "abstract": "Testing of concurrent software is extremely difficult. Despite all the progress in the testing and verification technology, concurrent bugs, the most common of which are deadlocks and races, make it to the field. This paper describes a set of techniques, implemented in a tool called ConTest, allowing concurrent programs to self-heal at run-time. Concurrent bugs have the very desirable property for healing that some of the interleaving produce correct results while in others bugs manifest. Healin...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Healing+data+races+on-the-fly&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "P. Liu, C. Zhang, \"Axis: Automatically fixing atomicity violations through solving control constraints\", <em>Proc. 34th International Conference on Software Engineering (ICSE)</em>, 2012.", "title": "Axis: Automatically fixing atomicity violations through solving control constraints", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[16][18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Some techniques patch the program code by inserting, e.g., locks and wait-signal operations, based on reports from race detectors and static analysis [12]\u2013[16], [29].", "part": "1"}], "links": {"documentLink": "/document/6227184", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227184", "abstract": "Atomicity, a general correctness criterion in concurrency programs, is often violated in real-world applications. The violations are difficult for developers to fix, making automatic bug fixing techniques attractive. The state of the art approach aims at automating the manual fixing process but cannot provide any theoretical reasoning and guarantees. We provide an automatic approach that applies well-studied discrete control theory to guarantee deadlocks are not introduced and maximal preservati...", "pdfSize": "879KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Axis%3A+Automatically+fixing+atomicity+violations+through+solving+control+constraints&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "B. Lucia, L. Ceze, \"Cooperative empirical failure avoidance for multithreaded programs\", <em>Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, 2013.", "title": "Cooperative empirical failure avoidance for multithreaded programs", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[17][18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": " The Aviso system [17] learns schedule constraints from successful and failing executions, and then uses these constraints to guide scheduling, much like our policy mechanism and controller.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2451116.2451121", "abstract": "Concurrency errors in multithreaded programs are difficult to find and fix. We propose Aviso, a system for avoiding schedule-dependent failures. Aviso monitors events during a program&#39;s execution and, when a failure occurs, records a history of events from the failing execution. It uses this history to generate schedule constraints that perturb the order of events in the execution and thereby avoids schedules that lead to failures in future program executions. Aviso leverages scenarios where man...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cooperative+empirical+failure+avoidance+for+multithreaded+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "B. Lucia, J. Devietti, L. Ceze, K. Strauss, \"Atom-Aid: Detecting and surviving atomicity violations\", <em>IEEE Micro</em>, vol. 29, no. 1, 2009.", "title": "Atom-Aid: Detecting and surviving atomicity violations", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Other approaches include rollback-recovery [33], replicated execution with different schedules [27], replication of shared state in critical sections [23], [24], or require special hardware [18], which would not be realistic for JavaScript.", "part": "1"}], "links": {"documentLink": "/document/4796171", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4796171", "abstract": "Hardware can play a significant role in improving reliability of multithreaded software. Recent architectural proposals arbitrarily group consecutive dynamic memory operations into atomic blocks to enforce coarse-grained memory ordering, providing implicit atomicity. The authors of this article observe that implicit atomicity probabilistically hides atomicity violations by reducing the number of interleaving opportunities between memory operations. They propose atom-aid, which creates implicit a...", "pdfSize": "1002KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Atom-Aid%3A+Detecting+and+surviving+atomicity+violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "P. Maiya, A. Kanade, R. Majumdar, \"Race detection for Android applications\", <em>Proc. 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, 2014.", "title": "Race detection for Android applications", "context": [{"sec": "sec8a", "text": "Event race detection algorithms have also been developed for Android, using similar techniques as those targeting JavaScript, but with more sophisticated happens-before relations [5], [9], [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+detection+for+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "E. Mutlu, S. Tasiran, B. Livshits, \"I know it when I see it: Observable races in JavaScript applications\", <em>Proc. Workshop on Dynamic Languages and Applications (Dyla)</em>, 2014.", "title": "I know it when I see it: Observable races in JavaScript applications", "context": [{"sec": "sec3", "text": "Recent work has focused on classifying event races as either harmful or harmless [11], [20], [21], [25].", "part": "1"}, {"sec": "sec7a1", "text": " [20], we focus on observable races that result in errors, such as, uncaught exceptions or visual differences so that we can confirm the effectiveness of our repairs.", "part": "1"}, {"sec": "sec8b", "text": " [20] proposes a notion of \u201cschedule shepherding\u201d for JavaScript, but does not present any mechanism for how to actually do it.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2617548.2617549", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=I+know+it+when+I+see+it%3A+Observable+races+in+JavaScript+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "E. Mutlu, S. Tasiran, B. Livshits, \"Detecting JavaScript races that matter\", <em>Proc. 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, 2015.", "title": "Detecting JavaScript races that matter", "context": [{"sec": "sec1", "text": " However, as studied in recent work [8], [11], [21], [22], [25], [34], this programming style can cause pernicious nondeterminism errors, which can lead to crashes, lost user data, and malfunctioning user interfaces.", "part": "1"}, {"sec": "sec3", "text": "Recent work has focused on classifying event races as either harmful or harmless [11], [20], [21], [25].", "part": "1"}, {"sec": "sec5a4", "text": " Consider the following example, which captures the essence of a race from gazzetta.it [21]:\n\n\n\n.", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " This significantly improves precision, however, these tools cannot distinguish harmful from benign races, which has motivated techniques that explore whether races cause observable differences [8], [11], [21].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786820", "abstract": "As JavaScript has become virtually omnipresent as the language for programming large and complex web applications in the last several years, we have seen an increase in interest in finding data races in client-side JavaScript. While JavaScript execution is single-threaded, there is still enough potential for data races, created largely by the non-determinism of the scheduler. Recently, several academic efforts have explored both static and run-time analysis approaches in an effort to find data r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+JavaScript+races+that+matter&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "B. Petrov, M.T. Vechev, M. Sridharan, J. Dolby, \"Race detection for web applications\", <em>Proc. 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, 2012.", "title": "Race detection for web applications", "context": [{"sec": "sec1", "text": " However, as studied in recent work [8], [11], [21], [22], [25], [34], this programming style can cause pernicious nondeterminism errors, which can lead to crashes, lost user data, and malfunctioning user interfaces.", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " Inspired by successful techniques developed for multi-threaded programs [7], WebRacer and EventRacer instead use dynamic analysis and a happens-before relation [22], [25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254095", "abstract": "Modern web pages are becoming increasingly full-featured, and this additional functionality often requires greater use of asynchrony. Unfortunately, this asynchrony can trigger unexpected concurrency errors, even though web page scripts are executed sequentially. We present the first formulation of a happens-before relation for common web platform features. Developing this relation was a non-trivial task, due to complex feature interactions and browser differences. We also present a logical memo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+detection+for+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "S.K. Rajamani, G. Ramalingam, V.P. Ranganath, K. Vaswani, \"ISOLATOR: dynamically ensuring isolation in concurrent programs\", <em>Proc. 14th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, 2009.", "title": "ISOLATOR: dynamically ensuring isolation in concurrent programs", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Other approaches include rollback-recovery [33], replicated execution with different schedules [27], replication of shared state in critical sections [23], [24], or require special hardware [18], which would not be realistic for JavaScript.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1508244.1508266", "abstract": "In this paper, we focus on concurrent programs that use locks to achieve isolation of data accessed by critical sections of code. We present ISOLATOR, an algorithm that guarantees isolation for well-behaved threads of a program that obey a locking discipline even in the presence of ill-behaved threads that disobey the locking discipline. ISOLATOR uses code instrumentation, data replication, and virtual memory protection to detect isolation violations and delays ill-behaved threads to ensure isol...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ISOLATOR%3A+dynamically+ensuring+isolation+in+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "P. Ratanaworabhan, M. Burtscher, D. Kirovski, B.G. Zorn, R. Nagpal, K. Pattabiraman, \"Efficient runtime detection and toleration of asymmetric races\", <em>IEEE Trans. Computers</em>, vol. 61, no. 4, 2012.", "title": "Efficient runtime detection and toleration of asymmetric races", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Other approaches include rollback-recovery [33], replicated execution with different schedules [27], replication of shared state in critical sections [23], [24], or require special hardware [18], which would not be realistic for JavaScript.", "part": "1"}], "links": {"documentLink": "/document/5719607", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5719607", "abstract": "We introduce ToleRace, a runtime system that allows programs to detect and even tolerate asymmetric data races. Asymmetric races are race conditions where one thread correctly acquires and releases a lock for a shared variable while another thread improperly accesses the same variable. ToleRace provides approximate isolation in the critical sections of lock-based parallel programs by creating a local copy of each shared variable when entering a critical section, operating on the local copies, an...", "pdfSize": "1540KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+runtime+detection+and+toleration+of+asymmetric+races&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "V. Raychev, M.T. Vechev, M. Sridharan, \"Effective race detection for event-driven programs\", <em>Proc. 28th ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applicative (OOPSLA)</em>, 2013.", "title": "Effective race detection for event-driven programs", "context": [{"sec": "sec1", "text": " However, as studied in recent work [8], [11], [21], [22], [25], [34], this programming style can cause pernicious nondeterminism errors, which can lead to crashes, lost user data, and malfunctioning user interfaces.", "part": "1"}, {"sec": "sec1", "text": " For web applications, event race detectors are capable of finding errors in real-world, deployed web applications [25].", "part": "1"}, {"sec": "sec3", "text": " [25].", "part": "1"}, {"sec": "sec3", "text": "Recent work has focused on classifying event races as either harmful or harmless [11], [20], [21], [25].", "part": "1"}, {"sec": "sec5c", "text": "To understand if a repair policy \\$\\mathcal{P}\\$ prevents the bad order of an event race, recall that state-of-the-art dynamic race detectors, such as EventRacer [25], report event races as two operations \\$\\sigma\\$ and \\$\\sigma^{\\prime}\\$ in a trace \\$\\tau\\$ where \\$evt(\\sigma)\\Vert evt(\\sigma^{\\prime})\\$.", "part": "1"}, {"sec": "sec5c", "text": " On the other hand, checking that the race becomes covered [25] gives false confidence.11Intuitively, a race \\$(\\sigma,\\sigma^{\\prime})\\$ is covered by another race \\$(\\delta,\\delta^{\\prime})\\$ if \\$(\\sigma,\\sigma^{\\prime})\\$ is no longer a race when \\$(\\delta,\\delta^{\\prime})\\$ is being treated as synchronization.", "part": "1"}, {"sec": "sec7a1", "text": "We use existing tools, such as, EventRacer [25] and \\$R^{4}\\$ [11], to identify candidate event races in the web applications of the 20 largest companies from the Fortune 500 list.", "part": "1"}, {"sec": "sec7c", "text": " We have attempted to address this concern by evaluating EventRaceCommander on the websites of the 20 largest companies from the Fortune 500 list, similar to previous work on event race detection [11], [25].", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " Inspired by successful techniques developed for multi-threaded programs [7], WebRacer and EventRacer instead use dynamic analysis and a happens-before relation [22], [25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2509136.2509538", "abstract": "Like shared-memory multi-threaded programs, event-driven programs such as client-side web applications are susceptible to data races that are hard to reproduce and debug. Race detection for such programs is hampered by their pervasive use of ad hoc synchronization, which can lead to a prohibitive number of false positives. Race detection also faces a scalability challenge, as a large number of short-running event handlers can quickly overwhelm standard vector-clock-based techniques. This paper p...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+race+detection+for+event-driven+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "G.M. Tchamgoue, K.H. Kim, Y. Jun, \"EventHealer: Bypassing data races in event-driven programs\", <em>Journal of Systems and Software</em>, vol. 118, 2016.", "title": "EventHealer: Bypassing data races in event-driven programs", "context": [{"sec": "sec8b", "text": "EventHealer [26], unlike most of the work mentioned above, considers event-driven programs, but with a different execution model than the one in JavaScript: execution takes place in a main thread, which has lower priority than event handlers, and preemption is possible but can be selectively disabled to protect critical sections.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2016.02.051", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=EventHealer%3A+Bypassing+data+races+in+event-driven+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "K. Veeraraghavan, P.M. Chen, J. Flinn, S. Narayanasamy, \"Detecting and surviving data races using complementary schedules\", <em>Proc. 23rd ACM Symposium on Operating Systems Principles (SOSP)</em>, 2011.", "title": "Detecting and surviving data races using complementary schedules", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Other approaches include rollback-recovery [33], replicated execution with different schedules [27], replication of shared state in critical sections [23], [24], or require special hardware [18], which would not be realistic for JavaScript.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2043556.2043590", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+and+surviving+data+races+using+complementary+schedules&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "W. Wang, Y. Zheng, P. Liu, L. Xu, X. Zhang, P. Eugster, \"ARROW: Automated repair of races on client-side web pages\", <em>Proc. International Symposium on Software Testing and Analysis (ISSTA)</em>, 2016.", "title": "ARROW: Automated repair of races on client-side web pages", "context": [{"sec": "sec1", "text": " [28] have proposed a repair technique for event races in web applications, but it has significant limitations in the types of races it can handle (see Section VIII).", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8b", "text": " [28] is the first to automatically repair races in JavaScript applications.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931052", "abstract": "Modern browsers have a highly concurrent page rendering process in order to be more responsive. However, such a concurrent execution model leads to various race issues. In this paper, we present ARROW, a static technique that can automatically, safely, and cost effectively patch certain race issues on client side pages. It works by statically modeling a web page as a causal graph denoting happens-before relations between page elements, according to the rendering process in browsers. Races are de...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ARROW%3A+Automated+repair+of+races+on+client-side+web+pages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "D. Weeratunge, X. Zhang, S. Jagannathan, \"Accentuating the positive: atomicity inference and enforcement using correct executions\", <em>Proc. 26th ACM SIGPLAN Conference on Object-Oriented Programming Systems Languages and Applications (OOPSLA)</em>, 2011.", "title": "Accentuating the positive: atomicity inference and enforcement using correct executions", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Some techniques patch the program code by inserting, e.g., locks and wait-signal operations, based on reports from race detectors and static analysis [12]\u2013[16], [29].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2048066.2048071", "abstract": "Concurrency bugs are often due to inadequate synchronization that fail to prevent specific (undesirable) thread interleavings. Such errors, often referred to as Heisenbugs, are difficult to detect, prevent, and repair. In this paper, we present a new technique to increase program robustness against Heisenbugs. We profile correct executions from provided test suites to infer fine-grained atomicity properties. Additional deadlock-free locking is injected into the program to guarantee these propert...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Accentuating+the+positive%3A+atomicity+inference+and+enforcement+using+correct+executions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "J. Wu, H. Cui, J. Yang, \"Bypassing races in live applications with execution filters\", <em>Proc. 9th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</em>, 2010.", "title": "Bypassing races in live applications with execution filters", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": " The Loom system [30] uses a notion of execution filters, which resembles our use of application-specific repair policies.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.21236/ADA640252", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bypassing+races+in+live+applications+with+execution+filters&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "Z. Yin, D. Yuan, Y. Zhou, S. Pasupathy, L.N. Bairavasundaram, \"How do fixes become bugs?\", <em>Proc. 13th European Software Engineering Conference and 19th ACM SIGSOFT Symposium on the Foundations of Software Engineering (ESEC/FSE)</em>, 2011.", "title": "How do fixes become bugs?", "context": [{"sec": "sec1", "text": " Manually devising such a fix is often not worth the effort, particularly for minor errors, when considering that fixes sometimes have unforeseen consequences [31].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025121", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+fixes+become+bugs%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "M. Zhang, Y. Wu, S. Lu, S. Qi, J. Ren, W. Zheng, \"AI: a lightweight system for tolerating concurrency bugs\", <em>Proc. 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE)</em>, 2014.", "title": "AI: a lightweight system for tolerating concurrency bugs", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": " The AI technique [32] attempts to stall threads where manifestation of a concurrency bug is about to become deterministic.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635885", "abstract": "Concurrency bugs are notoriously difficult to eradicate during software testing because of their non-deterministic nature. Moreover, fixing concurrency bugs is time-consuming and error-prone. Thus, tolerating concurrency bugs during production runs is an attractive complementary approach to bug detection and testing. Unfortunately, existing bug-tolerating tools are usually either 1) constrained in types of bugs they can handle or 2) requiring roll-back mechanism, which can hitherto not be fully ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AI%3A+a+lightweight+system+for+tolerating+concurrency+bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "W. Zhang, M. de Kruijf, A. Li, S. Lu, K. Sankaralingam, \"ConAir: featherweight concurrency bug recovery via single-threaded idempotent execution\", <em>Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, 2013.", "title": "ConAir: featherweight concurrency bug recovery via single-threaded idempotent execution", "context": [{"sec": "sec1", "text": " There is a wide body of work on repairing races in multi-threaded programs [6], [12]\u2013[18], [23], [24], [27], [29], [30], [32], [33], but relatively little work on repair for event races.", "part": "1"}, {"sec": "sec8b", "text": "Other approaches include rollback-recovery [33], replicated execution with different schedules [27], replication of shared state in critical sections [23], [24], or require special hardware [18], which would not be realistic for JavaScript.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2451116.2451129", "abstract": "Many concurrency bugs are hidden in deployed software and cause severe failures for end-users. When they finally manifest and become known by developers, they are difficult to fix correctly. To support end-users, we need techniques that help software survive hidden concurrency bugs during production runs. To help developers, we need techniques that fix exposed concurrency bugs. The state-of-the-art techniques on concurrency-bug fixing and survival only satisfy a subset of four important properti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ConAir%3A+featherweight+concurrency+bug+recovery+via+single-threaded+idempotent+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "Y. Zheng, T. Bao, X. Zhang, \"Statically locating web application bugs caused by asynchronous calls\", <em>Proc. 20th International Conference on World Wide Web (WWW)</em>, 2011.", "title": "Statically locating web application bugs caused by asynchronous calls", "context": [{"sec": "sec1", "text": " However, as studied in recent work [8], [11], [21], [22], [25], [34], this programming style can cause pernicious nondeterminism errors, which can lead to crashes, lost user data, and malfunctioning user interfaces.", "part": "1"}, {"sec": "sec2", "text": " [34]).", "part": "1"}, {"sec": "sec7c", "text": " Still, this is a significant improvement over recent work [8], [10], [11], [21], [22], [25], [28], [34], where the importance of reproducibility has mostly been ignored.", "part": "1"}, {"sec": "sec8a", "text": " [34] proposed a static analysis for automatically detecting JavaScript races.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1963405.1963517", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Statically+locating+web+application+bugs+caused+by+asynchronous+calls&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985670", "articleId": "7985670", "startPage": "289", "endPage": "299", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 3, "citationCountPatent": 0, "totalDownloads": 226}}
{"title": "Automatically Generating Precise Oracles from Structured Natural Language Specifications", "authors": [{"name": "Manish Motwani", "affiliation": "University of Massachusetts Amherst", "firstName": "Manish", "lastName": "Motwani", "id": "37074894900"}, {"name": "Yuriy Brun", "affiliation": "University of Massachusetts Amherst", "firstName": "Yuriy", "lastName": "Brun", "id": "37267551700"}], "abstract": "Software specifications often use natural language to describe the desired behavior, but such specifications are difficult to verify automatically. We present Swami, an automated technique that extracts test oracles and generates executable tests from structured natural language specifications. Swami focuses on exceptional behavior and boundary conditions that often cause field failures but that developers often fail to manually write tests for. Evaluated on the official JavaScript specification (ECMA-262), 98.4% of the tests Swami generated were precise to the specification. Using Swami to augment developer-written test suites improved coverage and identified 1 previously unknown defect and 15 missing JavaScript features in Rhino, 1 previously unknown defect in Node.js, and 18 semantic ambiguities in the ECMA-262 specification.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Natural languages", "Documentation", "Lenses", "Software", "Boundary conditions", "Semantics", "Prototypes"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["formal specification", "Java", "natural language processing", "program testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["structured natural language specifications", "developer-written test suites", "ECMA-262 specification", "software specifications", "test oracles", "Swami technique", "JavaScript features", "JavaScript specification"]}, {"type": "Author Keywords ", "kwd": ["oracle", "test oracle", "test generation", "natural language specification"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00035", "ref": [{"order": "1", "text": "<em>American fuzzy lop</em>, 2018,  [online]  Available: http://lcamtuf.coredump.cx/afl/.", "title": "American fuzzy lop", "context": [{"sec": "sec5", "text": "Automated test generation (e.g., EvoSuite [20] and Ran-doop [50]) and test fuzzing (e.g., afl [1]) generate test inputs.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=American+fuzzy+lop&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "Paul Ammann, Jeff Offutt, Introduction to Software Testing, Cambridge University Press, 2008.", "title": "Introduction to Software Testing", "context": [{"sec": "sec1", "text": "Of particular interest is generating tests for exceptional behavior and boundary conditions because, while developers spend significant time writing tests manually [2], [55], they often fail to write tests for such behavior.", "part": "1"}, {"sec": "sec1", "text": " For example, Developers often focus on the common behavior when writing tests and forget to account for exceptional or boundary cases [2].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1017/CBO9780511809163", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introduction+to+Software+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "Rico Angell, Brittany Johnson, Yuriy Brun, Alexandra Meliou, \"Themis: Automatically testing software for discrimination\", <em>ESEC/FSE Demo</em>, pp. 871-875, 2018.", "title": "Themis: Automatically testing software for discrimination", "context": [{"sec": "sec5", "text": " Work on generating tests for non-functional properties, such as software fairness, relies on oracles inferred by observing system behavior, e.g., by asserting that the behavior on inputs differing in a controlled way should be sufficiently similar [22], [11], [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3264590", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Themis%3A+Automatically+testing+software+for+discrimination&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>European Computer Manufacturer's Association. ECMA standards</em>, 2018,  [online]  Available: https://ecma-international.org/publications/standards/Standard.htm.", "title": "European Computer Manufacturer's Association. ECMA standards", "context": [{"sec": "sec4e", "text": " First, our evaluation uses ECMA-based specifications which has been used to specify hundreds of systems [4], from software systems, to programming languages, to Windows APIs, to data communication protocols, to telecommunication networks, to data storage formats, to wireless proximity systems, and so on.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=European+Computer+Manufacturer%27s+Association.+ECMA+standards&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "Beschastnikh Ivan, Brun Yuriy, Abrahamson Jenny, Michael D. Ernst, Arvind Krishnamurthy, \"Using declarative specification to improve the understanding extensibility and comparison of model-inference algorithms\", <em>IEEE TSE</em>, vol. 41, no. 4, pp. 408-428, April 2015.", "title": "Using declarative specification to improve the understanding, extensibility, and comparison of model-inference algorithms", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+declarative+specification+to+improve+the+understanding%2C+extensibility%2C+and+comparison+of+model-inference+algorithms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "Beschastnikh Ivan, Brun Yuriy, Michael D. Ernst, Arvind Krishnamurthy, \"Inferring models of concurrent systems from logs of their behavior with CSight\", <em>ICSE</em>, pp. 468-479, 2014.", "title": "Inferring models of concurrent systems from logs of their behavior with CSight", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[6][7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inferring+models+of+concurrent+systems+from+logs+of+their+behavior+with+CSight&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "Ivan Beschastnikh, Yuriy Brun, Sigurd Schneider, Michael Sloan, Michael D. Ernst, \"Leveraging existing instrumentation to automatically infer invariant-constrained models\", <em>ESEC/FSE</em>, pp. 267-277, 2011.", "title": "Leveraging existing instrumentation to automatically infer invariant-constrained models", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025151", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Leveraging+existing+instrumentation+to+automatically+infer+invariant-constrained+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "Blasi Arianna, Goffi Alberto, Kuznetsov Konstantin, Gorla Alessandra, Michael D. Ernst, Mauro Pezz\u00e8, Sergio Delgado Castellanos, \"Translating code comments to procedure specifications\", <em>ISSTA</em>, pp. 242-253, 2018.", "title": "Translating code comments to procedure specifications", "context": [{"sec": "sec1", "text": " The closest work to ours is Toradacu [24] and Jdoctor [8], which focus on extracting oracles for exceptional behavior, and @tComment [65], which focuses on extracting preconditions related to nullness of parameters.", "part": "1"}, {"sec": "sec1", "text": " Finally, prior test generation work [8], [20], [24], [50] requires access to the source code to be tested, whereas Swami can generate black-box tests entirely from the specification document, without needing the source code.", "part": "1"}, {"sec": "sec4c", "text": " This finding is consistent with prior studies of automated test generation of exceptional behavior [8].", "part": "1"}, {"sec": "sec4c", "text": "The tools most similar to Swami, Toradacu [24] and Jdoctor [8], are difficult to compare to directly because they work on Javadoc specifications and cannot generalize to the more complex natural language specifications Swami can handle.", "part": "1"}, {"sec": "sec4c", "text": " Meanwhile, on six Java libraries, Jdoctor eliminated only 3 of Randoop's false alarms out of 43,791 tests (but did generate 15 more tests and correct 20 tests' oracles) [8].", "part": "1"}, {"sec": "sec5", "text": " Toradacu [24] and Jdoctor [8] do this for exceptional behavior, and @tComment [65] for null pointers.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Translating+code+comments+to+procedure+specifications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "Chandrasekhar Boyapati, Sarfraz Khurshid, Darko Marinov, \"Korat: Automated testing based on Java predicates\", <em>ISSTA</em>, pp. 123-133, 2002.", "title": "Korat: Automated testing based on Java predicates", "context": [{"sec": "sec5", "text": " Korat uses formal specifications of pre- and post-conditions (e.g., written by the developer or inferred by invariant mining) to generate oracles and tests [9].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/566189.566191", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Korat%3A+Automated+testing+based+on+Java+predicates&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "Chad Brubaker, Suman Jana, Baishakhi Ray, Sarfraz Khurshid, Vitaly Shmatikov, \"Using frankencerts for automated adversarial testing of certificate validation in SSL/TLS implementations\", <em>S&P</em>, pp. 114-129, 2014.", "title": "Using frankencerts for automated adversarial testing of certificate validation in SSL/TLS implementations", "context": [{"sec": "sec5", "text": " Differential testing can also produce oracles by comparing behavior of multiple implementations of the same specification [10], [12], [19], [59], [63], [78] (e.g., comparing the behavior of Node.js to that of Rhino), but requires multiple implementations, whereas Swami requires none.", "part": "1"}], "links": {"documentLink": "/document/6956560", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6956560", "abstract": "Modern network security rests on the Secure Sockets Layer (SSL) and Transport Layer Security (TLS) protocols. Distributed systems, mobile and desktop applications, embedded devices, and all of secure Web rely on SSL/TLS for protection against network attacks. This protection critically depends on whether SSL/TLS clients correctly validate X.509 certificates presented by servers during the SSL/TLS handshake protocol. We design, implement, and apply the first methodology for large-scale testing of...", "pdfSize": "664KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+frankencerts+for+automated+adversarial+testing+of+certificate+validation+in+SSL%2FTLS+implementations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "Yuriy Brun, Alexandra Meliou, \"Software fairness\", <em>ESEC/FSE New Ideas and Emerging Results</em>, pp. 754-759, 2018.", "title": "Software fairness", "context": [{"sec": "sec5", "text": " Work on generating tests for non-functional properties, such as software fairness, relies on oracles inferred by observing system behavior, e.g., by asserting that the behavior on inputs differing in a controlled way should be sufficiently similar [22], [11], [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3264838", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+fairness&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "Yuting Chen, Zhendong Su, \"Guided differential testing of certificate validation in SSL/TLS implementations\", <em>ESEC/FSE</em>, pp. 793-804, 2015.", "title": "Guided differential testing of certificate validation in SSL/TLS implementations", "context": [{"sec": "sec5", "text": " Differential testing can also produce oracles by comparing behavior of multiple implementations of the same specification [10], [12], [19], [59], [63], [78] (e.g., comparing the behavior of Node.js to that of Rhino), but requires multiple implementations, whereas Swami requires none.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786835", "abstract": "Certificate validation in SSL/TLS implementations is critical for Internet security. There is recent strong effort, namely frankencert, in automatically synthesizing certificates for stress-testing certificate validation. Despite its early promise, it remains a significant challenge to generate effective test certificates as they are structurally complex with intricate syntactic and semantic constraints. This paper tackles this challenge by introducing mucert, a novel, guided technique to much m...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guided+differential+testing+of+certificate+validation+in+SSL%2FTLS+implementations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "Flaviu Cristian, \"Exception handling\", <em>Technical Report RJ5724 IBM Research</em>, 1987.", "title": "Exception handling", "context": [{"sec": "sec1", "text": " An IBM study found that up to two thirds of production code may be devoted to exceptional behavior handling [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exception+handling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "Valentin Dallmeier, Nikolai Knopp, Christoph Mallon, Sebastian Hack, Andreas Zeller, \"Generating test cases for specification mining\", <em>ISSTA</em>, pp. 85-96, 2010.", "title": "Generating test cases for specification mining", "context": [{"sec": "sec5", "text": " TAUTOKO uses such specifications to generate tests, e.g., of sequences of method invokations on a data structure [14], then iteratively improving the inferred model [14], [68].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1831708.1831719", "abstract": "Dynamic specification mining observes program executions to infer models of normal program behavior. What makes us believe that we have seen sufficiently many executions? The typestate miner generates test cases that cover previously unobserved behavior, systematically extending the execution space and enriching the specification. To our knowledge, this is the first combination of systematic test case generation and typestate mining--a combination with clear benefits: On a sample of 800 defects ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generating+test+cases+for+specification+mining&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Bogdan Dit, Meghan Revelle, Malcom Gethers, Denys Poshyvanyk, \"Feature location in source code: A taxonomy and survey\", <em>Journal of Software: Evolution and Process</em>, vol. 25, no. 1, pp. 53-95, 2013.", "title": "Feature location in source code: A taxonomy and survey", "context": [{"sec": "sec5", "text": "Requirements tracing maps specifications, bug reports, and other artifacts to code elements [15], [26], [77], which is related to Swami's Section Identification using the Okapi model [57], [64].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/smr.567", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+location+in+source+code%3A+A+taxonomy+and+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "Marc Eaddy, <em>Concern tagger case study data mapping the Rhino source code to the ECMA-262 specification)</em>, 2007,  [online]  Available: http://www.cs.columbia.edu/~eaddy/concerntagger/.", "title": "Concern tagger case study data mapping the Rhino source code to the ECMA-262 specification)", "context": [{"sec": "sec4d", "text": " [16] have constructed a ground-truth benchmark by manually mapping parts of the Rhino source code (v1.5R6) to the relevant concerns from ECMA-262 (v3).", "part": "1"}, {"sec": "sec4e", "text": "Our evaluation of the Okapi-model-based approach and our choice of similarity score threshold rely on a manually-created ground truth benchmark [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Concern+tagger+case+study+data+mapping+the+Rhino+source+code+to+the+ECMA-262+specification%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Marc Eaddy, Alfred V. Aho, Giuliano Antoniol, Yann-Ga\u00ebl Gu\u00e8h\u00e9neuc, \"Cerberus: Tracing requirements to source code using information retrieval dynamic analysis and program analysis\", <em>ICPC</em>, pp. 53-62, 2008.", "title": "Cerberus: Tracing requirements to source code using information retrieval, dynamic analysis, and program analysis", "context": [{"sec": "sec3b", "text": " We selected this threshold by computing the similarity scores of a small subset (196 sections) of ECMA-262, selecting the minimum similarity score of the relevant specifications (where relevant is defined by the ground-truth [17], described in Section IV-D).", "part": "1"}, {"sec": "sec4d", "text": " Research on information retrieval in software engineering uses this benchmark extensively [17], [25].", "part": "1"}, {"sec": "sec4e", "text": " We mitigate this threat by using a well-established benchmark from prior studies [17], [25], [26].", "part": "1"}, {"sec": "sec5", "text": "Dynamic analysis can also aid tracing, e.g., in the way Cerberus uses execution tracing and dependency pruning analysis [17].", "part": "1"}], "links": {"documentLink": "/document/4556117", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4556117", "abstract": "The concern location problem is to identify the source code within a program related to the features, requirements, or other concerns of the program. This problem is central to program development and maintenance. We present a new technique called prune dependency analysis that can be combined with existing techniques to dramatically improve the accuracy of concern location. We developed CERBERUS, a potent hybrid technique for concern location that combines information retrieval, execution traci...", "pdfSize": "832KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cerberus%3A+Tracing+requirements+to+source+code+using+information+retrieval%2C+dynamic+analysis%2C+and+program+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Michael D. Ernst, Jake Cockrell, William G. Griswold, David Notkin, \"Dynamically discovering likely program invariants to support program evolution\", <em>IEEE TSE</em>, vol. 27, no. 2, pp. 99-123, 2001.", "title": "Dynamically discovering likely program invariants to support program evolution", "context": [{"sec": "sec5", "text": "Dynamic invariant mining, e.g., Daikon [18], can infer oracles from test executions by observing arguments' values method return values [48].", "part": "1"}], "links": {"documentLink": "/document/908957", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=908957", "abstract": "Explicitly stated program invariants can help programmers by identifying program properties that must be preserved when modifying code. In practice, however, these invariants are usually implicit. An alternative to expecting programmers to fully annotate code with invariants is to automatically infer likely invariants from the program itself. This research focuses on dynamic techniques for discovering invariants from execution traces. This article reports three results. First, it describes techn...", "pdfSize": "769KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamically+discovering+likely+program+invariants+to+support+program+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "Robert B. Evans, Alberto Savoia, \"Differential testing: A new approach to change detection\", <em>ESEC/FSE Poster</em>, pp. 549-552, 2007.", "title": "Differential testing: A new approach to change detection", "context": [{"sec": "sec5", "text": " Differential testing can also produce oracles by comparing behavior of multiple implementations of the same specification [10], [12], [19], [59], [63], [78] (e.g., comparing the behavior of Node.js to that of Rhino), but requires multiple implementations, whereas Swami requires none.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Differential+testing%3A+A+new+approach+to+change+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Gordon Fraser, Andrea Arcuri, \"Whole test suite generation\", <em>IEEE TSE</em>, vol. 39, no. 2, pp. 276-291, February 2013.", "title": "Whole test suite generation", "context": [{"sec": "sec1", "text": " This paper focuses on generating oracles from such structured natural language specifications. (Test inputs can often be effectively generated randomly [20], [50], and together with the oracles, produce executable tests.).", "part": "1"}, {"sec": "sec1", "text": "Our research complements prior work on automatically generating test inputs for regression tests or manually-written oracles, such as EvoSuite [20] and Randoop [50], by automatically extracting oracles from natural language specifications.", "part": "1"}, {"sec": "sec1", "text": " Finally, prior test generation work [8], [20], [24], [50] requires access to the source code to be tested, whereas Swami can generate black-box tests entirely from the specification document, without needing the source code.", "part": "1"}, {"sec": "sec4c", "text": "Random test generation tools, such as EvoSuite [20] and Randoop [50], can generate tests in two ways: using explicit assertions in the code (typically written manually), or as regression tests, ensuring the tested behavior doesn't change as the software evolves.", "part": "1"}, {"sec": "sec5", "text": "Automated test generation (e.g., EvoSuite [20] and Ran-doop [50]) and test fuzzing (e.g., afl [1]) generate test inputs.", "part": "1"}, {"sec": "sec5", "text": " They require manually-specified oracles or oracles manually encoded in the code (e.g., assertions), or generate regression tests [20].", "part": "1"}], "links": {"documentLink": "/document/6152257", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6152257", "abstract": "Not all bugs lead to program crashes, and not always is there a formal specification to check the correctness of a software test&#39;s outcome. A common scenario in software testing is therefore that test data are generated, and a tester manually adds test oracles. As this is a difficult task, it is important to produce small yet representative test sets, and this representativeness is typically measured using code coverage. There is, however, a fundamental problem with the common approach of target...", "pdfSize": "1237KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Whole+test+suite+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Cibele Freire, Wolfgang Gatterbauer, Neil Immerman, Alexandra Meliou, \"A characterization of the complexity of resilience and responsibility for self-join-free conjunctive queries\", <em>Proceedings of the VLDB Endowment (PVLDB)</em>, vol. 9, no. 3, pp. 180-191, 2015.", "title": "A characterization of the complexity of resilience and responsibility for self-join-free conjunctive queries", "context": [{"sec": "sec5", "text": " Meanwhile, assertions on system data can also act as oracles [46], [47], and inferred causal relationships in data management systems [21], [42], [43] can help explain query results and suggest oracles for systems that rely on data management systems [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+characterization+of+the+complexity+of+resilience+and+responsibility+for+self-join-free+conjunctive+queries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Sainyam Galhotra, Yuriy Brun, Alexandra Meliou, \"Fairness testing: Testing software for discrimination\", <em>ESEC/FSE</em>, pp. 498-510, 2017.", "title": "Fairness testing: Testing software for discrimination", "context": [{"sec": "sec5", "text": " Work on generating tests for non-functional properties, such as software fairness, relies on oracles inferred by observing system behavior, e.g., by asserting that the behavior on inputs differing in a controlled way should be sufficiently similar [22], [11], [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106277", "abstract": "This paper defines software fairness and discrimination and develops a testing-based method for measuring if and how much software discriminates, focusing on causality in discriminatory behavior. Evidence of software discrimination has been found in modern software systems that recommend criminal sentences, grant access to financial products, and determine who is allowed to participate in promotions. Our approach, Themis, generates efficient test suites to measure discrimination. Given a schema ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fairness+testing%3A+Testing+software+for+discrimination&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "Carlo Ghezzi, Mauro Pezz\u00e8, Michele Sama, Giordano Tamburrelli, \"Mining behavior models from user-intensive web applications\", <em>ICSE</em>, pp. 277-287, 2014.", "title": "Mining behavior models from user-intensive web applications", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568234", "abstract": "Many modern user-intensive applications, such as Web applications, must satisfy the interaction requirements of thousands if not millions of users, which can be hardly fully understood at design time. Designing applications that meet user behaviors, by efficiently supporting the prevalent navigation patterns, and evolving with them requires new approaches that go beyond classic software engineering solutions. We present a novel approach that automates the acquisition of user-interaction requirem...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+behavior+models+from+user-intensive+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "Alberto Goffi, Alessandra Gorla, Michael D. Ernst, Mauro Pezz\u00e8, \"Automatic generation of oracles for exceptional behaviors\", <em>ISSTA</em>, pp. 213-224, 2016.", "title": "Automatic generation of oracles for exceptional behaviors", "context": [{"sec": "sec1", "text": " In a study of ten popular, well-tested, open-source projects, the coverage of exception handling statements lagged significantly behind overall statement coverage [24].", "part": "1"}, {"sec": "sec1", "text": " We scope our work by focusing on exceptional and boundary behavior, precisely the important-in-the-field behavior developers often undertest [24], [73].", "part": "1"}, {"sec": "sec1", "text": " The closest work to ours is Toradacu [24] and Jdoctor [8], which focus on extracting oracles for exceptional behavior, and @tComment [65], which focuses on extracting preconditions related to nullness of parameters.", "part": "1"}, {"sec": "sec1", "text": " Finally, prior test generation work [8], [20], [24], [50] requires access to the source code to be tested, whereas Swami can generate black-box tests entirely from the specification document, without needing the source code.", "part": "1"}, {"sec": "sec2c", "text": " We have found empirically that generating such inputs for all arguments tests parts of the code uncovered by developer written tests, which is consistent with prior studies [24].", "part": "1"}, {"sec": "sec4c", "text": "The tools most similar to Swami, Toradacu [24] and Jdoctor [8], are difficult to compare to directly because they work on Javadoc specifications and cannot generalize to the more complex natural language specifications Swami can handle.", "part": "1"}, {"sec": "sec4c", "text": " On nine classes from Google Guava, Toradocu reduced EvoSuite's false alarm rate by 11%: out of 290 tests, the false alarms went from 97 (33%) to 65 (22%) [24].", "part": "1"}, {"sec": "sec5", "text": " Toradacu [24] and Jdoctor [8] do this for exceptional behavior, and @tComment [65] for null pointers.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+generation+of+oracles+for+exceptional+behaviors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "Emily Hill, \"Developing natural language-based program analyses and tools to expedite software maintenance\", <em>ICSE Doctoral Symposium</em>, pp. 1015-1018, 2008.", "title": "Developing natural language-based program analyses and tools to expedite software maintenance", "context": [{"sec": "sec4d", "text": " Research on information retrieval in software engineering uses this benchmark extensively [17], [25].", "part": "1"}, {"sec": "sec4e", "text": " We mitigate this threat by using a well-established benchmark from prior studies [17], [25], [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1370175.1370226", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Developing+natural+language-based+program+analyses+and+tools+to+expedite+software+maintenance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "Emily Hill, Shivani Rao, Avinash Kak, \"On the use of stemming for concern location and bug localization in Java\", <em>SCAM</em>, pp. 184-193, 2012.", "title": "On the use of stemming for concern location and bug localization in Java", "context": [{"sec": "sec4e", "text": " We mitigate this threat by using a well-established benchmark from prior studies [17], [25], [26].", "part": "1"}, {"sec": "sec5", "text": "Requirements tracing maps specifications, bug reports, and other artifacts to code elements [15], [26], [77], which is related to Swami's Section Identification using the Okapi model [57], [64].", "part": "1"}], "links": {"documentLink": "/document/6392117", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6392117", "abstract": "As the popularity of text-based source code search and analysis grows, the use of stemmers to strip suffixes has increased. Although widely investigated in the information retrieval community, the comparative effectiveness of stemmers in the domain of software is relatively unknown. In this paper, we investigate which of the well-known stemmers perform best in the domain of Java software for concern location and bug localization. For these two problems, we evaluate the use of stemming on over 50...", "pdfSize": "222KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+use+of+stemming+for+concern+location+and+bug+localization+in+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "Daniel Jurafsky, James H. Martin, Speech and Language Processing, Pearson Education, Inc., 2009.", "title": "Speech and Language Processing", "context": [{"sec": "sec3a", "text": "Swami uses standard natural language processing [27] to convert the specification into more parsable format.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Speech+and+Language+Processing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "Yalin Ke, Kathryn T. Stolee, Claire Le Goues, Yuriy Brun, \"Repairing programs with semantic code search\", <em>ASE</em>, pp. 295-306, 2015.", "title": "Repairing programs with semantic code search", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"documentLink": "/document/7372019", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372019", "abstract": "Automated program repair can potentially reduce debugging costs and improve software quality but recent studies have drawn attention to shortcomings in the quality of automatically generated repairs. We propose a new kind of repair that uses the large body of existing open-source code to find potential fixes. The key challenges lie in efficiently finding code semantically similar (but not identical) to defective code and then appropriately integrating that code into a buggy program. We present S...", "pdfSize": "1340KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Repairing+programs+with+semantic+code+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Ivo Krka, Yuriy Brun, George Edwards, Nenad Medvidovic, \"Synthesizing partial component-level behavior models from system specifications\", <em>ESEC/FSE</em>, pp. 305-314, 2009.", "title": "Synthesizing partial component-level behavior models from system specifications", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1595696.1595756", "abstract": "Initial system specifications, such as use-case scenarios and properties, only partially specify the future system. We posit that synthesizing partial component-level behavior models from these early specifications can improve software development practices. In this paper, we provide a novel algorithm for deriving a Modal Transition System (MTS) for individual system components from system-level scenario and property specifications. The generated MTSs capture the possible component implementatio...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Synthesizing+partial+component-level+behavior+models+from+system+specifications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "Tien-Duy B. Le, Xuan-Bach D. Le, David Lo, Ivan Beschastnikh, \"Synergizing specification miners through model fissions and fusions\", <em>ASE</em>, 2015.", "title": "Synergizing specification miners through model fissions and fusions", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"documentLink": "/document/7372001", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372001", "abstract": "Software systems are often developed and released without formal specifications. For those systems that are formally specified, developers have to continuously maintain and update the specifications or have them fall out of date. To deal with the absence of formal specifications, researchers have proposed techniques to infer the missing specifications of an implementation in a variety of forms, such as finite state automaton (FSA). Despite the progress in this area, the efficacy of the proposed ...", "pdfSize": "260KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Synergizing+specification+miners+through+model+fissions+and+fusions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "Tien-Duy B. Le, David Lo, \"Beyond support and confidence: Exploring interestingness measures for rule-based specification mining\", <em>SANER</em>, 2015.", "title": "Beyond support and confidence: Exploring interestingness measures for rule-based specification mining", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"documentLink": "/document/7081843", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7081843", "abstract": "Numerous rule-based specification mining approaches have been proposed in the literature. Many of these approaches analyze a set of execution traces to discover interesting usage rules, e.g., whenever lock() is invoked, eventually unlock() is invoked. These techniques often generate and enumerate a set of candidate rules and compute some interestingness scores. Rules whose interestingness scores are above a certain threshold would then be output. In past studies, two measures, namely support and...", "pdfSize": "517KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Beyond+support+and+confidence%3A+Exploring+interestingness+measures+for+rule-based+specification+mining&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "Owolabi Legunsen, Wajih Ul Hassan, Xinyue Xu, Grigore Rosu, Darko Marinov, \"How good are the specs? A study of the bug-finding effectiveness of existing Java API specifications\", <em>ASE</em>, pp. 602-613, 2016.", "title": "How good are the specs? A study of the bug-finding effectiveness of existing Java API specifications", "context": [{"sec": "sec5", "text": " Meanwhile, instead of generating tests, runtime verification of Java API specifications can discover bugs, but with high false-alarm rates [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970356", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+good+are+the+specs%3F+A+study+of+the+bug-finding+effectiveness+of+existing+Java+API+specifications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "David Lo, Siau-Cheng Khoo, \"QUARK: Empirical assessment of automaton-based specification miners\", <em>WCRE</em>, 2006.", "title": "QUARK: Empirical assessment of automaton-based specification miners", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"documentLink": "/document/4023976", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4023976", "abstract": "Software is often built without specification. Tools to automatically extract specification from software are needed and many techniques have been proposed. One type of these specifications - temporal API specification - is often specified in the form of automaton. There has been much work on reverse engineering or mining software temporal specification, using dynamic analysis techniques; i.e., analysis of software program traces. Unfortunately, the issues of scalability, robustness and accuracy...", "pdfSize": "333KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=QUARK%3A+Empirical+assessment+of+automaton-based+specification+miners&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "David Lo, Siau-Cheng Khoo, \"SMArTIC: Towards building an accurate robust and scalable specification miner\", <em>FSE</em>, pp. 265-275, 2006.", "title": "SMArTIC: Towards building an accurate, robust and scalable specification miner", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[34][36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1181775.1181808", "abstract": "Improper management of software evolution, compounded by imprecise, and changing requirements, along with the &#34;short time to market&#34; requirement, commonly leads to a lack of up-to-date specifications. This can result in software that is characterized by bugs, anomalies and even security threats. Software specification mining is a new technique to address this concern by inferring specifications automatically. In this paper, we propose a novel API specification mining architecture called SMArTIC ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SMArTIC%3A+Towards+building+an+accurate%2C+robust+and+scalable+specification+miner&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "David Lo, Shahar Maoz, \"Scenario-based and value-based specification mining: Better together\", <em>ASE</em>, pp. 387-396, 2010.", "title": "Scenario-based and value-based specification mining: Better together", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[35][36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1858996.1859081", "abstract": "Specification mining takes execution traces as input and extracts likely program invariants, which can be used for comprehension, verification, and evolution related tasks. In this work we integrate scenario-based specification mining, which uses data-mining algorithms to suggest ordering constraints in the form of live sequence charts, an inter-object, visual, modal, scenario-based specification language, with mining of value-based invariants, which detects likely invariants holding at specific...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scenario-based+and+value-based+specification+mining%3A+Better+together&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "David Lo, Leonardo Mariani, Mauro Pezz\u00e8, \"Automatic steering of behavioral model inference\", <em>ESEC/FSE</em>, pp. 345-354, 2009.", "title": "Automatic steering of behavioral model inference", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1595696.1595761", "abstract": "Many testing and analysis techniques use finite state models to validate and verify the quality of software systems. Since the specification of such models is complex and time-consuming, researchers defined several techniques to extract finite state models from code and traces. Automatically generating models requires much less effort than designing them, and thus eases the verification and validation of large software systems. However, when models are inferred automatically, the precision of th...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+steering+of+behavioral+model+inference&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "Fan Long, Martin Rinard, \"Staged program repair with condition synthesis\", <em>ESEC/FSE</em>, pp. 166-178, 2015.", "title": "Staged program repair with condition synthesis", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786811", "abstract": "We present SPR, a new program repair system that combines staged program repair and condition synthesis. These techniques enable SPR to work productively with a set of parameterized transformation schemas to generate and efficiently search a rich space of program repairs. Together these techniques enable SPR to generate correct repairs for over five times as many defects as previous systems evaluated on the same benchmark set.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Staged+program+repair+with+condition+synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "Fan Long, Martin Rinard, \"Automatic patch generation by learning correct code\", <em>POPL</em>, pp. 298-312, 2016.", "title": "Automatic patch generation by learning correct code", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2837614.2837617", "abstract": "We present Prophet, a novel patch generation system that works with a set of successful human patches obtained from open- source software repositories to learn a probabilistic, application-independent model of correct code. It generates a space of candidate patches, uses the model to rank the candidate patches in order of likely correctness, and validates the ranked patches against a suite of test cases to find correct patches. Experimental results show that, on a benchmark set of 69 real-world ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+patch+generation+by+learning+correct+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "Christopher D. Manning, Mihai Surdeanu, John Bauer, Jenny Finkel, Steven J. Bethard, David McClosky, \"The Stanford CoreNLP natural language processing toolkit\", <em>ACL</em>, pp. 55-60, 2014.", "title": "The Stanford CoreNLP natural language processing toolkit", "context": [{"sec": "sec3a", "text": " Swami then tags the parts of speech using the Standford coreNLP toolkit [39].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3115/v1/P14-5010", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Stanford+CoreNLP+natural+language+processing+toolkit&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "Sergey Mechtaev, Jooyong Yi, Abhik Roychoudhury, \"DirectFix: Looking for simple program repairs\", <em>ICSE</em>, pp. 448-458, 2015.", "title": "DirectFix: Looking for simple program repairs", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"documentLink": "/document/7194596", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194596", "abstract": "Recent advances in program repair techniques have raised the possibility of patching bugs automatically. For an automatically generated patch to be accepted by developers, it should not only resolve the bug but also satisfy certain human-related factors including readability and comprehensibility. In this paper, we focus on the simplicity of patches (the size of changes). We present a novel semantics-based repair method that generates the simplest patch such that the program structure of the bug...", "pdfSize": "746KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DirectFix%3A+Looking+for+simple+program+repairs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "Sergey Mechtaev, Jooyong Yi, Abhik Roychoudhury, \"Angelix: Scalable multiline program patch synthesis via symbolic analysis\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 691-701, May 2016.", "title": "Angelix: Scalable multiline program patch synthesis via symbolic analysis", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884807", "abstract": "Since debugging is a time-consuming activity, automated program repair tools such as GenProg have garnered interest. A recent study revealed that the majority of GenProg repairs avoid bugs simply by deleting functionality. We found that SPR, a state-of-the-art repair tool proposed in 2015, still deletes functionality in their many &#34;plausible&#34; repairs. Unlike generate-and-validate systems such as GenProg and SPR, semantic analysis based repair techniques synthesize a repair based on semantic info...", "pdfSize": "471KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Angelix%3A+Scalable+multiline+program+patch+synthesis+via+symbolic+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Alexandra Meliou, Wolfgang Gatterbauer, Joseph Y. Halpern, Christoph Koch, Katherine F. Moore, Dan Suciu, \"Causality in databases\", <em>IEEE Data Engineering Bulletin</em>, vol. 33, no. 3, pp. 59-67, 2010.", "title": "Causality in databases", "context": [{"sec": "sec5", "text": " Meanwhile, assertions on system data can also act as oracles [46], [47], and inferred causal relationships in data management systems [21], [42], [43] can help explain query results and suggest oracles for systems that rely on data management systems [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Causality+in+databases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "Alexandra Meliou, Wolfgang Gatterbauer, Katherine F. Moore, Dan Suciu, \"The complexity of causality and responsibility for query answers and non-answers\", <em>Proceedings of the VLDB Endowment (PVLDB)</em>, vol. 4, no. 1, pp. 34-45, 2010.", "title": "The complexity of causality and responsibility for query answers and non-answers", "context": [{"sec": "sec5", "text": " Meanwhile, assertions on system data can also act as oracles [46], [47], and inferred causal relationships in data management systems [21], [42], [43] can help explain query results and suggest oracles for systems that rely on data management systems [45].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14778/1880172.1880176", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+complexity+of+causality+and+responsibility+for+query+answers+and+non-answers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "Alexandra Meliou, Wolfgang Gatterbauer, Dan Suciu, \"Bringing provenance to its full potential using causal reasoning\", <em>USENIX Workshop on the Theory and Practice of Provenance (TaPP)</em>, 2011.", "title": "Bringing provenance to its full potential using causal reasoning", "context": [{"sec": "sec5", "text": " Such inference can also help debug errors [70]\u2013[72] by tracking and using data provenance [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bringing+provenance+to+its+full+potential+using+causal+reasoning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "Alexandra Meliou, Sudeepa Roy, Dan Suciu, \"Causality and explanations in databases\", <em>Proceedings of the VLDB Endowment (PVLDB) tutorial</em>, vol. 7, no. 13, pp. 1715-1716, 2014.", "title": "Causality and explanations in databases", "context": [{"sec": "sec5", "text": " Meanwhile, assertions on system data can also act as oracles [46], [47], and inferred causal relationships in data management systems [21], [42], [43] can help explain query results and suggest oracles for systems that rely on data management systems [45].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14778/2733004.2733070", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Causality+and+explanations+in+databases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "Kivan\u00e7 Mu\u015flu, Yuriy Brun, Alexandra Meliou, \"Data debugging with continuous testing\", <em>ESEC/FSE New Ideas</em>, pp. 631-634, 2013.", "title": "Data debugging with continuous testing", "context": [{"sec": "sec5", "text": " Meanwhile, assertions on system data can also act as oracles [46], [47], and inferred causal relationships in data management systems [21], [42], [43] can help explain query results and suggest oracles for systems that rely on data management systems [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+debugging+with+continuous+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "Krvan\u00e7 Mu\u015flu, Yuriy Brun, Alexandra Meliou, \"Preventing data errors with continuous testing\", <em>ISSTA</em>, pp. 373-384, 2015.", "title": "Preventing data errors with continuous testing", "context": [{"sec": "sec5", "text": " Meanwhile, assertions on system data can also act as oracles [46], [47], and inferred causal relationships in data management systems [21], [42], [43] can help explain query results and suggest oracles for systems that rely on data management systems [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Preventing+data+errors+with+continuous+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "Jeremy W. Nimmer, Michael D. Ernst, \"Automatic generation of program specifications\", <em>ISSTA</em>, 2002.", "title": "Automatic generation of program specifications", "context": [{"sec": "sec5", "text": "Dynamic invariant mining, e.g., Daikon [18], can infer oracles from test executions by observing arguments' values method return values [48].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/566172.566213", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+generation+of+program+specifications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "Tony Ohmann, Michael Herzberg, Sebastian Fiss, Armand Halbert, Marc Palyart, Ivan Beschastnikh, Yuriy Brun, \"Behavioral resource-aware model inference\", <em>ASE</em>, pp. 19-30, 2014.", "title": "Behavioral resource-aware model inference", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2642937.2642988", "abstract": "Software bugs often arise because of differences between what developers think their system does and what the system actually does. These differences frustrate debugging and comprehension efforts. We describe Perfume, an automated approach for inferring behavioral, resource-aware models of software systems from logs of their executions. These finite state machine models ease understanding of system behavior and resource use. Perfume improves on the state of the art in model inference by differen...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Behavioral+resource-aware+model+inference&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "Carlos Pacheco, Michael D. Ernst, \"Randoop: Feedback-directed random testing for Java\", <em>OOPSLA</em>, pp. 815-816, 2007.", "title": "Randoop: Feedback-directed random testing for Java", "context": [{"sec": "sec1", "text": " This paper focuses on generating oracles from such structured natural language specifications. (Test inputs can often be effectively generated randomly [20], [50], and together with the oracles, produce executable tests.).", "part": "1"}, {"sec": "sec1", "text": "Our research complements prior work on automatically generating test inputs for regression tests or manually-written oracles, such as EvoSuite [20] and Randoop [50], by automatically extracting oracles from natural language specifications.", "part": "1"}, {"sec": "sec1", "text": " Finally, prior test generation work [8], [20], [24], [50] requires access to the source code to be tested, whereas Swami can generate black-box tests entirely from the specification document, without needing the source code.", "part": "1"}, {"sec": "sec4c", "text": "Random test generation tools, such as EvoSuite [20] and Randoop [50], can generate tests in two ways: using explicit assertions in the code (typically written manually), or as regression tests, ensuring the tested behavior doesn't change as the software evolves.", "part": "1"}, {"sec": "sec5", "text": "Automated test generation (e.g., EvoSuite [20] and Ran-doop [50]) and test fuzzing (e.g., afl [1]) generate test inputs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1297846.1297902", "abstract": "R<scp>ANDOOP</scp> for Java generates unit tests for Java code using feedback-directed random test generation. Below we describe R<scp>ANDOOP</scp>'s input, output, and test generation algorithm. We also give an overview of RANDOOP's annotation-based interface for specifying configuration parameters that affect R<scp>ANDOOP</scp>'s behavior and output.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Randoop%3A+Feedback-directed+random+testing+for+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "Denys Poshyvanyk, Malcom Gethers, Andrian Marcus, \"Concept location using formal concept analysis and information retrieval\", <em>ACM TOSEM</em>, vol. 21, no. 4, pp. 23, 2012.", "title": "Concept location using formal concept analysis and information retrieval", "context": [{"sec": "sec5", "text": " Static analysis techniques typically rely on similar information-retrieval-based approaches as Swami, e.g., BLUiR [51], for identifying code relevant to a bug report [58].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2377656.2377660", "abstract": "The article addresses the problem of concept location in source code by proposing an approach that combines Formal Concept Analysis and Information Retrieval. In the proposed approach, Latent Semantic Indexing, an advanced Information Retrieval approach, is used to map textual descriptions of software features or bug reports to relevant parts of the source code, presented as a ranked list of source code elements. Given the ranked list, the approach selects the most relevant attributes from the b...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Concept+location+using+formal+concept+analysis+and+information+retrieval&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "Zichao Qi, Fan Long, Sara Achour, Martin Rinard, \"An analysis of patch plausibility and correctness for generate-and-validate patch generation systems\", <em>ISSTA</em>, pp. 24-36, 2015.", "title": "An analysis of patch plausibility and correctness for generate-and-validate patch generation systems", "context": [{"sec": "sec5", "text": " Unfortunately, incomplete test suites lead to low repair quality [62], [52].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2771783.2771791", "abstract": "We analyze reported patches for three existing generate-and- validate patch generation systems (GenProg, RSRepair, and AE). The basic principle behind generate-and-validate systems is to accept only plausible patches that produce correct outputs for all inputs in the validation test suite. Because of errors in the patch evaluation infrastructure, the majority of the reported patches are not plausible \u2014 they do not produce correct outputs even for the inputs in the validation test suite. The over...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+analysis+of+patch+plausibility+and+correctness+for+generate-and-validate+patch+generation+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "Masudur Rahman, Saikat Chakraborty, Gail Kaiser, Baishakhi Ray, \"A case study on the impact of similarity measure on information retrieval based software engineering tasks\", <em>CoRR</em>, vol. abs/1808.02911, 2018.", "title": "A case study on the impact of similarity measure on information retrieval based software engineering tasks", "context": [{"sec": "sec3b", "text": " We chose to use the Okapi model because recent studies have found it to outperform more complex models on both text and source code artifacts [53], [67].", "part": "1"}, {"sec": "sec5", "text": " Swami's model is simpler, but works well in practice; recent studies have found it to outperform more complex models on both text and source code artifacts [53], [67].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+case+study+on+the+impact+of+similarity+measure+on+information+retrieval+based+software+engineering+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "Steven P. Reiss, Manos Renieris, \"Encoding program executions\", <em>ICSE</em>, pp. 221-230, 2001.", "title": "Encoding program executions", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"documentLink": "/document/919096", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=919096", "abstract": "Dynamic analysis is based on collecting data as the program runs. However, raw traces tend to be too voluminous and too unstructured to be used directly for visualization and understanding. We address this problem in two phases: the first phase selects subsets of the data and then compacts it, while the second phase encodes the data in an attempt to infer its structure. Our major compaction/selection techniques include gprof-style N-depth call sequences, selection based on class, compaction base...", "pdfSize": "878KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Encoding+program+executions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "\"The economic impacts of inadequate infrastructure for software testing\", <em>NIST Planning Report 02-3</em>, May 2002.", "title": "The economic impacts of inadequate infrastructure for software testing", "context": [{"sec": "sec1", "text": "Of particular interest is generating tests for exceptional behavior and boundary conditions because, while developers spend significant time writing tests manually [2], [55], they often fail to write tests for such behavior.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+economic+impacts+of+inadequate+infrastructure+for+software+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "Stephen Robertson, Hugo Zaragoza, Michael Taylor, \"Simple BM25 extension to multiple weighted fields\", <em>CIKM</em>, pp. 42-49, 2004.", "title": "Simple BM25 extension to multiple weighted fields", "context": [{"sec": "sec3b", "text": " More advanced models [56] might improve model quality by improving term weights, but as Section IV-D will show, this model produces sufficiently high-quality results.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1031171.1031181", "abstract": "This paper describes a simple way of adapting the BM25 ranking formula to deal with structured documents. In the past it has been common to compute scores for the individual fields (e.g. title and body) independently and then combine these scores (typically linearly) to arrive at a final score for the document. We highlight how this approach can lead to poor performance by breaking the carefully constructed non-linear saturation of term frequency in the BM25 function. We propose a much more intu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Simple+BM25+extension+to+multiple+weighted+fields&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "Stephen E. Robertson, Stephen Walker, Micheline Beaulieu, \"Experimentation as a way of life: Okapi at TREC\", <em>Information Processing and Management</em>, vol. 36, pp. 95-108, January 2000.", "title": "Experimentation as a way of life: Okapi at TREC", "context": [{"sec": "sec2a", "text": " Swami uses the Okapi information retrieval model [57] to map documentation sections to code elements.", "part": "1"}, {"sec": "sec3b", "text": " Finally, Swami uses the Indri toolkit to apply the Okapi information retrieval model [57] to map specification sections to source code, weighing more unique terms more strongly than more common terms.", "part": "1"}, {"sec": "sec5", "text": "Requirements tracing maps specifications, bug reports, and other artifacts to code elements [15], [26], [77], which is related to Swami's Section Identification using the Okapi model [57], [64].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0306-4573(99)00046-1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Experimentation+as+a+way+of+life%3A+Okapi+at+TREC&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "Ripon K. Saha, Matthew Lease, Sarfraz Khurshid, Dewayne E. Perry, \"Improving bug localization using structured information retrieval\", <em>ASE</em>, pp. 345-355, 2013.", "title": "Improving bug localization using structured information retrieval", "context": [{"sec": "sec5", "text": " Static analysis techniques typically rely on similar information-retrieval-based approaches as Swami, e.g., BLUiR [51], for identifying code relevant to a bug report [58].", "part": "1"}], "links": {"documentLink": "/document/6693093", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693093", "abstract": "Locating bugs is important, difficult, and expensive, particularly for large-scale systems. To address this, natural language information retrieval techniques are increasingly being used to suggest potential faulty source files given bug reports. While these techniques are very scalable, in practice their effectiveness remains low in accurately localizing bugs to a small number of files. Our key insight is that structured information retrieval based on code constructs, such as class and method n...", "pdfSize": "535KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+bug+localization+using+structured+information+retrieval&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "Vipin Samar, Sangeeta Patni, \"Differential testing for variational analyses: Experience from developing KConfigReader\", <em>CoRR</em>, vol. abs/1706.09357, 2017.", "title": "Differential testing for variational analyses: Experience from developing KConfigReader", "context": [{"sec": "sec5", "text": " Differential testing can also produce oracles by comparing behavior of multiple implementations of the same specification [10], [12], [19], [59], [63], [78] (e.g., comparing the behavior of Node.js to that of Rhino), but requires multiple implementations, whereas Swami requires none.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Differential+testing+for+variational+analyses%3A+Experience+from+developing+KConfigReader&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "Matthias Schur, Andreas Roth, Andreas Zeller, \"Mining behavior models from enterprise web applications\", <em>ESEC/FSE</em>, pp. 422-432, 2013.", "title": "Mining behavior models from enterprise web applications", "context": [{"sec": "sec5", "text": "Specification mining uses execution data to infer (typically) FSM-based specifications [5]\u2013[7], [23], [29], [30], [31], [33]\u2013[36], [49], [54], [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491426", "abstract": "Today&#39;s enterprise web applications demand very high release cycles---and consequently, frequent tests. Automating these tests typically requires a behavior model: A description of the states the application can be in, the transitions between these states, and the expected results. Furthermore one needs scripts to make the abstract actions (transitions) in the model executable. As specifying such behavior models and writing the necessary scripts manually is a hard task, a possible alternative co...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+behavior+models+from+enterprise+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "Stelios Sidiroglou-Douskos, Eric Lahtinen, Fan Long, Martin Rinard, \"Automatic error elimination by horizontal code transfer across multiple applications\", <em>PLDI</em>, pp. 43-54, 2015.", "title": "Automatic error elimination by horizontal code transfer across multiple applications", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2737988", "abstract": "We present Code Phage (CP), a system for automatically transferring correct code from donor applications into recipient applications that process the same inputs to successfully eliminate errors in the recipient. Experimental results using seven donor applications to eliminate ten errors in seven recipient applications highlight the ability of CP to transfer code across applications to eliminate out of bounds access, integer overflow, and divide by zero errors. Because CP works with binary donor...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+error+elimination+by+horizontal+code+transfer+across+multiple+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "Edward K. Smith, Earl Barr, Claire Le Goues, Yuriy Brun, \"Is the cure worse than the disease? Overfitting in automated program repair\", <em>ESEC/FSE</em>, pp. 532-543, 2015.", "title": "Is the cure worse than the disease? Overfitting in automated program repair", "context": [{"sec": "sec5", "text": " Unfortunately, incomplete test suites lead to low repair quality [62], [52].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786825", "abstract": "Automated program repair has shown promise for reducing the significant manual effort debugging requires. This paper addresses a deficit of earlier evaluations of automated repair techniques caused by repairing programs and evaluating generated patches&#39; correctness using the same set of tests. Since tests are an imperfect metric of program correctness, evaluations of this type do not discriminate between correct patches and patches that overfit the available tests and break untested but desired ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+the+cure+worse+than+the+disease%3F+Overfitting+in+automated+program+repair&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "Varun Srivastava, Michael D. Bond, Kathryn S. McKinley, Vitaly Shmatikov, \"A security policy oracle: Detecting security holes using multiple API implementations\", <em>PLDI</em>, pp. 343-354, 2011.", "title": "A security policy oracle: Detecting security holes using multiple API implementations", "context": [{"sec": "sec5", "text": " Differential testing can also produce oracles by comparing behavior of multiple implementations of the same specification [10], [12], [19], [59], [63], [78] (e.g., comparing the behavior of Node.js to that of Rhino), but requires multiple implementations, whereas Swami requires none.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1993498.1993539", "abstract": "Even experienced developers struggle to implement security policies correctly. For example, despite 15 years of development, standard Java libraries still suffer from missing and incorrectly applied permission checks, which enable untrusted applications to execute native calls or modify private class variables without authorization. Previous techniques for static verification of authorization enforcement rely on manually specified policies or attempt to infer the policy by code-mining. Neither a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+security+policy+oracle%3A+Detecting+security+holes+using+multiple+API+implementations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "Trevor Strohman, Donald Metzler, Howard Turtle, W. Bruce Croft, \"Indri: A language model-based search engine for complex queries\", <em>International Conference on Intelligence Analysis</em>, pp. 2-6, 2005.", "title": "Indri: A language model-based search engine for complex queries", "context": [{"sec": "sec3a", "text": " Swami uses the Indri toolkit [64] for removing stopwords and stemming.", "part": "1"}, {"sec": "sec3b", "text": " Swami then tokenizes the specification and uses the Indri toolkit [64] for stopword removal, stemming, and indexing by computing the term frequency, the number of times a term occurs in a document, and document frequency, the number of documents in which a term appears.", "part": "1"}, {"sec": "sec5", "text": "Requirements tracing maps specifications, bug reports, and other artifacts to code elements [15], [26], [77], which is related to Swami's Section Identification using the Okapi model [57], [64].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Indri%3A+A+language+model-based+search+engine+for+complex+queries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "Shin Hwei Tan, Darko Marinov, Lin Tan, Gary T. Leavens, \"@tComment: Testing Javadoc comments to detect comment-code inconsistencies\", <em>ICST</em>, pp. 260-269, 2012.", "title": "@tComment: Testing Javadoc comments to detect comment-code inconsistencies", "context": [{"sec": "sec1", "text": " The closest work to ours is Toradacu [24] and Jdoctor [8], which focus on extracting oracles for exceptional behavior, and @tComment [65], which focuses on extracting preconditions related to nullness of parameters.", "part": "1"}, {"sec": "sec1", "text": " These techniques are limited to using Javadoc comments, which are simpler than the specifications Swami tackles because Javadoc comments (1) provide specific annotations for pre- and post-conditions, including @param, @throws, and @returns, making them more formal [65]; (2) are collocated with the method implementations they specify, (3) use the variable names as they appear in the code, and (4) do not contain references to abstract operations specified elsewhere.", "part": "1"}, {"sec": "sec1", "text": " Additionally, recent work showed that Javadoc comments are often out of date because developers forget to update them when requirements change [65].", "part": "1"}, {"sec": "sec5", "text": " Toradacu [24] and Jdoctor [8] do this for exceptional behavior, and @tComment [65] for null pointers.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=%40tComment%3A+Testing+Javadoc+comments+to+detect+comment-code+inconsistencies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "Shin Hwei Tan, Abhik Roychoudhury, \"relifix: Automated repair of software regressions\", <em>ICSE</em>, pp. 471-482, 2015.", "title": "relifix: Automated repair of software regressions", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=relifix%3A+Automated+repair+of+software+regressions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "Chakkrit Tantithamthavorn, Surafel Abebe Lemma, Ahmed E. Hassan, Akinori Ihara, Kenichi Matsumoto, \"The impact of IR-based classifier configuration on the performance and the effort of method-level bug localization\", <em>Information and Software Technology</em>, 2018.", "title": "The impact of IR-based classifier configuration on the performance and the effort of method-level bug localization", "context": [{"sec": "sec3b", "text": " We chose to use the Okapi model because recent studies have found it to outperform more complex models on both text and source code artifacts [53], [67].", "part": "1"}, {"sec": "sec5", "text": " Swami's model is simpler, but works well in practice; recent studies have found it to outperform more complex models on both text and source code artifacts [53], [67].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2018.06.001", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+IR-based+classifier+configuration+on+the+performance+and+the+effort+of+method-level+bug+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "Robert J. Walls, Yuriy Brun, Marc Liberatore, Brian Neil Levine, \"Discovering specification violations in networked software systems\", <em>ISSRE</em>, pp. 496-506, 2015.", "title": "Discovering specification violations in networked software systems", "context": [{"sec": "sec5", "text": " TAUTOKO uses such specifications to generate tests, e.g., of sequences of method invokations on a data structure [14], then iteratively improving the inferred model [14], [68].", "part": "1"}], "links": {"documentLink": "/document/7381842", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7381842", "abstract": "Publicly released software implementations of network protocols often have bugs that arise from latent specification violations. We present Ape, a technique that explores program behavior to identify potential specification violations. Ape overcomes the challenge of exploring the large space of behavior by dynamically inferring precise models of behavior, stimulating unobserved behavior likely to lead to violations, and refining the behavioral models with the new, stimulated behavior. Ape can (1...", "pdfSize": "278KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Discovering+specification+violations+in+networked+software+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "Qianqian Wang, Yuriy Brun, Alessandro Orso, \"Behavioral execution comparison: Are tests representative of field behavior?\", <em>ICST</em>, pp. 321-332, 2017.", "title": "Behavioral execution comparison: Are tests representative of field behavior?", "context": [{"sec": "sec4b", "text": " However, coverage is an underestimate of test suite quality [69], as evidenced by the fact that Swami discovered defects in both projects.", "part": "1"}], "links": {"documentLink": "/document/7927986", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7927986", "abstract": "Software testing is the most widely used approach for assessing and improving software quality, but it is inherently incomplete and may not be representative of how the software is used in the field. This paper addresses the questions of to what extent tests represent how real users use software, and how to measure behavioral differences between test and field executions. We study four real-world systems, one used by endusers and three used by other (client) software, and compare test suites wri...", "pdfSize": "478KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Behavioral+execution+comparison%3A+Are+tests+representative+of+field+behavior%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "Xiaolan Wang, Xin Luna Dong, Alexandra Meliou, \"Data X-Ray: A diagnostic tool for data errors\", <em>SIGMOD</em>, pp. 1231-1245, 2015.", "title": "Data X-Ray: A diagnostic tool for data errors", "context": [{"sec": "sec5", "text": " Such inference can also help debug errors [70]\u2013[72] by tracking and using data provenance [44].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2723372.2750549", "abstract": "A lot of systems and applications are data-driven, and the correctness of their operation relies heavily on the correctness of their data. While existing data cleaning techniques can be quite effective at purging datasets of errors, they disregard the fact that a lot of errors are systematic, inherent to the process that produces the data, and thus will keep occurring unless the problem is corrected at its source. In contrast to traditional data cleaning, in this paper we focus on data diagnosis...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+X-Ray%3A+A+diagnostic+tool+for+data+errors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}, {"order": "71", "text": "Xiaolan Wang, Alexandra Meliou, Eugene Wu, \"QFix: Demonstrating error diagnosis in query histories\", <em>SIGMOD Demo</em>, pp. 2177-2180, 2016.", "title": "QFix: Demonstrating error diagnosis in query histories", "context": [{"sec": "sec5", "text": " Such inference can also help debug errors [70]\u2013[71][72] by tracking and using data provenance [44].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2882903.2899388", "abstract": "An increasing number of applications in all aspects of society rely on data. Despite the long line of research in data cleaning and repairs, data correctness has been an elusive goal. Errors in the data can be extremely disruptive, and are detrimental to the effectiveness and proper function of data-driven applications. Even when data is cleaned, new errors can be introduced by applications and users who interact with the data. Subsequent valid updates can obscure these errors and propagate them...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=QFix%3A+Demonstrating+error+diagnosis+in+query+histories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref71"}, {"order": "72", "text": "Xiaolan Wang, Alexandra Meliou, Eugene Wu, \"QFix: Diagnosing errors through query histories\", <em>SIGMOD</em>, pp. 1369-1384, 2017.", "title": "QFix: Diagnosing errors through query histories", "context": [{"sec": "sec5", "text": " Such inference can also help debug errors [70]\u2013[72] by tracking and using data provenance [44].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3035918.3035925", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=QFix%3A+Diagnosing+errors+through+query+histories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref72"}, {"order": "73", "text": "Westley Weimer, George C. Necula, \"Finding and preventing run-time error handling mistakes\", <em>OOPSLA</em>, pp. 419-431, 2004.", "title": "Finding and preventing run-time error handling mistakes", "context": [{"sec": "sec1", "text": " Finally, exceptional behavior is often the cause of field failures [73], and thus warrants high-quality testing.", "part": "1"}, {"sec": "sec1", "text": " We scope our work by focusing on exceptional and boundary behavior, precisely the important-in-the-field behavior developers often undertest [24], [73].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1028976.1029011", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+and+preventing+run-time+error+handling+mistakes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref73"}, {"order": "74", "text": "Westley Weimer, ThanhVu Nguyen, Claire Le Goues, Stephanie Forrest, \"Automatically finding patches using genetic programming\", <em>ICSE</em>, pp. 364-374, 2009.", "title": "Automatically finding patches using genetic programming", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"documentLink": "/document/5070536", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070536", "abstract": "Automatic program repair has been a longstanding goal in software engineering, yet debugging remains a largely manual process. We introduce a fully automated method for locating and repairing bugs in software. The approach works on off-the-shelf legacy applications and does not require formal specifications, program annotations or special coding practices. Once a program fault is discovered, an extended form of genetic programming is used to evolve program variants until one is found that both r...", "pdfSize": "264KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+finding+patches+using+genetic+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref74"}, {"order": "75", "text": "Aaron Weiss, Arjun Guha, Yuriy Brun, \"Tortoise: Interactive system configuration repair\", <em>ASE</em>, pp. 625-636, 2017.", "title": "Tortoise: Interactive system configuration repair", "context": [{"sec": "sec5", "text": "Automated program repair, e.g., [74], [28], [37], [38], [40], [41], [61], [66], [75], relies on test suites to judge repair quality.", "part": "1"}], "links": {"documentLink": "/document/8115673", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115673", "abstract": "System configuration languages provide powerful abstractions that simplify managing large-scale, networked systems. Thousands of organizations now use configuration languages, such as Puppet. However, specifications written in configuration languages can have bugs and the shell remains the simplest way to debug a misconfigured system. Unfortunately, it is unsafe to use the shell to fix problems when a system configuration language is in use: a fix applied from the shell may cause the system to d...", "pdfSize": "296KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tortoise%3A+Interactive+system+configuration+repair&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref75"}, {"order": "76", "text": "Allen Wirfs-Brock, Brian Terlson, <em>ECMA-262 ECMAScript 2017 language specification</em>, 2017,  [online]  Available: https://www.ecma-international.org/ecma-262/8.0.", "title": "ECMA-262, ECMAScript 2017 language specification", "context": [{"sec": "sec1", "text": "We evaluate Swami using ECMA-262, the official specification of the JavaScript programming language [76], and two well known JavaScript implementations: Java Rhino and C++ Node.js built on Chrome's V8 JavaScript engine.", "part": "1"}, {"sec": "sec2", "text": "To explain our approach for generating test oracles, we will use ECMA-262, the official specification of the JavaScript programming language [76].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ECMA-262%2C+ECMAScript+2017+language+specification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref76"}, {"order": "77", "text": "W. Eric Wong, Ruizhi Gao, Yihao Li, Rui Abreu, Franz Wotawa, \"A survey on software fault localization\", <em>IEEE TSE</em>, vol. 42, no. 8, pp. 707-740, 2016.", "title": "A survey on software fault localization", "context": [{"sec": "sec5", "text": "Requirements tracing maps specifications, bug reports, and other artifacts to code elements [15], [26], [77], which is related to Swami's Section Identification using the Okapi model [57], [64].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+on+software+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref77"}, {"order": "78", "text": "Xuejun Yang, Yang Chen, Eric Eide, John Regehr, \"Finding and understanding bugs in C compilers\", <em>PLDI</em>, pp. 283-294, 2011.", "title": "Finding and understanding bugs in C compilers", "context": [{"sec": "sec5", "text": " Differential testing can also produce oracles by comparing behavior of multiple implementations of the same specification [10], [12], [19], [59], [63], [78] (e.g., comparing the behavior of Node.js to that of Rhino), but requires multiple implementations, whereas Swami requires none.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1993498.1993532", "abstract": "Compilers should be correct. To improve the quality of C compilers, we created Csmith, a randomized test-case generation tool, and spent three years using it to find compiler bugs. During this period we reported more than 325 previously unknown bugs to compiler developers. Every compiler we tested was found to crash and also to silently generate wrong code when presented with valid input. In this paper we present our compiler-testing tool and the results of our bug-hunting study. Our first contr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+and+understanding+bugs+in+C+compilers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref78"}, {"order": "79", "text": "Xin Ye, Hui Shen, Xiao Ma, Razvan Bunescu, Chang Liu, \"From word embeddings to document similarities for improved information retrieval in software engineering\", <em>ICSE</em>, pp. 404-415, 2016.", "title": "From word embeddings to document similarities for improved information retrieval in software engineering", "context": [{"sec": "sec5", "text": " Machine learning can aid tracing, e.g., via word embeddings to identify similarities between API documents, tutorials, and reference documents [79].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884862", "abstract": "The application of information retrieval techniques to search tasks in software engineering is made difficult by the lexical gap between search queries, usually expressed in natural language (e.g. English), and retrieved documents, usually expressed in code (e.g. programming languages). This is often the case in bug and feature location, community question answering, or more generally the communication between technical personnel and non-technical stake holders in a software project. In this pap...", "pdfSize": "343KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=From+word+embeddings+to+document+similarities+for+improved+information+retrieval+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref79"}, {"order": "80", "text": "Chengxiang Zhai, John Lafferty, \"A study of smoothing methods for language models applied to ad hoc information retrieval\", <em>SIGIR</em>, pp. 334-342, 2001.", "title": "A study of smoothing methods for language models applied to ad hoc information retrieval", "context": [{"sec": "sec3b", "text": " The Okapi model computes the inverse document frequency, which captures both the frequency of the co-occurring terms and the uniqueness of those terms [80].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/383952.384019", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+study+of+smoothing+methods+for+language+models+applied+to+ad+hoc+information+retrieval&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref80"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812070", "articleId": "8812070", "startPage": "188", "endPage": "199", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 109}}
{"title": "Code Defenders: Crowdsourcing Effective Tests and Subtle Mutants with a Mutation Testing Game", "authors": [{"name": "Jos\u00e9 Miguel Rojas", "affiliation": "Dept. of Comput. Sci., Univ. of Sheffield, Sheffield, UK", "firstName": "Jos\u00e9 Miguel", "lastName": "Rojas", "id": "37085707182"}, {"name": "Thomas D. White", "affiliation": "Dept. of Comput. Sci., Univ. of Sheffield, Sheffield, UK", "firstName": "Thomas D.", "lastName": "White", "id": "37086187373"}, {"name": "Benjamin S. Clegg", "affiliation": "Dept. of Comput. Sci., Univ. of Sheffield, Sheffield, UK", "firstName": "Benjamin S.", "lastName": "Clegg", "id": "37085996733"}, {"name": "Gordon Fraser", "affiliation": "Dept. of Comput. Sci., Univ. of Sheffield, Sheffield, UK", "firstName": "Gordon", "lastName": "Fraser", "id": "37313745900"}], "abstract": "Writing good software tests is difficult and not every developer's favorite occupation. Mutation testing aims to help by seeding artificial faults (mutants) that good tests should identify, and test generation tools help by providing automatically generated tests. However, mutation tools tend to produce huge numbers of mutants, many of which are trivial, redundant, or semantically equivalent to the original program, automated test generation tools tend to produce tests that achieve good code coverage, but are otherwise weak and have no clear purpose. In this paper, we present an approach based on gamification and crowdsourcing to produce better software tests and mutants: The Code Defenders web-based game lets teams of players compete over a program, where attackers try to create subtle mutants, which the defenders try to counter by writing strong tests. Experiments in controlled and crowdsourced scenarios reveal that writing tests as part of the game is more enjoyable, and that playing Code Defenders results in stronger test suites and mutants than those produced by automated tools.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Games", "Tools", "Testing", "Crowdsourcing", "Writing", "Software", "Computer bugs"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["computer games", "crowdsourcing", "Internet", "program testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["Code Defenders", "mutation testing game", "gamification", "crowdsourcing", "software tests", "Web-based game"]}, {"type": "Author Keywords ", "kwd": ["gamification", "crowdsourcing", "software testing", "mutation testing"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.68", "ref": [{"order": "1", "text": "K. Adamopoulos, M. Harman, R.M. Hierons, \"How to overcome the equivalent mutant problem and achieve tailored selective mutation using co-evolution\", <em>Genetic and Evolutionary Computation Conference (GECCO)</em>, pp. 1338-1349, 2004.", "title": "How to overcome the equivalent mutant problem and achieve tailored selective mutation using co-evolution", "context": [{"sec": "sec2b", "text": " Different techniques and systems have been developed to detect equivalent mutants (e.g., [1], [31], [40]), but they are generally limited to certain types of mutants.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+overcome+the+equivalent+mutant+problem+and+achieve+tailored+selective+mutation+using+co-evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "J.H. Andrews, L.C. Briand, Y. Labiche, \"Is mutation an appropriate tool for testing experiments?\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 402-411, 2005.", "title": "Is mutation an appropriate tool for testing experiments?", "context": [{"sec": "sec2b", "text": " There is evidence [2], [24] that test suites that are good at finding mutants are also good at finding real faults.", "part": "1"}, {"sec": "sec4b1", "text": " While evidence supports that real faults are correlated with mutants [2], [24], it is possible that the use of faults created by developers may yield different results.", "part": "1"}], "links": {"abstract": "The empirical assessment of test techniques plays an important role in software testing research. One common practice is to instrument faults, either manually or by using mutation operators. The latter allows the systematic, repeatable seeding of large numbers of faults; however, we do not know whether empirical results obtained this way lead to valid, representative conclusions. This paper investigates this important question based on a number of programs with comprehensive pools of test cases ...", "pdfSize": "3121KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+mutation+an+appropriate+tool+for+testing+experiments%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "S. Arai, K. Sakamoto, H. Washizaki, Y. Fukazawa, \"A gamified tool for motivating developers to remove warnings of bug pattern tools\", <em>Int. Workshop on Empirical Software Engineering in Practice (IWESEP)</em>, pp. 37-42, 2014.", "title": "A gamified tool for motivating developers to remove warnings of bug pattern tools", "context": [{"sec": "sec6", "text": "There are several successful examples of gamification for software engineering, where the methodology has been applied mostly to increase the motivation and performance of people participating in software engineering activities [34], such as removing static analysis warnings [3] or committing changes often to version control [42].", "part": "1"}], "links": {"documentLink": "/document/6976020", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6976020", "abstract": "Static analysis tools such as bug pattern tools are useful to detect bugs early in software development. However, existing tools sometimes yield so many warnings that developers tend to ignore such warnings. To deal with this problem, we propose a gamified tool for motivating developers to remove such warnings. Our tool employs the gamification technique that calculates points by counting removed warnings with respect to each developer and each team. The points give developers feedback and urge ...", "pdfSize": "1036KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+gamified+tool+for+motivating+developers+to+remove+warnings+of+bug+pattern+tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "G. Balogh, T. Gergely, \u00c1. Besz\u00e9des, T. Gyim\u00f3thy, \"Using the city metaphor for visualizing test-related metrics\", <em>Int. Conference on Software Analysis Evolution and Reengineering (SANER)</em>, vol. 2, pp. 17-20, 2016.", "title": "Using the city metaphor for visualizing test-related metrics", "context": [{"sec": "sec7b", "text": " Research on code visualization, for example the city metaphor [4], [50], may be well suited for this.", "part": "1"}], "links": {"documentLink": "/document/7476755", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7476755", "abstract": "Software visualization techniques and tools play an important role in system comprehension efforts of software developers in the era of increasing code size and complexity. They enable the developer to have a global perception on various software attributes with the aid of different visualization metaphors and tools. One such tool is CodeMetropolis which is built on top of the game engine Minecraft and which uses the city metaphor to show the structure of the source code as a virtual city. In it...", "pdfSize": "336KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+the+city+metaphor+for+visualizing+test-related+metrics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "J. Bell, S. Sheth, G. Kaiser, \"Secret ninja testing with HALO software engineering\", <em>Int. Workshop on Social Software Engineering</em>, pp. 43-47, 2011.", "title": "Secret ninja testing with HALO software engineering", "context": [{"sec": "sec6", "text": " [5] use storylines and quests to gradually introduce students to testing without explicitly telling them.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2024645.2024657", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Secret+ninja+testing+with+HALO+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "M. Beller, G. Gousios, A. Panichella, A. Zaidman, \"When how and why developers (do not) test in their IDEs\", <em>ACM Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 179-190, 2015.", "title": "When, how, and why developers (do not) test in their IDEs", "context": [{"sec": "sec1", "text": "However, writing good tests is difficult and developers are often reluctant to do so [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786843", "abstract": "The research community in Software Engineering and Software Testing in particular builds many of its contributions on a set of mutually shared expectations. Despite the fact that they form the basis of many publications as well as open-source and commercial testing applications, these common expectations and beliefs are rarely ever questioned. For example, Frederic Brooks\u2019 statement that testing takes half of the development time seems to have manifested itself within the community since he firs...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When%2C+how%2C+and+why+developers+%28do+not%29+test+in+their+IDEs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "J. Bishop, R.N. Horspool, T. Xie, N. Tillmann, J. de Halleux, \"Code Hunt: Experience with coding contests at scale\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)(JSEET track)</em>, pp. 398-407, 2015.", "title": "Code Hunt: Experience with coding contests at scale", "context": [{"sec": "sec6", "text": "CodeHunt [7], based on Pex4Fun [46], is a game that integrates coding and test generation.", "part": "1"}], "links": {"abstract": "Mastering a complex skill like programming takes many hours. In order to encourage students to put in these hours, we built Code Hunt, a game that enables players to program against the computer with clues provided as unit tests. The game has become very popular and we are now running worldwide contests where students have a fixed amount of time to solve a set of puzzles. This paper describes Code Hunt and the contest experience it offers. We then show some early results that demonstrate how Cod...", "pdfSize": "2178KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+Hunt%3A+Experience+with+coding+contests+at+scale&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "T.A. Budd, D. Angluin, \"Two notions of correctness and their relation to testing\", <em>Acta Inf.</em>, vol. 18, pp. 31-45, 1982.", "title": "Two notions of correctness and their relation to testing", "context": [{"sec": "sec2b", "text": " Detecting equivalent mutants is an undecidable problem [8], [28], and effort on trying to derive such a test is likely wasted.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF00625279", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Two+notions+of+correctness+and+their+relation+to+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "J. Carver, L. Jaccheri, S. Morasca, F. Shull, \"Issues in using students in empirical studies in software engineering education\", <em>IEEE Int. Software Metrics Symposium (METRICS)</em>, pp. 239-249, 2003.", "title": "Issues in using students in empirical studies in software engineering education", "context": [{"sec": "sec4b3", "text": "Most participants of our study are students, which is a much debated topic in the literature (e.g., [9], [19]).", "part": "1"}], "links": {"abstract": "Several empirical studies have been carried out with college students as subjects in the last few years. Researchers often use these studies to pilot experiments before they are carried out in industrial environments. Reports on these studies usually focus on the results obtained and issues such as their external validity. However, the effects and value of empirical studies with students may go beyond the contribution to scientific literature. For instance, the pedagogical challenges and value o...", "pdfSize": "230KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Issues+in+using+students+in+empirical+studies+in+software+engineering+education&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "N. Chen, S. Kim, \"Puzzle-based automatic testing: bringing humans into the loop by solving puzzles\", <em>IEEE/ACM Int. Conference on Automated Software Engineering (ASE)</em>, pp. 140-149, 2012.", "title": "Puzzle-based automatic testing: bringing humans into the loop by solving puzzles", "context": [{"sec": "sec6", "text": "Chen and Kim [10] designed a game, where players solve puzzles that represent object mutation or constraint solving problems, to support automated test generation tools.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2351676.2351697", "abstract": "Recently, many automatic test generation techniques have been proposed, such as Randoop, Pex and jCUTE. However, usually test coverage of these techniques has been around 50-60% only, due to several challenges, such as 1) the object mutation problem, where test generators cannot create and/or modify test inputs to desired object states; and 2) the constraint solving problem, where test generators fail to solve path conditions to cover certain branches. By analyzing branches not covered by state-...", "pdfSize": "448KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Puzzle-based+automatic+testing%3A+bringing+humans+into+the+loop+by+solving+puzzles&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "E. Daka, J. Campos, G. Fraser, J. Dorn, W. Weimer, \"Modeling readability to improve unit tests\", <em>ACM Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 107-118, 2015.", "title": "Modeling readability to improve unit tests", "context": [{"sec": "sec5d", "text": " Alternatives to prevent games from early stagnation could involve ranking tests by non-functional properties (e.g., length or readability [11]) such that defenders have the chance to catch up if they submit shorter, more readable tests, possibly even stealing points from other team members.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786838", "abstract": "Writing good unit tests can be tedious and error prone, but even once they are written, the job is not done: Developers need to reason about unit tests throughout software development and evolution, in order to diagnose test failures, maintain the tests, and to understand code written by other developers. Unreadable tests are more difficult to maintain and lose some of their value to developers. To overcome this problem, we propose a domain-specific model of unit test readability based on human ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+readability+to+improve+unit+tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "S. Deterding, D. Dixon, R. Khaled, L. Nacke, \"From game design elements to gamefulness: Defining \u201cgamification\u201d\", <em>Int. Academic MindTrek Conference: Envisioning Future Media Environments (Min dTrek)</em>, pp. 9-15, 2011.", "title": "From game design elements to gamefulness: Defining \u201cgamification\u201d", "context": [{"sec": "sec1", "text": "The difficulties of writing good tests and using automated mutation tools are similar in nature to those generally targeted by gamification and crowdsourcing: Gamification [12] is the approach of converting tasks to components of entertaining gameplay.", "part": "1"}, {"sec": "sec2c", "text": "Gamification uses game design elements (competitions with other players, game rules, point scoring, fantasy scenarios, etc.) to make unpleasant or dull tasks more entertaining and rewarding [12].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2181037.2181040", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=From+game+design+elements+to+gamefulness%3A+Defining+%E2%80%9Cgamification%E2%80%9D&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "W. Dietl, S. Dietzel, M.D. Ernst, N. Mote, B. Walker, S. Cooper, T. Pavlik, Z. Popovi\u0107, \"Verification games: Making verification fun\", <em>Workshop on Formal Techniques for Java-like Programs (FTfJP)</em>, pp. 42-49, 2012.", "title": "Verification games: Making verification fun", "context": [{"sec": "sec6", "text": " [13] gamified the verification of certain program properties such that players are not aware of the underlying verification task.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2318202.2318210", "abstract": "Program verification is the only way to be certain that a given piece of software is free of (certain types of) errors --- errors that could otherwise disrupt operations in the field. To date, formal verification has been done by specially-trained engineers. Labor costs have heretofore made formal verification too costly to apply beyond small, critical software components. Our goal is to make verification more cost-effective by reducing the skill set required for program verification and increas...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Verification+games%3A+Making+verification+fun&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "D.J. Dubois, G. Tamburrelli, \"Understanding gamification mechanisms for software development\", <em>ACM Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 659-662, 2013.", "title": "Understanding gamification mechanisms for software development", "context": [{"sec": "sec3d", "text": "Whenever humans engage in competitive games, there is the possibility of cheating and unfair behaviour, and this also holds in gamified software engineering tasks [14].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2494589", "abstract": "In this paper we outline the idea to adopt gamification techniques to engage, train, monitor, and motivate all the players involved in the development of complex software artifacts, from the inception to the deployment and maintenance. The paper introduces the concept of gamification and proposes a research approach to understand how its principles may be successfully applied to the process of software development. Applying gamification to software engineering is not as straightforward as it may...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+gamification+mechanisms+for+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "S. Elbaum, S. Person, J. Dokulil, M. Jorde, \"Bug hunt: Making early software testing lessons engaging and affordable\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 688-697, 2007.", "title": "Bug hunt: Making early software testing lessons engaging and affordable", "context": [{"sec": "sec6", "text": " [15] developed Bug Hunt, a web-based tutorial system where students have to apply different testing techniques to solve challenges.", "part": "1"}], "links": {"documentLink": "/document/4222630", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222630", "abstract": "Software testing efforts account for a large part of software development costs. However, as educators, we struggle to properly prepare students to perform software testing activities. This struggle is caused by multiple factors: (1) it is challenging to effectively incorporate software testing into an already over-packed curriculum, (2) ad-hoc efforts to teach testing generally happen too late in the students&#39; career, after bad habits have already been developed, and (3) these efforts lack the ...", "pdfSize": "1449KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bug+hunt%3A+Making+early+software+testing+lessons+engaging+and+affordable&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "G. Fraser, A. Arcuri, \"EvoSuite: automatic test suite generation for object-oriented software\", <em>ACM Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 416-419, 2011.", "title": "EvoSuite: automatic test suite generation for object-oriented software", "context": [{"sec": "sec1", "text": " Code coverage and mutation scores are higher compared to tests (a) written outside the game and (b) generated by automated tools (on average, 28% higher mutation score than Randoop [29], and 25% higher mutation score than EvoSuite [16]).", "part": "1"}, {"sec": "sec2a", "text": " For example, EvoSuite [16] generates test suites using a genetic algorithm which aims to maximize code coverage.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025179", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=EvoSuite%3A+automatic+test+suite+generation+for+object-oriented+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "G. Fraser, A. Arcuri, \"A large scale evaluation of automated unit test generation using evosuite\", <em>ACM Transactions on Software Engineering and Methodology (TOSEM)</em>, vol. 24, no. 2, pp. 8:1-8:42, 2014.", "title": "A large scale evaluation of automated unit test generation using evosuite", "context": [{"sec": "sec5a", "text": "We followed a systematic procedure to select 20 classes from the SF110 [17] repository, which consists of randomly sampled SourceForge projects as well as the top ten most popular ones, and the Apache Commons (AC) libraries [44].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2685612", "abstract": "Research on software testing produces many innovative automated techniques, but because software testing is by necessity incomplete and approximate, any new technique faces the challenge of an empirical assessment. In the past, we have demonstrated scientific advance in automated unit test generation with the EVOSUITE tool by evaluating it on manually selected open-source projects or examples that represent a particular problem addressed by the underlying technique. However, demonstrating scient...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+large+scale+evaluation+of+automated+unit+test+generation+using+evosuite&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "J.P. Galeotti, G. Fraser, A. Arcuri, \"Improving search-based test suite generation with dynamic symbolic execution\", <em>Int. Symposium on Software Reliability Engineering (ISSRE)</em>, pp. 360-369, 2013.", "title": "Improving search-based test suite generation with dynamic symbolic execution", "context": [{"sec": "sec2a", "text": " For example, EvoSuite implements an experimental extension [18] that uses dynamic symbolic execution to generate primitive input values, and the Pex [45] tool uses dynamic symbolic execution to instantiate parameterized unit tests for C#.", "part": "1"}], "links": {"documentLink": "/document/6698889", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6698889", "abstract": "Search-based testing can automatically generate unit test suites for object oriented code, but may struggle to generate specific values necessary to cover difficult parts of the code. Dynamic symbolic execution (DSE) efficiently generates such specific values, but may struggle with complex datatypes, in particular those that require sequences of calls for construction. The solution to these problems lies in a hybrid approach that integrates the best of both worlds, but such an integration needs ...", "pdfSize": "442KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+search-based+test+suite+generation+with+dynamic+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "M. H\u00f6st, B. Regnell, C. Wohlin, \"Using students as subjects-A comparative study of students and professionals in lead-time impact assessment\", <em>Empirical Software Engineering (EMSE)</em>, vol. 5, no. 3, pp. 201-214, 2000.", "title": "Using students as subjects-A comparative study of students and professionals in lead-time impact assessment", "context": [{"sec": "sec4b3", "text": "Most participants of our study are students, which is a much debated topic in the literature (e.g., [9], [19]).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/A:1026586415054", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+students+as+subjects-A+comparative+study+of+students+and+professionals+in+lead-time+impact+assessment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J. Howe, \"The rise of crowdsourcing\", <em>Wired</em>, vol. 14, no. 6, June 2006.", "title": "The rise of crowdsourcing", "context": [{"sec": "sec1", "text": " Crowdsourcing is a problem solving strategy [20] where a difficult problem is encoded and assigned to an undefined group of workers (the crowd), who provide their solutions back to the requester; the requester then derives the final solution from the solutions collected from the workers, who are usually rewarded, e.g., with cash or prizes.", "part": "1"}, {"sec": "sec2c", "text": "Problems that are hard to solve computationally but can be effectively solved by humans can be amenable to crowd-sourcing [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+rise+of+crowdsourcing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "L. Inozemtseva, R. Holmes, \"Coverage is not strongly correlated with test suite effectiveness\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 435-445, 2014.", "title": "Coverage is not strongly correlated with test suite effectiveness", "context": [{"sec": "sec1", "text": " In contrast to more basic code coverage criteria such as statement coverage [21], the ability of a test suite to detect mutants is correlated with detecting real faults [24].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568271", "abstract": "The coverage of a test suite is often used as a proxy for its ability to detect faults. However, previous studies that investigated the correlation between code coverage and test suite effectiveness have failed to reach a consensus about the nature and strength of the relationship between these test suite characteristics. Moreover, many of the studies were done with small or synthetic programs, making it unclear whether their results generalize to larger programs, and some of the studies did not...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coverage+is+not+strongly+correlated+with+test+suite+effectiveness&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "R. Just, \"The Major mutation framework: Efficient and scalable mutation analysis for Java\", <em>ACM Int. Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 433-436, 2014.", "title": "The Major mutation framework: Efficient and scalable mutation analysis for Java", "context": [{"sec": "sec1", "text": " Mutants created by attackers are significantly harder to kill than those created by the Major mutation tool [22].", "part": "1"}, {"sec": "sec4a", "text": " We measure the standard quality attributes of code coverage and mutation scores using Jacoco11http://www.eclemma.org/jacoco, accessed August 2016 to measure coverage, and Major [22] to calculate mutation scores.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2628053", "abstract": "Mutation analysis seeds artificial faults (mutants) into a pro- gram and evaluates testing techniques by measuring how well they detect those mutants. Mutation analysis is well- established in software engineering research but hardly used in practice due to inherent scalability problems and the lack of proper tool support. In response to those challenges, this paper presents Major, a framework for mutation analysis and fault seeding. Major provides a compiler-integrated mu- tator and a mutation ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Major+mutation+framework%3A+Efficient+and+scalable+mutation+analysis+for+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "R. Just, M.D. Ernst, G. Fraser, \"Efficient mutation analysis by propagating and partitioning infected execution states\", <em>ACM Int. Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 315-326, 2014.", "title": "Efficient mutation analysis by propagating and partitioning infected execution states", "context": [{"sec": "sec2b", "text": " Despite many efforts to reduce the number of mutants produced (e.g., [23]) the number remains large, which is not only a problem for scalability, but also because many mutants are either trivial or subsumed by other mutants [30].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2610388", "abstract": "Mutation analysis evaluates a testing technique by measur- ing how well it detects seeded faults (mutants). Mutation analysis is hampered by inherent scalability problems \u2014 a test suite is executed for each of a large number of mutants. Despite numerous optimizations presented in the literature, this scalability issue remains, and this is one of the reasons why mutation analysis is hardly used in practice. Whereas most previous optimizations attempted to stati- cally reduce the number of executi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+mutation+analysis+by+propagating+and+partitioning+infected+execution+states&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "R. Just, D. Jalali, L. Inozemtseva, M.D. Ernst, R. Holmes, G. Fraser, \"Are mutants a valid substitute for real faults in software testing?\", <em>ACM Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 654-665, 2014.", "title": "Are mutants a valid substitute for real faults in software testing?", "context": [{"sec": "sec1", "text": " In contrast to more basic code coverage criteria such as statement coverage [21], the ability of a test suite to detect mutants is correlated with detecting real faults [24].", "part": "1"}, {"sec": "sec2b", "text": " There is evidence [2], [24] that test suites that are good at finding mutants are also good at finding real faults.", "part": "1"}, {"sec": "sec4b1", "text": " While evidence supports that real faults are correlated with mutants [2], [24], it is possible that the use of faults created by developers may yield different results.", "part": "1"}, {"sec": "sec5c", "text": " Finally, string modifications were common throughout the games, supporting recent evidence that such operators are missing in standard mutation tools [24].", "part": "1"}, {"sec": "sec5c", "text": " It has been shown that mutation scores (on mutants generated with Major) correlate to real fault detection [24]; thus we would like to see whether mutation scores calculated using Code Defenders mutants are similar to mutation scores calculated on standard mutants.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635929", "abstract": "A good test suite is one that detects real faults. Because the set of faults in a program is usually unknowable, this definition is not useful to practitioners who are creating test suites, nor to researchers who are creating and evaluating tools that generate test suites. In place of real faults, testing research often uses mutants, which are artificial faults -- each one a simple syntactic variation -- that are systematically seeded throughout the program under test. Mutation analysis is appea...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+mutants+a+valid+substitute+for+real+faults+in+software+testing%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "K.R. Lakhani, D.A. Garvin, E. Lonstein, \"TopCoder (A): Developing software through crowdsourcing\", <em>Technical Report 611-071</em>, 2011.", "title": "TopCoder (A): Developing software through crowdsourcing", "context": [{"sec": "sec7b", "text": " While there are successful crowdsourcing models based on coding tasks (e.g., TopCoder [25]), games are often successful when played with more graphical interactions.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=TopCoder+%28A%29%3A+Developing+software+through+crowdsourcing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "K. Mao, L. Capra, M. Harman, Y. Jia, \"A survey of the use of crowdsourcing in software engineering\", <em>Journal of Systems and Software (JSS)</em>, vol. 126, pp. 57-84, 2017.", "title": "A survey of the use of crowdsourcing in software engineering", "context": [{"sec": "sec2c", "text": " In software engineering, crowdsourcing platforms such as Amazon Mechanical Turk, where crowd workers are paid small fees for completed tasks, are often used for empirical studies [43], but there are attempts to crowdsource various parts of the software development process [26].", "part": "1"}, {"sec": "sec6", "text": " Testing has also been considered [47] as part of a general collaborative and crowdsourced approach to software engineering [26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2016.09.015", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+of+the+use+of+crowdsourcing+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "A. Marczewski, <em>Gamified UK: 48 gamification elements mechanics and ideas</em>,  [online]  Available: http://gamified.uk/2015/02/04/47-gamification-elements-mechanics-and-ideas.", "title": "Gamified UK: 48 gamification elements, mechanics and ideas", "context": [{"sec": "sec7c", "text": "Incorporating a compelling narrative and more gamification elements, e.g., personalization, signposting, random rewards and unlockable content [27], could help improve player engagement and enjoyment.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gamified+UK%3A+48+gamification+elements%2C+mechanics+and+ideas&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "A.J. Offutt, J. Pan, \"Automatically detecting equivalent mutants and infeasible paths\", <em>Software Testing Verification and Reliability (STVR)</em>, vol. 7, no. 3, pp. 165-192, 1997.", "title": "Automatically detecting equivalent mutants and infeasible paths", "context": [{"sec": "sec2b", "text": " Detecting equivalent mutants is an undecidable problem [8], [28], and effort on trying to derive such a test is likely wasted.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/(SICI)1099-1689(199709)7:3&lt;165::AID-STVR143&gt;3.0.CO;2-U", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+detecting+equivalent+mutants+and+infeasible+paths&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "C. Pacheco, S.K. Lahiri, M.D. Ernst, T. Ball, \"Feedback-directed random test generation\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 75-84, 2007.", "title": "Feedback-directed random test generation", "context": [{"sec": "sec1", "text": " Code coverage and mutation scores are higher compared to tests (a) written outside the game and (b) generated by automated tools (on average, 28% higher mutation score than Randoop [29], and 25% higher mutation score than EvoSuite [16]).", "part": "1"}, {"sec": "sec2a", "text": " For example, Randoop [29] is a mature test generation tool for Java that produces random sequences of calls for a given list of classes; violations of code contracts are reported as bugs, and tests that do not reveal bugs are equipped with regression oracles that capture the current program state for regression testing.", "part": "1"}], "links": {"documentLink": "/document/4222570", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222570", "abstract": "We present a technique that improves random test generation by incorporating feedback obtained from executing test inputs as they are created. Our technique builds inputs incrementally by randomly selecting a method call to apply and finding arguments from among previously-constructed inputs. As soon as an input is built, it is executed and checked against a set of contracts and filters. The result of the execution determines whether the input is redundant, illegal, contract-violating, or useful...", "pdfSize": "269KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feedback-directed+random+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "M. Papadakis, C. Henard, M. Harman, Y. Jia, Y. Le Traon, \"Threats to the validity of mutation-based test assessment\", <em>ACM Int. Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 354-365, 2016.", "title": "Threats to the validity of mutation-based test assessment", "context": [{"sec": "sec2b", "text": " Despite many efforts to reduce the number of mutants produced (e.g., [23]) the number remains large, which is not only a problem for scalability, but also because many mutants are either trivial or subsumed by other mutants [30].", "part": "1"}, {"sec": "sec5c", "text": " The slightly lower scores suggest that Code Defenders leads to less inflated scores [30] than mutation tools.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Threats+to+the+validity+of+mutation-based+test+assessment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "M. Papadakis, Y. Jia, M. Harman, Y. Le Traon, \"Trivial compiler equivalence: A large scale empirical study of a simple fast and effective equivalent mutant detection technique\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 936-946, 2015.", "title": "Trivial compiler equivalence: A large scale empirical study of a simple, fast and effective equivalent mutant detection technique", "context": [{"sec": "sec2b", "text": " Different techniques and systems have been developed to detect equivalent mutants (e.g., [1], [31], [40]), but they are generally limited to certain types of mutants.", "part": "1"}], "links": {"abstract": "Identifying equivalent mutants remains the largest impediment to the widespread uptake of mutation testing. Despite being researched for more than three decades, the problem remains. We propose Trivial Compiler Equivalence (TCE) a technique that exploits the use of readily available compiler technology to address this long-standing challenge. TCE is directly applicable to real-world programs and can imbue existing tools with the ability to detect equivalent mutants and a special form of useless ...", "pdfSize": "683KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Trivial+compiler+equivalence%3A+A+large+scale+empirical+study+of+a+simple%2C+fast+and+effective+equivalent+mutant+detection+technique&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "F. Pastore, L. Mariani, G. Fraser, \"Crowdoracles: Can the crowd solve the oracle problem?\", <em>IEEE Int. Conference on Software Testing Verification and Validation (ICST)</em>, pp. 342-351, 2013.", "title": "Crowdoracles: Can the crowd solve the oracle problem?", "context": [{"sec": "sec6", "text": " [32] used crowdsourcing on Amazon Mechanical Turk in order to have crowdworkers confirm test oracles with respect to API documentation.", "part": "1"}, {"sec": "sec7e", "text": " For example, testers could base their assertions on API specifications rather than source code, similar to the CrowdOracles approach [32].", "part": "1"}], "links": {"abstract": "Despite the recent advances in test generation, fully automatic software testing remains a dream: Ultimately, any generated test input depends on a test oracle that determines correctness, and, except for generic properties such as \u201cthe program shall not crash\u201d, such oracles require human input in one form or another. CrowdSourcing is a recently popular technique to automate computations that cannot be performed by machines, but only by humans. A problem is split into small chunks, that are then...", "pdfSize": "262KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Crowdoracles%3A+Can+the+crowd+solve+the+oracle+problem%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "Y. Pavlov, G. Fraser, \"Semi-automatic search-based test generation\", <em>IEEE Int. Conference on Software Testing Verification and Validation (ICST)</em>, pp. 777-784, 2012.", "title": "Semi-automatic search-based test generation", "context": [{"sec": "sec2a", "text": " Pavlov and Fraser [33] demonstrated that some of these can be overcome by including human intelligence by using an interactive genetic algorithm in the EvoSuite tool.", "part": "1"}, {"sec": "sec5b", "text": " However, beyond running time, there are fundamental limitations in the tools [33], [41], [51] that our approach aims to overcome.", "part": "1"}], "links": {"documentLink": "/document/6200188", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6200188", "abstract": "Search-based testing techniques can efficiently generate test data to achieve high code coverage. However, when the fitness function does not provide sufficient guidance, the search will only generate optimal results by chance. Yet, where the search algorithm struggles, a human tester with domain knowledge can often produce solutions easily. We therefore include the tester in the test generation process: When the search stagnates, the tester is given an opportunity to improve the current solutio...", "pdfSize": "459KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semi-automatic+search-based+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "O. Pedreira, F. Garca, N. Brisaboa, M. Piattini, \"Gamification in software engineering a systematic mapping\", <em>Information and Software Technology (IST)</em>, vol. 57, pp. 157-168, 2015.", "title": "Gamification in software engineering a systematic mapping", "context": [{"sec": "sec2c", "text": " It is often applied in education settings, but has also been useful for improving how people engage with aspects of their work, even in software engineering [34].", "part": "1"}, {"sec": "sec6", "text": "There are several successful examples of gamification for software engineering, where the methodology has been applied mostly to increase the motivation and performance of people participating in software engineering activities [34], such as removing static analysis warnings [3] or committing changes often to version control [42].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2014.08.007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gamification+in+software+engineering+a+systematic+mapping&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "J.M. Rojas, G. Fraser, \"Code Defenders: A Mutation Testing Game\", <em>Int. Workshop on Mutation Analysis (ICSTW)</em>, pp. 162-167, 2016.", "title": "Code Defenders: A Mutation Testing Game", "context": [{"sec": "sec3a", "text": " Unlike the round-based gameplay of our preliminary version of Code Defenders [35], attackers and defenders can submit mutants and tests at any time and do not need to wait for other players to act.", "part": "1"}, {"sec": "sec4", "text": " To this end, we used the two-player version [35], where one attacker plays against one defender in a round-based mode, and designed a controlled empirical study to answer the following research questions:\n\nRQl: Do testers produce better tests when playing a game?\nRQ2: Do testers prefer writing tests while playing a game?\n.", "part": "1"}], "links": {"documentLink": "/document/7528958", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7528958", "abstract": "Mutation testing is endorsed by software testing researchers for its unique capability of providing pragmatic estimates of a test suite&#39;s fault detection capability, and for guiding testers in improving their test suites. In practice, however, wide-spread adoption of mutation testing is hampered because any non-trivial program results in huge numbers of mutants, many of which are either trivial or equivalent, and thus useless. Trivial mutants reduce the motivation of developers in trusting and u...", "pdfSize": "657KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+Defenders%3A+A+Mutation+Testing+Game&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "J.M. Rojas, G. Fraser, \"Teaching Mutation Testing using Gamification\", <em>European Conference on Software Engineering Education (ECSEE)</em>, 2016.", "title": "Teaching Mutation Testing using Gamification", "context": [{"sec": "sec1", "text": " Our initial findings for educational applications are documented elsewhere [36].", "part": "1"}, {"sec": "sec6", "text": " While this paper explicitly focuses on the crowdsourcing aspect of Code Defenders, we are also considering an educational angle [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Teaching+Mutation+Testing+using+Gamification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "J.M. Rojas, G. Fraser, A. Arcuri, \"Automated unit test generation during software development: A controlled experiment and think-aloud observations\", <em>ACM Int. Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 338-349, 2015.", "title": "Automated unit test generation during software development: A controlled experiment and think-aloud observations", "context": [{"sec": "sec5a", "text": " Our experience from previous user studies suggests that classes in this size range tend to be suitable for experimental unit testing tasks [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+unit+test+generation+during+software+development%3A+A+controlled+experiment+and+think-aloud+observations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "U. Rueda, R. Just, J.P. Galeotti, T.E. Vos, \"Unit testing tool competition: round four\", <em>Int. Workshop on Search-Based Software Testing (SBST)</em>, pp. 19-28, 2016.", "title": "Unit testing tool competition: round four", "context": [{"sec": "sec2a", "text": "The annual unit test generation tool competition [38] compares different unit test generation tools for Java, and although tools have made substantial progress in recent years, there remain several challenges.", "part": "1"}, {"sec": "sec5a", "text": " We chose EvoSuite and Randoop as representatives of state-of-the-art test generation tools for Java [38] and ran them with default configurations and a one minute time budget to generate 30 test suites per class per tool (to account for the randomized algorithms they implement).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2897010.2897018", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Unit+testing+tool+competition%3A+round+four&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "O. Scekic, H.-L. Truong, S. Dustdar, \"Incentives and rewarding in social computing\", <em>Communications of the ACM</em>, vol. 56, no. 6, pp. 72-82, 2013.", "title": "Incentives and rewarding in social computing", "context": [{"sec": "sec7h", "text": " Existing research on incentive mechanisms (e.g., [39]) may help to identify improvements.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2461256.2461275", "abstract": "Praise, pay, and promote crowd-member workers to elicit desired behavioral responses and performance levels.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Incentives+and+rewarding+in+social+computing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "D. Schuler, A. Zeller, \"Covering and uncovering equivalent mutants\", <em>Software Testing Verification and Reliability (STVR)</em>, vol. 23, no. 5, pp. 353-374, 2013.", "title": "Covering and uncovering equivalent mutants", "context": [{"sec": "sec2b", "text": " Different techniques and systems have been developed to detect equivalent mutants (e.g., [1], [31], [40]), but they are generally limited to certain types of mutants.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stvr.1473", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Covering+and+uncovering+equivalent+mutants&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "S. Shamshiri, R. Just, J.M. Rojas, G. Fraser, P. McMinn, A. Arcuri, \"Do automatically generated unit tests find real faults? an empirical study of effectiveness and challenges (T)\", <em>IEEE/ACM Int. Conference on Automated Software Engineering (ASE)</em>, pp. 201-211, 2015.", "title": "Do automatically generated unit tests find real faults? an empirical study of effectiveness and challenges (T)", "context": [{"sec": "sec2a", "text": " [41] identified several problems that hinder automatically generated unit tests from finding real faults.", "part": "1"}, {"sec": "sec5b", "text": " However, beyond running time, there are fundamental limitations in the tools [33], [41], [51] that our approach aims to overcome.", "part": "1"}, {"sec": "sec5c", "text": "The following test, created in the game played on class WeakHashtable, illustrates how players use stronger assertions than the regression assertions that automated tools are able to generate [41] (for example, by asserting on chains of calls, and using observers that take parameters):\n\n.", "part": "1"}], "links": {"documentLink": "/document/7372009", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372009", "abstract": "Rather than tediously writing unit tests manually, tools can be used to generate them automatically - sometimes even resulting in higher code coverage than manual testing. But how good are these tests at actually finding faults? To answer this question, we applied three state-of-the-art unit test generation tools for Java (Randoop, EvoSuite, and Agitar) to the 357 real faults in the Defects4J dataset and investigated how well the generated test suites perform at detecting these faults. Although ...", "pdfSize": "677KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+automatically+generated+unit+tests+find+real+faults%3F+an+empirical+study+of+effectiveness+and+challenges+%28T%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "L. Singer, K. Schneider, \"It was a bit of a race: Gamification of version control\", <em>Int. Workshop on Games and Software Engineering (GAS)</em>, pp. 5-8, 2012.", "title": "It was a bit of a race: Gamification of version control", "context": [{"sec": "sec6", "text": "There are several successful examples of gamification for software engineering, where the methodology has been applied mostly to increase the motivation and performance of people participating in software engineering activities [34], such as removing static analysis warnings [3] or committing changes often to version control [42].", "part": "1"}], "links": {"documentLink": "/document/6225927", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6225927", "abstract": "The adoption of software engineering practices cannot always be achieved by education or processes. However, social software has the potential for supporting deliberate behavior change. We present preliminary results of an experiment in which we encouraged computer science students to make more frequent commits to version control by using a social software application. We provided a web-based newsfeed of commits that also displayed a leaderboard. While we have yet to analyze the data, interviews...", "pdfSize": "397KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=It+was+a+bit+of+a+race%3A+Gamification+of+version+control&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "K.T. Stolee, S. Elbaum, \"Exploring the use of crowdsourcing to support empirical studies in software engineering\", <em>The ACM/IEEE Int. Symposium on Empirical Software Engineering and Measurement (ESEM)</em>, pp. 35:1-35:4, 2010.", "title": "Exploring the use of crowdsourcing to support empirical studies in software engineering", "context": [{"sec": "sec2c", "text": " In software engineering, crowdsourcing platforms such as Amazon Mechanical Turk, where crowd workers are paid small fees for completed tasks, are often used for empirical studies [43], but there are attempts to crowdsource various parts of the software development process [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1852786.1852832", "abstract": "The power and the generality of the findings obtained through empirical studies are bounded by the number and type of participating subjects. In software engineering, obtaining a large number of adequate subjects to evaluate a technique or tool is often a major challenge. In this work we explore the use of crowdsourcing as a mechanism to address that challenge by assisting in subject recruitment. More specifically, through this work we show how we adapted a study to be performed under an infrast...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+the+use+of+crowdsourcing+to+support+empirical+studies+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "<em>Apache Commons Libraries</em>, 2016,  [online]  Available: http://commons.apache.org/.", "title": "Apache Commons Libraries", "context": [{"sec": "sec5a", "text": "We followed a systematic procedure to select 20 classes from the SF110 [17] repository, which consists of randomly sampled SourceForge projects as well as the top ten most popular ones, and the Apache Commons (AC) libraries [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+Commons+Libraries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "N. Tillmann, J. De Halleux, \"Pex-white box test generation for. NET\", <em>Int. Conference on Tests and Proofs (TAP)</em>, pp. 134-153, 2008.", "title": "Pex-white box test generation for. NET", "context": [{"sec": "sec2a", "text": " For example, EvoSuite implements an experimental extension [18] that uses dynamic symbolic execution to generate primitive input values, and the Pex [45] tool uses dynamic symbolic execution to instantiate parameterized unit tests for C#.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pex-white+box+test+generation+for.+NET&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "N. Tillmann, J. De Halleux, T. Xie, J. Bishop, \"Pex4Fun: Teaching and learning computer science via social gaming\", <em>Conference on Software Engineering Education and Training</em>, pp. 90-91, 2012.", "title": "Pex4Fun: Teaching and learning computer science via social gaming", "context": [{"sec": "sec6", "text": "CodeHunt [7], based on Pex4Fun [46], is a game that integrates coding and test generation.", "part": "1"}], "links": {"documentLink": "/document/6245014", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6245014", "abstract": "Pex4Fun (http://www.pexforfun.com/) is a web-based serious gaming environment for teaching computer science. Pex4Fun can be used to teach and learn computer programming at many levels, from high school all the way through graduate courses. With Pex4Fun, a student edits code in any browser -- with Intellisense -- and Pex4Fun executes it and analyzes it in the cloud. Pex4Fun connects teachers, curriculum authors, and students in a unique social experience, tracking and streaming progress updates i...", "pdfSize": "256KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pex4Fun%3A+Teaching+and+learning+computer+science+via+social+gaming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "Y.-H. Tung, S.-S. Tseng, \"A novel approach to collaborative testing in a crowdsourcing environment\", <em>Journal of Systems and Software</em>, vol. 86, no. 8, pp. 2143-2153, 2013.", "title": "A novel approach to collaborative testing in a crowdsourcing environment", "context": [{"sec": "sec6", "text": " Testing has also been considered [47] as part of a general collaborative and crowdsourced approach to software engineering [26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2013.03.079", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+novel+approach+to+collaborative+testing+in+a+crowdsourcing+environment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "L. von Ahn, \"Duolingo: learn a language for free while helping to translate the web\", <em>Int. Conference on Intelligent User Interfaces (IUI)</em>, pp. 1-2, 2013.", "title": "Duolingo: learn a language for free while helping to translate the web", "context": [{"sec": "sec2c", "text": " Famous examples include ReCaptcha [49] or DuoLingo [48].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2449396.2449398", "abstract": "I want to translate the Web into every major language: every webpage, every video, and, yes, even Justin Bieber&#39;s tweets. With its content split up into hundreds of languages -- and with over 50% of it in English -- most of the Web is inaccessible to most people in the world. This problem is pressing, now more than ever, with millions of people from China, Russia, Latin America and other quickly developing regions entering the Web. In this talk, I introduce my new project, called Duolingo, which...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Duolingo%3A+learn+a+language+for+free+while+helping+to+translate+the+web&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "L. Von Ahn, B. Maurer, C. McMillen, D. Abraham, M. Blum, \"recaptcha: Human-based character recognition via web security measures\", <em>Science</em>, vol. 321, no. 5895, pp. 1465-1468, 2008.", "title": "recaptcha: Human-based character recognition via web security measures", "context": [{"sec": "sec2c", "text": " Famous examples include ReCaptcha [49] or DuoLingo [48].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=recaptcha%3A+Human-based+character+recognition+via+web+security+measures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "R. Wettel, M. Lanza, \"Visualizing software systems as cities\", <em>IEEE Int. Workshop on Visualizing Software for Understanding and Analysis</em>, pp. 92-99, 2007.", "title": "Visualizing software systems as cities", "context": [{"sec": "sec7b", "text": " Research on code visualization, for example the city metaphor [4], [50], may be well suited for this.", "part": "1"}], "links": {"documentLink": "/document/4290706", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4290706", "abstract": "This paper presents a 3D visualization approach which gravitates around the city metaphor, i.e., an object-oriented software system is represented as a city that can be traversed and interacted with: the goal is to give the viewer a sense of locality to ease program comprehension. The key point in conceiving a realistic software city is to map the information about the source code in meaningful ways in order to take the approach beyond beautiful pictures. We investigated several concepts that co...", "pdfSize": "7812KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Visualizing+software+systems+as+cities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "X. Xiao, T. Xie, N. Tillmann, J. De Halleux, \"Precise identification of problems for structural test generation\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 611-620, 2011.", "title": "Precise identification of problems for structural test generation", "context": [{"sec": "sec2a", "text": " [51] identify different challenges that hinder test generation tools in reaching code (e.g., object mutation, complex constraints, etc.), and Shamshiri et al. [41] identified several problems that hinder automatically generated unit tests from finding real faults.", "part": "1"}, {"sec": "sec5b", "text": " However, beyond running time, there are fundamental limitations in the tools [33], [41], [51] that our approach aims to overcome.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985876", "abstract": "An important goal of software testing is to achieve at least high structural coverage. To reduce the manual efforts of producing such high-covering test inputs, testers or developers can employ tools built based on automated structural test-generation approaches. Although these tools can easily achieve high structural coverage for simple programs, when they are applied on complex programs in practice, these tools face various problems, such as (1) the external-method-call problem (EMCP), where t...", "pdfSize": "439KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Precise+identification+of+problems+for+structural+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "X. Yao, M. Harman, Y. Jia, \"A study of equivalent and stubborn mutation operators using human analysis of equivalence\", <em>ACM/IEEE Int. Conference on Software Engineering (ICSE)</em>, pp. 919-930, 2014.", "title": "A study of equivalent and stubborn mutation operators using human analysis of equivalence", "context": [{"sec": "sec2b", "text": " Thus, human intervention is still required to discern hard-to-kill (or \u201cstubborn\u201d) mutants from equivalent ones [52].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568265", "abstract": "Though mutation testing has been widely studied for more than thirty years, the prevalence and properties of equivalent mutants remain largely unknown. We report on the causes and prevalence of equivalent mutants and their relationship to stubborn mutants (those that remain undetected by a high quality test suite, yet are non-equivalent). Our results, based on manual analysis of 1,230 mutants from 18 programs, reveal a highly uneven distribution of equivalence and stubbornness. For example, the ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+study+of+equivalent+and+stubborn+mutation+operators+using+human+analysis+of+equivalence&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "S. Zogaj, U. Bretschneider, J.M. Leimeister, \"Managing crowdsourced software testing: a case study based insight on the challenges of a crowdsourcing intermediary\", <em>Journal of Business Economics</em>, vol. 84, no. 3, pp. 375-405, 2014.", "title": "Managing crowdsourced software testing: a case study based insight on the challenges of a crowdsourcing intermediary", "context": [{"sec": "sec6", "text": " Crowdsourced testing is now a common practice in industry, but unlike Code Defenders the focus is mainly testing of mobile and web applications [53].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s11573-014-0721-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Managing+crowdsourced+software+testing%3A+a+case+study+based+insight+on+the+challenges+of+a+crowdsourcing+intermediary&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985704", "articleId": "7985704", "startPage": "677", "endPage": "688", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 3, "citationCountPatent": 0, "totalDownloads": 470}}
{"title": "Leveraging Artifact Trees to Evolve and Reuse Safety Cases", "authors": [{"name": "Ankit Agrawal", "affiliation": "University of Notre Dame", "firstName": "Ankit", "lastName": "Agrawal", "id": "37086946944"}, {"name": "Seyedehzahra Khoshmanesh", "affiliation": "Iowa State University", "firstName": "Seyedehzahra", "lastName": "Khoshmanesh", "id": "37086525932"}, {"name": "Michael Vierhauser", "affiliation": "University of Notre Dame", "firstName": "Michael", "lastName": "Vierhauser", "id": "37085612188"}, {"name": "Mona Rahimi", "affiliation": "Northern Illinois University", "firstName": "Mona", "lastName": "Rahimi", "id": "37085414105"}, {"name": "Jane Cleland-Huang", "affiliation": "University of Notre Dame", "firstName": "Jane", "lastName": "Cleland-Huang", "id": "38272771600"}, {"name": "Robyn Lutz", "affiliation": "Iowa State University", "firstName": "Robyn", "lastName": "Lutz", "id": "37285371100"}], "abstract": "Safety Assurance Cases (SACs) are increasingly used to guide and evaluate the safety of software-intensive systems. They are used to construct a hierarchically organized set of claims, arguments, and evidence in order to provide a structured argument that a system is safe for use. However, as the system evolves and grows in size, a SAC can be difficult to maintain. In this paper we utilize design science to develop a novel solution for identifying areas of a SAC that are affected by changes to the system. Moreover, we generate actionable recommendations for updating the SAC, including its underlying artifacts and trace links, in order to evolve an existing safety case for use in a new version of the system. Our approach, Safety Artifact Forest Analysis (SAFA), leverages traceability to automatically compare software artifacts from a previously approved or certified version with a new version of the system. We identify, visualize, and explain changes in a Delta Tree. We evaluate our approach using the Dronology system for monitoring and coordinating the actions of cooperating, small Unmanned Aerial Vehicles. Results from a user study show that SAFA helped users to identify changes that potentially impacted system safety and provided information that could be used to help maintain and evolve a SAC.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Vegetation", "Hazards", "Monitoring", "Thermostats", "Computer science", "Forestry"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["safety-critical software", "software reliability", "trees (mathematics)"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["artifact trees", "software-intensive systems", "structured argument", "trace links", "software artifacts", "safety assurance cases", "dronology system", "safety artifact forest analysis"]}, {"type": "Author Keywords ", "kwd": ["Change Impact, Safety Assurance Cases, Evolution, Traceability"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00124", "ref": [{"order": "1", "text": "<em>Graphviz-graph visualization software</em>,  [online]  Available: http://www.graphviz.org/.", "title": "Graphviz-graph visualization software", "context": [{"sec": "sec4", "text": " SAFA uses Graphviz [1] to dynamically lay out nodes into a tree structure.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Graphviz-graph+visualization+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Adelard. Claims Arguments and Evidence (CAE)</em>, 2017,  [online]  Available: https://www.adelard.com/asce.", "title": "Adelard. Claims, Arguments and Evidence (CAE)", "context": [{"sec": "sec1", "text": " Similarly, the Ministry of Defense in the UK requires all defense system contractors to provide SACs for their products and services [61]. \\$\\text{SACs}\\$. are also recommended by standards such as ISO 26262 for road vehicles, IEC 62425 for railway electronic systems, and IAEA SSG-23 for radioactive waste management systems [6], [17]. \\$\\text{SACs}\\$. can be modeled in various ways; however, the most common approaches are Goal Structuring Notation (GSN)[41] and Claims-Arguments-Evidence notation [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adelard.+Claims%2C+Arguments+and+Evidence+%28CAE%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>ArduPilot. SITL Simulator</em>, 2017,  [online]  Available: http://ardupilot.org/dev/docs/sitl-simulator-software-in-the-loop.html.", "title": "ArduPilot. SITL Simulator", "context": [{"sec": "sec5a", "text": " It also interfaces with the ArduPilot Software-in-the-loop \\$(\\text{SITL})\\$ simulator [3] to enable high-fidelity simulations.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ArduPilot.+SITL+Simulator&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Ardupilot Flight Controller</em>, 2017,  [online]  Available: http://ardupilot.org.", "title": "Ardupilot Flight Controller", "context": [{"sec": "sec5a", "text": " It includes a flight manager responsible for scheduling flight routes for multiple UAVs, basic collision avoidance, a flight activity logger, several UIs for planning routes, monitoring UAVs in real time, registering UAVs, and a Ground Control Station (GCS) middleware, as well as a con- crete implementation for communicating and controlling both simulated and physical \\$\\text{UAVs}\\$ The Dronology GCS interfaces with ArduPilot-based \\$\\text{UAVs}\\$ [4] and has been flight-tested with five different physical \\$\\text{UAV}\\$ models.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ardupilot+Flight+Controller&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>Atlassian. Jira issue tracking system</em>,  [online]  Available: https://www.atlassian.com/software/jira.", "title": "Atlassian. Jira issue tracking system", "context": [{"sec": "sec4", "text": " It is implemented in Java with interfaces to Jira [5] and GitHub [27] repositories; however, it could easily be extended to interface with other repositories such as DOORS or Bitbucket.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Atlassian.+Jira+issue+tracking+system&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "J. Birch, R. Rivett, I. Habli, B. Bradshaw, J. Botham, D. Higham, P. Jesty, H. Monkhouse, R. Palin, \"Safety cases and their role in ISO 26262 functional safety assessment\", <em>Proc. of the Int'l Conf. on Computer Safety Reliability and Security</em>, pp. 154-165, 2013.", "title": "Safety cases and their role in ISO 26262 functional safety assessment", "context": [{"sec": "sec1", "text": " Similarly, the Ministry of Defense in the UK requires all defense system contractors to provide SACs for their products and services [61]. \\$\\text{SACs}\\$. are also recommended by standards such as ISO 26262 for road vehicles, IEC 62425 for railway electronic systems, and IAEA SSG-23 for radioactive waste management systems [6], [17]. \\$\\text{SACs}\\$. can be modeled in various ways; however, the most common approaches are Goal Structuring Notation (GSN)[41] and Claims-Arguments-Evidence notation [2].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-40793-2_15", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safety+cases+and+their+role+in+ISO+26262+functional+safety+assessment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "P. Bishop, R. Bloomfield, \"A Methodology for Safety Case Development\" in Ind. Perspect. Safety-critical Syst., Springer London, vol. 19, pp. 194-203, 1998.", "title": "A Methodology for Safety Case Development", "context": [{"sec": "sec1", "text": " Additionally, these arguments are supported by evidence such as test results, formal reviews, or simulations [7].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4471-1534-2_14", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Methodology+for+Safety+Case+Development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "P. Bishop, R. Bloomfield, S. Guerra, \"The future of goal-based assurance cases\", <em>Proc. of Workshop on Assurance Cases</em>, pp. 390-395, 2004.", "title": "The future of goal-based assurance cases", "context": [{"sec": "sec2", "text": " During the information gathering and analysis phase, we reviewed literature related to the use of Safety Assurance Cases (e.g., [8], [9], [41]) and traceability in safety-critical projects (e.g., [32], [33], [50]) including case studies and examples of completed SACs.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+future+of+goal-based+assurance+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "R. Bloomfield, P. Bishop, \"Safety and assurance cases: Past present and possible future-an Adelard perspective\" in Making Systems Safer, Springer, pp. 51-67, 2010.", "title": "Safety and assurance cases: Past, present and possible future-an Adelard perspective", "context": [{"sec": "sec1", "text": " A Safety Assurance Case (SAC)[9], [37] organizes goal-oriented or claim-based safety arguments [33] into a tree structure by decomposing a top-level safety goal or claim into several layers of arguments.", "part": "1"}, {"sec": "sec2", "text": " During the information gathering and analysis phase, we reviewed literature related to the use of Safety Assurance Cases (e.g., [8], [9], [41]) and traceability in safety-critical projects (e.g., [32], [33], [50]) including case studies and examples of completed SACs.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-84996-086-1_4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safety+and+assurance+cases%3A+Past%2C+present+and+possible+future-an+Adelard+perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "L. Briand, D. Falessi, S. Nejati, M. Sabetzadeh, T. Yue, \"Traceability and SysML design slices to support safety inspections: A controlled experiment\", <em>ACM Transactions on Software Engineering and Methodology (TOSEM)</em>, vol. 23, no. 1, 9 2014.", "title": "Traceability and SysML design slices to support safety inspections: A controlled experiment", "context": [{"sec": "sec8", "text": " [10] explored the use of SafeSlice to support the safety inspection process.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2559978", "abstract": "Certifying safety-critical software and ensuring its safety requires checking the conformance between safety requirements and design. Increasingly, the development of safety-critical software relies on modeling, and the System Modeling Language (SysML) is now commonly used in many industry sectors. Inspecting safety conformance by comparing design models against safety requirements requires safety inspectors to browse through large models and is consequently time consuming and error-prone. To ad...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Traceability+and+SysML+design+slices+to+support+safety+inspections%3A+A+controlled+experiment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "J. Chen, M. Goodrum, R. A. Metoyer, J. Cleland-Huang, \"How do practitioners perceive assurance cases in safety-critical software systems?\", <em>Proc. of the 11th Int'l Workshop on Cooperative and Human Aspects of Software Engineering</em>, pp. 57-60, 2018.", "title": "How do practitioners perceive assurance cases in safety-critical software systems?", "context": [{"sec": "sec1", "text": "Despite a number of papers discussing the use of SACs, problems associated with their evolution and maintenance have not yet been effectively addressed [11].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3195836.3195838", "abstract": "Safety-critical software systems are those whose failure or malfunction could result in casualty and/or serious financial loss. In such systems, safety assurance cases (SACs) are an emerging approach that adopts a proactive strategy to produce structuralized safety justifications and arguments. While SACs are recommended in many software-intensive safety-critical domains, the lack of knowledge regarding the practitioners&#39; perspectives on using SACs hinders effective adoption of this approach. To...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+practitioners+perceive+assurance+cases+in+safety-critical+software+systems%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "J. Cleland-Huang, M. Heimdahl, J. H. Hayes, R. Lutz, P. Maeder, \"Trace queries for safety requirements in high assurance systems\", <em>Proc. of the Int'l Working Conf. on Requirements Engineering: Foundation for software quality</em>, pp. 179-193, 2012.", "title": "Trace queries for safety requirements in high assurance systems", "context": [{"sec": "sec2a", "text": " We used the TIM depicted in Table I throughout our process, which depicts artifacts and their associations as commonly adopted across many safety critical development processes [12], [47], [53].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-28714-5_16", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Trace+queries+for+safety+requirements+in+high+assurance+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. Cleland-Huang, M. Rahimi, P. M\u00e4der, \"Achieving lightweight trustworthy traceability\", <em>Proc. of the 22nd ACM SIGSOFT Int'l Symp. on Foundations of Software Engineering</em>, pp. 849-852, 2014.", "title": "Achieving lightweight trustworthy traceability", "context": [{"sec": "sec2b", "text": " The trace links used by SAFA are required in most safety-critical domains [57], therefore our approach adds minimal overhead to the traceability effort [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2666612", "abstract": "Despite the fact that traceability is a required element of almost all safety-critical software development processes, the trace data is often incomplete, inaccurate, redundant, conflicting, and outdated. As a result, it is neither trusted nor trustworthy. In this vision paper we propose a philosophical change in the traceability landscape which transforms traceability from a heavy-weight process producing untrusted trace links, to a light-weight results-oriented trustworthy solution. Current tr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Achieving+lightweight+trustworthy+traceability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "J. Cleland-Huang, M. Vierhauser, \"Discovering analyzing and managing safety stories in agile projects\", <em>Proc. of the 26th IEEE Int'l Requirements Engineering Conf.</em>, pp. 262-273, 2018.", "title": "Discovering, analyzing, and managing safety stories in agile projects", "context": [{"sec": "sec2", "text": " We then used those trees to build a SAC for each leaf hazard in order to evaluate the safety of our own system (Dronology) under development [14], [15], using our observations from this experience to improve the design of SAFA.", "part": "1"}], "links": {"documentLink": "/document/8491141", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8491141", "abstract": "Traditionally, safety-critical projects have been developed using the waterfall process. However, this makes it costly and challenging to incrementally introduce new features and to certify the modified product for use. As a result, there has been increasing interest in adopting agile development paradigms within the safety-critical domain. This in turn introduces numerous challenges. In this paper we address the specific problems of discovering, analyzing, specifying, and managing safety requir...", "pdfSize": "392KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Discovering%2C+analyzing%2C+and+managing+safety+stories+in+agile+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "J. Cleland-Huang, M. Vierhauser, S. Bayley, \"Dronology: an incubator for cyber-physical systems research\", <em>Proc. of the 40th Int'l Conf. on Software Engineering: New Ideas and Emerging Results</em>, pp. 109-112, 2018.", "title": "Dronology: an incubator for cyber-physical systems research", "context": [{"sec": "sec1", "text": " Section V describes SAFA's application to the Dronology system [15] and Section VI presents a controlled user study.", "part": "1"}, {"sec": "sec2", "text": " We then used those trees to build a SAC for each leaf hazard in order to evaluate the safety of our own system (Dronology) under development [14], [15], using our observations from this experience to improve the design of SAFA.", "part": "1"}, {"sec": "sec5a", "text": "We evaluated SAFA within the context of the Dronology system, which provides features for managing, monitoring, coordinating, and controlling small unmanned aerial vehicles (UAVs)[15].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183399.3183408", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dronology%3A+an+incubator+for+cyber-physical+systems+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "B. Dagenais, S. Breu, F. W. Warr, M. P. Robillard, \"Inferring structural patterns for concern traceability in evolving software\", <em>Proc. of the 22nd IEEE/ACM Int'l Conf. on Automated Software Engineering</em>, pp. 254-263, 2007.", "title": "Inferring structural patterns for concern traceability in evolving software", "context": [{"sec": "sec8", "text": "Several approaches have been proposed that automate traceability across diverse artifacts [16], [26], [52].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1321631.1321669", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inferring+structural+patterns+for+concern+traceability+in+evolving+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "R. Dardar, B. Gallina, A. Johnsen, K. Lundqvist, M. Nyberg, \"Industrial experiences of building a safety case in compliance with iso 26262\", <em>Proc. of the 23rd Int'l Symp. on Software Reliability Engineering Workshops</em>, pp. 349-354, 2012.", "title": "Industrial experiences of building a safety case in compliance with iso 26262", "context": [{"sec": "sec1", "text": " Similarly, the Ministry of Defense in the UK requires all defense system contractors to provide SACs for their products and services [61]. \\$\\text{SACs}\\$. are also recommended by standards such as ISO 26262 for road vehicles, IEC 62425 for railway electronic systems, and IAEA SSG-23 for radioactive waste management systems [6], [17]. \\$\\text{SACs}\\$. can be modeled in various ways; however, the most common approaches are Goal Structuring Notation (GSN)[41] and Claims-Arguments-Evidence notation [2].", "part": "1"}], "links": {"documentLink": "/document/6405468", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6405468", "abstract": "The ISO 26262 functional safety standard provides appropriate development processes, requirements and safety integrity levels specific for the automotive domain. One crucial requirement consists of the creation of a safety case, a structured argument, which inter-relates evidence and claims, needed to show that safety-critical systems are acceptably safe. The standard is currently not mandatory to be applied to safety critical systems installed in heavy trucks, however, this is likely to be chan...", "pdfSize": "389KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Industrial+experiences+of+building+a+safety+case+in+compliance+with+iso+26262&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "E. Denney, G. Pai, \"Automating the assembly of aviation safety cases\", <em>IEEE Transactions on Reliability</em>, vol. 63(, no. 4, pp. 830-849, 2014.", "title": "Automating the assembly of aviation safety cases", "context": [{"sec": "sec8", "text": " Denney and Pai [18] automatically assembled auto-generated formal method sections of a \\$\\text{SAC}\\$ with manual parts and showed that integration of heterogeneous safety aspects can improve the correctness of safety assurance cases.", "part": "1"}], "links": {"documentLink": "/document/6866924", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6866924", "abstract": "Safety cases are among the state of the art in safety management mechanisms, providing an explicit way to reason about system and software safety. The intent is to provide convincing, valid, comprehensive assurance that a system is acceptably safe for a given application in a defined operating environment, by creating an argument structure that links claims about safety to a body of evidence. However, their construction is a largely manual, and therefore a time consuming, error prone, and expens...", "pdfSize": "2147KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automating+the+assembly+of+aviation+safety+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J. Dick, M. E. C. Hull, K. Jackson, Requirements Engineering, Springer, 2017.", "title": "Requirements Engineering", "context": [{"sec": "sec2d", "text": " [19], [42].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-61073-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Requirements+Engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "D. Dig, C. Comertoglu, D. Marinov, R. E. Johnson, \"Automated detection of refactorings in evolving components\", <em>Proc. of the 20th European Conf. on Object-Oriented Programming</em>, pp. 404-428, 2006.", "title": "Automated detection of refactorings in evolving components", "context": [{"sec": "sec3b", "text": "It employs a combination of information retrieval techniques (namely the Vector Space Model)[36], [48] and a refactoring detection tool [20] to detect 24 change scenarios organized into the six high-level change categories of add class, delete class, add method, delete method, modify method, and basic.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/11785477_24", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+detection+of+refactorings+in+evolving+components&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "L. Duan, S. Rayadurgam, M. P. E. Heimdahl, O. Sokolsky, I. Lee, \"Representing Confidence in Assurance Case Evidence\", <em>Proc. of the Int'l Conf. Comput. Safety Reliab. Secur.</em>, pp. 15-26, 2014.", "title": "Representing Confidence in Assurance Case Evidence", "context": [{"sec": "sec1", "text": " Challenges include a lack of guidance for constructing effective safety arguments [60], a tendency to suffer from confirmation bias [47], an over reliance on the regulation culture [59], and lack of focus on confidence and uncertainty issues [21], [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-24249-1_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Representing+Confidence+in+Assurance+Case+Evidence&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "D. Falessi, S. Nejati, M. Sabetzadeh, L. Briand, A. Messina, \"SafeSlice: a model slicing and design safety inspection tool for sysml\", <em>Proc. of the 19th ACM SIGSOFT Symp. and the 13th European Conf. on Foundations of Software Engineering</em>, pp. 460-463, 2011.", "title": "SafeSlice: a model slicing and design safety inspection tool for sysml", "context": [{"sec": "sec8", "text": " [22] present SafeSlice that uses a \\$\\text{TIM}\\$ to guide the extraction of design slices with respect to functional safety requirements.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025191", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SafeSlice%3A+a+model+slicing+and+design+safety+inspection+tool+for+sysml&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "M. Felici, \"Modeling safety case evolution - examples from the air traffic management domain\", <em>Proc. of the Int'l Workshop on Rapid Integration of Software Engineering Techniques Revised Selected Papers</em>, pp. 81-96, 2005.", "title": "Modeling safety case evolution - examples from the air traffic management domain", "context": [{"sec": "sec8", "text": " For example, Jardat et al. [38], [39] used uncertainty analysis to extract contracts from Fault Tree Analyses \\$\\mathrm{(FTA)}\\$ and to trace changes to the safety argument, while Felici [23] detected structural changes and content changes in nodes between two safety cases.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/11751113_7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+safety+case+evolution+-+examples+from+the+air+traffic+management+domain&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "\"Food and Drug Administration\", <em>General Principles of Software Validation; Final Guidance for Industry and FDA Staff 2002</em>.", "title": "Food and Drug Administration", "context": [{"sec": "sec1", "text": " For example, the US Food and Drug Administration (FDA) has issued formal guidelines requiring infusion pump manufacturers to submit \\$\\text{SACs}\\$. as part of the safety approval process [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Food+and+Drug+Administration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "M. Fowler, Refactoring: Improving the Design of Existing Code, Boston, MA, USA:Addison-Wesley Longman Publishing Co., Inc., 1999.", "title": "Refactoring: Improving the Design of Existing Code", "context": [{"sec": "sec3b", "text": " TLE is a publicly available tool designed to detect a set of change scenarios based primarily on Fowler's dictionary of source code refactorings [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Refactoring%3A+Improving+the+Design+of+Existing+Code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "A. Ghabi, A. Egyed, \"Exploiting traceability uncertainty among artifacts and code\", <em>Journal of Systems and Software</em>, vol. 108, pp. 178-192, 2015.", "title": "Exploiting traceability uncertainty among artifacts and code", "context": [{"sec": "sec8", "text": "Several approaches have been proposed that automate traceability across diverse artifacts [16], [26], [52].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2015.06.037", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploiting+traceability+uncertainty+among+artifacts+and+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>Github</em>,  [online]  Available: https://www.github.com.", "title": "Github", "context": [{"sec": "sec4", "text": " It is implemented in Java with interfaces to Jira [5] and GitHub [27] repositories; however, it could easily be extended to interface with other repositories such as DOORS or Bitbucket.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Github&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "P. J. Graydon, C. M. Holloway, \"An investigation of proposed techniques for quantifying confidence in assurance arguments\", <em>Saf. Sci.</em>, vol. 92, pp. 53-65, feb 2017.", "title": "An investigation of proposed techniques for quantifying confidence in assurance arguments", "context": [{"sec": "sec1", "text": " SACs are therefore a useful and well-established technique for supporting developers, architects, safety analysts, and other project stakeholders as they proactively build, evaluate, and provide evidence for the safety of a system [28], [61].", "part": "1"}, {"sec": "sec1", "text": " Challenges include a lack of guidance for constructing effective safety arguments [60], a tendency to suffer from confirmation bias [47], an over reliance on the regulation culture [59], and lack of focus on confidence and uncertainty issues [21], [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.ssci.2016.09.014", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+investigation+of+proposed+techniques+for+quantifying+confidence+in+assurance+arguments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "W. S. Greenwell, E. A. Strunk, J. C. Knight, \"Failure analysis and the safety-case lifecycle\", <em>Proc. of the IFIP 18th World Computer Congress TC13 / WG13.5 7th Working Conf. on Human Error Safety and Systems Development</em>, vol. 152 of IFIP, pp. 163-176, 2004.", "title": "Failure analysis and the safety-case lifecycle", "context": [{"sec": "sec8", "text": " [29] introduced the safety case life cycle which feeds failure history of a system back into the \\$\\text{SAC}\\$ to find faulty assumptions or evidence and to recommend revisions.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/1-4020-8153-7_11", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Failure+analysis+and+the+safety-case+lifecycle&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "J. Guo, N. Monaikul, J. Cleland-Huang, \"Trace links explained: An automated approach for generating rationales\", <em>Proc. of the 23rd IEEE Int'l Requirements Engineering Conf.</em>, pp. 202-207, 2015.", "title": "Trace links explained: An automated approach for generating rationales", "context": [{"sec": "sec2d", "text": " In the context of \\$\\text{SAFA}\\$. this means that the analyst must carefully evaluate contextual information in the Safety Tree and incrementally refine it by adding additional arguments and contextual information so that the rationale for each claim is sufficiently clear [30].", "part": "1"}], "links": {"documentLink": "/document/7320423", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7320423", "abstract": "Software Traceability is a critical element in all safety critical software systems. Trace links are created across diverse artifacts such as requirements, design, code, test cases, and hazards - either manually or with the help of supporting tools. The links are then used to support a range of software engineering activities including impact analysis, compliance verification, and safety inspections. For traceability to effectively support these activities it is important for the meaning and rat...", "pdfSize": "262KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Trace+links+explained%3A+An+automated+approach+for+generating+rationales&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "M. Hammad, M. L. Collard, J. I. Maletic, \"Automatically identifying changes that impact code-to-design traceability during evolution\", <em>Software Quality Journal</em>, vol. 19, no. 1, pp. 35-64, 2011.", "title": "Automatically identifying changes that impact code-to-design traceability during evolution", "context": [{"sec": "sec8", "text": " Several researchers have also investigated impact analysis from the perspective of system evolution - for example identifying the impact of operational anomalies [49] or source code changes on design [31].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s11219-010-9103-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+identifying+changes+that+impact+code-to-design+traceability+during+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "R. Hawkins, K. Clegg, R. Alexander, T. Kelly, \"Using a software safety argument pattern catalogue: Two case studies\", <em>Proc. of the Int'l Conf. on Computer Safety Reliability and Security</em>, pp. 185-198, 2011.", "title": "Using a software safety argument pattern catalogue: Two case studies", "context": [{"sec": "sec2", "text": " During the information gathering and analysis phase, we reviewed literature related to the use of Safety Assurance Cases (e.g., [8], [9], [41]) and traceability in safety-critical projects (e.g., [32], [33], [50]) including case studies and examples of completed SACs.", "part": "1"}, {"sec": "sec2c", "text": " The heuristics for node insertion were derived from several literature sources describing guidelines for constructing safety arguments [32], [35], [42], [43].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-24270-0_14", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+a+software+safety+argument+pattern+catalogue%3A+Two+case+studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "R. Hawkins, I. Habli, T. Kelly, J. McDermid, \"Assurance cases and prescriptive software safety certification: A comparative study\", <em>Saf. Sci.</em>, vol. 59, pp. 55-71, 2013.", "title": "Assurance cases and prescriptive software safety certification: A comparative study", "context": [{"sec": "sec1", "text": " A Safety Assurance Case (SAC)[9], [37] organizes goal-oriented or claim-based safety arguments [33] into a tree structure by decomposing a top-level safety goal or claim into several layers of arguments.", "part": "1"}, {"sec": "sec2", "text": " During the information gathering and analysis phase, we reviewed literature related to the use of Safety Assurance Cases (e.g., [8], [9], [41]) and traceability in safety-critical projects (e.g., [32], [33], [50]) including case studies and examples of completed SACs.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.ssci.2013.04.007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Assurance+cases+and+prescriptive+software+safety+certification%3A+A+comparative+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "R. Hawkins, T. Kelly, \"A Systematic Approach for Developing Software Safety Arguments\", <em>27th Int. Syst. Saf. Conf.</em>, pp. 25-33, 2009.", "title": "A Systematic Approach for Developing Software Safety Arguments", "context": [{"sec": "sec1", "text": " Furthermore, SACs need to co-evolve with the system they represent, requiring analysts to identify the impact of a system change and to recognize when seemingly innocuous changes in the operating environment impact the \\$\\text{SACs}\\$. validity [34].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Systematic+Approach+for+Developing+Software+Safety+Arguments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "R. Hawkins, T. Kelly, J. Knight, P. Graydon, \"A new approach to creating clear safety arguments\", <em>Advances in Systems Safety</em>, pp. 3-23, 2011.", "title": "A new approach to creating clear safety arguments", "context": [{"sec": "sec2c", "text": " The heuristics for node insertion were derived from several literature sources describing guidelines for constructing safety arguments [32], [35], [42], [43].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-0-85729-133-2_1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+new+approach+to+creating+clear+safety+arguments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "J. H. Hayes, A. Dekhtyar, S. K. Sundaram, \"Advancing candidate link generation for requirements tracing: The study of methods\", <em>IEEE Trans. Softw. Eng.</em>, vol. 32, no. 1, pp. 4-19, 2006.", "title": "Advancing candidate link generation for requirements tracing: The study of methods", "context": [{"sec": "sec3b", "text": "It employs a combination of information retrieval techniques (namely the Vector Space Model)[36], [48] and a refactoring detection tool [20] to detect 24 change scenarios organized into the six high-level change categories of add class, delete class, add method, delete method, modify method, and basic.", "part": "1"}], "links": {"documentLink": "/document/1583599", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1583599", "abstract": "This paper addresses the issues related to improving the overall quality of the dynamic candidate link generation for the requirements tracing process for verification and validation and independent verification and validation analysts. The contribution of the paper is four-fold: we define goals for a tracing tool based on analyst responsibilities in the tracing process, we introduce several new measures for validating that the goals have been satisfied, we implement analyst feedback in the trac...", "pdfSize": "2833KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Advancing+candidate+link+generation+for+requirements+tracing%3A+The+study+of+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "C. M. Holloway, \"Safety case notations: Alternatives for the non-graphically inclined?\", <em>Proc. of the 3rd IET Int'l Conf. on System Safety</em>, pp. 1-6, 2008.", "title": "Safety case notations: Alternatives for the non-graphically inclined?", "context": [{"sec": "sec1", "text": " A Safety Assurance Case (SAC)[9], [37] organizes goal-oriented or claim-based safety arguments [33] into a tree structure by decomposing a top-level safety goal or claim into several layers of arguments.", "part": "1"}], "links": {"documentLink": "/document/4781267", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4781267", "abstract": "This working paper presents preliminary ideas of five possible text-based notations for representing safety cases, which may be easier for non-graphically inclined people to use and understand than the currently popular graphics-based representations.", "pdfSize": "968KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safety+case+notations%3A+Alternatives+for+the+non-graphically+inclined%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "O. Jaradat, I. Bate, S. Punnekkat, \"Using sensitivity analysis to facilitate the maintenance of safety cases\", <em>Proc. of the Ada-Europe Int'l Conf. on Reliable Software Technologies</em>, pp. 162-176, 2015.", "title": "Using sensitivity analysis to facilitate the maintenance of safety cases", "context": [{"sec": "sec8", "text": " [38], [39] used uncertainty analysis to extract contracts from Fault Tree Analyses \\$\\mathrm{(FTA)}\\$ and to trace changes to the safety argument, while Felici [23] detected structural changes and content changes in nodes between two safety cases.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-19584-1_11", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+sensitivity+analysis+to+facilitate+the+maintenance+of+safety+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "O. Jaradat, I. Bate, S. Punnekkat, \"Facilitating the maintenance of safety cases\" in Current Trends in Reliability Availability Maintainability and Safety, Springer, pp. 349-371, 2016.", "title": "Facilitating the maintenance of safety cases", "context": [{"sec": "sec8", "text": " For example, Jardat et al. [38], [39] used uncertainty analysis to extract contracts from Fault Tree Analyses \\$\\mathrm{(FTA)}\\$ and to trace changes to the safety argument, while Felici [23] detected structural changes and content changes in nodes between two safety cases.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-23597-4_25", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Facilitating+the+maintenance+of+safety+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "S. Kan, \"Traceability and model checking to support safety requirement verification\", <em>Proc. of the 22nd ACM SIGSOFT Int'l Symp. on Foundations of Software Engineering</em>, pp. 783-786, 2014.", "title": "Traceability and model checking to support safety requirement verification", "context": [{"sec": "sec8", "text": " Other closely related work focuses on generating artifact slices or using formal verification techniques to support safety analysis [40], [58].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2666606", "abstract": "Ensuring safety-critical software safety requires strict verification of the conformance between safety requirements and programs. Formal verification techniques, such as model checking and theorem proving, can be used to partially realize this objective. DO-178C, a standard for airborne systems, allows formal verification techniques to replace certain forms of testing. My research is concerned with applying model checking to verify the conformance between safety requirements and programs. First...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Traceability+and+model+checking+to+support+safety+requirement+verification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "T. Kelly, R. Weaver, \"The Goal Structuring Notation-a safety argument notation\", <em>Proc. of the Dependable Systems and Networks 2004 WS on Assurance Cases</em>, pp. 6, 2004.", "title": "The Goal Structuring Notation-a safety argument notation", "context": [{"sec": "sec1", "text": " Similarly, the Ministry of Defense in the UK requires all defense system contractors to provide SACs for their products and services [61]. \\$\\text{SACs}\\$. are also recommended by standards such as ISO 26262 for road vehicles, IEC 62425 for railway electronic systems, and IAEA SSG-23 for radioactive waste management systems [6], [17]. \\$\\text{SACs}\\$. can be modeled in various ways; however, the most common approaches are Goal Structuring Notation (GSN)[41] and Claims-Arguments-Evidence notation [2].", "part": "1"}, {"sec": "sec2", "text": " During the information gathering and analysis phase, we reviewed literature related to the use of Safety Assurance Cases (e.g., [8], [9], [41]) and traceability in safety-critical projects (e.g., [32], [33], [50]) including case studies and examples of completed SACs.", "part": "1"}, {"sec": "sec2", "text": " We adopt the Goal Structuring Notation [41].", "part": "1"}, {"sec": "sec8", "text": "In the area of \\$\\text{SAC}\\$ maintenance, Kelly and Weaver [41] presented a set of patterns and recommended the use of modularity to support \\$\\text{SAC}\\$ evolution.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Goal+Structuring+Notation-a+safety+argument+notation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "T. P. Kelly, <em>Arguing safety: a systematic approach to managing safety cases</em>, 1999.", "title": "Arguing safety: a systematic approach to managing safety cases", "context": [{"sec": "sec2c", "text": " The heuristics for node insertion were derived from several literature sources describing guidelines for constructing safety arguments [32], [35], [42], [43].", "part": "1"}, {"sec": "sec2d", "text": " Finally, safety arguments need sufficient contextual information to enable future maintainers to understand the claims and to modify the \\$\\text{SAC}\\$. [19], [42].", "part": "1"}, {"sec": "sec3", "text": " Kelly [42] provides examples of change scenarios that could impact system safety and trigger the need to review and potentially update the \\$\\text{SAC}\\$.", "part": "1"}, {"sec": "sec3a", "text": "Kelly identified three ways in which changes to a \\$\\text{SAC}\\$. argument structure could challenge its integrity [42].", "part": "1"}, {"sec": "sec3c", "text": "actual recovery [42].", "part": "1"}, {"sec": "sec5c", "text": " This confirmed previous observations by Kelly [42].", "part": "1"}, {"sec": "sec6a", "text": " They were then asked the following question which was designed to evaluate the extent to which SAFA supported key steps in Kelly's safety case change process for recognizing challenges to the validity of the safety case [42]: (Q1) \u201cWith respect to this hazard, has the system changed in a way that potentially affects its safety? If so please explain your answer.\u201d After the participant had evaluated all six hazards we asked three additional questions. (Q2) \u201cWas the information provided to you for each of the two methods sufficient for assessing the impact of change upon system safety?\u201d; (Q3) \u201cWhich of the two methods did you prefer using? Why?\u201d; and finally (Q4) \u201cCan you suggest any improvements for the Delta Views?\u201d.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Arguing+safety%3A+a+systematic+approach+to+managing+safety+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "T. P. Kelly, J. A. McDermid, \"A systematic approach to safety case maintenance\", <em>Reliability Engineering & System Safety</em>, vol. 71, no. 3, 2001.", "title": "A systematic approach to safety case maintenance", "context": [{"sec": "sec1", "text": " The differences between the two safety trees are then depicted in a Delta view (see Fig. 1.c), and SAFA then generates warnings within each Safety Tree to highlight changes that potentially undermine system safety [43].", "part": "1"}, {"sec": "sec2c", "text": " The heuristics for node insertion were derived from several literature sources describing guidelines for constructing safety arguments [32], [35], [42], [43].", "part": "1"}, {"sec": "sec3c", "text": " We incorporated a preliminary set of recommendations into SAFA based on the change scenarios discussed by Kelly and McDermid [43] and also our own observations from developing the Dronology systems of how change events impact SACs.", "part": "1"}, {"sec": "sec3c", "text": " Kelly and McDermid [43] reported that when the integrity of a safety case is challenged, responsible parties should decide on an appropriate response ranging from a complete revision of the safety case to doing \u201cnothing at all\u201d.", "part": "1"}, {"sec": "sec8", "text": " Kelly and McDermid [43] investigated changes in evidence, context, assumption and requirements \\$\\text{GSN}\\$ nodes to determine how changes impact the safety assurance case.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0951-8320(00)00079-X", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+approach+to+safety+case+maintenance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "J. Knight, Fundamentals of Dependable Computing for Software Engineers, Chapman Hall/CRC, 2011.", "title": "Fundamentals of Dependable Computing for Software Engineers", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fundamentals+of+Dependable+Computing+for+Software+Engineers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "J. C. Knight, \"Safety critical systems: challenges and directions\", <em>Proc. of the 24th Int'l Conf. on Software Engineering</em>, pp. 547-550, 2002.", "title": "Safety critical systems: challenges and directions", "context": [{"sec": "sec1", "text": "Safety-critical software systems represent a class of systems whose failure or malfunction could result in casualties or serious financial loss [45].", "part": "1"}], "links": {"documentLink": "/document/1007998", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1007998", "abstract": "Safety-critical systems are those systems whose failure could result in loss of life, significant property damage or damage to the environment. There are many well-known examples in application areas such as medical devices, aircraft flight control, weapons and nuclear systems. Many modern information systems are becoming safety-critical in a general sense because financial loss and even loss of life can result from their failure. Future safety-critical systems will be more common and more power...", "pdfSize": "461KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safety+critical+systems%3A+challenges+and+directions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "S. Kokaly, R. Salay, V. Cassano, T. Maibaum, M. Chechik, \"A model management approach for assurance case reuse due to system evolution\", <em>Proc. of the ACM/IEEE 19th Int'l Conf. on Model Driven Engineering Languages and Systems</em>, pp. 196-206, 2016.", "title": "A model management approach for assurance case reuse due to system evolution", "context": [{"sec": "sec8", "text": " [46] use a \\$\\mathrm{KAOS}\\$ goal tree to describe an assurance case and annotated evidence nodes when a change occurred.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2976767.2976792", "abstract": "Evolution in software systems is a necessary activity that occurs due to fixing bugs, adding functionality or improving system quality. Systems often need to be shown to comply with regulatory standards. Along with demonstrating compliance, an artifact, called an assurance case, is often produced to show that the system indeed satisfies the property imposed by the standard (e.g., safety, privacy, security, etc.). Since each of the system, the standard, and the assurance case can be presented as ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+model+management+approach+for+assurance+case+reuse+due+to+system+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "N. G. Leveson, \"The Use of Safety Cases in Certification and Regulation\", <em>Technical report MIT</em>, 2011.", "title": "The Use of Safety Cases in Certification and Regulation", "context": [{"sec": "sec1", "text": " Challenges include a lack of guidance for constructing effective safety arguments [60], a tendency to suffer from confirmation bias [47], an over reliance on the regulation culture [59], and lack of focus on confidence and uncertainty issues [21], [28].", "part": "1"}, {"sec": "sec2a", "text": " We used the TIM depicted in Table I throughout our process, which depicts artifacts and their associations as commonly adopted across many safety critical development processes [12], [47], [53].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Use+of+Safety+Cases+in+Certification+and+Regulation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "A. D. Lucia, A. Marcus, R. Oliveto, D. Poshyvanyk, \"Information retrieval methods for automated traceability recovery\", <em>Software and Systems Traceability.</em>, pp. 71-98, 2012.", "title": "Information retrieval methods for automated traceability recovery", "context": [{"sec": "sec2b", "text": " Such trace links can be created manually, generated using an automated approach [48], or mined from commit messages [56].", "part": "1"}, {"sec": "sec3b", "text": "It employs a combination of information retrieval techniques (namely the Vector Space Model)[36], [48] and a refactoring detection tool [20] to detect 24 change scenarios organized into the six high-level change categories of add class, delete class, add method, delete method, modify method, and basic.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4471-2239-5_4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Information+retrieval+methods+for+automated+traceability+recovery&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "R. R. Lutz, A. Patterson-Hine, S. Nelson, C. R. Frost, D. Tal, R. Harris, \"Using obstacle analysis to identify contingency requirements on an unpiloted aerial vehicle\", <em>Requir: Eng.</em>, vol. 12, no. 1, pp. 41-54, 2007.", "title": "Using obstacle analysis to identify contingency requirements on an unpiloted aerial vehicle", "context": [{"sec": "sec8", "text": " Several researchers have also investigated impact analysis from the perspective of system evolution - for example identifying the impact of operational anomalies [49] or source code changes on design [31].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s00766-006-0039-4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+obstacle+analysis+to+identify+contingency+requirements+on+an+unpiloted+aerial+vehicle&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "P. M\u00e4der, P. L. Jones, Y. Zhang, J. Cleland-Huang, \"Strategic traceability for safety-critical projects\", <em>IEEE Software</em>, vol. 30, no. 3, pp. 58-66, 2013.", "title": "Strategic traceability for safety-critical projects", "context": [{"sec": "sec2", "text": " During the information gathering and analysis phase, we reviewed literature related to the use of Safety Assurance Cases (e.g., [8], [9], [41]) and traceability in safety-critical projects (e.g., [32], [33], [50]) including case studies and examples of completed SACs.", "part": "1"}, {"sec": "sec2a", "text": "SAFA depends upon the presence of an underlying Traceability Information Model (TIM) that defines artifacts and their traceability paths [50].", "part": "1"}, {"sec": "sec2b", "text": " The generation of the Artifact Tree depends upon the existence of semantically-typed trace links defined in the TIM [50], [55].", "part": "1"}, {"sec": "sec5c", "text": " Many of these issues were caused by inconsistencies between artifacts and missing trace links [50].", "part": "1"}], "links": {"documentLink": "/document/6504885", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6504885", "abstract": "To support any claim that a product is safe for its intended use, manufacturers must establish traceability within that product&#39;s development life cycle. Unfortunately, traceability information submitted to regulators and third parties is often weak, casting doubt rather than confidence in a product&#39;s integrity. This article evaluates traceability information for 10 submissions prepared by manufacturers for review at the US Food and Drug Administration. The authors observed nine widespread trace...", "pdfSize": "1734KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Strategic+traceability+for+safety-critical+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "M. B. Miles, A. M. Huberman, J. Saldana, <em>Qualitative data analysis: a methods sourcebook</em>, 2014.", "title": "Qualitative data analysis: a methods sourcebook", "context": [{"sec": "sec6b", "text": "Two researchers (co-authors on this paper) then inductively coded the responses to questions Q3 and Q4 to identify prominent themes [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Qualitative+data+analysis%3A+a+methods+sourcebook&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "L. G. Murta, A. van der Hoek, C. M. Werner, \"Continuous and automated evolution of architecture-to-implementation traceability links\", <em>Automated Software Engineering</em>, vol. 15, no. 1, pp. 75-107, 2008.", "title": "Continuous and automated evolution of architecture-to-implementation traceability links", "context": [{"sec": "sec8", "text": "Several approaches have been proposed that automate traceability across diverse artifacts [16], [26], [52].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-007-0020-6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+and+automated+evolution+of+architecture-to-implementation+traceability+links&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "S. C. of, <em>RTCA. DO-178C software considerations in airborne systems and equipment certification</em>, 2011.", "title": "RTCA. DO-178C, software considerations in airborne systems and equipment certification", "context": [{"sec": "sec2a", "text": " We used the TIM depicted in Table I throughout our process, which depicts artifacts and their associations as commonly adopted across many safety critical development processes [12], [47], [53].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=RTCA.+DO-178C%2C+software+considerations+in+airborne+systems+and+equipment+certification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "M. Rahimi, J. Cleland-Huang, \"Evolving software trace links between requirements and source code\", <em>Empirical Software Engineering</em>, vol. 23, no. 4, pp. 2198-2231, 2018.", "title": "Evolving software trace links between requirements and source code", "context": [{"sec": "sec3b", "text": "Furthermore, to gain a deeper understanding of any code modifications and their potential impact upon the safe mitigation of the hazards, we utilize Trace Link Evolution (TLE)[54], to reverse engineer source code refactorings, identify previously unlinked code that could impact the safety case, and recommend potential links between design definitions and code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-017-9561-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evolving+software+trace+links+between+requirements+and+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "B. Ramesh, M. Jarke, \"Toward reference models of requirements traceability\", <em>IEEE Trans. on Software Engineering</em>, vol. 27, no. 1, pp. 58-93, 2001.", "title": "Toward reference models of requirements traceability", "context": [{"sec": "sec2b", "text": " The generation of the Artifact Tree depends upon the existence of semantically-typed trace links defined in the TIM [50], [55].", "part": "1"}], "links": {"documentLink": "/document/895989", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=895989", "abstract": "Requirements traceability is intended to ensure continued alignment between stakeholder requirements and various outputs of the system development process. To be useful, traces must be organized according to some modeling framework. Indeed, several such frameworks have been proposed, mostly based on theoretical considerations or analysis of other literature. This paper, in contrast, follows an empirical approach. Focus groups and interviews conducted in 26 major software development organization...", "pdfSize": "14646KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Toward+reference+models+of+requirements+traceability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "M. Rath, J. Rendall, J. L. C. Guo, J. Cleland-Huang, P. M\u00e4der, \"Traceability in the wild: automatically augmenting incomplete trace links\", <em>Proc. of the 40th Int'l Conf. on Software Engineering</em>, pp. 834-845, 2018.", "title": "Traceability in the wild: automatically augmenting incomplete trace links", "context": [{"sec": "sec2b", "text": " Such trace links can be created manually, generated using an automated approach [48], or mined from commit messages [56].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180207", "abstract": "Software and systems traceability is widely accepted as an essential element for supporting many software development tasks. Today&#39;s version control systems provide inbuilt features that allow developers to tag each commit with one or more issue ID, thereby providing the building blocks from which project-wide traceability can be established between feature requests, bug fixes, commits, source code, and specific developers. However, our analysis of six open source projects showed that on average...", "pdfSize": "625KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Traceability+in+the+wild%3A+automatically+augmenting+incomplete+trace+links&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "P. Rempel, P. M\u00e4der, T. Kuschke, J. Cleland-Huang, \"Mind the gap: assessing the conformance of software traceability to relevant guidelines\", <em>Proc. 36th Int'l Conf. on Software Engineering</em>, pp. 943-954, 2014.", "title": "Mind the gap: assessing the conformance of software traceability to relevant guidelines", "context": [{"sec": "sec2b", "text": " The trace links used by SAFA are required in most safety-critical domains [57], therefore our approach adds minimal overhead to the traceability effort [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568290", "abstract": "Many guidelines for safety-critical industries such as aeronautics, medical devices, and railway communications, specify that traceability must be used to demonstrate that a rigorous process has been followed and to provide evidence that the system is safe for use. In practice, there is a gap between what is prescribed by guidelines and what is implemented in practice, making it difficult for organizations and certifiers to fully evaluate the safety of the software system. In this paper we prese...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mind+the+gap%3A+assessing+the+conformance+of+software+traceability+to+relevant+guidelines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "M. Sabetzadeh, S. Nejati, L. Briand, A.-H. E. Mills, \"Using SysML for modeling of safety-critical software-hardware interfaces: Guidelines and industry experience\", <em>Proc. of the IEEE 13th Int'l Symp. on High-Assurance Systems Engineering</em>, pp. 193-201, 2011.", "title": "Using SysML for modeling of safety-critical software-hardware interfaces: Guidelines and industry experience", "context": [{"sec": "sec8", "text": " Other closely related work focuses on generating artifact slices or using formal verification techniques to support safety analysis [40], [58].", "part": "1"}], "links": {"documentLink": "/document/6113898", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6113898", "abstract": "Safety-critical embedded systems often need to undergo a rigorous certification process to ensure that the safety risks associated with the use of the systems are adequately mitigated. Interfaces between software and hardware components (SW/HW interfaces) play a fundamental role in these systems by linking the systems&#39; control software to either the physical hardware components or to a hardware abstraction layer. Subsequently, safety certification of embedded systems necessarily has to cover the...", "pdfSize": "552KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+SysML+for+modeling+of+safety-critical+software-hardware+interfaces%3A+Guidelines+and+industry+experience&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "R. Steinzor, \"Lessons from the North Sea: Should \u201csafety cases\u201d come to America?\", <em>Bost. Coll. Environ. Aff. Law Rev.</em>, vol. 38, no. 2, pp. 417-444, 2011.", "title": "Lessons from the North Sea: Should \u201csafety cases\u201d come to America?", "context": [{"sec": "sec1", "text": " Challenges include a lack of guidance for constructing effective safety arguments [60], a tendency to suffer from confirmation bias [47], an over reliance on the regulation culture [59], and lack of focus on confidence and uncertainty issues [21], [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lessons+from+the+North+Sea%3A+Should+%E2%80%9Csafety+cases%E2%80%9D+come+to+America%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "M. Sujan, I. Habli, T. Kelly, S. Pozzi, C. Johnson, \"Should healthcare providers do safety cases? Lessons from a cross-industry review of safety case practices\", <em>Saf. Sci.</em>, vol. 84, pp. 181-189, Apr 2016.", "title": "Should healthcare providers do safety cases? Lessons from a cross-industry review of safety case practices", "context": [{"sec": "sec1", "text": " Challenges include a lack of guidance for constructing effective safety arguments [60], a tendency to suffer from confirmation bias [47], an over reliance on the regulation culture [59], and lack of focus on confidence and uncertainty issues [21], [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.ssci.2015.12.021", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Should+healthcare+providers+do+safety+cases%3F+Lessons+from+a+cross-industry+review+of+safety+case+practices&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "\"U.K. Ministry of Defence\", <em>Defence Standard 00\u201356</em>, no. 7, 2017.", "title": "U.K. Ministry of Defence", "context": [{"sec": "sec1", "text": " SACs are therefore a useful and well-established technique for supporting developers, architects, safety analysts, and other project stakeholders as they proactively build, evaluate, and provide evidence for the safety of a system [28], [61].", "part": "1"}, {"sec": "sec1", "text": " Similarly, the Ministry of Defense in the UK requires all defense system contractors to provide SACs for their products and services [61]. \\$\\text{SACs}\\$. are also recommended by standards such as ISO 26262 for road vehicles, IEC 62425 for railway electronic systems, and IAEA SSG-23 for radioactive waste management systems [6], [17]. \\$\\text{SACs}\\$. can be modeled in various ways; however, the most common approaches are Goal Structuring Notation (GSN)[41] and Claims-Arguments-Evidence notation [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=U.K.+Ministry+of+Defence&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "Requirements Engineering Management Handbook Appendix A - Isolette Thermostat Example. DOD/FAA/AR-08/32, 2009.", "title": "Requirements Engineering Management Handbook, Appendix A - Isolette Thermostat Example. DOD/FAA/AR-08/32", "context": [{"sec": "sec2", "text": " In the remainder of this section we discuss SAFA in more detail, using an example drawn from the Isolette case study, a safety-critical infant incubator used in hospitals [62].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Requirements+Engineering+Management+Handbook%2C+Appendix+A+-+Isolette+Thermostat+Example.+DOD%2FFAA%2FAR-08%2F32&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "R. Wieringa, Design Science Methodology for Information Systems and Software Engineering, Springer, 2014.", "title": "Design Science Methodology for Information Systems and Software Engineering", "context": [{"sec": "sec2", "text": "We adopted a modified version of Wieringa's design science approach [63] to design, develop, and refine the SAFA solution.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-662-43839-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Design+Science+Methodology+for+Information+Systems+and+Software+Engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812137", "articleId": "8812137", "startPage": "1222", "endPage": "1233", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 100}}
{"title": "BugSwarm: Mining and Continuously Growing a Dataset of Reproducible Failures and Fixes", "authors": [{"name": "David A. Tomassi", "affiliation": "University of California, Davis", "firstName": "David A.", "lastName": "Tomassi", "id": "37086951769"}, {"name": "Naji Dmeiri", "affiliation": "University of California, Davis", "firstName": "Naji", "lastName": "Dmeiri", "id": "37086951888"}, {"name": "Yichen Wang", "affiliation": "University of California, Davis", "firstName": "Yichen", "lastName": "Wang", "id": "37086953914"}, {"name": "Antara Bhowmick", "affiliation": "University of California, Davis", "firstName": "Antara", "lastName": "Bhowmick", "id": "37086952668"}, {"name": "Yen-Chuan Liu", "affiliation": "University of California, Davis", "firstName": "Yen-Chuan", "lastName": "Liu", "id": "37086949073"}, {"name": "Premkumar T. Devanbu", "affiliation": "University of California, Davis", "firstName": "Premkumar T.", "lastName": "Devanbu", "id": "37267727500"}, {"name": "Bogdan Vasilescu", "affiliation": "Carnegie Mellon University", "firstName": "Bogdan", "lastName": "Vasilescu", "id": "38229105200"}, {"name": "Cindy Rubio-Gonz\u00e1lez", "affiliation": "University of California, Davis", "firstName": "Cindy", "lastName": "Rubio-Gonz\u00e1lez", "id": "37085410448"}], "abstract": "Fault-detection, localization, and repair methods are vital to software quality; but it is difficult to evaluate their generality, applicability, and current effectiveness. Large, diverse, realistic datasets of durably-reproducible faults and fixes are vital to good experimental evaluation of approaches to software quality, but they are difficult and expensive to assemble and keep current. Modern continuous-integration (CI) approaches, like TRAVIS-CI, which are widely used, fully configurable, and executed within custom-built containers, promise a path toward much larger defect datasets. If we can identify and archive failing and subsequent passing runs, the containers will provide a substantial assurance of durable future reproducibility of build and test. Several obstacles, however, must be overcome to make this a practical reality. We describe BUGSWARM, a toolset that navigates these obstacles to enable the creation of a scalable, diverse, realistic, continuously growing set of durably reproducible failing and passing versions of real-world, open-source systems. The BUGSWARM toolkit has already gathered 3,091 fail-pass pairs, in Java and Python, all packaged within fully reproducible containers. Furthermore, the toolkit can be run periodically to detect fail-pass activities, thus growing the dataset continually.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Containers", "Tools", "Maintenance engineering", "History", "Software", "Libraries", "Currencies"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["data mining", "Java", "program debugging", "program testing", "Python", "software fault tolerance", "software maintenance", "software quality"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["reproducible failures", "fault-detection", "repair methods", "software quality", "realistic datasets", "durably-reproducible faults", "TRAVIS-CI", "BUGSWARM toolkit", "fail-pass pairs", "fully reproducible containers", "fail-pass activities", "continuous-integration approach", "mining", "fault localization", "Java", "Python"]}, {"type": "Author Keywords ", "kwd": ["Bug Database", "Reproducibility", "Software Testing", "Program Analysis", "Experiment Infrastructure"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00048", "ref": [{"order": "1", "text": "<em>Apache Ant.</em>,  [online]  Available: http://ant.apache.org.", "title": "Apache Ant.", "context": [{"sec": "sec3f", "text": " For Java, we support the most popular build systems-Maven [8], Gradle [6], and Ant [1]-and test frameworks-JUnit [7] and testng [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+Ant.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Microsoft Azure.</em>,  [online]  Available: http://azure.microsoft.com.", "title": "Microsoft Azure.", "context": [{"sec": "sec4d", "text": " The BugSwarm infrastructure provides support to run these as batch tasks on Microsoft Azure [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Microsoft+Azure.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Cobertura.</em>,  [online]  Available: https://github.com/cobertura/cobertura/wiki.", "title": "Cobertura.", "context": [{"sec": "sec4c", "text": "Using the BugSwarm framework presented in Section III-G, we successfully ran the code coverage tool Cober-tura [3] and two static analyzers-Google\u2018s ErrorProne [5] and SpotBugs [11]-on the 320 randomly selected artifacts used in the manual classification [30], with minimal effort.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cobertura.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Defects4J.</em>,  [online]  Available: https://github.com/rjust/defects4j.", "title": "Defects4J.", "context": [{"sec": "sec6", "text": "Defects4J [24] [4] is a dataset of 395 real, reproducible bugs from 6 large Java projects.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Defects4J.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>Error Prone.</em>,  [online]  Available: https://github.com/google/error-prone.", "title": "Error Prone.", "context": [{"sec": "sec4c", "text": "Using the BugSwarm framework presented in Section III-G, we successfully ran the code coverage tool Cober-tura [3] and two static analyzers-Google\u2018s ErrorProne [5] and SpotBugs [11]-on the 320 randomly selected artifacts used in the manual classification [30], with minimal effort.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Error+Prone.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Gradle Build Tool.</em>,  [online]  Available: https://gradle.org.", "title": "Gradle Build Tool.", "context": [{"sec": "sec3f", "text": " For Java, we support the most popular build systems-Maven [8], Gradle [6], and Ant [1]-and test frameworks-JUnit [7] and testng [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gradle+Build+Tool.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>JUnit Test Framework.</em>,  [online]  Available: https://junit.org/junit5.", "title": "JUnit Test Framework.", "context": [{"sec": "sec3f", "text": " For Java, we support the most popular build systems-Maven [8], Gradle [6], and Ant [1]-and test frameworks-JUnit [7] and testng [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=JUnit+Test+Framework.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Apache Maven Project.</em>,  [online]  Available: https://maven.apache.org.", "title": "Apache Maven Project.", "context": [{"sec": "sec3f", "text": " For Java, we support the most popular build systems-Maven [8], Gradle [6], and Ant [1]-and test frameworks-JUnit [7] and testng [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+Maven+Project.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "<em>Test Framework nose.</em>,  [online]  Available: http://nose.readthedocs.io/en/latest.", "title": "Test Framework nose.", "context": [{"sec": "sec3f", "text": " For Python, we support the most popular test frameworks-unittest [15], unittest2 [16], nose [9], and pytest [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+Framework+nose.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "<em>Test Framework pytest.</em>,  [online]  Available: https://docs.pytest.org/en/latest.", "title": "Test Framework pytest.", "context": [{"sec": "sec3f", "text": " For Python, we support the most popular test frameworks-unittest [15], unittest2 [16], nose [9], and pytest [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+Framework+pytest.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "<em>SpotBugs Bug Descriptions.</em>,  [online]  Available: https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html.", "title": "SpotBugs Bug Descriptions.", "context": [{"sec": "sec4c", "text": "Using the BugSwarm framework presented in Section III-G, we successfully ran the code coverage tool Cober-tura [3] and two static analyzers-Google\u2018s ErrorProne [5] and SpotBugs [11]-on the 320 randomly selected artifacts used in the manual classification [30], with minimal effort.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SpotBugs+Bug+Descriptions.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "<em>Test Framework testng.</em>,  [online]  Available: http://testng.org/doc.", "title": "Test Framework testng.", "context": [{"sec": "sec3f", "text": " For Java, we support the most popular build systems-Maven [8], Gradle [6], and Ant [1]-and test frameworks-JUnit [7] and testng [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+Framework+testng.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "<em>Travis CI.</em>,  [online]  Available: https://travis-ci.org.", "title": "Travis CI.", "context": [{"sec": "sec1", "text": " CI services, like Travis-ci [13], allow open-source projects to outsource integration testing.", "part": "1"}, {"sec": "sec6", "text": " There are over 900K projects in GITHuB that use Travis-ci [13], so our toolkit enables the creation of datasets and ensuing experiments at a scale substantially larger than previous datasets allow.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Travis+CI.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "<em>Job Lifecycle.</em>,  [online]  Available: https://docs.travis-ci.com/user/job-lifecycle/#breaking-the-build.", "title": "Job Lifecycle.", "context": [{"sec": "sec4b", "text": " This naming convention is from Travis-ci [14] and is defined by the part of the job lifecycle that encounters a non-zero exit code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Job+Lifecycle.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "<em>Test Framework unittest.</em>,  [online]  Available: https://docs.python.org/2/library/unittest.html.", "title": "Test Framework unittest.", "context": [{"sec": "sec3f", "text": " For Python, we support the most popular test frameworks-unittest [15], unittest2 [16], nose [9], and pytest [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+Framework+unittest.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>Test Framework unittest2</em>,  [online]  Available: https://pypi.python.org/pypi/unittest2.", "title": "Test Framework unittest2", "context": [{"sec": "sec3f", "text": " For Python, we support the most popular test frameworks-unittest [15], unittest2 [16], nose [9], and pytest [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+Framework+unittest2&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Beller, G. Gousios, A. Zaidman, \"TravisTorrent: Synthesizing Travis CI and GitHub for Full-Stack Research on Continuous Integration\", <em>Proceedings of the 14th International Conference on Mining Software Repositories MSR 2017 Buenos Aires Argentina May 20\u201328 2017</em>, pp. 447-450, 2017.", "title": "TravisTorrent: Synthesizing Travis CI and GitHub for Full-Stack Research on Continuous Integration", "context": [{"sec": "sec3c", "text": " [17] to extract this information.", "part": "1"}, {"sec": "sec4", "text": " The initial Java-specific Analyzer was ported to Python from TRAVISToRRENT'S [17] implementation in Ruby.", "part": "1"}], "links": {"documentLink": "/document/7962393", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7962393", "abstract": "Continuous Integration (CI) has become a best practice of modern software development. Thanks in part to its tight integration with GitHub, Travis CI has emerged as arguably the most widely used CI platform for Open-Source Software (OSS) development. However, despite its prominent role in Software Engineering in practice, the benefits, costs, and implications of doing CI are all but clear from an academic standpoint. Little research has been done, and even less was of quantitative nature. In ord...", "pdfSize": "467KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=TravisTorrent%3A+Synthesizing+Travis+CI+and+GitHub+for+Full-Stack+Research+on+Continuous+Integration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "C. Cifuentes, C. Hoermann, N. Keynes, L. Li, S. Long, E. Mealy, M. Mounteney, B. Scholz, \"BegBunch: Benchmarking for C Bug Detection Tools\", <em>DEFECTS \u201809: Proceedings of the 2nd International Workshop on Defects in Large Software Systems</em>, pp. 16-20, 2009.", "title": "BegBunch: Benchmarking for C Bug Detection Tools", "context": [{"sec": "sec6", "text": " BegBunch [18] contains two suites to measure the accuracy and scalability of bug detection tools for C. iBugs [19] is a dataset drawn from the 5-year history of the AspectJ compiler with 369 faulty versions of the project. iBugs provides metadata such as number of methods and classes involved in the bug fix.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1555860.1555866", "abstract": "Benchmarks for bug detection tools are still in their infancy. Though in recent years various tools and techniques were introduced, little effort has been spent on creating a benchmark suite and a harness for a consistent quantitative and qualitative performance measurement. For assessing the performance of a bug detection tool and determining which tool is better than another for the type of code to be looked at, the following questions arise: 1) how many bugs are correctly found, 2) what is th...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=BegBunch%3A+Benchmarking+for+C+Bug+Detection+Tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "V. Dallmeier, T. Zimmermann, \"Extraction of Bug Localization Benchmarks from History\", <em>22nd IEEE/ACM International Conference on Automated Software Engineering (ASE 2007) November 5\u20139 2007</em>, pp. 433-436, 2007.", "title": "Extraction of Bug Localization Benchmarks from History", "context": [{"sec": "sec6", "text": " BegBunch [18] contains two suites to measure the accuracy and scalability of bug detection tools for C. iBugs [19] is a dataset drawn from the 5-year history of the AspectJ compiler with 369 faulty versions of the project. iBugs provides metadata such as number of methods and classes involved in the bug fix.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1321631.1321702", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Extraction+of+Bug+Localization+Benchmarks+from+History&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "F. M. Delfim, S. Urli, M. de Almeida Maia, M. Monperrus, \"Bears: An Extensible Java Bug Benchmark for Automatic Program Repair Studies\", <em>To appear in SANER</em>, 2019.", "title": "Bears: An Extensible Java Bug Benchmark for Automatic Program Repair Studies", "context": [{"sec": "sec6", "text": " [20] develop Bears, which mines Maven-based Java GITHuB projects that use Travis-ci.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bears%3A+An+Extensible+Java+Bug+Benchmark+for+Automatic+Program+Repair+Studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "H. Do, S. G. Elbaum, G. Rothermel, \"Supporting Controlled Experimentation with Testing Techniques: An Infrastructure and its Potential Impact\", <em>Empirical Software Engineering</em>, vol. 10, no. 4, pp. 405-435, 2005.", "title": "Supporting Controlled Experimentation with Testing Techniques: An Infrastructure and its Potential Impact", "context": [{"sec": "sec1", "text": "Some hand-curated datasets (e.g., Siemens test suite [23], the SIR repository [21], Defects4J [24]) provide artifact collections to support controlled experimentation with program analysis and testing techniques.", "part": "1"}, {"sec": "sec6", "text": "The Software-artifact Infrastructure Repository (SIR)[21] comprises source code, tests, and defects from OS projects along with needed infrastructure (e.g., automated build and test scripts).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-005-3861-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+Controlled+Experimentation+with+Testing+Techniques%3A+An+Infrastructure+and+its+Potential+Impact&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "G. Gousios, A. Zaidman, M. D. Storey, A. van Deursen, \"Work Practices and Challenges in Pull-Based Development: The Integrator's Perspective\", <em>37th IEEE/ACM International Conference on Software Engineering ICSE 2015</em>, vol. 1, pp. 358-368, May 16\u201324, 2015.", "title": "Work Practices and Challenges in Pull-Based Development: The Integrator's Perspective", "context": [{"sec": "sec1", "text": " For example, typical GITHuB projects require that each pull request (PR) be integration tested, and failures fixed, before being vetted or merged by integrators [22], [32].", "part": "1"}], "links": {"documentLink": "/document/7675420", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7675420", "abstract": "In the pull-based development model, the integrator has the crucial role of managing and integrating contributions. This work focuses on the role of the integrator and investigates working habits and challenges alike. We set up an exploratory qualitative study involving a large-scale survey of 749 integrators, to which we add quantitative data from the integrator&#39;s project. Our results provide insights into the factors they consider in their decision making process to accept or reject a contribu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Work+Practices+and+Challenges+in+Pull-Based+Development%3A+The+Integrator%27s+Perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "M. Hutchins, H. Foster, T. Goradia, T. J. Ostrand, \"Experiments of the Effectiveness of Dataflow- and Controlflow-Based Test Adequacy Criteria\", <em>Proceedings of the 16th International Conference on Software Engineering</em>, pp. 191-200, May 16\u201321, 1994.", "title": "Experiments of the Effectiveness of Dataflow- and Controlflow-Based Test Adequacy Criteria", "context": [{"sec": "sec1", "text": "Some hand-curated datasets (e.g., Siemens test suite [23], the SIR repository [21], Defects4J [24]) provide artifact collections to support controlled experimentation with program analysis and testing techniques.", "part": "1"}, {"sec": "sec6", "text": "The Siemens test suite [23] (7 small C programs and about 130 manually seeded bugs) is among the earliest.", "part": "1"}], "links": {"documentLink": "/document/296778", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=296778", "abstract": "This paper reports an experimental study investigating the effectiveness of two code-based test adequacy criteria for identifying sets of test cases that detect faults. The all-edges and all-DUs (modified all-uses) coverage criteria were applied to 130 faulty program versions derived from seven moderate size base programs by seeding realistic faults. We generated several thousand test sets for each faulty program and examined the relationship between fault detection and coverage. Within the limi...", "pdfSize": "972KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Experiments+of+the+Effectiveness+of+Dataflow-+and+Controlflow-Based+Test+Adequacy+Criteria&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "R. Just, D. Jalali, M. D. Ernst, \"Defects4J: A Database of Existing Faults to Enable Controlled Testing Studies for Java Programs\", <em>International Symposium on Software Testing and Analysis ISSTA \u201814</em>, pp. 437-440, July 21 \u2212 26, 2014.", "title": "Defects4J: A Database of Existing Faults to Enable Controlled Testing Studies for Java Programs", "context": [{"sec": "sec1", "text": "Some hand-curated datasets (e.g., Siemens test suite [23], the SIR repository [21], Defects4J [24]) provide artifact collections to support controlled experimentation with program analysis and testing techniques.", "part": "1"}, {"sec": "sec6", "text": "Defects4J [24] [4] is a dataset of 395 real, reproducible bugs from 6 large Java projects.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2628055", "abstract": "Empirical studies in software testing research may not be comparable, reproducible, or characteristic of practice. One reason is that real bugs are too infrequently used in software testing research. Extracting and reproducing real bugs is challenging and as a result hand-seeded faults or mutants are commonly used as a substitute. This paper presents Defects4J, a database and extensible framework providing real bugs to enable reproducible studies in software testing research. The initial version...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Defects4J%3A+A+Database+of+Existing+Faults+to+Enable+Controlled+Testing+Studies+for+Java+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "C. Le Goues, N. Holtschulte, E. K. Smith, Y. Brun, P. T. Devanbu, S. Forrest, W. Weimer, \"The ManyBugs and IntroClass Benchmarks for Automated Repair of C Programs\", <em>IEEE Trans. Software Eng.</em>, vol. 41, no. 12, pp. 1236-1256, 2015.", "title": "The ManyBugs and IntroClass Benchmarks for Automated Repair of C Programs", "context": [{"sec": "sec1", "text": " However, these collections are curated by hand, and are necessarily quite limited in scale and diversity; others incorporate small-sized student homeworks [25], which may not reflect development by professionals.", "part": "1"}, {"sec": "sec6", "text": "MANYBUGS [25] is a benchmark for program repair with 185 defects and fixes from 9 large C projects.", "part": "1"}], "links": {"documentLink": "/document/7153570", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7153570", "abstract": "The field of automated software repair lacks a set of common benchmark problems. Although benchmark sets are used widely throughout computer science, existing benchmarks are not easily adapted to the problem of automatic defect repair, which has several special requirements. Most important of these is the need for benchmark programs with reproducible, important defects and a deterministic method for assessing if those defects have been repaired. This article details the need for a new set of ben...", "pdfSize": "979KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+ManyBugs+and+IntroClass+Benchmarks+for+Automated+Repair+of+C+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "S. Lu, Z. Li, F. Qin, L. Tan, P. Zhou, Y. Zhou, \"Bugbench: Benchmarks for Evaluating Bug Detection Tools\", <em>In Workshop on the Evaluation of Software Defect Detection Tools</em>, 2005.", "title": "Bugbench: Benchmarks for Evaluating Bug Detection Tools", "context": [{"sec": "sec6", "text": " BugBench [26] is one of the earliest datasets of real-world bugs.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bugbench%3A+Benchmarks+for+Evaluating+Bug+Detection+Tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "Q. Luo, F. Hariri, L. Eloussi, D. Marinov, \"An Empirical Analysis of Flaky Tests\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE-22)</em>, pp. 643-653, November 16 \u2212 22, 2014.", "title": "An Empirical Analysis of Flaky Tests", "context": [{"sec": "sec4b", "text": " An initial direction could involve selecting pairs based on keywords in their commit messages (e.g., [27]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635920", "abstract": "Regression testing is a crucial part of software development. It checks that software changes do not break existing functionality. An important assumption of regression testing is that test outcomes are deterministic: an unmodified test is expected to either always pass or always fail for the same code under test. Unfortunately, in practice, some tests often called flaky tests\u2014have non-deterministic outcomes. Such tests undermine the regression testing as they make it difficult to rely on test r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+Empirical+Analysis+of+Flaky+Tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "R. K. Saha, Y. Lyu, W. Lam, H. Yoshida, M. R. Prasad, \"Bugs.jar: A Large-Scale Diverse Dataset of Real-World Java Bugs\", <em>Proceedings of the 15th International Conference on Mining Software Repositories MSR 2018</em>, pp. 10-13, May 28\u201329, 2018.", "title": "Bugs.jar: A Large-Scale, Diverse Dataset of Real-World Java Bugs", "context": [{"sec": "sec6", "text": " The Bugs.jar [28] dataset contains 1,158 real, reproducible Java bugs collected from 8 Apache projects by identifying commit messages that reference bug reports.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bugs.jar%3A+A+Large-Scale%2C+Diverse+Dataset+of+Real-World+Java+Bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "C. S. Timperley, S. Stepney, C. Le Goues, \"BugZoo: A Platform for Studying Software Bugs\", <em>Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings ICSE 2018</em>, pp. 446-447, May 27 - June 03, 2018.", "title": "BugZoo: A Platform for Studying Software Bugs", "context": [{"sec": "sec6", "text": " To facilitate the reproduction of these defects, MANYBUgs provides virtual machine images (recently extended to use Docker [29]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183440.3195050", "abstract": "Proposing a new method for automatically detecting, localising, or repairing software faults requires a fair, reproducible evaluation of the effectiveness of the method relative to existing alternatives. Measuring effectiveness requires both an indicative set of bugs, and a mechanism for reliably reproducing and interacting with those bugs. We present BugZoo: a decentralised platform for distributing, reproducing, and interacting with historical software bugs. BugZoo connects existing datasets a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=BugZoo%3A+A+Platform+for+Studying+Software+Bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "D. A. Tomassi, \"Bugs in the Wild: Examining the Effectiveness of Static Analyzers at Finding Real-World Bugs\", <em>Proceedings of the 2018 ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering ESEC/SIGSOFT FSE 2018 Lake Buena Vista</em>, pp. 980-982, November 04\u201309, 2018.", "title": "Bugs in the Wild: Examining the Effectiveness of Static Analyzers at Finding Real-World Bugs", "context": [{"sec": "sec4c", "text": " To better understand the types of bugs in BugSwarm, we conduct a manual classification of 320 randomly sampled Maven-based Java artifacts, first described in [30].", "part": "1"}, {"sec": "sec4c", "text": "Using the BugSwarm framework presented in Section III-G, we successfully ran the code coverage tool Cober-tura [3] and two static analyzers-Google\u2018s ErrorProne [5] and SpotBugs [11]-on the 320 randomly selected artifacts used in the manual classification [30], with minimal effort.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3275439", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bugs+in+the+Wild%3A+Examining+the+Effectiveness+of+Static+Analyzers+at+Finding+Real-World+Bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "S. Urli, Z. Yu, L. Seinturier, M. Monperrus, \"How to Design a Program Repair Bot?: Insights from the Repairnator Project\", <em>Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice ICSE (SEIP)2018</em>, pp. 95-104, May 27 - June 03, 2018.", "title": "How to Design a Program Repair Bot?: Insights from the Repairnator Project", "context": [{"sec": "sec6", "text": " [31] describe an approach to mining builds that fail tests from TRAVIS-CI.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183519.3183540", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+Design+a+Program+Repair+Bot%3F%3A+Insights+from+the+Repairnator+Project&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "B. Vasilescu, Y. Yu, H. Wang, P. T. Devanbu, V. Filkov, \"Quality and Productivity Outcomes Relating to Continuous Integration in GitHub\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering ESEC/FSE 2015</em>, pp. 805-816, August 30 - September 4, 2015.", "title": "Quality and Productivity Outcomes Relating to Continuous Integration in GitHub", "context": [{"sec": "sec1", "text": " For example, typical GITHuB projects require that each pull request (PR) be integration tested, and failures fixed, before being vetted or merged by integrators [22], [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786850", "abstract": "Software processes comprise many steps; coding is followed by building, integration testing, system testing, deployment, operations, among others. Software process integration and automation have been areas of key concern in software engineering, ever since the pioneering work of Osterweil; market pressures for Agility, and open, decentralized, software development have provided additional pressures for progress in this area. But do these innovations actually help projects? Given the numerous co...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quality+and+Productivity+Outcomes+Relating+to+Continuous+Integration+in+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812141", "articleId": "8812141", "startPage": "339", "endPage": "349", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 199}}
{"title": "Efficient Detection of Thread Safety Violations via Coverage-Guided Generation of Concurrent Tests", "authors": [{"name": "Ankit Choudhary", "affiliation": "Dept. of Comput. Sci., Tech. Univ. Darmstadt, Darmstadt, Germany", "firstName": "Ankit", "lastName": "Choudhary", "id": "37086148616"}, {"name": "Shan Lu", "affiliation": "Dept. of Comput. Sci., Univ. of Chicago, Chicago, IL, USA", "firstName": "Shan", "lastName": "Lu", "id": "37086146430"}, {"name": "Michael Pradel", "affiliation": "Dept. of Comput. Sci., Tech. Univ. Darmstadt, Darmstadt, Germany", "firstName": "Michael", "lastName": "Pradel", "id": "37394864900"}], "abstract": "As writing concurrent programs is challenging, developers often rely on thread-safe classes, which encapsulate most synchronization issues. Testing such classes is crucial to ensure the correctness of concurrent programs. An effective approach to uncover otherwise missed concurrency bugs is to automatically generate concurrent tests. Existing approaches either create tests randomly, which is inefficient, build on a computationally expensive analysis of potential concurrency bugs exposed by sequential tests, or focus on exposing a particular kind of concurrency bugs, such as atomicity violations. This paper presents CovCon, a coverage-guided approach to generate concurrent tests. The key idea is to measure how often pairs of methods have already been executed concurrently and to focus the test generation on infrequently or not at all covered pairs of methods. The approach is independent of any particular bug pattern, allowing it to find arbitrary concurrency bugs, and is computationally inexpensive, allowing it to generate many tests in short time. We apply CovCon to 18 thread-safe Java classes, and it detects concurrency bugs in 17 of them. Compared to five state of the art approaches, CovCon detects more bugs than any other approach while requiring less time. Specifically, our approach finds bugs faster in 38 of 47 cases, with speedups of at least 4x for 22 of 47 cases.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Instruction sets", "Computer bugs", "Concurrent computing", "Testing", "Synchronization", "Schedules"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["concurrency (computers)", "Java", "program debugging", "program testing", "synchronisation"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["thread safety violation detection", "coverage-guided generation", "concurrent tests", "concurrent program writing", "synchronization", "missed concurrency bugs", "sequential tests", "CovCon", "bug pattern", "thread-safe Java classes", "test generation"]}, {"type": "Author Keywords ", "kwd": ["test generation", "coverage", "concurrency"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.32", "ref": [{"order": "1", "text": "C. Artho, K. Havelund, A. Biere, \"High-level data races\", <em>Software Testing Verification and Reliability</em>, vol. 13, no. 4, pp. 207-227, 2003.", "title": "High-level data races", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stvr.281", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=High-level+data+races&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "S. Artzi, J. Dolby, S.H. Jensen, A. M\u00f8ller, F. Tip, \"A framework for automated testing of JavaScript web applications\", <em>ICSE</em>, pp. 571-580, 2011.", "title": "A framework for automated testing of JavaScript web applications", "context": [{"sec": "sec1", "text": " They indicate which parts of the code still lack testing, and guide developers or automated test generation tools [2], [24], [36], [58] toward those parts.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985871", "abstract": "Current practice in testing JavaScript web applications requires manual construction of test cases, which is difficult and tedious. We present a framework for feedback-directed automated test generation for JavaScript in which execution is monitored to collect information that directs the test generator towards inputs that yield increased coverage. We implemented several instantiations of the framework, corresponding to variations on feedback-directed random testing, in a tool called Artemis. Ex...", "pdfSize": "2253KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+framework+for+automated+testing+of+JavaScript+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "M. B\u00f6hme, S. Paul, \"On the efficiency of automated testing\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE-22)</em>, pp. 632-642, November 16\u201322, 2014.", "title": "On the efficiency of automated testing", "context": [{"sec": "sec6d", "text": "The overall effectiveness of automated testing depends both on how effective individual tests are and on how long it takes to generate such tests [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635923", "abstract": "The aim of automated program testing is to gain confidence about a program&#39;s correctness by sampling its input space. The sampling process can be either systematic or random. For every systematic testing technique the sampling is informed by the analysis of some program artefacts, like the specification, the source code (e.g., to achieve coverage), or even faulty versions of the program (e.g., mutation testing). This analysis incurs some cost. In contrast, random testing is unsystematic and does...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+efficiency+of+automated+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "A. Bron, E. Farchi, Y. Magid, Y. Nir, S. Ur, \"Applications of synchronization coverage\", <em>Symposium on Principles and Practice of Parallel Programming (PPOPP)</em>, pp. 206-212, 2005.", "title": "Applications of synchronization coverage", "context": [{"sec": "sec7b", "text": " Bron et al. discuss coverage metrics that are useful for human developers that write concurrent tests [4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1065944.1065972", "abstract": "Coverage analysis is a useful testing technology. However, some coverage models are more acceptable to the industry than others. In the field of testing multi-threaded applications, there is a need for a coverage model that can be used to evaluate tests for concurrent completeness and to find new testing requirements. We present a new coverage model: synchronization coverage. This model is simple to understand and the action items generated by each uncovered task are clear to testers and develop...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Applications+of+synchronization+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "S. Burckhardt, C. Dern, M. Musuvathi, R. Tan, \"Line-Up: a complete and automatic linearizability checker\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 330-340, 2010.", "title": "Line-Up: a complete and automatic linearizability checker", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806596.1806634", "abstract": "Modular development of concurrent applications requires thread-safe components that behave correctly when called concurrently by multiple client threads. This paper focuses on linearizability, a specific formalization of thread safety, where all operations of a concurrent component appear to take effect instantaneously at some point between their call and return. The key insight of this paper is that if a component is intended to be deterministic, then it is possible to build an automatic linear...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Line-Up%3A+a+complete+and+automatic+linearizability+checker&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "J. Burnim, Koushik, S.C. Stergiou, \"Testing concurrent programs on relaxed memory models\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 122-132, 2011.", "title": "Testing concurrent programs on relaxed memory models", "context": [{"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2001420.2001436", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+concurrent+programs+on+relaxed+memory+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C. Cadar, D. Dunbar, D.R. Engler, \"KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs\", <em>Symposium on Operating Systems Design and Implementation (OSDI)</em>, pp. 209-224, 2008.", "title": "KLEE: Unassisted and automatic generation of high-coverage tests for complex systems programs", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=KLEE%3A+Unassisted+and+automatic+generation+of+high-coverage+tests+for+complex+systems+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "J. Chen, S. MacDonald, \"Testing concurrent programs using value schedules\", <em>Conference on Automated Software Engineering (ASE)</em>, pp. 313-322, 2007.", "title": "Testing concurrent programs using value schedules", "context": [{"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1321631.1321678", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+concurrent+programs+using+value+schedules&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "I. Ciupa, A. Leitner, M. Oriol, B. Meyer, \"ARTOO: adaptive random testing for object-oriented software\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 71-80, 2008.", "title": "ARTOO: adaptive random testing for object-oriented software", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368099", "abstract": "Intuition is often not a good guide to know which testing strategies will work best. There is no substitute for experimental analysis based on objective criteria: how many faults a strategy finds, and how fast. &#34;Random&#34; testing is an example of an idea that intuitively seems simplistic or even dumb, but when assessed through such criteria can yield better results than seemingly smarter strategies. The efficiency of random testing is improved if the generated inputs are evenly spread across the i...", "pdfSize": "365KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ARTOO%3A+adaptive+random+testing+for+object-oriented+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "K. Claessen, M. Palka, N. Smallbone, J. Hughes, H. Svensson, T. Arts, U.T. Wiger, \"Finding race conditions in Erlang with QuickCheck and PULSE\", <em>International Conference on Functional programming (ICFP)</em>, pp. 149-160, 2009.", "title": "Finding race conditions in Erlang with QuickCheck and PULSE", "context": [{"sec": "sec7a", "text": " Claessen et al. propose a test generator for Erlang programs [10].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1596550.1596574", "abstract": "We address the problem of testing and debugging concurrent, distributed Erlang applications. In concurrent programs, race conditions are a common class of bugs and are very hard to find in practice. Traditional unit testing is normally unable to help finding all race conditions, because their occurrence depends so much on timing. Therefore, race conditions are often found during system testing, where due to the vast amount of code under test, it is often hard to diagnose the error resulting from...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+race+conditions+in+Erlang+with+QuickCheck+and+PULSE&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "K.E. Coons, S. Burckhardt, M. Musuvathi, \"GAMBIT: effective unit testing for concurrency libraries\", <em>Symposium on Principles and Practice of Parallel Programming (PPOPP)</em>, pp. 15-24, 2010.", "title": "GAMBIT: effective unit testing for concurrency libraries", "context": [{"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1693453.1693458", "abstract": "As concurrent programming becomes prevalent, software providers are investing in concurrency libraries to improve programmer productivity. Concurrency libraries improve productivity by hiding error-prone, low-level synchronization from programmers and providing higher-level concurrent abstractions. Testing such libraries is difficult, however, because concurrency failures often manifest only under particular scheduling circumstances. Current best testing practices are often inadequate: heuristic...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=GAMBIT%3A+effective+unit+testing+for+concurrency+libraries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "C. Csallner, Y. Smaragdakis, \"JCrasher: an automatic robustness tester for Java\", <em>Software Practice and Experience</em>, vol. 34, no. 11, pp. 1025-1050, 2004.", "title": "JCrasher: an automatic robustness tester for Java", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/spe.602", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=JCrasher%3A+an+automatic+robustness+tester+for+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "D. Deng, W. Zhang, S. Lu, \"Efficient concurrency-bug detection across inputs\", <em>Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA)</em>, pp. 785-802, 2013.", "title": "Efficient concurrency-bug detection across inputs", "context": [{"sec": "sec4a", "text": " This terminology differs from the mathematical definition of \u201cpair\u201d but is in line with previous work [13].", "part": "1"}, {"sec": "sec4a", "text": " Concurrent method pairs are inspired by Deng et aI.'s concurrent function pairs [13], which was proposed to reduce the dynamic bug-detection cost for predefined inputs.", "part": "1"}, {"sec": "fn1", "text": " This terminology differs from the mathematical definition of \u201cpair\u201d but is in line with previous work [13].", "type": "footnote"}, {"sec": "sec7b", "text": " The coverage criterion that CovCon builds on, concurrent method pairs, is inspired by Deng et al.'s concurrent function pairs [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2509136.2509539", "abstract": "In the multi-core era, it is critical to efficiently test multi-threaded software and expose concurrency bugs before software release. Previous work has made significant progress in detecting and validating concurrency bugs under a given input. Unfortunately, software testing always faces large sets of test inputs, and existing techniques are still too expensive to be applied to every test input in practice. In this paper, we use open-source software to study how existing concurrency-bug detecti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+concurrency-bug+detection+across+inputs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "O. Edelstein, E. Farchi, Y. Nir, G. Ratsaby, S. Ur, \"Multithreaded Java program test generation\", <em>IBM Systems Journal</em>, vol. 41, no. 1, pp. 111-125, 2002.", "title": "Multithreaded Java program test generation", "context": [{"sec": "sec4d", "text": " One could achieve the same goal by inserting sleeps or synchronization operations [14].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1147/sj.411.0111", "abstract": "We describe ConTest, a tool for detecting synchronization faults in multithreaded Java\u2122 programs. The program under test is seeded with a sleep( ), yield( ), or priority( ) primitive at shared memory accesses and synchronization events. At run time, ConTest makes random or coverage-based decisions as to whether the seeded primitive is to be executed. Thus, the probability of finding concurrent faults is increased. A replay algorithm facilitates debugging by saving the order of shared memory acce...", "pdfSize": "3347KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multithreaded+Java+program+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "C. Flanagan, S.N. Freund, \"Atomizer: a dynamic atomicity checker for multithreaded programs\", <em>Symposium on Principles of Programming Languages (POPL)</em>, pp. 256-267, 2004.", "title": "Atomizer: a dynamic atomicity checker for multithreaded programs", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/964001.964023", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Atomizer%3A+a+dynamic+atomicity+checker+for+multithreaded+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "C. Flanagan, S.N. Freund, \"FastTrack: efficient and precise dynamic race detection\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 121-133, 2009.", "title": "FastTrack: efficient and precise dynamic race detection", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1542476.1542490", "abstract": "\\begin{abstract} Multithreaded programs are notoriously prone to race conditions. Prior work on dynamic race detectors includes fast but imprecise race detectors that report false alarms, as well as slow but precise race detectors that never report false alarms. The latter typically use expensive vector clock operations that require time linear in the number of program threads. This paper exploits the insight that the full generality of vector clocks is unnecessary in most cases. That is, we can...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=FastTrack%3A+efficient+and+precise+dynamic+race+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "C. Flanagan, S.N. Freund, J. Yi, \"Velodrome: a sound and complete dynamic atomicity checker for multithreaded programs\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 293-303, 2008.", "title": "Velodrome: a sound and complete dynamic atomicity checker for multithreaded programs", "context": [{"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1375581.1375618", "abstract": "Atomicity is a fundamental correctness property in multithreaded programs, both because atomic code blocks are amenable to sequential reasoning (which significantly simplifies correctness arguments), and because atomicity violations often reveal defects in a program&#39;s synchronization structure. Unfortunately, all atomicity analyses developed to date are incomplete in that they may yield false alarms on correctly synchronized programs, which limits their usefulness. We present the first dynamic a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Velodrome%3A+a+sound+and+complete+dynamic+atomicity+checker+for+multithreaded+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "G. Fraser, A. Zeller, \"Mutation-driven generation of unit tests and oracles\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 147-158, 2010.", "title": "Mutation-driven generation of unit tests and oracles", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1831708.1831728", "abstract": "To assess the quality of test suites, mutation analysis seeds artificial defects (mutations) into programs; a non-detected mutation indicates a weakness in the test suite. We present an automated approach to generate unit tests that detect these mutations for object-oriented classes. This has two advantages: First, the resulting test suite is optimized towards finding defects rather than covering code. Second, the state change caused by mutations induces oracles that precisely detect the mutants...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mutation-driven+generation+of+unit+tests+and+oracles&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "P. Godefroid, N. Klarlund, K. Sen, \"DART: directed automated random testing\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 213-223, 2005.", "title": "DART: directed automated random testing", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1065010.1065036", "abstract": "We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test input...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DART%3A+directed+automated+random+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "P. Hawkins, A. Aiken, K. Fisher, M.C. Rinard, M. Sagiv, \"Concurrent data representation synthesis\", <em>PLDI</em>, pp. 417-428, 2012.", "title": "Concurrent data representation synthesis", "context": [{"sec": "sec7d", "text": "One alternative to testing concurrent software are synthesis and verification [20], [49], [56].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254114", "abstract": "We describe an approach for synthesizing data representations for concurrent programs. Our compiler takes as input a program written using concurrent relations and synthesizes a representation of the relations as sets of cooperating data structures as well as the placement and acquisition of locks to synchronize concurrent access to those data structures. The resulting code is correct by construction: individual relational operations are implemented correctly and the aggregate set of operations ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Concurrent+data+representation+synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "S. Hong, J. Ahn, S. Park, M. Kim, M.J. Harrold, \"Testing concurrent programs to achieve high synchronization coverage\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 210-220, 2012.", "title": "Testing concurrent programs to achieve high synchronization coverage", "context": [{"sec": "sec1", "text": "Note that our work differs from recent work on generating schedules based on concurrent coverage metrics [21], [60], [65] because CovCon generates test cases instead of schedules.", "part": "1"}, {"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec7c", "text": " Other work uses concurrent coverage metrics to select and prioritize schedules to explore [21], [52], [60], [65].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2338965.2336779", "abstract": "The effectiveness of software testing is often assessed by measuring coverage of some aspect of the software, such as its code. There is much research aimed at increasing code coverage of sequential software. However, there has been little research on increasing coverage for concurrent software. This paper presents a new technique that aims to achieve high coverage of concurrent programs by generating thread schedules to cover uncovered coverage requirements. Our technique first estimates synchr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+concurrent+programs+to+achieve+high+synchronization+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "V. Jagannath, M. Gligoric, D. Jin, Q. Luo, G. Rosu, D. Marinov, \"Improved multithreaded unit testing\", <em>European Software Engineering Conference and Symposium on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 223-233, 2011.", "title": "Improved multithreaded unit testing", "context": [{"sec": "sec7a", "text": " MultithreadedTC [41] and IMUnit [22] are unit testing frameworks to manually write concurrent unit tests.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025145", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improved+multithreaded+unit+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "V. Jagannath, Q. Luo, D. Marinov, \"Change-aware preemption prioritization\", <em>ISSTA</em>, pp. 133-143, 2011.", "title": "Change-aware preemption prioritization", "context": [{"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2001420.2001437", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Change-aware+preemption+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "H. Jaygarl, S. Kim, T. Xie, C.K. Chang, \"OCAT: object S. automated testing\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 159-170, 2010.", "title": "OCAT: object S. automated testing", "context": [{"sec": "sec1", "text": " They indicate which parts of the code still lack testing, and guide developers or automated test generation tools [2], [24], [36], [58] toward those parts.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1831708.1831729", "abstract": "Testing object-oriented (OO) software is critical because OO languages are commonly used in developing modern software systems. In testing OO software, one important and yet challenging problem is to generate desirable object instances for receivers and arguments to achieve high code coverage, such as branch coverage, or find bugs. Our initial empirical findings show that coverage of nearly half of the difficult-to-cover branches that a state-of-the-art test-generation tool cannot cover requires...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=OCAT%3A+object+S.+automated+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "P. Joshi, M. Naik, C.-S. Park, K. Sen, \"CalFuzzer: An extensible active testing framework for concurrent programs\", <em>Conference on Computer Aided Verification</em>, pp. 675-681, 2009.", "title": "CalFuzzer: An extensible active testing framework for concurrent programs", "context": [{"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec5", "text": " More sophisticated test execution approaches, such as systematic exploration of interleavings [31] or active testing [25] could be plugged into our implementation.", "part": "1"}, {"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-02658-4_54", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CalFuzzer%3A+An+extensible+active+testing+framework+for+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "P. Joshi, M. Naik, K. Sen, D. Gay, \"An effective dynamic S. for detecting generalized deadlocks\", <em>Symposium on Foundations of Software Engineering (FSE)</em>, pp. 327-336, 2010.", "title": "An effective dynamic S. for detecting generalized deadlocks", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+effective+dynamic+S.+for+detecting+generalized+deadlocks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "P. Joshi, C.-S. Park, K. Sen, M. Naik, \"A randomized dynamic program analysis technique for detecting real deadlocks\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 110-120, 2009.", "title": "A randomized dynamic program analysis technique for detecting real deadlocks", "context": [{"sec": "sec6a", "text": " In contrast, Nainom and AutoTestGen build upon more sophisticated approaches for exploring interleavings that are likely to reveal concurrency bugs quicker [27], [29], [38], [47].", "part": "1"}, {"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1542476.1542489", "abstract": "We present a novel dynamic analysis technique that finds real deadlocks in multi-threaded programs. Our technique runs in two stages. In the first stage, we use an imprecise dynamic analysis technique to find potential deadlocks in a multi-threaded program by observing an execution of the program. In the second stage, we control a random thread scheduler to create the potential deadlocks with high probability. Unlike other dynamic analysis techniques, our approach has the advantage that it does ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+randomized+dynamic+program+analysis+technique+for+detecting+real+deadlocks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "K. Kim, T. Yavuz-Kahveci, B.A. Sanders, \"Precise data race detection in a relaxed memory model using heuristic-based model checking\", <em>Conference on Automated Software Engineering (ASE)</em>, pp. 495-499, 2009.", "title": "Precise data race detection in a relaxed memory model using heuristic-based model checking", "context": [{"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "links": {"abstract": "Most approaches to reasoning about multithreaded programs, including model checking, make the implicit assumption that the system being considered is sequentially consistent. This is, however, invalid in most modern computer architectures and results in unsound reasoning for programs that contain data races, where data races are defined by the memory model of the programming environment. We describe an extension to the model checker Java PathFinder that incorporates knowledge of the Java Memory ...", "pdfSize": "522KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Precise+data+race+detection+in+a+relaxed+memory+model+using+heuristic-based+model+checking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Z. Lai, S.-C. Cheung, W.K. Chan, \"Detecting atomic-set serializability violations in multithreaded programs through active randomized testing\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 235-244, 2010.", "title": "Detecting atomic-set serializability violations in multithreaded programs through active randomized testing", "context": [{"sec": "sec6a", "text": " In contrast, Nainom and AutoTestGen build upon more sophisticated approaches for exploring interleavings that are likely to reveal concurrency bugs quicker [27], [29], [38], [47].", "part": "1"}, {"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806836", "abstract": "Concurrency bugs are notoriously difficult to detect because there can be vast combinations of interleavings among concurrent threads, yet only a small fraction can reveal them. Atomic-set serializability characterizes a wide range of concurrency bugs, including data races and atomicity violations. In this paper, we propose a two-phase testing technique that can effectively detect atomic-set serializability violations. In Phase I, our technique infers potential violations that do not appear in a...", "pdfSize": "499KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+atomic-set+serializability+violations+in+multithreaded+programs+through+active+randomized+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "S. Lu, S. Park, C. Hu, X. Ma, W. Jiang, Z. Li, R.A. Popa, Y. Zhou, \"MUVI: Automatically inferring multi-variable access correlations and detecting related semantic and concurrency bugs\", <em>Symposium on Operating Systems Principles (SOSP)</em>, pp. 103-116, 2007.", "title": "MUVI: Automatically inferring multi-variable access correlations and detecting related semantic and concurrency bugs", "context": [{"sec": "sec7b", "text": " Lu et al. theoretically analyze the cost of seven interleaving coverage criteria [30].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1294261.1294272", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=MUVI%3A+Automatically+inferring+multi-variable+access+correlations+and+detecting+related+semantic+and+concurrency+bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "M. Musuvathi, S. Qadeer, T. Ball, G. Basler, P.A. Nainar, I. Neamtiu, \"Finding and reproducing Heisenbugs in concurrent programs\", <em>Symposium on Operating Systems Design and Implementation</em>, pp. 267-280, 2008.", "title": "Finding and reproducing Heisenbugs in concurrent programs", "context": [{"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec5", "text": " More sophisticated test execution approaches, such as systematic exploration of interleavings [31] or active testing [25] could be plugged into our implementation.", "part": "1"}, {"sec": "sec6a", "text": " Since targeted strategies to explore the space of possible interleavings are known to outperform repeated execution [31], we expect this difference in the setups to work in favor of Nainom and AutoConTest.", "part": "1"}, {"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+and+reproducing+Heisenbugs+in+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "M. Naik, C.-S. Park, K. Sen, D. Gay, \"Effective static deadlock detection\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 386-396, 2009.", "title": "Effective static deadlock detection", "context": [{"sec": "sec7d", "text": " Another alternative are static analyses, e.g., to detect data races [59] or deadlocks [32], [61].", "part": "1"}], "links": {"abstract": "We present an effective static deadlock detection algorithm for Java. Our algorithm uses a novel combination of static analyses each of which approximates a different necessary condition for a deadlock. We have implemented the algorithm and report upon our experience applying it to a suite of multi-threaded Java programs. While neither sound nor complete, our approach is effective in practice, finding all known deadlocks as well as discovering previously unknown ones in our benchmarks with few f...", "pdfSize": "201KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+static+deadlock+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "A. Nistor, Q. Luo, M. Pradel, T.R. Gross, D. Marinov, \"Ballerina: Automatic generation and clustering of efficient random unit tests for multithreaded code\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 727-737, 2012.", "title": "Ballerina: Automatic generation and clustering of efficient random unit tests for multithreaded code", "context": [{"sec": "sec1", "text": " Random-based approaches select at random which methods to call in the concurrently executed threads and randomly combine threads with each other [33], [39].", "part": "1"}, {"sec": "sec3", "text": " Similar to prior work [33], [39], [40], this paper focuses on tests with two suffixes.", "part": "1"}, {"sec": "sec7a", "text": " Other existing approaches include the random-based Ballerina [33] and the coverage-based ConSuite [51].", "part": "1"}], "links": {"documentLink": "/document/6227145", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227145", "abstract": "Testing multithreaded code is hard and expensive. A multithreaded unit test creates two or more threads, each executing one or more methods on shared objects of the class under test. Such unit tests can be generated at random, but basic random generation produces tests that are either slow or do not trigger concurrency bugs. Worse, such tests have many false alarms, which require human effort to filter out. We present Ballerina, a novel technique for automated random generation of efficient mult...", "pdfSize": "415KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ballerina%3A+Automatic+generation+and+clustering+of+efficient+random+unit+tests+for+multithreaded+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "R. O'Callahan, J.-D. Choi, \"Hybrid dynamic data race detection\", <em>Symposium on Principles and Practice of Parallel Programming (PPOPP)</em>, pp. 167-178, 2003.", "title": "Hybrid dynamic data race detection", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/781498.781528", "abstract": "We present a new method for dynamically detecting potential data races in multithreaded programs. Our method improves on the state of the art in accuracy, in usability, and in overhead. We improve accuracy by combining two previously known race detection techniques -- lockset-based detection and happens-before-based detection -- to obtain fewer false positives than lockset-based detection alone. We enhance usability by reporting more information about detected races than any previous dynamic det...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hybrid+dynamic+data+race+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "C. Pacheco, S.K. Lahiri, M.D. Ernst, T. Ball, \"Feedback-directed random test generation\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 75-84, 2007.", "title": "Feedback-directed random test generation", "context": [{"sec": "sec6a", "text": " For a fair comparison with CovCon, which does not require creating any sequential tests, and to avoid biasing Nainom's behavior by providing a particular set of manually written sequential tests, we generate sequential tests via feedback-directed, random test generation, similar to Randoop [35].", "part": "1"}, {"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "links": {"documentLink": "/document/4222570", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222570", "abstract": "We present a technique that improves random test generation by incorporating feedback obtained from executing test inputs as they are created. Our technique builds inputs incrementally by randomly selecting a method call to apply and finding arguments from among previously-constructed inputs. As soon as an input is built, it is executed and checked against a set of contracts and filters. The result of the execution determines whether the input is redundant, illegal, contract-violating, or useful...", "pdfSize": "269KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feedback-directed+random+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "R. Pandita, T. Xie, N. Tillmann, J. de Halleux, \"Guided test generation for coverage criteria\", <em>International Conference on Software Maintenance (ICSM)</em>, pp. 1-10, 2010.", "title": "Guided test generation for coverage criteria", "context": [{"sec": "sec1", "text": " They indicate which parts of the code still lack testing, and guide developers or automated test generation tools [2], [24], [36], [58] toward those parts.", "part": "1"}], "links": {"documentLink": "/document/5609565", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5609565", "abstract": "Test coverage criteria including boundary-value and logical coverage such as Modified Condition/Decision Coverage (MC/DC) have been increasingly used in safety-critical or mission-critical domains, complementing those more popularly used structural coverage criteria such as block or branch coverage. However, existing automated test-generation approaches often target at block or branch coverage for test generation and selection, and therefore do not support testing against boundary-value coverage...", "pdfSize": "290KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guided+test+generation+for+coverage+criteria&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "C.-S. Park, K. Sen, \"Randomized active atomicity violation detection in concurrent programs\", <em>Symposium on Foundations of Software Engineering (FSE)</em>, pp. 135-145, 2008.", "title": "Randomized active atomicity violation detection in concurrent programs", "context": [{"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1453101.1453121", "abstract": "Atomicity is an important specification that enables programmers to understand atomic blocks of code in a multi-threaded program as if they are sequential. This significantly simplifies the programmer&#39;s job to reason about correctness. Several modern multithreaded programming languages provide no built-in support to ensure atomicity; instead they rely on the fact that programmers would use locks properly in order to guarantee that atomic code blocks are indeed atomic. However, improper use of lo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Randomized+active+atomicity+violation+detection+in+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "S. Park, S. Lu, Y. Zhou, \"CTrigger: exposing atomicity violation bugs from their hiding places\", <em>Conference on ArchitecturalSupport for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 25-36, 2009.", "title": "CTrigger: exposing atomicity violation bugs from their hiding places", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}, {"sec": "sec6a", "text": " In contrast, Nainom and AutoTestGen build upon more sophisticated approaches for exploring interleavings that are likely to reveal concurrency bugs quicker [27], [29], [38], [47].", "part": "1"}, {"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1508244.1508249", "abstract": "Multicore hardware is making concurrent programs pervasive. Unfortunately, concurrent programs are prone to bugs. Among different types of concurrency bugs, atomicity violation bugs are common and important. Existing techniques to detect atomicity violation bugs suffer from one limitation: requiring bugs to manifest during monitored runs, which is an open problem in concurrent program testing. This paper makes two contributions. First, it studies the interleaving characteristics of the common pr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CTrigger%3A+exposing+atomicity+violation+bugs+from+their+hiding+places&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "M. Pradel, T.R. Gross, \"Fully automatic and precise detection of thread safety violations\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 521-530, 2012.", "title": "Fully automatic and precise detection of thread safety violations", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}, {"sec": "sec1", "text": " Random-based approaches select at random which methods to call in the concurrently executed threads and randomly combine threads with each other [33], [39].", "part": "1"}, {"sec": "sec3", "text": " Similar to prior work [33], [39], [40], this paper focuses on tests with two suffixes.", "part": "1"}, {"sec": "sec3", "text": "To check whether executing a concurrent test exposes a concurrency bug, we build upon the thread safety oracle [39].", "part": "1"}, {"sec": "sec4d", "text": " It builds upon the test generation approach from [39] to create the prefix that instantiates the class under test and calls up to \\$k\\$ additional methods with appropriate arguments to bring the tested object into a state that may reveal concurrency errors.", "part": "1"}, {"sec": "sec4d", "text": " The existing test generation approach from [39] generates the suffixes using randomly selected methods, which clearly does not fit the prioritization goal here.", "part": "1"}, {"sec": "sec6", "text": "To evaluate CovCon, we apply our implementation to 18 supposedly thread-safe classes with known, real-world concurrency bugs, which have been used to evaluate prior work [39], [55].", "part": "1"}, {"sec": "sec6", "text": " We compare the effectiveness and efficiency of CovCon to five state of the art approaches for generating concurrent unit tests [39], [42]\u2013[44], [55].", "part": "1"}, {"sec": "sec6a", "text": " The benchmarks include all classes used in [39], except for one because we could not obtain the source code, and all classes used in [55].", "part": "1"}, {"sec": "sec6a", "text": "We compare our approach to random-based test generation using ConTeGe [39] and to coverage-based test generation using AutoConTest [55].", "part": "1"}, {"sec": "sec7a", "text": "Section VI experimentally compares our work to recent random-based [39], sequential test-based [42]\u2013[44], and coverage-based [55] generators of concurrent tests.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254126", "abstract": "Concurrent, object-oriented programs often use thread-safe library classes. Existing techniques for testing a thread-safe class either rely on tests using the class, on formal specifications, or on both. Unfortunately, these techniques often are not fully automatic as they involve the user in analyzing the output. This paper presents an automatic testing technique that reveals concurrency bugs in supposedly thread-safe classes. The analysis requires as input only the class under test and reports...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fully+automatic+and+precise+detection+of+thread+safety+violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "M. Pradel, M. Huggler, T.R. Gross, \"Performance regression testing of concurrent classes\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 13-25, 2014.", "title": "Performance regression testing of concurrent classes", "context": [{"sec": "sec3", "text": " Similar to prior work [33], [39], [40], this paper focuses on tests with two suffixes.", "part": "1"}, {"sec": "sec7a", "text": "SpeedGun [40] generates concurrent tests that expose performance problems.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2610393", "abstract": "Developers of thread-safe classes struggle with two opposing goals. The class must be correct, which requires synchronizing concurrent accesses, and the class should provide reasonable performance, which is difficult to realize in the presence of unnecessary synchronization. Validating the performance of a thread-safe class is challenging because it requires diverse workloads that use the class, because existing performance analysis techniques focus on individual bottleneck methods, and because ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Performance+regression+testing+of+concurrent+classes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "W. Pugh, N. Ayewah, \"Unit testing concurrent software\", <em>Conference on Automated Software Engineering (ASE)</em>, pp. 513-516, 2007.", "title": "Unit testing concurrent software", "context": [{"sec": "sec7a", "text": " MultithreadedTC [41] and IMUnit [22] are unit testing frameworks to manually write concurrent unit tests.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1321631.1321722", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Unit+testing+concurrent+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "M. Samak, M.K. Ramanathan, \"Multithreaded test synthesis for deadlock detection\", <em>Conference on Object-Oriented Programming Systems Languages and Applications (OOPSLA)</em>, pp. 473-489, 2014.", "title": "Multithreaded test synthesis for deadlock detection", "context": [{"sec": "sec1", "text": " Sequential test-based approaches execute existing sequential unit tests of the thread-safe class, identify concurrency bugs that may occur when combining multiple sequential tests into concurrent tests, and then synthesize such tests [42]\u2013[44].", "part": "1"}, {"sec": "sec1", "text": " Furthermore, a common limitation of existing non-random approaches is to consider only a particular kind of concurrency bugs, e.g., data races [44], atomicity violations [43], [55], or deadlocks [42].", "part": "1"}, {"sec": "sec6", "text": " We compare the effectiveness and efficiency of CovCon to five state of the art approaches for generating concurrent unit tests [39], [42]\u2013[44], [55].", "part": "1"}, {"sec": "sec6a", "text": " To compare our approach with sequential test-based approaches, we use Narada [44], Intruder [43], and Omen [42], which detect data races, atomicity violations, and deadlocks, respectively.", "part": "1"}, {"sec": "sec7a", "text": "Section VI experimentally compares our work to recent random-based [39], sequential test-based [42]\u2013[44], and coverage-based [55] generators of concurrent tests.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multithreaded+test+synthesis+for+deadlock+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "M. Samak, M.K. Ramanathan, \"Synthesizing tests for detecting atomicity violations\", <em>ESEC/FSE</em>, pp. 131-142, 2015.", "title": "Synthesizing tests for detecting atomicity violations", "context": [{"sec": "sec1", "text": " Sequential test-based approaches execute existing sequential unit tests of the thread-safe class, identify concurrency bugs that may occur when combining multiple sequential tests into concurrent tests, and then synthesize such tests [42]\u2013[43][44].", "part": "1"}, {"sec": "sec1", "text": " Furthermore, a common limitation of existing non-random approaches is to consider only a particular kind of concurrency bugs, e.g., data races [44], atomicity violations [43], [55], or deadlocks [42].", "part": "1"}, {"sec": "sec6", "text": " We compare the effectiveness and efficiency of CovCon to five state of the art approaches for generating concurrent unit tests [39], [42]\u2013[43][44], [55].", "part": "1"}, {"sec": "sec6a", "text": " To compare our approach with sequential test-based approaches, we use Narada [44], Intruder [43], and Omen [42], which detect data races, atomicity violations, and deadlocks, respectively.", "part": "1"}, {"sec": "sec7a", "text": "Section VI experimentally compares our work to recent random-based [39], sequential test-based [42]\u2013[43][44], and coverage-based [55] generators of concurrent tests.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786874", "abstract": "Using thread-safe libraries can help programmers avoid the complexities of multithreading. However, designing libraries that guarantee thread-safety can be challenging. Detecting and eliminating atomicity violations when methods in the libraries are invoked concurrently is vital in building reliable client applications that use the libraries. While there are dynamic analyses to detect atomicity violations, these techniques are critically dependent on effective multithreaded tests. Unfortunately,...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Synthesizing+tests+for+detecting+atomicity+violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "M. Samak, M.K. Ramanathan, S. Jagannathan, \"Synthesizing racy tests\", <em>PLDI</em>, pp. 175-185, 2015.", "title": "Synthesizing racy tests", "context": [{"sec": "sec1", "text": " Sequential test-based approaches execute existing sequential unit tests of the thread-safe class, identify concurrency bugs that may occur when combining multiple sequential tests into concurrent tests, and then synthesize such tests [42]\u2013[44].", "part": "1"}, {"sec": "sec1", "text": " Furthermore, a common limitation of existing non-random approaches is to consider only a particular kind of concurrency bugs, e.g., data races [44], atomicity violations [43], [55], or deadlocks [42].", "part": "1"}, {"sec": "sec6", "text": " We compare the effectiveness and efficiency of CovCon to five state of the art approaches for generating concurrent unit tests [39], [42]\u2013[44], [55].", "part": "1"}, {"sec": "sec6a", "text": " To compare our approach with sequential test-based approaches, we use Narada [44], Intruder [43], and Omen [42], which detect data races, atomicity violations, and deadlocks, respectively.", "part": "1"}, {"sec": "sec7a", "text": "Section VI experimentally compares our work to recent random-based [39], sequential test-based [42]\u2013[44], and coverage-based [55] generators of concurrent tests.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2737998", "abstract": "Subtle concurrency errors in multithreaded libraries that arise because of incorrect or inadequate synchronization are often difficult to pinpoint precisely using only static techniques. On the other hand, the effectiveness of dynamic race detectors is critically dependent on multithreaded test suites whose execution can be used to identify and trigger races. Usually, such multithreaded tests need to invoke a specific combination of methods with objects involved in the invocations being shared a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Synthesizing+racy+tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, T.E. Anderson, \"Eraser: A dynamic data race detector for multithreaded programs\", <em>ACM Transactions on ComputerSystems</em>, vol. 15, no. 4, pp. 391-411, 1997.", "title": "Eraser: A dynamic data race detector for multithreaded programs", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/265924.265927", "abstract": "Multithreaded programming is difficult and error prone. It is easy to make a mistake in synchronization that produces a data race, yet it can be extremely hard to locate this mistake during debugging. This article describes a new tool, called Eraser, for dynamically detecting data races in lock-based multithreaded programs. Eraser uses binary rewriting techniques to monitor every shared-monory reference and verify that consistent locking behavior is observed. We present several case studies, inc...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eraser%3A+A+dynamic+data+race+detector+for+multithreaded+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "J. Schimmel, K. Molitorisz, A. Jannesari, W.F. Tichy, \"Automatic generation of parallel unit tests\", <em>Workshop on Automation of Software Test (AST)</em>, pp. 40-46, 2013.", "title": "Automatic generation of parallel unit tests", "context": [{"sec": "sec7a", "text": " [46] combine test generation with a static pre-analysis of the code to find methods that access shared data.", "part": "1"}], "links": {"abstract": "Multithreaded software is subject to data races. Currently available data race detectors report such errors to the developer, but consume large amounts of time and memory; many approaches are not applicable for large software projects. Unit tests containing fractions of the program lead to better results. We propose AutoRT, an approach to automatically generate parallel unit tests as target for data race detectors from existing programs. AutoRT uses the Single Static Multiple Dynamic (SSMD) anal...", "pdfSize": "267KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+generation+of+parallel+unit+tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "K. Sen, \"Race directed random testing of concurrent programs\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 11-21, 2008.", "title": "Race directed random testing of concurrent programs", "context": [{"sec": "sec1", "text": " To determine whether a generated test exposes a bug, the concurrent execution is then compared against linearizations of the test [5], [39] or analyzed by existing detectors of data races [16], [34], [45], [47], atomicity violations [1], [15], [38], or deadlocks [26].", "part": "1"}, {"sec": "sec6a", "text": " In contrast, Nainom and AutoTestGen build upon more sophisticated approaches for exploring interleavings that are likely to reveal concurrency bugs quicker [27], [29], [38], [47].", "part": "1"}, {"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1375581.1375584", "abstract": "Bugs in multi-threaded programs often arise due to data races. Numerous static and dynamic program analysis techniques have been proposed to detect data races. We propose a novel randomized dynamic analysis technique that utilizes potential data race information obtained from an existing analysis tool to separate real races from false races without any need for manual inspection. Specifically, we use potential data race information obtained from an existing dynamic analysis technique to control ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+directed+random+testing+of+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "K. Sen, D. Marinov, G. Agha, \"CUTE: a concolic unit testing engine for C\", <em>European Software Engineering Conference and International Symposium on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 263-272, 2005.", "title": "CUTE: a concolic unit testing engine for C", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=CUTE%3A+a+concolic+unit+testing+engine+for+C&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "A. Solar-Lezama, C.G. Jones, R. Bod\u00edk, \"Sketching concurrent data structures\", <em>Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 136-148, 2008.", "title": "Sketching concurrent data structures", "context": [{"sec": "sec7d", "text": "One alternative to testing concurrent software are synthesis and verification [20], [49], [56].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1375581.1375599", "abstract": "We describe PSketch, a program synthesizer that helps programmers implement concurrent data structures. The system is based on the concept of sketching, a form of synthesis that allows programmers to express their insight about an implementation as a partial program: a sketch. The synthesizer automatically completes the sketch to produce an implementation that matches a given correctness criteria. PSketch is based on a new counterexample-guided inductive synthesis algorithm (CEGIS) that generali...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sketching+concurrent+data+structures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "F. Sorrentino, A. Farzan, P. Madhusudan, \"PENELOPE: weaving threads to expose atomicity violations\", <em>Symposium on Foundations of Software Engineering (FSE)</em>, pp. 37-46, 2010.", "title": "PENELOPE: weaving threads to expose atomicity violations", "context": [{"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1882291.1882300", "abstract": "Testing concurrent programs is challenged by the interleaving explosion problem--- the problem of exploring the large number of interleavings a program exhibits, even under a single test input. Rather than try all interleavings, we propose to test wisely: to exercise only those schedules that lead to interleavings that are typical error patterns. In particular, in this paper we select schedules that exercise patterns of interaction that correspond to atomicity violations. Given an execution of a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=PENELOPE%3A+weaving+threads+to+expose+atomicity+violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "S. Steenbuck, G. Fraser, \"Generating unit tests for concurrent classes\", <em>International Conference on Software Testing Verification and Validation (ICST)</em>, 2013.", "title": "Generating unit tests for concurrent classes", "context": [{"sec": "sec1", "text": " Finally, coverage-based approaches compute a set of concurrency-related coverage requirements and generate tests that cover as many of these requirements as possible [51], [55].", "part": "1"}, {"sec": "sec1", "text": " We follow the philosophy of recent coverage-based approaches [51], [55] to guide random-based test generation toward not yet covered inter-leavings, making it less random and more likely to trigger not yet exercised (mis)behavior.", "part": "1"}, {"sec": "sec4a", "text": " Recent coverage-based approaches [51], [55] focus on partial-order interleavings, and hence address the practicality issue of the naive approach, but cannot address the efficiency issues.", "part": "1"}, {"sec": "sec7a", "text": " Other existing approaches include the random-based Ballerina [33] and the coverage-based ConSuite [51].", "part": "1"}], "links": {"abstract": "As computers become more and more powerful, programs are increasingly split up into multiple threads to leverage the power of multi-core CPUs. However, writing correct multi-threaded code is a hard problem, as the programmer has to ensure that all access to shared data is coordinated. Existing automated testing tools for multi-threaded code mainly focus on re-executing existing test cases with different schedules. In this paper, we introduce a novel coverage criterion that enforces concurrent ex...", "pdfSize": "213KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generating+unit+tests+for+concurrent+classes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "S. Tasharofi, M. Pradel, Y. Lin, R. Johnson, \"Bita: Coverage-guided automatic testing of actor programs\", <em>Conference on Automated Software Engineering (ASE)</em>, 2013.", "title": "Bita: Coverage-guided, automatic testing of actor programs", "context": [{"sec": "sec7c", "text": " Other work uses concurrent coverage metrics to select and prioritize schedules to explore [21], [52], [60], [65].", "part": "1"}], "links": {"documentLink": "/document/6693072", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693072", "abstract": "Actor programs are concurrent programs where concurrent entities communicate asynchronously by exchanging messages. Testing actor programs is challenging because the order of message receives depends on the non-deterministic scheduler and because exploring all schedules does not scale to large programs. This paper presents Bita, a scalable, automatic approach for testing non-deterministic behavior of actor programs. The key idea is to generate and explore schedules that are likely to reveal conc...", "pdfSize": "328KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bita%3A+Coverage-guided%2C+automatic+testing+of+actor+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "R.N. Taylor, D.L. Levine, C.D. Kelly, \"Structural testing of concurrent programs\", <em>IEEE Transactions on Software Engineering</em>, vol. 18, no. 3, pp. 206-215, 1992.", "title": "Structural testing of concurrent programs", "context": [{"sec": "sec7b", "text": " Taylor et al. pioneered by proposing a hierarchy of concurrency coverage criteria [53].", "part": "1"}], "links": {"documentLink": "/document/126769", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=126769", "abstract": "Although structural testing techniques are among the weakest available with regard to developing confidence in sequential programs, they are not without merit. The authors extend the notion of structural testing criteria to concurrent programs and propose a hierarchy of supporting structural testing techniques. Coverage criteria described include concurrency state coverage, state transition coverage and synchronization coverage. Requisite support tools include a static concurrency analyzer and e...", "pdfSize": "834KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Structural+testing+of+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "V. Terragni, S. Cheung, C. Zhang, \"RECONTEST: effective regression testing of concurrent programs\", <em>ICSE</em>, pp. 246-256, 2015.", "title": "RECONTEST: effective regression testing of concurrent programs", "context": [{"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "links": {"abstract": "Concurrent programs proliferate as multi-core technologies advance. The regression testing of concurrent programs often requires running a failing test for weeks before catching a faulty interleaving, due to the myriad of possible interleavings of memory accesses arising from concurrent program executions. As a result, the conventional approach that selects a sub-set of test cases for regression testing without considering interleavings is insufficient. In this paper we present RECONTEST to addr...", "pdfSize": "887KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=RECONTEST%3A+effective+regression+testing+of+concurrent+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "V. Terragni, S.-C. Cheung, \"Coverage-driven test code generation for concurrent classes\", <em>ICSE</em>, 2016.", "title": "Coverage-driven test code generation for concurrent classes", "context": [{"sec": "sec1", "text": " Finally, coverage-based approaches compute a set of concurrency-related coverage requirements and generate tests that cover as many of these requirements as possible [51], [55].", "part": "1"}, {"sec": "sec1", "text": " Furthermore, a common limitation of existing non-random approaches is to consider only a particular kind of concurrency bugs, e.g., data races [44], atomicity violations [43], [55], or deadlocks [42].", "part": "1"}, {"sec": "sec1", "text": " We follow the philosophy of recent coverage-based approaches [51], [55] to guide random-based test generation toward not yet covered inter-leavings, making it less random and more likely to trigger not yet exercised (mis)behavior.", "part": "1"}, {"sec": "sec4a", "text": " Recent coverage-based approaches [51], [55] focus on partial-order interleavings, and hence address the practicality issue of the naive approach, but cannot address the efficiency issues.", "part": "1"}, {"sec": "sec6", "text": "To evaluate CovCon, we apply our implementation to 18 supposedly thread-safe classes with known, real-world concurrency bugs, which have been used to evaluate prior work [39], [55].", "part": "1"}, {"sec": "sec6", "text": " We compare the effectiveness and efficiency of CovCon to five state of the art approaches for generating concurrent unit tests [39], [42]\u2013[44], [55].", "part": "1"}, {"sec": "sec6a", "text": " The benchmarks include all classes used in [39], except for one because we could not obtain the source code, and all classes used in [55].", "part": "1"}, {"sec": "sec6a", "text": "We compare our approach to random-based test generation using ConTeGe [39] and to coverage-based test generation using AutoConTest [55].", "part": "1"}, {"sec": "sec7a", "text": "Section VI experimentally compares our work to recent random-based [39], sequential test-based [42]\u2013[44], and coverage-based [55] generators of concurrent tests.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884876", "abstract": "Previous techniques on concurrency testing have mainly focused on exploring the interleaving space of manually written test code to expose faulty interleavings of shared memory accesses. These techniques assume the availability of failure-inducing tests. In this paper, we present AutoConTest, a coverage-driven approach to generate effective concurrent test code that achieve high interleaving coverage. AutoConTest consists of three components. First, it computes the coverage requirements dynamica...", "pdfSize": "752KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coverage-driven+test+code+generation+for+concurrent+classes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "M.T. Vechev, E. Yahav, G. Yorsh, \"Abstraction-guided synthesis of synchronization\", <em>Proceedings of the 37th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages POPL 2010</em>, pp. 327-338, January 17\u201323, 2010.", "title": "Abstraction-guided synthesis of synchronization", "context": [{"sec": "sec7d", "text": "One alternative to testing concurrent software are synthesis and verification [20], [49], [56].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1706299.1706338", "abstract": "We present a novel framework for automatic inference of efficient synchronization in concurrent programs, a task known to be difficult and error-prone when done manually. Our framework is based on abstract interpretation and can infer synchronization for infinite state programs. Given a program, a specification, and an abstraction, we infer synchronization that avoids all (abstract) interleavings that may violate the specification, but permits as many valid interleavings as possible. Combined wi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Abstraction-guided+synthesis+of+synchronization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "W. Visser, K. Havelund, G.P. Brat, S. Park, F. Lerda, \"Model checking programs\", <em>Automated Software Engineering</em>, vol. 10, no. 2, pp. 203-232, 2003.", "title": "Model checking programs", "context": [{"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec7c", "text": "A single program and input may have many different schedules; approaches for exhaustive [28], [57], bounded [31], change-based [23], [54], and heuristic [8], [11] exploration of schedules have been proposed.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/A:1022920129859", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Model+checking+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "W. Visser, C.S. Pasareanu, S. Khurshid, \"Test input generation with Java PathFinder\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 97-107, 2004.", "title": "Test input generation with Java PathFinder", "context": [{"sec": "sec1", "text": " They indicate which parts of the code still lack testing, and guide developers or automated test generation tools [2], [24], [36], [58] toward those parts.", "part": "1"}, {"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1007512.1007526", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+input+generation+with+Java+PathFinder&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "C. von Praun, T.R. Gross, \"Static conflict analysis for multi-threaded object-oriented programs\", <em>Conference on Programming Languages Design and Implementation</em>, pp. 115-128, 2003.", "title": "Static conflict analysis for multi-threaded object-oriented programs", "context": [{"sec": "sec7d", "text": " Another alternative are static analyses, e.g., to detect data races [59] or deadlocks [32], [61].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/781131.781145", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+conflict+analysis+for+multi-threaded+object-oriented+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "C. Wang, M. Said, A. Gupta, \"Coverage guided systematic concurrency testing\", <em>Proceedings of the 33rd International Conference on Software Engineering ICSE 2011</em>, pp. 221-230, May 21\u201328, 2011.", "title": "Coverage guided systematic concurrency testing", "context": [{"sec": "sec1", "text": "Note that our work differs from recent work on generating schedules based on concurrent coverage metrics [21], [60], [65] because CovCon generates test cases instead of schedules.", "part": "1"}, {"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec7c", "text": " Other work uses concurrent coverage metrics to select and prioritize schedules to explore [21], [52], [60], [65].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985824", "abstract": "Shared-memory multi-threaded programs are notoriously difficult to test, and because of the often astronomically large number of thread schedules, testing all possible interleavings is practically infeasible. In this paper we propose a coverage-guided systematic testing framework, where we use dynamically learned ordering constraints over shared object accesses to select only high-risk interleavings for test execution. An interleaving is of high-risk if it has not been covered by the ordering co...", "pdfSize": "442KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coverage+guided+systematic+concurrency+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "A. Williams, W. Thies, M.D. Ernst, \"Static deadlock detection for java libraries\", <em>European Conference on Object-Oriented Programming (ECOOP)</em>, pp. 602-629, 2005.", "title": "Static deadlock detection for java libraries", "context": [{"sec": "sec7d", "text": " Another alternative are static analyses, e.g., to detect data races [59] or deadlocks [32], [61].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+deadlock+detection+for+java+libraries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "T. Xie, D. Marinov, W. Schulte, D. Notkin, \"Symstra: A framework for generating object-oriented unit tests using symbolic execution\", <em>Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</em>, pp. 365-381, 2005.", "title": "Symstra: A framework for generating object-oriented unit tests using symbolic execution", "context": [{"sec": "sec7a", "text": " Besides concurrent tests, there is a long history of approaches for generating sequential tests, e.g., based on random testing [9], [12], [35], symbolic execution [58], [62], concolic execution [7], [19], [48], and genetic algorithms [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symstra%3A+A+framework+for+generating+object-oriented+unit+tests+using+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "W. Xiong, S. Park, J. Zhang, Y. Zhou, Z. Ma, \"\n            \n              \\$A\\$\n            \n            d hoc synchronization considered harmful\n          \", <em>Symposium on Operating Systems Design and Implementation (OSDI)</em>, pp. 163-176, 2010.", "title": "\n            ", "context": [{"sec": "sec4c", "text": " Finally, static analysis may incorrectly judge a pair of methods that cannot execute concurrently due to ad hoc synchronization [63], but our prioritization score would not be affected.", "part": "1"}], "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "C.-S. D. Yang, A.L. Souter, L.L. Pollock, \"All-du-path coverage for parallel programs\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 153-162, 1998.", "title": "All-du-path coverage for parallel programs", "context": [{"sec": "sec7b", "text": " Other work adapts the definition-use path coverage criterion to concurrent programs [64].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/271771.271804", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=All-du-path+coverage+for+parallel+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "J. Yu, S. Narayanasamy, C. Pereira, G. Pokam, \"Maple: a coverage-driven testing tool for multithreaded programs\", <em>Conference on Object-Oriented Programming Systems Languages and Applications (OOPSLA)</em>, pp. 485-502, 2012.", "title": "Maple: a coverage-driven testing tool for multithreaded programs", "context": [{"sec": "sec1", "text": "Note that our work differs from recent work on generating schedules based on concurrent coverage metrics [21], [60], [65] because CovCon generates test cases instead of schedules.", "part": "1"}, {"sec": "sec1", "text": " Once test cases are available, e.g., generated by CovCon, they can be explored with any approach for generating schedules, including coverage-based approaches [21], [60], [65], active testing [25], bounded exploration [31], and exhaustive exploration [28], [57].", "part": "1"}, {"sec": "sec7c", "text": " Other work uses concurrent coverage metrics to select and prioritize schedules to explore [21], [52], [60], [65].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2384616.2384651", "abstract": "Testing multithreaded programs is a hard problem, because it is challenging to expose those rare interleavings that can trigger a concurrency bug. We propose a new thread interleaving coverage-driven testing tool called Maple that seeks to expose untested thread interleavings as much as possible. It memoizes tested interleavings and actively seeks to expose untested interleavings for a given test input to increase interleaving coverage. We discuss several solutions to realize the above goal. Fir...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Maple%3A+a+coverage-driven+testing+tool+for+multithreaded+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "W. Zhang, J. Lim, R. Olichandran, J. Scherpelz, G. Jin, S. Lu, T.W. Reps, \"ConSeq: detecting concurrency bugs through sequential errors\", <em>Conference on ArchitecturalSupport for Programming Languages and Operating Systems (A SPL OS)</em>, pp. 251-264, 2011.", "title": "ConSeq: detecting concurrency bugs through sequential errors", "context": [{"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1950365.1950395", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ConSeq%3A+detecting+concurrency+bugs+through+sequential+errors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "W. Zhang, C. Sun, S. Lu, \"ConMem: detecting severe concurrency bugs through an effect-oriented approach\", <em>Conference on ArchitecturalSupport for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 179-192, 2010.", "title": "ConMem: detecting severe concurrency bugs through an effect-oriented approach", "context": [{"sec": "sec7c", "text": " Active testing searches for potential concurrency bugs with a static or dynamic analysis and forces schedules that may trigger the potential bugs [6], [17], [25], [27], [29], [37], [38], [47], [50], [66], [67].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1736020.1736041", "abstract": "Multicore technology is making concurrent programs increasingly pervasive. Unfortunately, it is difficult to deliver reliable concurrent programs, because of the huge and non-deterministic interleaving space. In reality, without the resources to thoroughly check the interleaving space, critical concurrency bugs can slip into production runs and cause failures in the field. Approaches to making the best use of the limited resources and exposing severe concurrency bugs before software release woul...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ConMem%3A+detecting+severe+concurrency+bugs+through+an+effect-oriented+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985668", "articleId": "7985668", "startPage": "266", "endPage": "277", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 8, "citationCountPatent": 0, "totalDownloads": 254}}
{"title": "A SEALANT for Inter-App Security Holes in Android", "authors": [{"name": "Youn Kyu Lee", "affiliation": "Comput. Sci. Dept., Univ. of Southern California, Los Angeles, CA, USA", "firstName": "Youn Kyu", "lastName": "Lee", "id": "37086072489"}, {"name": "Jae Young Bang", "affiliation": "Kakao Corp., Seongnam, South Korea", "firstName": "Jae Young", "lastName": "Bang", "id": "37086069466"}, {"name": "Gholamreza Safi", "affiliation": "Comput. Sci. Dept., Univ. of Southern California, Los Angeles, CA, USA", "firstName": "Gholamreza", "lastName": "Safi", "id": "38272312900"}, {"name": "Arman Shahbazian", "affiliation": "Comput. Sci. Dept., Univ. of Southern California, Los Angeles, CA, USA", "firstName": "Arman", "lastName": "Shahbazian", "id": "37085494077"}, {"name": "Yixue Zhao", "affiliation": "Comput. Sci. Dept., Univ. of Southern California, Los Angeles, CA, USA", "firstName": "Yixue", "lastName": "Zhao", "id": "37085998488"}, {"name": "Nenad Medvidovic", "affiliation": "Comput. Sci. Dept., Univ. of Southern California, Los Angeles, CA, USA", "firstName": "Nenad", "lastName": "Medvidovic", "id": "37271749400"}], "abstract": "Android's communication model has a major security weakness: malicious apps can manipulate other apps into performing unintended operations and can steal end-user data, while appearing ordinary and harmless. This paper presents SEALANT, a technique that combines static analysis of app code, which infers vulnerable communication channels, with runtime monitoring of inter-app communication through those channels, which helps to prevent attacks. SEALANT's extensive evaluation demonstrates that (1) it detects and blocks inter-app attacks with high accuracy in a corpus of over 1,100 real-world apps, (2) it suffers from fewer false alarms than existing techniques in several representative scenarios, (3) its performance overhead is negligible, and (4) end-users do not find it challenging to adopt.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Sealing materials", "Androids", "Humanoid robots", "Runtime", "Security", "Monitoring", "Focusing"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "program diagnostics", "security of data"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["SEALANT technique", "inter-app security holes", "Android communication model", "static analysis", "app code", "vulnerable communication channels", "inter-app communication runtime monitoring"]}, {"type": "Author Keywords ", "kwd": ["Android", "Security", "Inter-app vulnerability"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.36", "ref": [{"order": "1", "text": "<em>2012 Norton Cybercrime Report</em>, 2012,  [online]  Available: http://www.norton.com/2012cybercrimereport.", "title": "2012 Norton Cybercrime Report", "context": [{"sec": "sec1", "text": "This paper targets a known vulnerability in the design of Android's communication model [1], in which components in a single app or across multiple apps communicate by exchanging messages called intents.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=2012+Norton+Cybercrime+Report&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "E. Chin, A.P. Felt, K. Greenwood, D. Wagner, \"Analyzing Inter-Application Communication in Android\", <em>Proceedings of the 9th International Conference on Mobile Systems Applications and Services</em>.", "title": "Analyzing Inter-Application Communication in Android", "context": [{"sec": "sec1", "text": " Inter-component communication (ICC) via intent exchange can expose a vulnerable surface to several security attacks, including intent spoofing [2], unauthorized intent receipt [2], and privilege escalation [3].", "part": "1"}, {"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[14].", "part": "1"}, {"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec3a", "text": " It does so by focusing, both, on the data-flow between components and on compositional patterns of ICCs derived from published literature [2].", "part": "1"}, {"sec": "sec3a3", "text": " Algorithm 1 iterates over each edge \\$e\\$ in \\$IAC\\cup ICC\\$ (lines 5\u201319) and considers four different cases that cover all types of vulnerable paths we target in this paper: the first two cases identify paths that involve vulnerable components; the latter two cases identify paths based on previously identified compositional patterns [2].", "part": "1"}, {"sec": "sec5b1", "text": " To mitigate internal threats to the validity of our results, we also asked 39 graduate students at University of Southern California (USC) to build sets of apps that implement inter-app attacks based on published literature [2], [11].", "part": "1"}, {"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[63].", "part": "1"}, {"sec": "sec6", "text": " ComDroid [2] categorizes vulnerabilities in inter-app communication and detects vulnerabilities in target apps via static analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1999995.2000018", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analyzing+Inter-Application+Communication+in+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "S. Bugiel, L. Davi, A. Dmitrienko, T. Fischer, A.-R. Sadeghi, \"XManDroid: A New Android Evolution to Mitigate Privilege Escalation Attacks\", <em>Tech. Rep. TR-2011-04</em>, 2011.", "title": "XManDroid: A New Android Evolution to Mitigate Privilege Escalation Attacks", "context": [{"sec": "sec1", "text": " Inter-component communication (ICC) via intent exchange can expose a vulnerable surface to several security attacks, including intent spoofing [2], unauthorized intent receipt [2], and privilege escalation [3].", "part": "1"}, {"sec": "sec5a", "text": "To the best of our knowledge, two existing works share SEALANT's goal of providing protection of end-users from inter-app attacks: SEPAR [15] (previously named Droid-Guard [17]) and XmanDroid [3], [11].", "part": "1"}, {"sec": "sec5a", "text": " For these reasons, we decided to analytically compare the three techniques, relying on the published algorithms of SEPAR [15] and XmanDroid [3], [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=XManDroid%3A+A+New+Android+Evolution+to+Mitigate+Privilege+Escalation+Attacks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "L. Li, A. Bartel, T.F. Bissyand\u00e9, J. Klein, Y. Le Traon, S. Arzt, S. Rasthofer, E. Bodden, D. Octeau, P. Mcdaniel, \"IccTA: Detecting Inter-Component Privacy Leaks in Android App\", <em>Proceedings of the 37th International Conference on Software Engineering</em>, 2015.", "title": "IccTA: Detecting Inter-Component Privacy Leaks in Android App", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[14].", "part": "1"}, {"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec1", "text": " The state-of-the-art techniques [4], [5], [15] employ data-flow analyses that rely on lists of frequently used Android API methods [16], but tend to overlook ICC vulnerabilities caused by custom methods.", "part": "1"}, {"sec": "sec1", "text": " Moreover, these analyses [4]\u2013[6] have been shown to experience scalability problems when applied on large numbers of apps [17].", "part": "1"}, {"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}, {"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}, {"sec": "sec6", "text": " IccTA [4] is a taint-flow analysis targeting privacy leaks.", "part": "1"}], "links": {"abstract": "Shake Them All is a popular &#34;Wallpaper&#34; application exceeding millions of downloads on Google Play. At installation, this application is given permission to (1) access the Internet (for updating wallpapers) and (2) use the device microphone (to change background following noise changes). With these permissions, the application could silently record user conversations and upload them remotely. To give more confidence about how Shake Them All actually processes what it records, it is necessary to ...", "pdfSize": "724KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=IccTA%3A+Detecting+Inter-Component+Privacy+Leaks+in+Android+App&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "W. Klieber, L. Flynn, A. Bhosale, L. Jia, L. Bauer, \"Android Taint Flow Analysis for App Sets\", <em>Proceedings of the 3rd International Workshop on the State of the Art in Java Program Analysis</em>, 2014.", "title": "Android Taint Flow Analysis for App Sets", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[5][14].", "part": "1"}, {"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[5][6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec1", "text": " The state-of-the-art techniques [4], [5], [15] employ data-flow analyses that rely on lists of frequently used Android API methods [16], but tend to overlook ICC vulnerabilities caused by custom methods.", "part": "1"}, {"sec": "sec1", "text": " Moreover, these analyses [4]\u2013[5][6] have been shown to experience scalability problems when applied on large numbers of apps [17].", "part": "1"}, {"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}, {"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[5][7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}, {"sec": "sec6", "text": " DidFail [5] uses taint-flow analysis to locate sensitive inter-app data-flows, but targets only Activity components and neglects intents' data scheme.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2614628.2614633", "abstract": "One approach to defending against malicious Android applications has been to analyze them to detect potential information leaks. This paper describes a new static taint analysis for Android that combines and augments the FlowDroid and Epicc analyses to precisely track both inter-component and intra-component data flow in a set of Android applications. The analysis takes place in two phases: given a set of applications, we first determine the data flows enabled individually by each application, a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Taint+Flow+Analysis+for+App+Sets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "F. Wei, S. Roy, X. Ou, Robby, \"Amandroid: A Precise and General Inter-component Data Flow Analysis Framework for Security Vetting of Android Apps\", <em>Proceedings of the ACM SIGSAC Conference on Computer and Communications Security</em>, 2014.", "title": "Amandroid: A Precise and General Inter-component Data Flow Analysis Framework for Security Vetting of Android Apps", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[6][14].", "part": "1"}, {"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec1", "text": " Moreover, these analyses [4]\u2013[6] have been shown to experience scalability problems when applied on large numbers of apps [17].", "part": "1"}, {"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}, {"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[6][7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}, {"sec": "sec6", "text": " AmanDroid [6] identifies privacy leaks by tracking components interactions, but has been shown to work incorrectly on Content Provider components and certain ICC methods.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660357", "abstract": "We propose a new approach to conduct static analysis for security vetting of Android apps, and built a general framework, called Amandroid for determining points-to information for all objects in an Android app in a flow- and context-sensitive way across Android apps components. We show that: (a) this type of comprehensive analysis is completely feasible in terms of computing resources needed with modern hardware, (b) one can easily leverage the results from this general analysis to build variou...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Amandroid%3A+A+Precise+and+General+Inter-component+Data+Flow+Analysis+Framework+for+Security+Vetting+of+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "H. Bagheri, A. Sadeghi, J. Garcia, S. Malek, \"COVERT: Compositional Analysis of Android Inter-App Permission Leakage\", <em>IEEE Transactions on Software Engineering</em>, vol. 41, no. 9, pp. 866-886, 2015.", "title": "COVERT: Compositional Analysis of Android Inter-App Permission Leakage", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[7][14].", "part": "1"}, {"sec": "sec4", "text": " Analyzer integrates two static analysis tools, IC3 [34] and COVERT [7], to extract architectural objects from apps.", "part": "1"}, {"sec": "sec4", "text": " We employed both tools because neither of them alone discovers all of the needed information: IC3 misses outbound intents in certain scenarios [34], while COVERT only returns coarse-grained intent information that excludes certain attributes (e.g., data type) [7].", "part": "1"}, {"sec": "sec5b2", "text": " It was unable to correctly extract intent information in three cases due to the inaccuracies inherited from IC3 [34] and COVERT [7] (recall Section IV).", "part": "1"}, {"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}, {"sec": "sec6", "text": " COVERT [7] introduces a compositional analysis of inter-app vulnerabilities, especially against permission leakage.", "part": "1"}], "links": {"documentLink": "/document/7079508", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7079508", "abstract": "Android is the most popular platform for mobile devices. It facilitates sharing of data and services among applications using a rich inter-app communication system. While access to resources can be controlled by the Android permission system, enforcing permissions is not sufficient to prevent security violations, as permissions may be mismanaged, intentionally or unintentionally. Android&#39;s enforcement of the permissions is at the level of individual apps, allowing multiple malicious apps to coll...", "pdfSize": "1655KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=COVERT%3A+Compositional+Analysis+of+Android+Inter-App+Permission+Leakage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "S. Rasthofer, S. Arzt, E. Lovat, E. Bodden, \"DroidForce: Enforcing Complex Data-centric System-wide Policies in Android\", <em>Proceedings of the 9th International Conference on Availability Reliability and Security (ARES)</em>, 2014.", "title": "DroidForce: Enforcing Complex, Data-centric, System-wide Policies in Android", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[8][14].", "part": "1"}, {"sec": "sec1", "text": " Additionally, these techniques assume a degree of expertise in Android security [8], [9], [11], [13].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec6", "text": " DroidForce [8] enforces custom data-centric policies by instrumenting an app's bytecode.", "part": "1"}], "links": {"abstract": "Smartphones are nowadays used to store and process many kinds of privacy-sensitive data such as contacts, photos, and e-mails. Sensors provide access to the phone&#39;s physical location, and can record audio and video. While this is convenient for many applications, it also makes smartphones a worthwhile target for attackers providing malicious applications. Current approaches to runtime enforcement try to mitigate unauthorized leaks of confidential data. However, they are often capable of enforcin...", "pdfSize": "266KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidForce%3A+Enforcing+Complex%2C+Data-centric%2C+System-wide+Policies+in+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "M. Ongtang, S. McLaughlin, W. Enck, P. McDaniel, \"Semantically Rich Application-Centric Security in Android\", <em>Proceedings of the Annual Computer Security Applications Conference (ACSAC)</em>, 2009.", "title": "Semantically Rich Application-Centric Security in Android", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[9][14].", "part": "1"}, {"sec": "sec1", "text": " Additionally, these techniques assume a degree of expertise in Android security [8], [9], [11], [13].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec6", "text": " Saint [9] extends Android to enable control of an app's behavior via app provider's policies.", "part": "1"}], "links": {"abstract": "Smartphones are now ubiquitous. However, the security requirements of these relatively new systems and the applications they support are still being understood. As a result, the security infrastructure available in current smartphone operating systems is largely underdeveloped. In this paper, we consider the security requirements of smartphone applications and augment the existing Android operating system with a framework to meet them. We present Secure Application INTeraction (Saint), a modifie...", "pdfSize": "567KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semantically+Rich+Application-Centric+Security+in+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S. Bugiel, S. Heuser, A.-R. Sadeghi, \"Flexible and Fine-Grained Mandatory Access Control on Android for Diverse Security and Privacy Policies\", <em>Proceedings of the 22nd USENIX Conference on Security</em>.", "title": "Flexible and Fine-Grained Mandatory Access Control on Android for Diverse Security and Privacy Policies", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[10][14].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[10][11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec7", "text": " We can counter such attacks by combining our solution with kernel-level solutions (e.g, SELinux [93] and FlaskDroid [10]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Flexible+and+Fine-Grained+Mandatory+Access+Control+on+Android+for+Diverse+Security+and+Privacy+Policies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "S. Bugiel, L. Davi, R. Dmitrienko, T. Fischer, \"Towards Taming Privilege-Escalation Attacks on Android\", <em>NDSS</em>, 2012.", "title": "Towards Taming Privilege-Escalation Attacks on Android", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[11][14].", "part": "1"}, {"sec": "sec1", "text": " Meanwhile, the runtime protection techniques suffer from acknowledged frequent \u201cfalse alarms\u201d [11], [15] because of the coarse granularity at which they capture ICC information.", "part": "1"}, {"sec": "sec1", "text": " Additionally, these techniques assume a degree of expertise in Android security [8], [9], [11], [13].", "part": "1"}, {"sec": "sec5a", "text": "To the best of our knowledge, two existing works share SEALANT's goal of providing protection of end-users from inter-app attacks: SEPAR [15] (previously named Droid-Guard [17]) and XmanDroid [3], [11].", "part": "1"}, {"sec": "sec5a", "text": " For these reasons, we decided to analytically compare the three techniques, relying on the published algorithms of SEPAR [15] and XmanDroid [3], [11].", "part": "1"}, {"sec": "sec5a2", "text": " Although a few general policies for XmanDroid have been proposed [11], they do not cover all vulnerability scenarios.", "part": "1"}, {"sec": "sec5b1", "text": " To mitigate internal threats to the validity of our results, we also asked 39 graduate students at University of Southern California (USC) to build sets of apps that implement inter-app attacks based on published literature [2], [11].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec6", "text": " XmanDroid [11] also extends the monitoring mechanism of Android to prevent app-level privilege escalation attacks based on permission-based policies.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+Taming+Privilege-Escalation+Attacks+on+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "L. Lu, Z. Li, Z. Wu, W. Lee, G. Jiang, \"Chex: Statically Vetting Android Apps for Component Hijacking Vulnerabilities\", <em>Proceedings of the Conference on Computer and Communications Security</em>, 2012.", "title": "Chex: Statically Vetting Android Apps for Component Hijacking Vulnerabilities", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[12][14].", "part": "1"}, {"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec6", "text": " CHEX [12] leverages data-flow analysis to discover component hijacking vulnerabilities.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2382196.2382223", "abstract": "An enormous number of apps have been developed for Android in recent years, making it one of the most popular mobile operating systems. However, the quality of the booming apps can be a concern [4]. Poorly engineered apps may contain security vulnerabilities that can severally undermine users&#39; security and privacy. In this paper, we study a general category of vulnerabilities found in Android apps, namely the component hijacking vulnerabilities. Several types of previously reported app vulnerabi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Chex%3A+Statically+Vetting+Android+Apps+for+Component+Hijacking+Vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "M. Dietz, S. Shekhar, D.S. Wallach, Y. Pisetsky, A. Shu, \"QUIRE: Lightweight Provenance for Smart Phone Operating Systems\", <em>Proceedings of the 20th USENIX Conference on Security</em>, 2011.", "title": "QUIRE: Lightweight Provenance for Smart Phone Operating Systems", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[13][14].", "part": "1"}, {"sec": "sec1", "text": " Additionally, these techniques assume a degree of expertise in Android security [8], [9], [11], [13].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=QUIRE%3A+Lightweight+Provenance+for+Smart+Phone+Operating+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, Y. Le Traon, \"Effective Inter-component Communication Mapping in Android with Epicc: An Essential Step Towards Holistic Security Analysis\", <em>Proceedings of the 22nd USENIX Conference on Security</em>.", "title": "Effective Inter-component Communication Mapping in Android with Epicc: An Essential Step Towards Holistic Security Analysis", "context": [{"sec": "sec1", "text": "A large volume of research has focused on ICC vulnerabilities in Android [2], [4]\u2013[14].", "part": "1"}, {"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}, {"sec": "sec6", "text": " Epicc [14] and IC3 [34] statically extract information from Android apps for ICC-aware analyses.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+Inter-component+Communication+Mapping+in+Android+with+Epicc%3A+An+Essential+Step+Towards+Holistic+Security+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "H. Bagheri, A. Sadeghi, R. Jabbarvand, S. Malek, \"Practical Formal Synthesis and Automatic Enforcement of Security Policies for Android\", <em>Proceedings of the 46th IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</em>, 2016.", "title": "Practical, Formal Synthesis and Automatic Enforcement of Security Policies for Android", "context": [{"sec": "sec1", "text": " However, existing detection techniques target only certain types of inter-app attacks [4]\u2013[6], [15] and/or do not support compositional analysis of multiple apps [2], [12], [14].", "part": "1"}, {"sec": "sec1", "text": " The state-of-the-art techniques [4], [5], [15] employ data-flow analyses that rely on lists of frequently used Android API methods [16], but tend to overlook ICC vulnerabilities caused by custom methods.", "part": "1"}, {"sec": "sec1", "text": " Meanwhile, the runtime protection techniques suffer from acknowledged frequent \u201cfalse alarms\u201d [11], [15] because of the coarse granularity at which they capture ICC information.", "part": "1"}, {"sec": "sec1", "text": " While certain techniques [15], [17] combine vulnerability detection with runtime protection to aid ordinary end-users, they also suffer from potentially large numbers of false alarms.", "part": "1"}, {"sec": "sec5a", "text": "To the best of our knowledge, two existing works share SEALANT's goal of providing protection of end-users from inter-app attacks: SEPAR [15] (previously named Droid-Guard [17]) and XmanDroid [3], [11].", "part": "1"}, {"sec": "sec5a", "text": " For these reasons, we decided to analytically compare the three techniques, relying on the published algorithms of SEPAR [15] and XmanDroid [3], [11].", "part": "1"}, {"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}, {"sec": "sec5b1", "text": " Among the apps that were previously identified [15] from repositories such as Google Play [20], F-Droid [41], MalGenome [21], and Bazaar [42], we selected 13 that are exposed to the three types of attacks SEALANT targets.", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec6", "text": " SEPAR [15] automatically synthesizes security policies, which it also enforces through dynamic memory instrumentation.", "part": "1"}], "links": {"documentLink": "/document/7579768", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7579768", "abstract": "As the dominant mobile computing platform, Android has become a prime target for cyber-security attacks. Many of these attacks are manifested at the application level, and through the exploitation of vulnerabilities in apps downloaded from the popular app stores. Increasingly, sophisticated attacks exploit the vulnerabilities in multiple installed apps, making it extremely difficult to foresee such attacks, as neither the app developers nor the store operators know a priori which apps will be in...", "pdfSize": "661KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical%2C+Formal+Synthesis+and+Automatic+Enforcement+of+Security+Policies+for+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "S. Rasthofer, S. Arzt, E. Bodden, \"A Machine-Learning Approach for Classifying and Categorizing Android Sources and Sinks\", <em>NDSS</em>, 2014.", "title": "A Machine-Learning Approach for Classifying and Categorizing Android Sources and Sinks", "context": [{"sec": "sec1", "text": " The state-of-the-art techniques [4], [5], [15] employ data-flow analyses that rely on lists of frequently used Android API methods [16], but tend to overlook ICC vulnerabilities caused by custom methods.", "part": "1"}, {"sec": "sec3a1", "text": " A sensitive method is an Android API method that can access sensitive user information (e.g., getLastKnownLocation ()) or trigger a sensitive operation (e.g., sendTextMessage ()) [16], [31].", "part": "1"}, {"sec": "sec5b2", "text": " This is primarily because SEPAR was designed (1) to identify vulnerable components or interfaces rather than specific ICC paths between them and (2) to return an ICC path only when both sender and receiver contain sensitive Android API methods [16], hampering its applicability in cases such as privilege escalation via a transitive ICC.", "part": "1"}, {"sec": "sec5b2", "text": " Since it targets a single type of attack (privacy leaks), IccTA also returned an ICC path only when it involved sensitive API methods [16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2014.23039", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Machine-Learning+Approach+for+Classifying+and+Categorizing+Android+Sources+and+Sinks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "H. Bagheri, A. Sadeghi, R. Jabbarvand, S. Malek, \"Automated Dynamic Enforcement of Synthesized Security Policies in Android\", <em>Tech. Rep. GMU-CS-TR-2015-5</em>, 2015.", "title": "Automated Dynamic Enforcement of Synthesized Security Policies in Android", "context": [{"sec": "sec1", "text": " Moreover, these analyses [4]\u2013[6] have been shown to experience scalability problems when applied on large numbers of apps [17].", "part": "1"}, {"sec": "sec1", "text": " While certain techniques [15], [17] combine vulnerability detection with runtime protection to aid ordinary end-users, they also suffer from potentially large numbers of false alarms.", "part": "1"}, {"sec": "sec1", "text": " The test suite includes apps previously identified as vulnerable [17], an open-source testing ground [19], externally developed real-world apps that implement inter-app attacks, and real-world apps randomly selected from publicly available sources [20], [21].", "part": "1"}, {"sec": "sec5a", "text": "To the best of our knowledge, two existing works share SEALANT's goal of providing protection of end-users from inter-app attacks: SEPAR [15] (previously named Droid-Guard [17]) and XmanDroid [3], [11].", "part": "1"}, {"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}, {"sec": "sec5c2", "text": " The above numbers were selected because they reflect (in fact, surpass) those found in the real-world: an average user regularly uses about 30 apps per month [46], and around 10% of Android apps are vulnerable to inter-app attacks [17].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+Dynamic+Enforcement+of+Synthesized+Security+Policies+in+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Is Rooting Your Phone Safe? The Security Risks of Rooting Devices, Samsung Electronics America,  [online]  Available: https://insights.samsung.com/2015/10/12/is-rooting-your-phone-safe-the-security-risks-of-rooting-devices.", "title": "Is Rooting Your Phone Safe? The Security Risks of Rooting Devices", "context": [{"sec": "sec1", "text": " We elected to modify Android over two other alternatives\u2014instrumenting the installed apps' bytecode and acquiring administrator privileges, i.e., \u201crooting\u201d\u2014because (1) once our approach is applied to a device, it does not require altering any of the installed apps, and (2) rooting itself introduces serious vulnerabilities [18].", "part": "1"}, {"sec": "sec6", "text": " Rooting may introduce vulnerabilities and compatibility issues on custom ROM [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+Rooting+Your+Phone+Safe%3F+The+Security+Risks+of+Rooting+Devices&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>DroidBench: A micro-benchmark suite to assess the stability of taint-analysis tools for Android</em>, 2015,  [online]  Available: https://github.com/secure-software-engineering/DroidBench.", "title": "DroidBench: A micro-benchmark suite to assess the stability of taint-analysis tools for Android", "context": [{"sec": "sec1", "text": " The test suite includes apps previously identified as vulnerable [17], an open-source testing ground [19], externally developed real-world apps that implement inter-app attacks, and real-world apps randomly selected from publicly available sources [20], [21].", "part": "1"}, {"sec": "sec5b1", "text": " We also included six apps from DroidBench 2.0 [19], an app collection for benchmarking ICC-based data leaks.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidBench%3A+A+micro-benchmark+suite+to+assess+the+stability+of+taint-analysis+tools+for+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Google Play, Google, 2015,  [online]  Available: http://play.google.com/store/apps.", "title": "Google Play", "context": [{"sec": "sec1", "text": " The test suite includes apps previously identified as vulnerable [17], an open-source testing ground [19], externally developed real-world apps that implement inter-app attacks, and real-world apps randomly selected from publicly available sources [20], [21].", "part": "1"}, {"sec": "sec5b1", "text": " Among the apps that were previously identified [15] from repositories such as Google Play [20], F-Droid [41], MalGenome [21], and Bazaar [42], we selected 13 that are exposed to the three types of attacks SEALANT targets.", "part": "1"}, {"sec": "sec5b1", "text": " Subsequently, we created an expanded test suite totaling 1,150 apps, by including another 1,015 apps randomly selected from Google Play [20] and MalGenome [21].", "part": "1"}, {"sec": "sec5d1", "text": "Type 1-A dialog asks the user whether to install an app randomly selected from a credible source (Google Play [20]) given the list of permissions the app requires.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google+Play&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Y. Zhou, X. Jiang, \"Dissecting Android Malware: Characterization and Evolution\", <em>Proceedings of the 33rd IEEE Symposium on Security and Privacy (SP)</em>, 2012.", "title": "Dissecting Android Malware: Characterization and Evolution", "context": [{"sec": "sec1", "text": " The test suite includes apps previously identified as vulnerable [17], an open-source testing ground [19], externally developed real-world apps that implement inter-app attacks, and real-world apps randomly selected from publicly available sources [20], [21].", "part": "1"}, {"sec": "sec5b1", "text": " Among the apps that were previously identified [15] from repositories such as Google Play [20], F-Droid [41], MalGenome [21], and Bazaar [42], we selected 13 that are exposed to the three types of attacks SEALANT targets.", "part": "1"}, {"sec": "sec5b1", "text": " Subsequently, we created an expanded test suite totaling 1,150 apps, by including another 1,015 apps randomly selected from Google Play [20] and MalGenome [21].", "part": "1"}], "links": {"documentLink": "/document/6234407", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6234407", "abstract": "The popularity and adoption of smart phones has greatly stimulated the spread of mobile malware, especially on the popular platforms such as Android. In light of their rapid growth, there is a pressing need to develop effective solutions. However, our defense capability is largely constrained by the limited understanding of these emerging mobile malware and the lack of timely access to related samples. In this paper, we focus on the Android platform and aim to systematize or characterize existin...", "pdfSize": "454KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dissecting+Android+Malware%3A+Characterization+and+Evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "J. Garcia, D. Popescu, G. Safi, W.G.J. Halfond, N. Medvidovic, \"Identifying Message Flow in Distributed Event-Based Systems\", <em>Proceedings of the 9th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, 2013.", "title": "Identifying Message Flow in Distributed Event-Based Systems", "context": [{"sec": "sec1", "text": "The research we present in this paper is based on our prior work on inter-component communication in event-based systems (EBS) [22], [23].", "part": "1"}, {"sec": "sec3a1", "text": " Analyzer extracts each intent's attributes (i.e., target component, action, categories, and data) using string constant propagation [22].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491462", "abstract": "Distributed event-based (DEB) systems contain highly-decoupled components that interact by exchanging messages. This enables flexible system composition and adaptation, but also makes DEB systems difficult to maintain. Most existing program analysis techniques to support maintenance are not well suited to DEB systems, while those that are tend to suffer from inaccuracy or make assumptions that limit their applicability. This paper presents Eos, a static analysis technique that identifies message...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Identifying+Message+Flow+in+Distributed+Event-Based+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "G. Safi, A. Shahbazian, W.G. Halfond, N. Medvidovic, \"Detecting Event Anomalies in Event-Based Systems\", <em>Proceedings of the 10th. Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering</em>.", "title": "Detecting Event Anomalies in Event-Based Systems", "context": [{"sec": "sec1", "text": "The research we present in this paper is based on our prior work on inter-component communication in event-based systems (EBS) [22], [23].", "part": "1"}, {"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786836", "abstract": "Event-based interaction is an attractive paradigm because its use can lead to highly flexible and adaptable systems. One problem in this paradigm is that events are sent, received, and processed nondeterministically, due to the systems\u2019 reliance on implicit invocation and implicit concurrency. This nondeterminism can lead to event anomalies, which occur when an event-based system receives multiple events that lead to the write of a shared field or memory location. Event anomalies can lead to unr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+Event+Anomalies+in+Event-Based+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "A. Belokosztolszki, D.M. Eyers, P.R. Pietzuch, J. Bacon, K. Moody, \"Role-Based Access Control for Publish/Subscribe Middleware Architectures\", <em>Proceedings of the 2nd International Workshop on Distributed Event-Based Systems (DEBS)</em>, 2003.", "title": "Role-Based Access Control for Publish/Subscribe Middleware Architectures", "context": [{"sec": "sec1", "text": " While this paper focuses explicitly on Android, SEALANT can be expanded to other EBS (e.g., [24]\u2013[28]) with certain modifications.", "part": "1"}, {"sec": "sec2", "text": "Although security violations such as these have been studied in computer networks and distributed systems [24]\u2013[29], those techniques cannot be directly applied to Android due to the specifics of its communication mechanism and features.", "part": "1"}, {"sec": "sec2", "text": " For example, role-based access control [24], [25] has been applied in Android as a form of permission grants; however, it can be violated by privilege escalation attacks.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/966618.966622", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Role-Based+Access+Control+for+Publish%2FSubscribe+Middleware+Architectures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "B. Shand, P. Pietzuch, I. Papagiannis, K. Moody, M. Migliavacca, D.M. Eyers, J. Bacon, \"ch. Security Policy and Information Sharing in Distributed Event-Based Systems\", <em>Reasoning in Event-Based Distributed Systems</em>, 2011.", "title": "ch. Security Policy and Information Sharing in Distributed Event-Based Systems", "context": [{"sec": "sec1", "text": " While this paper focuses explicitly on Android, SEALANT can be expanded to other EBS (e.g., [24]\u2013[25][28]) with certain modifications.", "part": "1"}, {"sec": "sec2", "text": "Although security violations such as these have been studied in computer networks and distributed systems [24]\u2013[25][29], those techniques cannot be directly applied to Android due to the specifics of its communication mechanism and features.", "part": "1"}, {"sec": "sec2", "text": " For example, role-based access control [24], [25] has been applied in Android as a form of permission grants; however, it can be violated by privilege escalation attacks.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-19724-6_7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ch.+Security+Policy+and+Information+Sharing+in+Distributed+Event-Based+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "L.I.W. Pesonen, D.M. Eyers, J. Bacon, \"Encryption-Enforced Access Control in Dynamic Multi-Domain Publish/Subscribe Networks\", <em>Proceedings of the Inaugural International Conference on Distributed Event-based Systems (DEBS)</em>, 2007.", "title": "Encryption-Enforced Access Control in Dynamic Multi-Domain Publish/Subscribe Networks", "context": [{"sec": "sec1", "text": " While this paper focuses explicitly on Android, SEALANT can be expanded to other EBS (e.g., [24]\u2013[26][28]) with certain modifications.", "part": "1"}, {"sec": "sec2", "text": "Although security violations such as these have been studied in computer networks and distributed systems [24]\u2013[26][29], those techniques cannot be directly applied to Android due to the specifics of its communication mechanism and features.", "part": "1"}, {"sec": "sec2", "text": " Encryption [26], [27], another popular technique, is not a good fit for Android due to encryption-key distribution issues and limited mobile resources.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1266894.1266916", "abstract": "Publish/subscribe systems provide an efficient, event-based, wide-area distributed communications infrastructure. Large scale publish/subscribe systems are likely to employ components of the event transport network owned by cooperating, but independent organisations. As the number of participants in the network increases, security becomes an increasing concern. This paper extends previous work to present and evaluate a secure multi-domain publish/subscribe infrastructure that supports and enforc...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Encryption-Enforced+Access+Control+in+Dynamic+Multi-Domain+Publish%2FSubscribe+Networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "M. Srivatsa, L. Liu, A. Iyengar, \"EventGuard: A System Architecture for Securing Publish-Subscribe Networks\", <em>ACM Transactions on Computer Systems (TOCS)</em>, vol. 29, no. 4, pp. 10:1-10:40, 2011.", "title": "EventGuard: A System Architecture for Securing Publish-Subscribe Networks", "context": [{"sec": "sec1", "text": " While this paper focuses explicitly on Android, SEALANT can be expanded to other EBS (e.g., [24]\u2013[27][28]) with certain modifications.", "part": "1"}, {"sec": "sec2", "text": "Although security violations such as these have been studied in computer networks and distributed systems [24]\u2013[27][29], those techniques cannot be directly applied to Android due to the specifics of its communication mechanism and features.", "part": "1"}, {"sec": "sec2", "text": " Encryption [26], [27], another popular technique, is not a good fit for Android due to encryption-key distribution issues and limited mobile resources.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2063509.2063510", "abstract": "Publish-subscribe (pub-sub) is an emerging paradigm for building a large number of distributed systems. A wide area pub-sub system is usually implemented on an overlay network infrastructure to enable information dissemination from publishers to subscribers. Using an open overlay network raises several security concerns such as: confidentiality and integrity, authentication, authorization and Denial-of-Service (DoS) attacks. In this article we present EventGuard, a framework for building secure ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=EventGuard%3A+A+System+Architecture+for+Securing+Publish-Subscribe+Networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "L. Fiege, M. Mezini, G. M\u00fchl, A.P. Buchmann, \"Engineering Event-Based Systems with Scopes\", <em>Proceedings of the 16th European Conference on Object-Oriented Programming (ECOOP)</em>, 2002.", "title": "Engineering Event-Based Systems with Scopes", "context": [{"sec": "sec1", "text": " While this paper focuses explicitly on Android, SEALANT can be expanded to other EBS (e.g., [24]\u2013[28]) with certain modifications.", "part": "1"}, {"sec": "sec2", "text": "Although security violations such as these have been studied in computer networks and distributed systems [24]\u2013[28][29], those techniques cannot be directly applied to Android due to the specifics of its communication mechanism and features.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-47993-7_14", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Engineering+Event-Based+Systems+with+Scopes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "S.J. Templeton, K.E. Levitt, \"Detecting Spoofed Packets\", <em>DARPA Information Survivability Conference and Exposition Proceedings</em>, 2003.", "title": "Detecting Spoofed Packets", "context": [{"sec": "sec2", "text": "Although security violations such as these have been studied in computer networks and distributed systems [24]\u2013[29], those techniques cannot be directly applied to Android due to the specifics of its communication mechanism and features.", "part": "1"}], "links": {"abstract": "Packets sent using the IP protocol include the IP address of the sending host. The recipient directs replies to the sender using this source address. However, the correctness of this address is not verified by the protocol. The IP protocol specifies no method for validating the authenticity of the packet&#39;s source. This implies that an attacker can forge the source address to be any desired. This is almost exclusively done for malicious or at least inappropriate purposes. Given that attackers can...", "pdfSize": "1073KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+Spoofed+Packets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "<em>android.app \u2223 Android Developers</em>,  [online]  Available: http://developer.android.com/reference/android/app/package-summary.html.", "title": "android.app \u2223 Android Developers", "context": [{"sec": "sec3a1", "text": " An ICC call method is a standard Android method for sending or receiving intents (e.g., startActivity()) [30].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=android.app+%E2%88%A3+Android+Developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "K.W.Y. Au, Y.F. Zhou, Z. Huang, D. Lie, \"PScout: Analyzing the Android Permission Specification\", <em>Proceedings of the 19th ACM Conference on Computer and Communications Security (CCS)</em>, 2012.", "title": "PScout: Analyzing the Android Permission Specification", "context": [{"sec": "sec3a1", "text": " A sensitive method is an Android API method that can access sensitive user information (e.g., getLastKnownLocation ()) or trigger a sensitive operation (e.g., sendTextMessage ()) [16], [31].", "part": "1"}, {"sec": "sec3a3", "text": " If \\$c_{2}\\$ holds a permission that \\$c_{1}\\$ does not, and the permission is required to use \\$m\\$ [31], PermCompare returns \u201cprivilege escalation\u201d; otherwise, it returns \u201cintent spoofing\u201d.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2382196.2382222", "abstract": "Modern smartphone operating systems (OSs) have been developed with a greater emphasis on security and protecting privacy. One of the mechanisms these systems use to protect users is a permission system, which requires developers to declare what sensitive resources their applications will use, has users agree with this request when they install the application and constrains the application to the requested resources during runtime. As these permission systems become more common, questions have r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=PScout%3A+Analyzing+the+Android+Permission+Specification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. Le Traon, D. Octeau, P. McDaniel, \"Flowdroid: Precise Context Flow Field Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps\", <em>Proceedings of the 35th annual ACM SIGPLAN conference on Programming Language Design and Implementation (PLDI)</em>, 2014.", "title": "Flowdroid: Precise Context, Flow, Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps", "context": [{"sec": "sec3a1", "text": " Analyzer identifies the relevant paths by employing a static taint analysis that tracks data-flows between methods [32].", "part": "1"}, {"sec": "sec4", "text": " In identifying intra-component paths between ICC call methods and sensitive methods, Analyzer uses FlowDroid [32], a highly precise intra-component taint analysis tool for Android.", "part": "1"}, {"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}, {"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[63].", "part": "1"}, {"sec": "sec6", "text": " FlowDroid [32] provides intra-component taint-flow analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2666356.2594299", "abstract": "Today&#39;s smartphones are a ubiquitous source of private and confidential data. At the same time, smartphone users are plagued by carelessly programmed apps that leak important data by accident, and by malicious apps that exploit their given privileges to copy such data intentionally. While existing static taint-analysis approaches have the potential of detecting such data leaks ahead of time, all approaches for Android use a number of coarse-grain approximations that can yield high numbers of mis...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Flowdroid%3A+Precise+Context%2C+Flow%2C+Field%2C+Object-Sensitive+and+Lifecycle-Aware+Taint+Analysis+for+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "<em>Intents and Intent Filters \u2223 Android Developers</em>,  [online]  Available: https://developer.android.com/guide/components/intents-filters.html.", "title": "Intents and Intent Filters \u2223 Android Developers", "context": [{"sec": "sec3a2", "text": "With the extracted information, Analyzer builds an ICC graph based on the rules from Android's API reference documentation [33].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Intents+and+Intent+Filters+%E2%88%A3+Android+Developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "D. Octeau, D. Luchaup, M. Dering, S. Jha, P. McDaniel, \"Composite Constant Propagation: Application to Android Inter-Component Communication Analysis\", <em>Proceedings of the 37th International Conference on Software Engineering (ICSE)</em>, 2015.", "title": "Composite Constant Propagation: Application to Android Inter-Component Communication Analysis", "context": [{"sec": "sec4", "text": " Analyzer integrates two static analysis tools, IC3 [34] and COVERT [7], to extract architectural objects from apps.", "part": "1"}, {"sec": "sec4", "text": " We employed both tools because neither of them alone discovers all of the needed information: IC3 misses outbound intents in certain scenarios [34], while COVERT only returns coarse-grained intent information that excludes certain attributes (e.g., data type) [7].", "part": "1"}, {"sec": "sec5b2", "text": " It was unable to correctly extract intent information in three cases due to the inaccuracies inherited from IC3 [34] and COVERT [7] (recall Section IV).", "part": "1"}, {"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}, {"sec": "sec6", "text": " Epicc [14] and IC3 [34] statically extract information from Android apps for ICC-aware analyses.", "part": "1"}], "links": {"abstract": "Many program analyses require statically inferring the possible values of composite types. However, current approaches either do not account for correlations between object fields or do so in an ad hoc manner. In this paper, we introduce the problem of composite constant propagation. We develop the first generic solver that infers all possible values of complex objects in an interprocedural, flow and context-sensitive manner, taking field correlations into account. Composite constant propagation...", "pdfSize": "918KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Composite+Constant+Propagation%3A+Application+to+Android+Inter-Component+Communication+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "<em>Android Open Source Project</em>, 2016,  [online]  Available: https://source.android.com.", "title": "Android Open Source Project", "context": [{"sec": "sec4", "text": "We implemented SEALANT's Interceptor on top of Android Open Source Project (AOSP) 4.4.4 KitKat [35], which is the most popular version of Android [36] today.", "part": "1"}, {"sec": "sec5c2", "text": "To evaluate Interceptor's impact on performance, we measured the differences in execution times between Android with Interceptor and without it (in the remainder of this section, referred to as \u201cInterceptor\u201d and \u201cAOSP\u201d [35], respectively).", "part": "1"}, {"sec": "sec5c2", "text": " Interceptor introduces low overhead because it simply extends an existing operation that AOSP already regularly performs to match a requested ICC with the list of paths on the device [35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Open+Source+Project&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "<em>Dashboards \u2223 Android Developers</em>, 2016,  [online]  Available: https://developer.android.com/about/dashboards.", "title": "Dashboards \u2223 Android Developers", "context": [{"sec": "sec4", "text": "We implemented SEALANT's Interceptor on top of Android Open Source Project (AOSP) 4.4.4 KitKat [35], which is the most popular version of Android [36] today.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dashboards+%E2%88%A3+Android+Developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "<em>Run Apps on the Android Emulator \u2223 Android Studio</em>, 2016,  [online]  Available: https://developer.android.com/studio/run/emulator.html.", "title": "Run Apps on the Android Emulator \u2223 Android Studio", "context": [{"sec": "sec4", "text": " We were able to successfully run Interceptor's system image, both, on the Android emulator [37] and on a Google Nexus 7 device.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Run+Apps+on+the+Android+Emulator+%E2%88%A3+Android+Studio&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "<em>Android Debug Bridge</em>, 2016,  [online]  Available: http://developer.android.com/tools/help/adb.html.", "title": "Android Debug Bridge", "context": [{"sec": "sec4", "text": "Running SEALANT requires compiling Interceptor's source code with the provided drivers, and installing the image files using the freely available Android debug bridge [38] and Fast-boot [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Debug+Bridge&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "<em>Running Builds-Booting into Fastboot Mode</em>,  [online]  Available: https://source.android.com/source/running.html#booting-into-fastboot-mode.", "title": "Running Builds-Booting into Fastboot Mode", "context": [{"sec": "sec4", "text": "Running SEALANT requires compiling Interceptor's source code with the provided drivers, and installing the image files using the freely available Android debug bridge [38] and Fast-boot [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Running+Builds-Booting+into+Fastboot+Mode&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "<em>IccTA</em>, 2016,  [online]  Available: http://sites.google.com/site/icctawebpage.", "title": "IccTA", "context": [{"sec": "sec5b", "text": "We evaluated Analyzer's accuracy in identifying vulnerable ICC paths by comparing its results against those of SEPAR [15], [17] and IccTA [4], [40], state-of-the-art tools for ICC vulnerability detection [5], [6], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=IccTA&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "<em>F-Droid \u2014 Free and Open Source Android App Repository</em>, 2016,  [online]  Available: https://f-droid.org.", "title": "F-Droid \u2014 Free and Open Source Android App Repository", "context": [{"sec": "sec5b1", "text": " Among the apps that were previously identified [15] from repositories such as Google Play [20], F-Droid [41], MalGenome [21], and Bazaar [42], we selected 13 that are exposed to the three types of attacks SEALANT targets.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=F-Droid+%E2%80%94+Free+and+Open+Source+Android+App+Repository&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "<em>Bazaar</em>, 2016,  [online]  Available: http://cafebazaar.ir.", "title": "Bazaar", "context": [{"sec": "sec5b1", "text": " Among the apps that were previously identified [15] from repositories such as Google Play [20], F-Droid [41], MalGenome [21], and Bazaar [42], we selected 13 that are exposed to the three types of attacks SEALANT targets.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bazaar&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "<em>apps-for-android \u2014 Google Code Archive</em>, 2016,  [online]  Available: https://code.google.com/archive/p/apps-for-android/.", "title": "apps-for-android \u2014 Google Code Archive", "context": [{"sec": "sec5b1", "text": " This yielded 91 apps in total, of which 47 were new, while 42 were modified and 2 unmodified apps obtained from public sources [43], [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=apps-for-android+%E2%80%94+Google+Code+Archive&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "<em>Sourcecodester.com</em>, 2016,  [online]  Available: http://www.sourcecodester.com/android.", "title": "Sourcecodester.com", "context": [{"sec": "sec5b1", "text": " This yielded 91 apps in total, of which 47 were new, while 42 were modified and 2 unmodified apps obtained from public sources [43], [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sourcecodester.com&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "<em>logcat Command-line Tool \u2223 Android Studio</em>, 2015,  [online]  Available: https://developer.android.com/studio/command-line/logcat.html.", "title": "logcat Command-line Tool \u2223 Android Studio", "context": [{"sec": "sec5b1", "text": " We confirmed that the attacks from the malicious apps were successfully launched and exploited the vulnerable apps by observing the apps' behavior via the device's UI and via logcat, a native Android tool for monitoring system debug outputs [45].", "part": "1"}, {"sec": "sec5b3", "text": " To monitor all ICCs exchanged on a device, we integrated a logging module that outputs information of each ICC instance via logcat [45] into ActivityManager (recall Section III).", "part": "1"}, {"sec": "sec5d1", "text": "During the study, we logged every interaction between a participant and the device via logcat [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=logcat+Command-line+Tool+%E2%88%A3+Android+Studio&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "<em>So Many Apps So Much Time For Entertainment</em>, 2015,  [online]  Available: http://www.nielsen.com/us/en/insights/news/2015/so-many-apps-so-much-more-time-for-entertainment.html.", "title": "So Many Apps, So Much Time For Entertainment", "context": [{"sec": "sec5b2", "text": " We created 50-app bundles because this number is higher than the recently cited number of apps an average smartphone user regularly uses each month [46].", "part": "1"}, {"sec": "sec5c2", "text": " The above numbers were selected because they reflect (in fact, surpass) those found in the real-world: an average user regularly uses about 30 apps per month [46], and around 10% of Android apps are vulnerable to inter-app attacks [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=So+Many+Apps%2C+So+Much+Time+For+Entertainment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "<em>monkeyrunner \u2223 Android Studio</em>, 2016,  [online]  Available: https://developer.android.com/studio/test/monkeyrunner.", "title": "monkeyrunner \u2223 Android Studio", "context": [{"sec": "sec5b3", "text": "To run test scripts that trigger ICCs, we used monkeyrunner [47], an Android tool for running test suites.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=monkeyrunner+%E2%88%A3+Android+Studio&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "<em>Download APK Android Apps and Games</em>, 2016,  [online]  Available: http://www.appsapk.com.", "title": "Download APK Android Apps and Games", "context": [{"sec": "sec5c2", "text": " We installed the 50 most popular third-party apps [48] on the devices.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Download+APK+Android+Apps+and+Games&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "<em>UI/Application Exerciser Monkey \u2223 Android Studio</em>, 2016,  [online]  Available: http://developer.android.com/tools/help/monkey.html.", "title": "UI/Application Exerciser Monkey \u2223 Android Studio", "context": [{"sec": "sec5c2", "text": " To trigger a large number of ICCs on the test devices, we used Monkey [49], which generates pseudo-random streams of user-and system-level events on a target device.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=UI%2FApplication+Exerciser+Monkey+%E2%88%A3+Android+Studio&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "<em>Keeping Your App Responsive \u2223 Android Developers</em>, 2016,  [online]  Available: http://developer.android.com/training/articles/perf-anr.html.", "title": "Keeping Your App Responsive \u2223 Android Developers", "context": [{"sec": "sec5c2", "text": " Differences of this degree are negligible because the threshold at which an end-user begins noticing slowdown in mobile app response is 100-200ms [50].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Keeping+Your+App+Responsive+%E2%88%A3+Android+Developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "A.P. Fuchs, A. Chaudhuri, J.S. Foster, \"SCanDroid: Automated Security Certification of Android Applications\", <em>Tech. Rep.</em>, 2009.", "title": "SCanDroid: Automated Security Certification of Android Applications", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[63].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SCanDroid%3A+Automated+Security+Certification+of+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "C. Gibler, J. Crussell, J. Erickson, H. Chen, \"AndroidLeaks: Automatically Detecting Potential Privacy Leaks in Android Applications on a Large Scale\", <em>Proceedings of the 5th International Conference on Trust and Trustworthy Computing (TRUST)</em>, 2012.", "title": "AndroidLeaks: Automatically Detecting Potential Privacy Leaks in Android Applications on a Large Scale", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[52][63].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-30921-2_17", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AndroidLeaks%3A+Automatically+Detecting+Potential+Privacy+Leaks+in+Android+Applications+on+a+Large+Scale&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "Y. Zhou, X. Jiang, \"Detecting Passive Content Leaks and Pollution in Android Applications\", <em>NDSS</em>, 2013.", "title": "Detecting Passive Content Leaks and Pollution in Android Applications", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[53][63].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+Passive+Content+Leaks+and+Pollution+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "W. Enck, P. Gilbert, B.-G. Chun, L.P. Cox, J. Jung, P. McDaniel, A.N. Sheth, \"TaintDroid: An Information-flow Tracking System for Realtime Privacy Monitoring on Smartphones\", <em>Proceedings of the 9th USENIX Conference on Operating Systems Design and Implementation</em>.", "title": "TaintDroid: An Information-flow Tracking System for Realtime Privacy Monitoring on Smartphones", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[54][63].", "part": "1"}, {"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec7", "text": " This can be remedied by leveraging additional sources of vulnerabilities [91] and dynamic analysis techniques [54], [92].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2619091", "abstract": "Today\u2019s smartphone operating systems frequently fail to provide users with visibility into how third-party applications collect and share their private data. We address these shortcomings with TaintDroid, an efficient, system-wide dynamic taint tracking and analysis system capable of simultaneously tracking multiple sources of sensitive data. TaintDroid enables realtime analysis by leveraging Android\u2019s virtualized execution environment. TaintDroid incurs only 32% performance overhead on a CPU-bo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=TaintDroid%3A+An+Information-flow+Tracking+System+for+Realtime+Privacy+Monitoring+on+Smartphones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "M.C. Grace, Y. Zhou, Z. Wang, X. Jiang, \"Systematic Detection of Capability Leaks in Stock Android Smartphones\", <em>NDSS</em>, 2012.", "title": "Systematic Detection of Capability Leaks in Stock Android Smartphones", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[55][63].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Systematic+Detection+of+Capability+Leaks+in+Stock+Android+Smartphones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "M.I. Gordon, D. Kim, J.H. Perkins, L. Gilham, N. Nguyen, M.C. Rinard, \"Information Flow Analysis of Android Applications in DroidSafe\", <em>NDSS</em>, 2015.", "title": "Information Flow Analysis of Android Applications in DroidSafe", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[56][63].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2015.23089", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Information+Flow+Analysis+of+Android+Applications+in+DroidSafe&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "Z. Yang, M. Yang, Y. Zhang, G. Gu, P. Ning, X.S. Wang, \"AppIntent: Analyzing Sensitive Data Transmission in Android for Privacy Leakage Detection\", <em>Proceedings of the ACM SIGSAC Conference on Computer Communications Security (CCS)</em>, 2013.", "title": "AppIntent: Analyzing Sensitive Data Transmission in Android for Privacy Leakage Detection", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[57][63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516676", "abstract": "Android phones often carry personal information, attracting malicious developers to embed code in Android applications to steal sensitive data. With known techniques in the literature, one may easily determine if sensitive data is being transmitted out of an Android phone. However, transmission of sensitive data in itself does not necessarily indicate privacy leakage; a better indicator may be whether the transmission is by user intention or not. When transmission is not intended by the user, it...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AppIntent%3A+Analyzing+Sensitive+Data+Transmission+in+Android+for+Privacy+Leakage+Detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "P.P. Chan, L.C. Hui, S.M. Yiu, \"DroidChecker: Analyzing Android Applications for Capability Leak\", <em>Proceedings of the 5th Conference on Security and Privacy in Wireless and Mobile Networks</em>, 2012.", "title": "DroidChecker: Analyzing Android Applications for Capability Leak", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[58][63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2185448.2185466", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidChecker%3A+Analyzing+Android+Applications+for+Capability+Leak&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "A.P. Felt, E. Chin, S. Hanna, D. Song, D. Wagner, \"Android Permissions Demystified\", <em>Proceedings of the 18th ACM Conference on Computer and Communications Security (CCS)</em>, 2011.", "title": "Android Permissions Demystified", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[59][63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2046707.2046779", "abstract": "Android provides third-party applications with an extensive API that includes access to phone hardware, settings, and user data. Access to privacy- and security-relevant parts of the API is controlled with an install-time application permission system. We study Android applications to determine whether Android developers follow least privilege with their permission requests. We built Stowaway, a tool that detects overprivilege in compiled Android applications. Stowaway determines the set of API ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Permissions+Demystified&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "J. Kim, Y. Yoon, K. Yi, J. Shin, \"ScanDal: Static Analyzer for Detecting Privacy Leaks in Android Applications\", <em>Proceedings of the Mobile Security Technologies (MoST)</em>, 2012.", "title": "ScanDal: Static Analyzer for Detecting Privacy Leaks in Android Applications", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[60][63].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ScanDal%3A+Static+Analyzer+for+Detecting+Privacy+Leaks+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "S. Yang, D. Yan, H. Wu, Y. Wang, A. Rountev, \"Static Control-Flow Analysis of User-driven Callbacks in Android Applications\", <em>Proceedings of the 37th International Conference on Software Engineering (ICSE)</em>, 2015.", "title": "Static Control-Flow Analysis of User-driven Callbacks in Android Applications", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[61][63].", "part": "1"}], "links": {"abstract": "Android software presents many challenges for static program analysis. In this work we focus on the fundamental problem of static control-flow analysis. Traditional analyses cannot be directly applied to Android because the applications are framework-based and event-driven. We consider user-event-driven components and the related sequences of callbacks from the Android framework to the application code, both for lifecycle callbacks and for event handler callbacks. We propose a program representa...", "pdfSize": "849KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+Control-Flow+Analysis+of+User-driven+Callbacks+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "C. Mann, A. Starostin, \"A Framework for Static Detection of Privacy Leaks in Android Applications\", <em>Proceedings of the 27th Symposium on Applied Computing (SAC)</em>, 2012.", "title": "A Framework for Static Detection of Privacy Leaks in Android Applications", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[62][63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2245276.2232009", "abstract": "We report on applying techniques for static information flow analysis to identify privacy leaks in Android applications. We have crafted a framework which checks with the help of a security type system whether the Dalvik bytecode implementation of an Android app conforms to a given privacy policy. We have carefully analyzed the Android API for possible sources and sinks of private data and identified exemplary privacy policies based on this. We demonstrate the applicability of our framework on t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Framework+for+Static+Detection+of+Privacy+Leaks+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "J. Huang, X. Zhang, L. Tan, P. Wang, B. Liang, \"AsDroid: Detecting Stealthy Behaviors in Android Applications by User Interface and Program Behavior Contradiction\", <em>Proceedings of the 36th International Conference on Software Engineering (ICSE)</em>, 2014.", "title": "AsDroid: Detecting Stealthy Behaviors in Android Applications by User Interface and Program Behavior Contradiction", "context": [{"sec": "sec6", "text": "Program Analysis is employed by several approaches [2], [23], [32], [51]\u2013\u2013[63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568301", "abstract": "Android smartphones are becoming increasingly popular. The open nature of Android allows users to install miscellaneous applications, including the malicious ones, from third-party marketplaces without rigorous sanity checks. A large portion of existing malwares perform stealthy operations such as sending short messages, making phone calls and HTTP connections, and installing additional malicious components. In this paper, we propose a novel technique to detect such stealthy behavior. We model s...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AsDroid%3A+Detecting+Stealthy+Behaviors+in+Android+Applications+by+User+Interface+and+Program+Behavior+Contradiction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "L. Li, A. Bartel, J. Klein, Y.L. Traon, \"Automatically Exploiting Potential Component Leaks in Android Applications\", <em>Proceedings of the 13th International Conference on Trust Security and Privacy in Computing and Communications (TRUSTCOM)</em>, 2014.", "title": "Automatically Exploiting Potential Component Leaks in Android Applications", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}], "links": {"abstract": "We present PCLeaks, a tool based on inter-component communication (ICC) vulnerabilities to perform data-flow analysis on Android applications to find potential component leaks that could potentially be exploited by other components. To evaluate our approach, we run PCLeaks on 2000 apps randomly selected from the Google Play store. PCLeaks reports 986 potential component leaks in 185 apps. For each leak reported by PCLeaks, PCLeaksValidator automatically generates an Android app which tries to ex...", "pdfSize": "328KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+Exploiting+Potential+Component+Leaks+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "T. Ravitch, E.R. Creswick, A. Tomb, A. Foltzer, T. Elliott, L. Casburn, \"Multi-App Security Analysis with FUSE: Statically Detecting Android App Collusion\", <em>Proceedings of the 4th Program Protection and Reverse Engineering Workshop (PPREW)</em>, 2014.", "title": "Multi-App Security Analysis with FUSE: Statically Detecting Android App Collusion", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[65][74].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2689702.2689705", "abstract": "Android&#39;s popularity has given rise to myriad application analysis techniques to improve the security and robustness of mobile applications, motivated by the evolving adversarial landscape. These techniques have focused on identifying undesirable behaviors in individual applications, either due to malicious intent or programmer error. We present a collection of tools that provide a static information flow analysis across a set of applications, showing a holistic view of all the applications dest...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multi-App+Security+Analysis+with+FUSE%3A+Statically+Detecting+Android+App+Collusion&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "F. Shen, N. Vishnubhotla, C. Todarka, M. Arora, B. Dhandapani, E.J. Lehner, S.Y. Ko, L. Ziarek, \"Information Flows As a Permission Mechanism\", <em>Proceedings of the 29th ACM/IEEE International Conference on Automated Software Engineering (ASE)</em>, 2014.", "title": "Information Flows As a Permission Mechanism", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[66][74].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Information+Flows+As+a+Permission+Mechanism&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "K. Choi, B.-M. Chang, \"A Type and Effect System for Activation Flow of Components in Android Programs\", <em>Information Processing Letters</em>, vol. 114, no. 11, pp. 620-627, November 2014.", "title": "A Type and Effect System for Activation Flow of Components in Android Programs", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[67][74].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.ipl.2014.05.011", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Type+and+Effect+System+for+Activation+Flow+of+Components+in+Android+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "S. Bartsch, B. Berger, M. Bunke, K. Sohr, \"The Transitivity-of-Trust Problem in Android Application Interaction\", <em>Proceedings of the 8th International Conference on Availability Reliability and Security</em>, 2013.", "title": "The Transitivity-of-Trust Problem in Android Application Interaction", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[68][74].", "part": "1"}], "links": {"abstract": "Mobile phones have developed into complex platforms with large numbers of installed applications and a wide range of sensitive data. Application security policies limit the permissions of each installed application. As applications may interact, restricting single applications may create a false sense of security for end users, while data may still leave the mobile phone through other applications. Instead, the information flow needs to be policed for the composite system of applications in a tr...", "pdfSize": "204KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Transitivity-of-Trust+Problem+in+Android+Application+Interaction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "Y. Zhongyang, Z. Xin, B. Mao, L. Xie, \"DroidAlarm: An All-Sided Static Analysis Tool for Android Privilege-Escalation Malware\", <em>Proceedings of the 8th ACM SIGSAC Symposium on Information Computer and Communications Security (ASIA CCS)</em>, 2013.", "title": "DroidAlarm: An All-Sided Static Analysis Tool for Android Privilege-Escalation Malware", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[69][74].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2484313.2484359", "abstract": "Since smartphones have stored diverse sensitive privacy information, including credit card and so on, a great deal of malware are desired to tamper them. As one of the most prevalent platforms, Android contains sensitive resources that can only be accessed via corresponding APIs, and the APIs can be invoked only when user has authorized permissions in the Android permission model. However, a novel threat called privilege escalation attack may bypass this watchdog. It&#39;s presented as that an appli...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidAlarm%3A+An+All-Sided+Static+Analysis+Tool+for+Android+Privilege-Escalation+Malware&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "M.D. Ernst, R. Just, S. Millstein, W. Dietl, S. Pernsteiner, F. Roesner, K. Koscher, P.B. Barros, R. Bhoraskar, S. Han, P. Vines, E.X. Wu, \"Collaborative Verification of Information Flow for a High-Assurance App Store\", <em>Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security (CCS)</em>, 2014.", "title": "Collaborative Verification of Information Flow for a High-Assurance App Store", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[70][74].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660343", "abstract": "Current app stores distribute some malware to unsuspecting users, even though the app approval process may be costly and time-consuming. High-integrity app stores must provide stronger guarantees that their apps are not malicious. We propose a verification model for use in such app stores to guarantee that the apps are free of malicious information flows. In our model, the software vendor and the app store auditor collaborate -- each does tasks that are easy for her/him, reducing overall verific...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Collaborative+Verification+of+Information+Flow+for+a+High-Assurance+App+Store&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}, {"order": "71", "text": "J. Wu, T. Cui, T. Ban, S. Guo, L. Cui, \"PaddyFrog: Systematically Detecting Confused Deputy Vulnerability in Android Applications\", <em>Security and Communication Network</em>, vol. 8, no. 13, September 2015.", "title": "PaddyFrog: Systematically Detecting Confused Deputy Vulnerability in Android Applications", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[71][74].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/sec.1179", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=PaddyFrog%3A+Systematically+Detecting+Confused+Deputy+Vulnerability+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref71"}, {"order": "72", "text": "D. Octeau, S. Jha, M. Dering, P. McDaniel, A. Bartel, L. Li, J. Klein, Y.L. Traon, \"Combining Static Analysis with Probabilistic Models to Enable Market-Scale Android Inter-Component Analysis\", <em>Proceedings of the 43rd Symposium on Principles of Programming Languages</em>, 2016.", "title": "Combining Static Analysis with Probabilistic Models to Enable Market-Scale Android Inter-Component Analysis", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[72][74].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2837614.2837661", "abstract": "Static analysis has been successfully used in many areas, from verifying mission-critical software to malware detection. Unfortunately, static analysis often produces false positives, which require significant manual effort to resolve. In this paper, we show how to overlay a probabilistic model, trained using domain knowledge, on top of static analysis results, in order to triage static analysis results. We apply this idea to analyzing mobile applications. Android application components can comm...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combining+Static+Analysis+with+Probabilistic+Models+to+Enable+Market-Scale+Android+Inter-Component+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref72"}, {"order": "73", "text": "L. Wu, M. Grace, Y. Zhou, C. Wu, X. Jiang, \"The Impact of Vendor Customizations on Android Security\", <em>Proceedings of the 2013 ACM SIGSAC Conference on Computer and Communications Security</em>, 2013.", "title": "The Impact of Vendor Customizations on Android Security", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[73][74].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516728", "abstract": "The smartphone market has grown explosively in recent years, as more and more consumers are attracted to the sensor-studded multipurpose devices. Android is particularly ascendant; as an open platform, smartphone manufacturers are free to extend and modify it, allowing them to differentiate themselves from their competitors. However, vendor customizations will inherently impact overall Android security and such impact is still largely unknown. In this paper, we analyze ten representative stock A...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Vendor+Customizations+on+Android+Security&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref73"}, {"order": "74", "text": "K.O. Elish, D. Yao, B.G. Ryder, \"On the Need of Precise Inter-App ICC Classification for Detecting Android Malware Collusions\", <em>Proceedings of IEEE Mobile Security Technologies (MoST) in conjunction with the IEEE Symposium on Security and Privacy</em>, 2015.", "title": "On the Need of Precise Inter-App ICC Classification for Detecting Android Malware Collusions", "context": [{"sec": "sec6", "text": "ICC Analysis is the focus of another body of research [4]\u2013[7], [14], [34], [64]\u2013\u2013[74].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+Need+of+Precise+Inter-App+ICC+Classification+for+Detecting+Android+Malware+Collusions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref74"}, {"order": "75", "text": "M. Backes, S. Gerling, C. Hammer, M. Maffei, P. von Styp-Rekowsky, \"AppGuard: Enforcing User Requirements on Android Apps\", <em>Proceedings of the 19th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS)</em>, 2013.", "title": "AppGuard: Enforcing User Requirements on Android Apps", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=AppGuard%3A+Enforcing+User+Requirements+on+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref75"}, {"order": "76", "text": "R. Xu, H. Sa\u00efdi, R. Anderson, \"Aurasium: Practical Policy Enforcement for Android Applications\", <em>Proceedings of the 21st USENIX Conference on Security Symposium</em>, 2012.", "title": "Aurasium: Practical Policy Enforcement for Android Applications", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[76][81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec6", "text": " Aurasium [76] enforces arbitrary policies by interposing code into the target app.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Aurasium%3A+Practical+Policy+Enforcement+for+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref76"}, {"order": "77", "text": "B. Davis, B. Sanders, A. Khodaverdian, H. Chen, \"I-ARM-Droid: A Rewriting Framework for In-App Reference Monitors for Android Applications\", <em>Proceedings of the Mobile Security Technologies</em>, 2012.", "title": "I-ARM-Droid: A Rewriting Framework for In-App Reference Monitors for Android Applications", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[77][81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=I-ARM-Droid%3A+A+Rewriting+Framework+for+In-App+Reference+Monitors+for+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref77"}, {"order": "78", "text": "B. Davis, H. Chen, \"RetroSkeleton: Retrofitting Android Apps\", <em>Proceeding of the 11th Annual International Conference on Mobile Systems Applications and Services (MobiSys)</em>, 2013.", "title": "RetroSkeleton: Retrofitting Android Apps", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[78][81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2462456.2464462", "abstract": "An obvious asset of the Android platform is the tremendous number and variety of available apps. There is a less obvious, but potentially even more important, benefit to the fact that nearly all apps are developed using a common platform. We can leverage the relatively uniform nature of Android apps to allow users to tweak applications for improved security, usability, and functionality with relative ease (compared to desktop applications). We design and implement an Android app rewriting framew...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=RetroSkeleton%3A+Retrofitting+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref78"}, {"order": "79", "text": "J. Jeon, K.K. Micinski, J.A. Vaughan, A. Fogel, N. Reddy, J.S. Foster, T. Millstein, \"Dr. Android and Mr. Hide: Fine-grained Permissions in Android Applications\", <em>Proceedings of the 2nd ACM Workshop on Security and Privacy in Smartphones and Mobile Devices</em>, 2012.", "title": "Dr. Android and Mr. Hide: Fine-grained Permissions in Android Applications", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[79][81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2381934.2381938", "abstract": "Google&#39;s Android platform includes a permission model that protects access to sensitive capabilities, such as Internet access, GPS use, and telephony. While permissions provide an important level of security, for many applications they allow broader access than actually required. In this paper, we introduce a novel framework that addresses this issue by adding finer-grained permissions to Android. Underlying our framework is a taxonomy of four major groups of Android permissions, each of which a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dr.+Android+and+Mr.+Hide%3A+Fine-grained+Permissions+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref79"}, {"order": "80", "text": "K.Z. Chen, N. Johnson, S. Dai, K. Macnamara, T. Magrino, E. Wu, M. Rinard, D. Song, \"Contextual Policy Enforcement in Android Applications with Permission Event Graphs\", <em>NDSS</em>, 2013.", "title": "Contextual Policy Enforcement in Android Applications with Permission Event Graphs", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[80][81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Contextual+Policy+Enforcement+in+Android+Applications+with+Permission+Event+Graphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref80"}, {"order": "81", "text": "M. Zhang, H. Yin, \"Appsealer: Automatic Generation of Vulnerability-Specific Patches for Preventing Component Hijacking Attacks in Android Applications\", <em>NDSS</em>, 2014.", "title": "Appsealer: Automatic Generation of Vulnerability-Specific Patches for Preventing Component Hijacking Attacks in Android Applications", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2014.23255", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Appsealer%3A+Automatic+Generation+of+Vulnerability-Specific+Patches+for+Preventing+Component+Hijacking+Attacks+in+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref81"}, {"order": "82", "text": "Z. Zhao, F.C. Colon Osono, \"\u201cTrustDroid\u2122\u201d: Preventing the Use of Smartphones for Information Leaking in Corporate Networks Through the Used of Static Analysis Taint Tracking\", <em>Proceedings of the 7th International Conference on Malicious and Unwanted Software</em>, 2012.", "title": "\u201cTrustDroid\u2122\u201d: Preventing the Use of Smartphones for Information Leaking in Corporate Networks Through the Used of Static Analysis Taint Tracking", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "links": {"abstract": "Over the last 12 years three important dates have marked the beginning of a major paradigm shift in computing and the security models applied to protect an emerging computing environment - March 1999, January 9th, 2007, and July 2007. These dates roughly correspond to the birth of SalesForce.com, the most successful Software as a Service (SaS) provider to date, Steve Jobs introduction of the Iphone,, and the discovery of the Zeus Botnet. These innovations have been instrumental in enabling a par...", "pdfSize": "993KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=%E2%80%9CTrustDroid%E2%84%A2%E2%80%9D%3A+Preventing+the+Use+of+Smartphones+for+Information+Leaking+in+Corporate+Networks+Through+the+Used+of+Static+Analysis+Taint+Tracking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref82"}, {"order": "83", "text": "W. Enck, M. Ongtang, P. McDaniel, \"On Lightweight Mobile Phone Application Certification\", <em>Proceedings of the 16th ACM Conference on Computer and Communications Security (CCS)</em>, 2009.", "title": "On Lightweight Mobile Phone Application Certification", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[83][86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1653662.1653691", "abstract": "Users have begun downloading an increasingly large number of mobile phone applications in response to advancements in handsets and wireless networks. The increased number of applications results in a greater chance of installing Trojans and similar malware. In this paper, we propose the Kirin security service for Android, which performs lightweight certification of applications to mitigate malware at install time. Kirin certification uses security rules, which are templates designed to conservat...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+Lightweight+Mobile+Phone+Application+Certification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref83"}, {"order": "84", "text": "D. Schreckling, J. Posegga, J. K\u00f6stler, M. Schaff, \"Kynoid: Real-Time Enforcement of Fine-Grained User-Defined and Data-Centric Security Policies for Android\", <em>Proceedings of the 6th IFIP International Conference on Information Security Theory and Practice: Security Privacy and Trust in Computing Systems and Ambient Intelligent</em>, 2012.", "title": "Kynoid: Real-Time Enforcement of Fine-Grained, User-Defined, and Data-Centric Security Policies for Android", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[84][86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Kynoid%3A+Real-Time+Enforcement+of+Fine-Grained%2C+User-Defined%2C+and+Data-Centric+Security+Policies+for+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref84"}, {"order": "85", "text": "A.P. Felt, H.J. Wang, A. Moshchuk, S. Hanna, E. Chin, \"Permission re-delegation: Attacks and defenses\", <em>Proceedings of the 20th USENIX Conference on Security (SEC)</em>, 2011.", "title": "Permission re-delegation: Attacks and defenses", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[85][86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Permission+re-delegation%3A+Attacks+and+defenses&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref85"}, {"order": "86", "text": "P. Hornyack, S. Han, J. Jung, S. Schechter, D. Wetherall, \"These Aren't the Droids You're Looking for: Retrofitting Android to Protect Data from Imperious Applications\", <em>Proceedings of the 18th ACM Conference on Computer and Communications Security</em>, 2011.", "title": "These Aren't the Droids You're Looking for: Retrofitting Android to Protect Data from Imperious Applications", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2046707.2046780", "abstract": "We examine two privacy controls for Android smartphones that empower users to run permission-hungry applications while protecting private data from being exfiltrated: (1) covertly substituting shadow data in place of data that the user wants to keep private, and (2) blocking network transmissions that contain data the user made available to the application for on-device use only. We retrofit the Android operating system to implement these two controls for use with unmodified applications. A key ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=These+Aren%27t+the+Droids+You%27re+Looking+for%3A+Retrofitting+Android+to+Protect+Data+from+Imperious+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref86"}, {"order": "87", "text": "X. Wang, K. Sun, Y. Wang, J. Jing, \"DeepDroid: Dynamically Enforcing Enterprise Policy on Android Devices\", <em>NDSS</em>, 2015.", "title": "DeepDroid: Dynamically Enforcing Enterprise Policy on Android Devices", "context": [{"sec": "sec6", "text": "Policy Enforcement in Android is explored via (1) app code instrumentation [8], [17], [75]\u2013\u2013[81], (2) Android framework extension [9]\u2013[11], [13], [54], [82]\u2013[86], and (3) dynamic memory instrumentation [15], [87].", "part": "1"}, {"sec": "sec6", "text": " DeepDroid [87] provides enterprise policy enforcement by applying dynamic memory instrumentation (i.e., rooting) to Android's runtime environment.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2015.23263", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DeepDroid%3A+Dynamically+Enforcing+Enterprise+Policy+on+Android+Devices&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref87"}, {"order": "88", "text": "H. Hao, V. Singh, W. Du, \"On the Effectiveness of API-Level Access Control Using Bytecode Rewriting in Android\", <em>Proceedings of the 8th Symposium on Information Computer and Communications Security</em>.", "title": "On the Effectiveness of API-Level Access Control Using Bytecode Rewriting in Android", "context": [{"sec": "sec6", "text": " While rewriting apps can be effective, incomplete implementations of bytecode rewriting results in a number of potential attacks [88].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2484313.2484317", "abstract": "Bytecode rewriting on Android applications has been widely adopted to implement fine-grained access control. It endows more flexibility and convenience without modifying the Android platform. Bytecode rewriting uses static analysis to identify the usage of security-sensitive API methods, before it instruments the bytecode to control the access to these API calls. Due to the significance of this technique, the effectiveness of its performance in providing fine-grained access control is crucial. W...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+Effectiveness+of+API-Level+Access+Control+Using+Bytecode+Rewriting+in+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref88"}, {"order": "89", "text": "S. Heuser, A. Nadkarni, W. Enck, A.-R. Sadeghi, \"ASM: A Programmable Interface for Extending Android Security\", <em>Proceedings of the 23rd USENIX Conference on Security Symposium</em>, 2014.", "title": "ASM: A Programmable Interface for Extending Android Security", "context": [{"sec": "sec6", "text": " ASM [89] provides an API that enables enforcement of app-specific security requirements.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ASM%3A+A+Programmable+Interface+for+Extending+Android+Security&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref89"}, {"order": "90", "text": "L. Li, T.F. Bissyand\u00e9, D. Octeau, J. Klein, \"DroidRA: Taming Reflection to Support Whole-Program Analysis of Android Apps\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis (ISSTA)</em>, 2016.", "title": "DroidRA: Taming Reflection to Support Whole-Program Analysis of Android Apps", "context": [{"sec": "sec7", "text": " To this end, we will explore reflection analysis techniques [90].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidRA%3A+Taming+Reflection+to+Support+Whole-Program+Analysis+of+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref90"}, {"order": "91", "text": "Y. Zhou, Z. Wang, W. Zhou, X. Jiang, \"Hey You Get Off of My Market: Detecting Malicious Apps in Official and Alternative Android Markets\", <em>NDSS</em>, 2012.", "title": "Hey, You, Get Off of My Market: Detecting Malicious Apps in Official and Alternative Android Markets", "context": [{"sec": "sec7", "text": " This can be remedied by leveraging additional sources of vulnerabilities [91] and dynamic analysis techniques [54], [92].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hey%2C+You%2C+Get+Off+of+My+Market%3A+Detecting+Malicious+Apps+in+Official+and+Alternative+Android+Markets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref91"}, {"order": "92", "text": "Y.K. Lee, J. Bang, J. Garcia, N. Medvidovic, \"ViVA: A Visualization and Analysis Tool for Distributed Event-based Systems\", <em>Proceedings of the 36th International Conference on Software Engineering</em>, 2014.", "title": "ViVA: A Visualization and Analysis Tool for Distributed Event-based Systems", "context": [{"sec": "sec7", "text": " This can be remedied by leveraging additional sources of vulnerabilities [91] and dynamic analysis techniques [54], [92].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2591062.2591074", "abstract": "Distributed event-based (DEB) systems are characterized by highly-decoupled components that communicate by exchanging messages. This form of communication enables flexible and scalable system composition but also reduces understandability and maintainability due to the indirect manner in which DEB components communicate. To tackle this problem, we present Visualizer for eVent-based Architectures, ViVA, a tool that effectively visualizes the large number of messages and dependencies that can be e...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ViVA%3A+A+Visualization+and+Analysis+Tool+for+Distributed+Event-based+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref92"}, {"order": "93", "text": "A. Shabtai, Y. Fledel, Y. Elovici, \"Securing Android-Powered Mobile Devices Using SELinux\", <em>IEEE Security & Privacy</em>, vol. 8, no. 3, 2010.", "title": "Securing Android-Powered Mobile Devices Using SELinux", "context": [{"sec": "sec7", "text": " We can counter such attacks by combining our solution with kernel-level solutions (e.g, SELinux [93] and FlaskDroid [10]).", "part": "1"}], "links": {"documentLink": "/document/5342408", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5342408", "abstract": "Google's Android framework incorporates an operating system and software stack for mobile devices. Using a general-purpose operating system such as Linux in mobile devices has advantages but also security risks. Security-Enhanced Linux (SELinux) can help reduce potential damage from a successful attack.", "pdfSize": "1119KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Securing+Android-Powered+Mobile+Devices+Using+SELinux&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref93"}, {"order": "94", "text": "A. Shahbazian, G. Edwards, N. Medvidovic, \"An End-to-End Domain Specific Modeling and Analysis Platform\", <em>Proceedings of the 8th International Workshop on Modeling in Software Engineering</em>, 2016.", "title": "An End-to-End Domain Specific Modeling and Analysis Platform", "context": [{"sec": "sec7", "text": " Eventually, we can incorporate these techniques in designing applications [94], [95].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2896982.2896994", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+End-to-End+Domain+Specific+Modeling+and+Analysis+Platform&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref94"}, {"order": "95", "text": "M. Langhammer, A. Shahbazian, N. Medvidovic, R.H. Reussner, \"Automated Extraction of Rich Software Models from Limited System Information\", <em>Proceedings of the 13th Working IEEE/IFIP Conference on Software Architecture (WICSA)</em>, 2016.", "title": "Automated Extraction of Rich Software Models from Limited System Information", "context": [{"sec": "sec7", "text": " Eventually, we can incorporate these techniques in designing applications [94], [95].", "part": "1"}], "links": {"abstract": "Reverse engineering a software system is challenged by the typically very limited information available about existing systems. Useful reverse engineering tasks include recovering a system&#39;s architectural, behavioral, and usage models, which can then be leveraged to answer important questions about a system. For example, using such models to analyze and predict a system&#39;s non-functional properties would help to efficiently assess the system&#39;s current state, planned adaptations, scalability issue...", "pdfSize": "808KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+Extraction+of+Rich+Software+Models+from+Limited+System+Information&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref95"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985672", "articleId": "7985672", "startPage": "312", "endPage": "323", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 9, "citationCountPatent": 0, "totalDownloads": 434}}
{"title": "Mining Software Defects: Should We Consider Affected Releases?", "authors": [{"name": "Suraj Yatish", "affiliation": "The University of Adelaide", "firstName": "Suraj", "lastName": "Yatish", "id": "37086948556"}, {"name": "Jirayus Jiarpakdee", "affiliation": "Monash University", "firstName": "Jirayus", "lastName": "Jiarpakdee", "id": "37086081492"}, {"name": "Patanamon Thongtanunam", "affiliation": "The University of Melbourne", "firstName": "Patanamon", "lastName": "Thongtanunam", "id": "37085394302"}, {"name": "Chakkrit Tantithamthavorn", "affiliation": "Monash University", "firstName": "Chakkrit", "lastName": "Tantithamthavorn", "id": "38468091400"}], "abstract": "With the rise of the Mining Software Repositories (MSR) field, defect datasets extracted from software repositories play a foundational role in many empirical studies related to software quality. At the core of defect data preparation is the identification of post-release defects. Prior studies leverage many heuristics (e.g., keywords and issue IDs) to identify post-release defects. However, such the heuristic approach is based on several assumptions, which pose common threats to the validity of many studies. In this paper, we set out to investigate the nature of the difference of defect datasets generated by the heuristic approach and the realistic approach that leverages the earliest affected release that is realistically estimated by a software development team for a given defect. In addition, we investigate the impact of defect identification approaches on the predictive accuracy and the ranking of defective modules that are produced by defect models. Through a case study of defect datasets of 32 releases, we find that that the heuristic approach has a large impact on both defect count datasets and binary defect datasets. Surprisingly, we find that the heuristic approach has a minimal impact on defect count models, suggesting that future work should not be too concerned about defect count models that are constructed using heuristic defect datasets. On the other hand, using defect datasets generated by the realistic approach lead to an improvement in the predictive accuracy of defect classification models.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Predictive models", "Object oriented modeling", "Software quality", "Feature extraction", "Data mining", "Control systems"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["data mining", "pattern classification", "software maintenance", "software quality"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["defect count models", "defect classification models", "software quality", "defect data preparation", "post-release defects", "software development team", "software repositories", "defect identification", "software defect mining"]}, {"type": "Author Keywords ", "kwd": ["Mining Software Repositories", "Empirical Software Engineering", "Software Quality", "Defect Prediction Models"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00075", "ref": [{"order": "1", "text": "G. Antoniol, K. Ayari, M. D. Penta, F. Khomh, \"Is it a Bug or an Enhancement? A Text-based Approach to Classify Change Requests\", <em>Proceedings of the Conference of the Center for Advanced Studies on Collaborative Research (CASCON)</em>, pp. 1-15, 2008.", "title": "Is it a Bug or an Enhancement? A Text-based Approach to Classify Change Requests", "context": [{"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec2c", "text": " [1] and Herzig et al. [21] find that many issue reports are misclassified.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+it+a+Bug+or+an+Enhancement%3F+A+Text-based+Approach+to+Classify+Change+Requests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "J. Aranda, G. Venolia, \"The Secret Life of Bugs: Going Past the Errors and Omissions in Software Repositories\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 298-308, 2009.", "title": "The Secret Life of Bugs: Going Past the Errors and Omissions in Software Repositories", "context": [{"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[2][9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec2c", "text": " For example, Aranda and Venolia [2] point out that ITS and VCS repositories are noisy sources of data.", "part": "1"}], "links": {"documentLink": "/document/5070530", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070530", "abstract": "Every bug has a story behind it. The people that discover and resolve it need to coordinate, to get information from documents, tools, or other people, and to navigate through issues of accountability, ownership, and organizational structure. This paper reports on a field study of coordination activities around bug fixing that used a combination of case study research and a survey of software professionals. Results show that the histories of even simple bugs are strongly dependent on social, org...", "pdfSize": "193KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Secret+Life+of+Bugs%3A+Going+Past+the+Errors+and+Omissions+in+Software+Repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "E. Arisholm, L. C. Briand, E. B. Johannessen, \"A Systematic and Comprehensive Investigation of Methods to Build and Evaluate Fault Prediction Models\", <em>Journal of Systems and Software</em>, vol. 83, no. 1, pp. 2-17, 2010.", "title": "A Systematic and Comprehensive Investigation of Methods to Build and Evaluate Fault Prediction Models", "context": [{"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[3][9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec4b", "text": " Similar to prior studies [3], [76], we use the default probability value of 0.5 as a threshold value to compute the confusion matrix for threshold-dependent measures, i.e., if a module has a predicted probability above 0.5, it is considered defective; otherwise, the module is considered clean.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2009.06.055", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Systematic+and+Comprehensive+Investigation+of+Methods+to+Build+and+Evaluate+Fault+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "A. Bachmann, C. Bird, F. Rahman, P. Devanbu, A. Bernstein, \"The Missing Links: Bugs and Bug-fix Commits Categories and Subject Descriptors\", <em>Proceedings of the International Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 97-106, 2010.", "title": "The Missing Links: Bugs and Bug-fix Commits Categories and Subject Descriptors", "context": [{"sec": "sec1", "text": "However, such the heuristic approach is based on several assumptions [4], [6], [42], [43], [61], [72], which pose common threats to the validity of many studies.", "part": "1"}, {"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[4][9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec2c", "text": " [4] find that the defect reports are not recorded in the commit logs and thus are not visible to the automated linking tools used to extract defect datasets, which generate many missing links between code changes and defect reports.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Missing+Links%3A+Bugs+and+Bug-fix+Commits+Categories+and+Subject+Descriptors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "V. R. Basili, L. C. Briand, W. L. Melo, \"A Validation of Object-oriented Design Metrics as Quality Indicators\", <em>Transactions on Software Engineering (TSE)</em>, vol. 22, no. 10, pp. 751-761, 1996.", "title": "A Validation of Object-oriented Design Metrics as Quality Indicators", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[5][9] +) in commit logs after the release of interest.", "part": "1"}], "links": {"documentLink": "/document/544352", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=544352", "abstract": "This paper presents the results of a study in which we empirically investigated the suite of object-oriented (OO) design metrics introduced in (Chidamber and Kemerer, 1994). More specifically, our goal is to assess these metrics as predictors of fault-prone classes and, therefore, determine whether they can be used as early quality indicators. This study is complementary to the work described in (Li and Henry, 1993) where the same suite of metrics had been used to assess frequencies of maintenan...", "pdfSize": "1508KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Validation+of+Object-oriented+Design+Metrics+as+Quality+Indicators&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "C. Bird, A. Bachmann, E. Aune, J. Duffy, A. Bernstein, V. Filkov, P. Devanbu, \"Fair and Balanced? Bias in Bug-Fix Datasets\", <em>Proceedings of the joint meeting of the European Software Engineering Conference and the Foundations of Software Engineering (ESEC/FSE)</em>, pp. 121-130, 2009.", "title": "Fair and Balanced? Bias in Bug-Fix Datasets", "context": [{"sec": "sec1", "text": "However, such the heuristic approach is based on several assumptions [4], [6], [42], [43], [61], [72], which pose common threats to the validity of many studies.", "part": "1"}, {"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[6][9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec2c", "text": " [6] point out that more experienced developers are more likely to explicitly link issue reports to the corresponding code changes.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1595696.1595716", "abstract": "Software engineering researchers have long been interested in where and why bugs occur in code, and in predicting where they might turn up next. Historical bug-occurence data has been key to this research. Bug tracking systems, and code version histories, record when, how and by whom bugs were fixed; from these sources, datasets that relate file changes to bug fixes can be extracted. These historical datasets can be used to test hypotheses concerning processes of bug introduction, and also to bu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fair+and+Balanced%3F+Bias+in+Bug-Fix+Datasets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C. Bird, N. Nagappan, P. Devanbu, H. Gall, B. Murphy, \"Does distributed development affect software quality? an empirical case study of windows vista\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 518-528, 2009.", "title": "Does distributed development affect software quality? an empirical case study of windows vista", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[7][9] +) in commit logs after the release of interest.", "part": "1"}], "links": {"documentLink": "/document/5070550", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070550", "abstract": "It is widely believed that distributed software development is riskier and more challenging than collocated development. Prior literature on distributed development in software engineering and other fields discuss various challenges, including cultural barriers, expertise transfer difficulties, and communication and coordination overhead. We evaluate this conventional belief by examining the overall development of Windows Vista and comparing the post-release failures of components that were deve...", "pdfSize": "663KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Does+distributed+development+affect+software+quality%3F+an+empirical+case+study+of+windows+vista&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "C. Bird, N. Nagappan, B. Murphy, H. Gall, P. Devanbu, \"Don't touch my code!: examining the effects of ownership on software quality\", <em>Proceedings of the joint meeting of the European Software Engineering Conference and the Foundations of Software Engineering (ESEC/FSE)</em>, pp. 4-14, 2011.", "title": "Don't touch my code!: examining the effects of ownership on software quality", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[8][9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec4a", "text": "Ownership metrics describe the relationship between the ownership of modules and software quality [8], [49], [66].", "part": "1"}, {"sec": "sec4a", "text": " [8], for each module, we first measure the ownership of each developer using the proportion of the code changes made by the developer on the total code changes.", "part": "1"}, {"sec": "sec4a", "text": " [8].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025119", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Don%27t+touch+my+code%21%3A+examining+the+effects+of+ownership+on+software+quality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "C. Bird, P. C. Rigby, E. T. Barr, D. J. Hamilton, D. M. German, P. Devanbu, \"The Promises and Perils of Mining Git\", <em>Proceedings of the International Working Conference on Mining Software Repositories (MSR)</em>, pp. 1-10, 2009.", "title": "The Promises and Perils of Mining Git", "context": [{"sec": "sec2a", "text": " To identify defect-fixing commits, Fischer et al. [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec2c", "text": "Software repositories are often noisy (e.g., incorrect, missing information) [9], [32].", "part": "1"}], "links": {"documentLink": "/document/5069475", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5069475", "abstract": "We are now witnessing the rapid growth of decentralized source code management (DSCM) systems, in which every developer has her own repository. DSCMs facilitate a style of collaboration in which work output can flow sideways (and privately) between collaborators, rather than always up and down (and publicly) via a central repository. Decentralization comes with both the promise of new data and the peril of its misinterpretation. We focus on git, a very popular DSCM used in high-profile projects....", "pdfSize": "307KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Promises+and+Perils+of+Mining+Git&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "D. Bowes, T. Hall, M. Harman, Y. Jia, F. Sarro, F. Wu, \"Mutation-Aware Fault Prediction\", <em>Proceedings of the International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 330-341, 2016.", "title": "Mutation-Aware Fault Prediction", "context": [{"sec": "sec1", "text": " For example, prior studies develop defect prediction models that learn historical defect characteristics in order to predict the most defective modules [10], [19], [22], [36], [71], [73].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931039", "abstract": "We introduce mutation-aware fault prediction, which leverages additional guidance from metrics constructed in terms of mutants and the test cases that cover and detect them. We report the results of 12 sets of experiments, applying 4 different predictive modelling techniques to 3 large real-world systems (both open and closed source). The results show that our proposal can significantly (p \u2264 0.05) improve fault prediction performance. Moreover, mutation-based metrics lie in the top 5% most frequ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mutation-Aware+Fault+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "L. Breiman, A. Cutler, A. Liaw, M. Wiener, \"randomForest: Breiman and Cutler's Random Forests for Classification and Regression. R package version 4.6-12\", <em>Software</em>, 2006,  [online]  Available: https://cran.r-project.org/web/packages/randomForest.", "title": "randomForest: Breiman and Cutler's Random Forests for Classification and Regression. R package version 4.6-12", "context": [{"sec": "sec4b", "text": " We use the implementation of the random forest regression technique as provided by the randomForest R package [11].", "part": "1"}, {"sec": "sec4b", "text": " We use the implementation of the random forest regression technique as provided by the randomForest R package [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=randomForest%3A+Breiman+and+Cutler%27s+Random+Forests+for+Classification+and+Regression.+R+package+version+4.6-12&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "B. Caglayan, B. Turhan, A. Bener, M. Habayeb, A. Miransky, E. Cialini, \"Merits of organizational metrics in defect prediction: an industrial replication\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 89-98, 2015.", "title": "Merits of organizational metrics in defect prediction: an industrial replication", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"documentLink": "/document/7202953", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7202953", "abstract": "Defect prediction models presented in the literature lack generalization unless the original study can be replicated using new datasets and in different organizational settings. Practitioners can also benefit from replicating studies in their own environment by gaining insights and comparing their findings with those reported. In this work, we replicated an earlier study in order to investigate the merits of organizational metrics in building defect prediction models for large-scale enterprise s...", "pdfSize": "1257KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Merits+of+organizational+metrics+in+defect+prediction%3A+an+industrial+replication&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "G. Canfora, A. De Lucia, M. Di Penta, R. Oliveto, A. Panichella, S. Panichella, \"Multi-objective Cross-project Defect Prediction\", <em>Proceedings of the International Conference on Software Testing Verification and Validation (ICST)</em>, pp. 252-261, 2013.", "title": "Multi-objective Cross-project Defect Prediction", "context": [{"sec": "sec6c", "text": " However, there are a variety of defect prediction scenarios in the literature (e.g., cross-project defect prediction [13], [68], [76], just-in-time defect prediction [25], heterogenous defect prediction [41]).", "part": "1"}], "links": {"documentLink": "/document/6569737", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6569737", "abstract": "Cross-project defect prediction is very appealing because (i) it allows predicting defects in projects for which the availability of data is limited, and (ii) it allows producing generalizable prediction models. However, existing research suggests that cross-project prediction is particularly challenging and, due to heterogeneity of projects, prediction accuracy is not always very good. This paper proposes a novel, multi-objective approach for cross-project defect prediction, based on a multi-ob...", "pdfSize": "2028KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multi-objective+Cross-project+Defect+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "D. A. da Costa, S. McIntosh, W. Shang, U. Kulesza, R. Coelho, A. E. Hassan, \"A framework for evaluating the results of the szz approach for identifying bug-introducing changes\", <em>Transactions on Software Engineering (TSE)</em>, vol. 43, no. 7, pp. 641-657, 2017.", "title": "A framework for evaluating the results of the szz approach for identifying bug-introducing changes", "context": [{"sec": "sec1", "text": " [14] suggest that the affected-release field in an Issue Tracking System (ITS) should be considered when identifying defect-introducing commits.", "part": "1"}, {"sec": "sec2b", "text": " [14] suggest that the affected-release field in an ITS should be considered when identifying defect-introducing changes.", "part": "1"}, {"sec": "sec2d", "text": "Recent work [14] suggests that the affected-release field in an ITS should be considered when identifying defect-introducing changes.", "part": "1"}, {"sec": "sec6a", "text": " [14] heavily relies on the software development team of a software project.", "part": "1"}], "links": {"documentLink": "/document/7588121", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7588121", "abstract": "The approach proposed by Silwerski, Zimmermann, and Zeller (SZZ) for identifying bug-introducing changes is at the foundation of several research areas within the software engineering discipline. Despite the foundational role of SZZ, little effort has been made to evaluate its results. Such an evaluation is a challenging task because the ground truth is not readily available. By acknowledging such challenges, we propose a framework to evaluate the results of alternative SZZ implementations. The ...", "pdfSize": "1308KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+framework+for+evaluating+the+results+of+the+szz+approach+for+identifying+bug-introducing+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "M. D'Ambros, M. Lanza, R. Robbes, \"Evaluating Defect Prediction Approaches: A Benchmark and an Extensive Comparison\", <em>Empirical Software Engineering</em>, vol. 17, no. 4-5, pp. 531-577, 2012.", "title": "Evaluating Defect Prediction Approaches: A Benchmark and an Extensive Comparison", "context": [{"sec": "sec1", "text": " The widely-used heuristic approach to identify post-release defects is based on the extraction of specific keywords and issue IDs in commit logs in the Version Control System (VCS) using regular expression [15], [17], [25], [56], [75] within a specific post-release window period (e.g., 6 months).", "part": "1"}, {"sec": "sec2a", "text": "Post-release defects are defined as modules that are changed to address a defect report within a post-release window period (e.g., 6 months) [15], [17], [25], [56], [75].", "part": "1"}, {"sec": "sec4a", "text": " Similar to prior studies [15], [17], [25], [56], [75], we apply a collection of regular expression patterns on commit logs in VCS to search for specific keywords and issue IDs within the 6-month period after the release of interest to identify post-release defect counts of each module.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-011-9173-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+Defect+Prediction+Approaches%3A+A+Benchmark+and+an+Extensive+Comparison&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "B. Efron, R. J. Tibshirani, An Introduction to the Bootstrap, Boston, MA:Springer US, 1993.", "title": "An Introduction to the Bootstrap", "context": [{"sec": "sec4b", "text": " On average, 36.8% of the original dataset will not appear in the bootstrap samples, since the samples are drawn with replacement [16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4899-4541-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+Introduction+to+the+Bootstrap&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Fischer, M. Pinzger, H. Gall, \"Populating a Release History Database from Version Control and Bug Tracking Systems\", <em>Proceedings of the International Conference on Software Maintenance (ICSM)</em>, pp. 23-32, 2003.", "title": "Populating a Release History Database from Version Control and Bug Tracking Systems", "context": [{"sec": "sec1", "text": " The widely-used heuristic approach to identify post-release defects is based on the extraction of specific keywords and issue IDs in commit logs in the Version Control System (VCS) using regular expression [15], [17], [25], [56], [75] within a specific post-release window period (e.g., 6 months).", "part": "1"}, {"sec": "sec2a", "text": "Post-release defects are defined as modules that are changed to address a defect report within a post-release window period (e.g., 6 months) [15], [17], [25], [56], [75].", "part": "1"}, {"sec": "sec2a", "text": " [17] are among the first to introduce a heuristic approach by using regular expression to search for specific keywords (e.g., fix (e[ds]) ?, bugs?, defects?) and issue IDs (e.g., [0], [1]\u2013[9] +) in commit logs after the release of interest.", "part": "1"}, {"sec": "sec4a", "text": " Similar to prior studies [15], [17], [25], [56], [75], we apply a collection of regular expression patterns on commit logs in VCS to search for specific keywords and issue IDs within the 6-month period after the release of interest to identify post-release defect counts of each module.", "part": "1"}], "links": {"documentLink": "/document/1235403", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1235403", "abstract": "Version control and bug tracking systems contain large amounts of historical information that can give deep insight into the evolution of a software project. Unfortunately, these systems provide only insufficient support for a detailed analysis of software evolution aspects. We address this problem and introduce an approach for populating a release history database that combines version data with bug tracking data and adds missing data not covered by version control systems such as merge points....", "pdfSize": "312KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Populating+a+Release+History+Database+from+Version+Control+and+Bug+Tracking+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "B. Ghotra, S. McIntosh, A. E. Hassan, \"Revisiting the Impact of Classification Techniques on the Performance of Defect Prediction Models\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 789-800, 2015.", "title": "Revisiting the Impact of Classification Techniques on the Performance of Defect Prediction Models", "context": [{"sec": "sec4b", "text": " AUC measures the ability of classifiers in discriminating between defective and clean modules, as suggested by prior studies [18], [31], [50], [58].", "part": "1"}], "links": {"documentLink": "/document/7194626", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194626", "abstract": "Defect prediction models help software quality assurance teams to effectively allocate their limited resources to the most defect-prone software modules. A variety of classification techniques have been used to build defect prediction models ranging from simple (e.g., Logistic regression) to advanced techniques (e.g., Multivariate Adaptive Regression Splines (MARS)). Surprisingly, recent research on the NASA dataset suggests that the performance of a defect prediction model is not significantly ...", "pdfSize": "730KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Revisiting+the+Impact+of+Classification+Techniques+on+the+Performance+of+Defect+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "T. Hall, S. Beecham, D. Bowes, D. Gray, S. Counsell, \"A Systematic Literature Review on Fault Prediction Performance in Software Engineering\", <em>Transactions on Software Engineering (TSE)</em>, vol. 38, no. 6, pp. 1276-1304, 2012.", "title": "A Systematic Literature Review on Fault Prediction Performance in Software Engineering", "context": [{"sec": "sec1", "text": " For example, prior studies develop defect prediction models that learn historical defect characteristics in order to predict the most defective modules [10], [19], [22], [36], [71], [73].", "part": "1"}], "links": {"documentLink": "/document/6035727", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6035727", "abstract": "Background: The accurate prediction of where faults are likely to occur in code can help direct test effort, reduce costs, and improve the quality of software. Objective: We investigate how the context of models, the independent variables used, and the modeling techniques applied influence the performance of fault prediction models. Method: We used a systematic literature review to identify 208 fault prediction studies published from January 2000 to December 2010. We synthesize the quantitative ...", "pdfSize": "6095KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Systematic+Literature+Review+on+Fault+Prediction+Performance+in+Software+Engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J. A. Hanley, B. J. McNeil, \"The meaning and use of the area under a receiver operating characteristic (ROC) curve\", <em>Radiology</em>, vol. 143, no. 4, pp. 29-36, 1982.", "title": "The meaning and use of the area under a receiver operating characteristic (ROC) curve", "context": [{"sec": "sec4b", "text": " The value of AUC measure ranges between 0 (worst performance), 0.5 (no better than random guessing), and 1 (best performance) [20].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1148/radiology.143.1.7063747", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+meaning+and+use+of+the+area+under+a+receiver+operating+characteristic+%28ROC%29+curve&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "K. Herzig, S. Just, A. Zeller, \"It's not a Bug it's a Feature: How Misclassification Impacts Bug Prediction\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, no. Section XII, pp. 392-401, 2013.", "title": "It's not a Bug, it's a Feature: How Misclassification Impacts Bug Prediction", "context": [{"sec": "sec2c", "text": " [21] find that many issue reports are misclassified.", "part": "1"}, {"sec": "sec2d", "text": " [21] and Kovalenko et al. [29] demonstrate that noise that is generated by issue report mislabelling and branches has little impact on the predictive accuracy of defect models, respectively.", "part": "1"}, {"sec": "sec2d", "text": " [21] find that noise that is generated by issue report mislabelling can impact the ranking of defective modules produced by defect models.", "part": "1"}], "links": {"documentLink": "/document/6606585", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6606585", "abstract": "In a manual examination of more than 7,000 issue reports from the bug databases of five open-source projects, we found 33.8% of all bug reports to be misclassified - that is, rather than referring to a code fix, they resulted in a new feature, an update to documentation, or an internal refactoring. This misclassification introduces bias in bug prediction models, confusing bugs and features: On average, 39% of files marked as defective actually never had a bug. We discuss the impact of this miscl...", "pdfSize": "352KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=It%27s+not+a+Bug%2C+it%27s+a+Feature%3A+How+Misclassification+Impacts+Bug+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "R. Hosseini, B. Turhan, D. Gunarathna, \"A Systematic Literature Review and Meta-analysis on Cross Project Defect Prediction\", <em>Transactions on software Engineering (TSE)</em>, 2017.", "title": "A Systematic Literature Review and Meta-analysis on Cross Project Defect Prediction", "context": [{"sec": "sec1", "text": " For example, prior studies develop defect prediction models that learn historical defect characteristics in order to predict the most defective modules [10], [19], [22], [36], [71], [73].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Systematic+Literature+Review+and+Meta-analysis+on+Cross+Project+Defect+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "J. Jiarpakdee, C. Tantithamthavorn, A. E. Hassan, \"The Impact of Correlated Metrics on Defect Models\", <em>Transactions on Software Engineering (TSE)</em>, 2019.", "title": "The Impact of Correlated Metrics on Defect Models", "context": [{"sec": "sec4b", "text": " For each type of models, we apply 2 machine learning techniques (i.e, regression and random forest) on each training sample, since they often produce highly accurate predictions [23], [31], [62], [65].", "part": "1"}], "links": {"abstract": "Defect models are analytical models for building empirical theories related to software quality. Prior studies often derive knowledge from such models using interpretation techniques, e.g., ANOVA Type-I. Recent work raises concerns that correlated metrics may impact the interpretation of defect models. Yet, the impact of correlated metrics in such models has not been investigated. In this paper, we investigate the impact of correlated metrics on the interpretation of defect models and the improv...", "pdfSize": "4926KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Correlated+Metrics+on+Defect+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "J. Jiarpakdee, C. Tantithamthavorn, C. Treude, \"AutoSpearman: Automatically Mitigating Correlated Metrics for Interpreting Defect Models\", <em>Proceeding of the International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 92-103, 2018.", "title": "AutoSpearman: Automatically Mitigating Correlated Metrics for Interpreting Defect Models", "context": [{"sec": "sec4b", "text": " Prior to constructing defect models, we remove irrelevant and mitigate correlated metrics [24] using the implementation as provided by the AutoSpearman function of the Rnalytica R package [60].", "part": "1"}], "links": {"documentLink": "/document/8530020", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8530020", "abstract": "The following topics are dealt with: software maintenance; public domain software; software engineering; program debugging; program testing; Java; mobile computing; application program interfaces; pattern classification; Android (operating system).", "pdfSize": "221KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AutoSpearman%3A+Automatically+Mitigating+Correlated+Metrics+for+Interpreting+Defect+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "Y. Kamei, E. Shihab, B. Adams, A. E. Hassan, A. Mockus, A. Sinha, N. Ubayashi, \"A Large-Scale Empirical Study of Just-In-Time Quality Assurance\", <em>Transactions on Software Engineering (TSE)</em>, vol. 39, no. 6, pp. 757-773, 2013.", "title": "A Large-Scale Empirical Study of Just-In-Time Quality Assurance", "context": [{"sec": "sec1", "text": " The widely-used heuristic approach to identify post-release defects is based on the extraction of specific keywords and issue IDs in commit logs in the Version Control System (VCS) using regular expression [15], [17], [25], [56], [75] within a specific post-release window period (e.g., 6 months).", "part": "1"}, {"sec": "sec2a", "text": "Post-release defects are defined as modules that are changed to address a defect report within a post-release window period (e.g., 6 months) [15], [17], [25], [56], [75].", "part": "1"}, {"sec": "sec4a", "text": " Similar to prior studies [15], [17], [25], [56], [75], we apply a collection of regular expression patterns on commit logs in VCS to search for specific keywords and issue IDs within the 6-month period after the release of interest to identify post-release defect counts of each module.", "part": "1"}, {"sec": "sec6c", "text": " However, there are a variety of defect prediction scenarios in the literature (e.g., cross-project defect prediction [13], [68], [76], just-in-time defect prediction [25], heterogenous defect prediction [41]).", "part": "1"}], "links": {"documentLink": "/document/6341763", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6341763", "abstract": "Defect prediction models are a well-known technique for identifying defect-prone files or packages such that practitioners can allocate their quality assurance efforts (e.g., testing and code reviews). However, once the critical files or packages have been identified, developers still need to spend considerable time drilling down to the functions or even code snippets that should be reviewed or tested. This makes the approach too time consuming and impractical for large software systems. Instead...", "pdfSize": "2140KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Large-Scale+Empirical+Study+of+Just-In-Time+Quality+Assurance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "F. Khomh, M. Di Penta, Y.-G. Gueheneuc, \"An Exploratory Study of the Impact of Code Smells on Software Change-proneness\", <em>Proceedings of the Working Conference on Reverse Engineering (WCRE)</em>, pp. 75-84, 2009.", "title": "An Exploratory Study of the Impact of Code Smells on Software Change-proneness", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"documentLink": "/document/5328703", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5328703", "abstract": "Code smells are poor implementation choices, thought to make object-oriented systems hard to maintain. In this study, we investigate if classes with code smells are more change-prone than classes without smells. Specifically, we test the general hypothesis: classes with code smells are not more change prone than other classes. We detect 29 code smells in 9 releases of Azureus and in 13 releases of Eclipse, and study the relation between classes with these code smells and class change-proneness. ...", "pdfSize": "221KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+Exploratory+Study+of+the+Impact+of+Code+Smells+on+Software+Change-proneness&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "F. Khomh, M. Di Penta, Y.-G. Gu\u00e9h\u00e9neuc, G. Antoniol, \"An exploratory study of the impact of antipatterns on class change-and fault-proneness\", <em>Empirical Software Engineering</em>, vol. 17, no. 3, pp. 243-275, 2012.", "title": "An exploratory study of the impact of antipatterns on class change-and fault-proneness", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-011-9171-y", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+exploratory+study+of+the+impact+of+antipatterns+on+class+change-and+fault-proneness&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "S. Kim, H. Zhang, R. Wu, L. Gong, \"Dealing with Noise in Defect Prediction\", <em>Proceedings of the International Conference on Software engineering (ICSE)</em>, pp. 481-490, 2011.", "title": "Dealing with Noise in Defect Prediction", "context": [{"sec": "sec2d", "text": " [28] demonstrate that random noise that is generated by missing links has a large negative impact on the predictive accuracy of defect models.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985859", "abstract": "Many software defect prediction models have been built using historical defect data obtained by mining software repositories (MSR). Recent studies have discovered that data so collected contain noises because current defect collection practices are based on optional bug fix keywords or bug report links in change logs. Automatically collected defect data based on the change logs could include noises. This paper proposes approaches to deal with the noise in defect data. First, we measure the impac...", "pdfSize": "684KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dealing+with+Noise+in+Defect+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "V. Kovalenko, F. Palomba, A. Bacchelli, \"Mining file histories: Should we consider branches?\", <em>Proceedings of the International Conference on Automated Software Engineering (ASE)</em>, pp. 202-213, 2018.", "title": "Mining file histories: Should we consider branches?", "context": [{"sec": "sec2d", "text": " [29] demonstrate that noise that is generated by issue report mislabelling and branches has little impact on the predictive accuracy of defect models, respectively.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3238147.3238169", "abstract": "Modern distributed version control systems, such as Git, offer support for branching - the possibility to develop parts of software outside the master trunk. Consideration of the repository structure in Mining Software Repository (MSR) studies requires a thorough approach to mining, but there is no well-documented, widespread methodology regarding the handling of merge commits and branches. Moreover, there is still a lack of knowledge of the extent to which considering branches during MSR studie...", "pdfSize": "300KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+file+histories%3A+Should+we+consider+branches%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "W. B. Langdon, J. Dolado, F. Sarro, M. Harman, \"Exact Mean Absolute Error of Baseline Predictor MARPO\", <em>Information and Software Technology</em>, vol. 73, pp. 16-18, 2016.", "title": "Exact Mean Absolute Error of Baseline Predictor, MARPO", "context": [{"sec": "sec4b", "text": "For defect count models, we use the Mean Absolute Error (MAE) and the Standardized Accuracy (SA), as suggested by prior work [30], [53], [54], [75].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2016.01.003", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exact+Mean+Absolute+Error+of+Baseline+Predictor%2C+MARPO&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "S. Lessmann, B. Baesens, C. Mues, S. Pietsch, \"Benchmarking Classification Models for Software Defect Prediction: A Proposed Framework and Novel Findings\", <em>Transactions on Software Engineering (TSE)</em>, vol. 34, no. 4, pp. 485-496, 2008.", "title": "Benchmarking Classification Models for Software Defect Prediction: A Proposed Framework and Novel Findings", "context": [{"sec": "sec4b", "text": " For each type of models, we apply 2 machine learning techniques (i.e, regression and random forest) on each training sample, since they often produce highly accurate predictions [23], [31], [62], [65].", "part": "1"}, {"sec": "sec4b", "text": " AUC measures the ability of classifiers in discriminating between defective and clean modules, as suggested by prior studies [18], [31], [50], [58].", "part": "1"}], "links": {"documentLink": "/document/4527256", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4527256", "abstract": "Software defect prediction strives to improve software quality and testing efficiency by constructing predictive classification models from code attributes to enable a timely identification of fault-prone modules. Several classification models have been evaluated for this task. However, due to inconsistent findings regarding the superiority of one classifier over another and the usefulness of metric-based classification in general, more research is needed to improve convergence across studies an...", "pdfSize": "3758KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Benchmarking+Classification+Models+for+Software+Defect+Prediction%3A+A+Proposed+Framework+and+Novel+Findings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "G. A. Liebchen, M. Shepperd, \"Data sets and data quality in software engineering\", <em>Proceedings of the International Workshop on Predictor Models in Software Engineering (PROMISE)</em>, pp. 39-44, 2008.", "title": "Data sets and data quality in software engineering", "context": [{"sec": "sec2c", "text": "Software repositories are often noisy (e.g., incorrect, missing information) [9], [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1370788.1370799", "abstract": "OBJECTIVE - to assess the extent and types of techniques used to manage quality within software engineering data sets. We consider this a particularly interesting question in the context of initiatives to promote sharing and secondary analysis of data sets. METHOD - we perform a systematic review of available empirical software engineering studies. RESULTS - only 23 out of the many hundreds of studies assessed, explicitly considered data quality. CONCLUSIONS - first, the community needs to consi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+sets+and+data+quality+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "S. Mcintosh, Y. Kamei, B. Adams, A. E. Hassan, \"The Impact of Code Review Coverage and Code Review Participation on Software Quality\", <em>Proceedings of the Working Conference on Mining Software Repositories (MSR)</em>, pp. 192-201, 2014.", "title": "The Impact of Code Review Coverage and Code Review Participation on Software Quality", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Code+Review+Coverage+and+Code+Review+Participation+on+Software+Quality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "T. Menzies, J. Greenwald, A. Frank, \"Data Mining Static Code Attributes to Learn Defect Predictors\", <em>Transactions on Software Engineering (TSE)</em>, vol. 33, no. 1, pp. 2-13, 2007.", "title": "Data Mining Static Code Attributes to Learn Defect Predictors", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"documentLink": "/document/4027145", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4027145", "abstract": "The value of using static code attributes to learn defect predictors has been widely debated. Prior work has explored issues like the merits of &#34;McCabes versus Halstead versus lines of code counts&#34; for generating defect predictors. We show here that such debates are irrelevant since how the attributes are used to build predictors is much more important than which particular attributes are used. Also, contrary to prior pessimism, we show that such defect predictors are demonstrably useful and, on...", "pdfSize": "2114KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+Mining+Static+Code+Attributes+to+Learn+Defect+Predictors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "T. Menzies, Z. Milton, B. Turhan, B. Cukic, Y. Jiang, A. Bener, \"Defect prediction from static code features: current results limitations new approaches\", <em>Automated Software Engineering (ASE)</em>, vol. 17, no. 4, pp. 375-407, 2010.", "title": "Defect prediction from static code features: current results, limitations, new approaches", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[35][40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-010-0069-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Defect+prediction+from+static+code+features%3A+current+results%2C+limitations%2C+new+approaches&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "T. Menzies, T. Zimmermann, \"Software Analytics: So What?\", <em>Software</em>, vol. 30, no. 4, pp. 31-37, 2013.", "title": "Software Analytics: So What?", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[36][40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec1", "text": " For example, prior studies develop defect prediction models that learn historical defect characteristics in order to predict the most defective modules [10], [19], [22], [36], [71], [73].", "part": "1"}], "links": {"documentLink": "/document/6547619", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6547619", "abstract": "The guest editors of this special issue of IEEE Software invited submissions that reflected the benefits (and drawbacks) of software analytics, an area of explosive growth. They had so many excellent submissions that they had to split this special issue into two volumes--you&#39;ll see even more content in the September/October issue. They divided the articles on conceptual grounds, so both volumes will feature equally excellent work. The Web extra at http://youtu.be/nO6X0azR0nw is a video interview...", "pdfSize": "1116KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+Analytics%3A+So+What%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "N. Nagappan, T. Ball, \"Use of Relative Code Churn Measures to Predict System Defect Density\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 284-292, 2005.", "title": "Use of Relative Code Churn Measures to Predict System Defect Density", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[37][40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1062455.1062514", "abstract": "Software systems evolve over time due to changes in requirements, optimization of code, fixes for security and reliability bugs etc. Code churn, which measures the changes made to a component over a period of time, quantifies the extent of this change. We present a technique for early prediction of system defect density using a set of relative code churn measures that relate the amount of churn to other variables such as component size and the temporal extent of churn.Using statistical regressio...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Use+of+Relative+Code+Churn+Measures+to+Predict+System+Defect+Density&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "N. Nagappan, T. Ball, A. Zeller, \"Mining Metrics to Predict Component Failures\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 452-461, 2006.", "title": "Mining Metrics to Predict Component Failures", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[38][40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134349", "abstract": "What is it that makes software fail? In an empirical study of the post-release defect history of five Microsoft software systems, we found that failure-prone software entities are statistically correlated with code complexity measures. However, there is no single set of complexity metrics that could act as a universally best defect predictor. Using principal component analysis on the code metrics, we built regression models that accurately predict the likelihood of post-release defects for new e...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+Metrics+to+Predict+Component+Failures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "N. Nagappan, B. Murphy, V. Basili, \"The influence of organizational structure on software quality\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 521-530, 2008.", "title": "The influence of organizational structure on software quality", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[39][40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368160", "abstract": "Often software systems are developed by organizations consisting of many teams of individuals working together. Brooks states in the Mythical Man Month book that product quality is strongly affected by organization structure. Unfortunately there has been little empirical evidence to date to substantiate this assertion. In this paper we present a metric scheme to quantify organizational complexity, in relation to the product development process to identify if the metrics impact failure-proneness....", "pdfSize": "196KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+influence+of+organizational+structure+on+software+quality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "N. Nagappan, A. Zeller, T. Zimmermann, K. Herzig, B. Murphy, \"Change Bursts as Defect Predictors\", <em>Proceedings of the International Symposium on Software Reliability Engineering (ISSRE)</em>, pp. 309-318, 2010.", "title": "Change Bursts as Defect Predictors", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"documentLink": "/document/5635057", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5635057", "abstract": "In software development, every change induces a risk. What happens if code changes again and again in some period of time? In an empirical study on Windows Vista, we found that the features of such change bursts have the highest predictive power for defect-prone components. With precision and recall values well above 90%, change bursts significantly improve upon earlier predictors such as complexity metrics, code churn, or organizational structure. As they only rely on version history and a cont...", "pdfSize": "758KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Change+Bursts+as+Defect+Predictors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "J. Nam, W. Fu, S. Kim, T. Menzies, L. Tan, \"Heterogeneous Defect Prediction\", <em>Transactions on Software Engineering (TSE)</em>, vol. 44, no. 9, pp. 874-896, 2017.", "title": "Heterogeneous Defect Prediction", "context": [{"sec": "sec6c", "text": " However, there are a variety of defect prediction scenarios in the literature (e.g., cross-project defect prediction [13], [68], [76], just-in-time defect prediction [25], heterogenous defect prediction [41]).", "part": "1"}], "links": {"documentLink": "/document/7959597", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7959597", "abstract": "Many recent studies have documented the success of cross-project defect prediction (CPDP) to predict defects for new projects lacking in defect data by using prediction models built by other projects. However, most studies share the same limitations: it requires homogeneous data; i.e., different projects must describe themselves using the same metrics. This paper presents methods for heterogeneous defect prediction (HDP) that matches up different metrics in different projects. Metric matching fo...", "pdfSize": "1046KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Heterogeneous+Defect+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "A. T. Nguyen, T. T. Nguyen, H. A. Nguyen, T. N. Nguyen, \"Multi-layered approach for recovering links between bug reports and fixes\", <em>Proceedings of the International Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 1-11, 2012.", "title": "Multi-layered approach for recovering links between bug reports and fixes", "context": [{"sec": "sec1", "text": "However, such the heuristic approach is based on several assumptions [4], [6], [42], [43], [61], [72], which pose common threats to the validity of many studies.", "part": "1"}, {"sec": "sec2c", "text": " To address this challenge, prior studies [42], [72] introduce the textual similarity approaches between issue reports and commit messages to automatically recover the missing links between issue reports to the corresponding code changes.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2393596.2393671", "abstract": "The links between the bug reports in an issue-tracking system and the corresponding fixing changes in a version repository are not often recorded by developers. Such linking information is crucial for research in mining software repositories in measuring software defects and maintenance efforts. However, the state-of-the-art bug-to-fix link recovery approaches still rely much on textual matching between bug reports and commit/change logs and cannot handle well the cases where their contents are ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multi-layered+approach+for+recovering+links+between+bug+reports+and+fixes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "T. H. Nguyen, B. Adams, A. E. Hassan, \"A Case Study of Bias in Bug-Fix Datasets\", <em>Proceedings of the Working Conference on Reverse Engineering (WCRE)</em>, pp. 259-268, 2010.", "title": "A Case Study of Bias in Bug-Fix Datasets", "context": [{"sec": "sec1", "text": "However, such the heuristic approach is based on several assumptions [4], [6], [42], [43], [61], [72], which pose common threats to the validity of many studies.", "part": "1"}, {"sec": "sec2c", "text": " [43] show that such noises also exist in commercial datasets.", "part": "1"}], "links": {"documentLink": "/document/5645567", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5645567", "abstract": "Software quality researchers build software quality models by recovering traceability links between bug reports in issue tracking repositories and source code files. However, all too often the data stored in issue tracking repositories is not explicitly tagged or linked to source code. Researchers have to resort to heuristics to tag the data (e.g., to determine if an issue is a bug report or a work item), or to link a piece of code to a particular issue or bug. Recent studies by Bird et al. and ...", "pdfSize": "274KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Case+Study+of+Bias+in+Bug-Fix+Datasets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "M. Ortu, G. Destefanis, B. Adams, A. Murgia, M. Marchesi, R. Tonelli, \"The jira repository dataset: Understanding social aspects of software development\", <em>Proceedings of the International Conference on Predictive Models and Data Analytics in Software Engineering (PROMISE)</em>, pp. 1, 2015.", "title": "The jira repository dataset: Understanding social aspects of software development", "context": [{"sec": "sec3", "text": "To satisfy criterion 1, we first select a set of systems from the corpus of software systems [44], [45] which extensively use JIRA Issue Tracking System.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2810146.2810147", "abstract": "Issue tracking systems store valuable data for testing hypotheses concerning maintenance, building statistical prediction models and recently investigating developers &#34;affectiveness&#34;. In particular, the Jira Issue Tracking System is a proprietary tracking system that has gained a tremendous popularity in the last years and offers unique features like the project management system and the Jira agile kanban board. This paper presents a dataset extracted from the Jira ITS of four popular open sourc...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+jira+repository+dataset%3A+Understanding+social+aspects+of+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "M. Ortu, A. Murgia, G. Destefanis, P. Tourani, R. Tonelli, M. Marchesi, B. Adams, \"The emotional side of software developers in jira\", <em>Proceedings of the International Conference on Mining Software Repositories (MSR)</em>, pp. 480-483, 2016.", "title": "The emotional side of software developers in jira", "context": [{"sec": "sec3", "text": "To satisfy criterion 1, we first select a set of systems from the corpus of software systems [44], [45] which extensively use JIRA Issue Tracking System.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2901739.2903505", "abstract": "Issue tracking systems store valuable data for testing hypotheses concerning maintenance, building statistical prediction models and (recently) investigating developer affectiveness. For the latter, issue tracking systems can be mined to explore developers emotions, sentiments and politeness---affects for short. However, research on affect detection in software artefacts is still in its early stage due to the lack of manually validated data and tools. In this paper, we contribute to the research...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+emotional+side+of+software+developers+in+jira&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "F. Palomba, G. Bavota, M. Di Penta, R. Oliveto, D. Poshyvanyk, A. De Lucia, \"Mining version histories for detecting code smells\", <em>Transactions on Software Engineering (TSE)</em>, vol. 41, no. 5, pp. 462-489, 2015.", "title": "Mining version histories for detecting code smells", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"documentLink": "/document/6963448", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6963448", "abstract": "Code smells are symptoms of poor design and implementation choices that may hinder code comprehension, and possibly increase changeand fault-proneness. While most of the detection techniques just rely on structural information, many code smells are intrinsically characterized by how code elements change overtime. In this paper, we propose Historical Information for Smell deTection (HIST), an approach exploiting change history information to detect instances of five different code smells, namely ...", "pdfSize": "1307KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+version+histories+for+detecting+code+smells&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "D. M. Powers, What the F-measure doesn't measure: Features Flaws Fallacies and Fixes, 2015.", "title": "What the F-measure doesn't measure: Features, Flaws, Fallacies and Fixes", "context": [{"sec": "sec6b", "text": "Recent work [47] raised concerns that F-measure neglects the True Negative predictions.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+the+F-measure+doesn%27t+measure%3A+Features%2C+Flaws%2C+Fallacies+and+Fixes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "\"R Core Team\", <em>R: A language and environment for statistical computing</em>, 2013,  [online]  Available: http://www/R-project.org/.", "title": "R Core Team", "context": [{"sec": "sec4b", "text": " We use the implementation of the linear regression technique as provided by the lm function of the base R package [48].", "part": "1"}, {"sec": "sec4b", "text": " We use the implementation of logistic regression as provided by the glm function of the stats R package [48].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=R+Core+Team&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "F. Rahman, P. Devanbu, \"Ownership experience and defects: a fine-grained study of authorship\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 491-500, 2011.", "title": "Ownership, experience and defects: a fine-grained study of authorship", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec4a", "text": "Ownership metrics describe the relationship between the ownership of modules and software quality [8], [49], [66].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985860", "abstract": "Recent research indicates that &#34;people&#34; factors such as ownership, experience, organizational structure, and geographic distribution have a big impact on software quality. Understanding these factors, and properly deploying people resources can help managers improve quality outcomes. This paper considers the impact of code ownership and developer experience on software quality. In a large project, a file might be entirely owned by a single developer, or worked on by many. Some previous research ...", "pdfSize": "490KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ownership%2C+experience+and+defects%3A+a+fine-grained+study+of+authorship&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "F. Rahman, P. Devanbu, \"How and Why Process Metrics are Better\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 432-441, 2013.", "title": "How, and Why, Process Metrics are Better", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec2c", "text": " [50] argue that the size of the defect datasets matters more than the dataset quality.", "part": "1"}, {"sec": "sec4a", "text": " [50], we normalize the values of the lines added and the lines deleted of a module by the total lines added and lines deleted.", "part": "1"}, {"sec": "sec4b", "text": " AUC measures the ability of classifiers in discriminating between defective and clean modules, as suggested by prior studies [18], [31], [50], [58].", "part": "1"}, {"sec": "sec4b", "text": " Thus, developers often prioritize their limited resources on the most defective modules [50], [76].", "part": "1"}], "links": {"documentLink": "/document/7190081", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7190081", "abstract": "Defect prediction techniques could potentially help us to focus quality-assurance efforts on the most defect-prone files. Modern statistical tools make it very easy to quickly build and deploy prediction models. Software metrics are at the heart of prediction models; understanding how and especially why different types of metrics are effective is very important for successful model deployment. In this paper we analyze the applicability and efficacy of process and code metrics from several differ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How%2C+and+Why%2C+Process+Metrics+are+Better&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "J. Romano, J. Kromrey, J. Coraggio, J. Skowronek, \"Should we really be using t-test and cohen's d for evaluating group differences on the nsse and other surveys\", <em>Annual meeting of the Florida Association of Institutional Research</em>, 2006.", "title": "Should we really be using t-test and cohen's d for evaluating group differences on the nsse and other surveys", "context": [{"sec": "sec5b", "text": " To quantify the magnitude of the difference, we use Cliff's \\$\\vert \\delta\\vert\\$ effect size [51] with the interpretation of Romano et al.", "part": "1"}, {"sec": "sec5b", "text": " [51]: negligible for \\$\\vert \\delta\\vert \\leq 0.147\\$, small for \\$\\vert \\delta\\vert \\leq 0.33\\$, medium for \\$\\vert \\delta\\vert \\leq 0.474\\$, and large for \\$\\vert \\delta\\vert \\geq 0.474\\$.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Should+we+really+be+using+t-test+and+cohen%27s+d+for+evaluating+group+differences+on+the+nsse+and+other+surveys&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "S. Ruangwan, P. Thongtanunam, A. Ihara, K. Matsumoto, \"The Impact of Human Factors on the Participation Decision of Reviewers in Modern Code Review\" in Empirical Software Engineering (EMSE), press, 2018.", "title": "The Impact of Human Factors on the Participation Decision of Reviewers in Modern Code Review", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Human+Factors+on+the+Participation+Decision+of+Reviewers+in+Modern+Code+Review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "F. Sarro, A. Petrozziello, \"LP4EE: Linear Programming as a Baseline for Software Effort Estimation\", <em>Transactions on Software Engineering and Methodology (TOSEM)</em>, vol. 27, no. 3, 2018.", "title": "LP4EE: Linear Programming as a Baseline for Software Effort Estimation", "context": [{"sec": "sec4b", "text": "For defect count models, we use the Mean Absolute Error (MAE) and the Standardized Accuracy (SA), as suggested by prior work [30], [53], [54], [75].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=LP4EE%3A+Linear+Programming+as+a+Baseline+for+Software+Effort+Estimation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "M. Shepperd, S. MacDonell, \"Evaluating Prediction Systems in Software Project Estimation\", <em>Information and Software Technology</em>, vol. 54, no. 8, pp. 820-827, 2012.", "title": "Evaluating Prediction Systems in Software Project Estimation", "context": [{"sec": "sec4b", "text": "For defect count models, we use the Mean Absolute Error (MAE) and the Standardized Accuracy (SA), as suggested by prior work [30], [53], [54], [75].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2011.12.008", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+Prediction+Systems+in+Software+Project+Estimation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "E. Shihab, Z. M. Jiang, W. M. Ibrahim, B. Adams, A. E. Hassan, \"Understanding the Impact of Code and Process Metrics on Post-release Defects: A Case Study on the Eclipse Project\", <em>Proceedings of the International Symposium on Empirical Software Engineering and Measurement (ESEM)</em>, no. 4, 2010.", "title": "Understanding the Impact of Code and Process Metrics on Post-release Defects: A Case Study on the Eclipse Project", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1852786.1852792", "abstract": "Research studying the quality of software applications continues to grow rapidly with researchers building regression models that combine a large number of metrics. However, these models are hard to deploy in practice due to the cost associated with collecting all the needed metrics, the complexity of the models and the black box nature of the models. For example, techniques such as PCA merge a large number of metrics into composite metrics that are no longer easy to explain. In this paper, we u...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+the+Impact+of+Code+and+Process+Metrics+on+Post-release+Defects%3A+A+Case+Study+on+the+Eclipse+Project&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "J. \u015aliwerski, T. Zimmermann, A. Zeller, \"When do changes induce fixes?\", <em>Software Engineering Notes (SEN)</em>, vol. 30, no. 4, pp. 1, 2005.", "title": "When do changes induce fixes?", "context": [{"sec": "sec1", "text": " The widely-used heuristic approach to identify post-release defects is based on the extraction of specific keywords and issue IDs in commit logs in the Version Control System (VCS) using regular expression [15], [17], [25], [56], [75] within a specific post-release window period (e.g., 6 months).", "part": "1"}, {"sec": "sec2a", "text": "Post-release defects are defined as modules that are changed to address a defect report within a post-release window period (e.g., 6 months) [15], [17], [25], [56], [75].", "part": "1"}, {"sec": "sec4a", "text": " Similar to prior studies [15], [17], [25], [56], [75], we apply a collection of regular expression patterns on commit logs in VCS to search for specific keywords and issue IDs within the 6-month period after the release of interest to identify post-release defect counts of each module.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1082983.1083147", "abstract": "As a software system evolves, programmers make changes that sometimes cause problems. We analyze CVS archives for fix-inducing changes---changes that lead to problems, indicated by fixes. We show how to automatically locate fix-inducing changes by linking a version archive (such as CVS) to a bug database (such as BUGZILLA). In a first investigation of the MOZILLA and ECLIPSE history, it turns out that fix-inducing changes show distinct patterns with respect to their size and the day of week they...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+do+changes+induce+fixes%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "C. Tantithamthavorn, \"Towards a Better Understanding of the Impact of Experimental Components on Defect Prediction Modelling\", <em>Companion Proceeding of the International Conference on Software Engineering (ICSE)</em>, pp. 867-870, 2016.", "title": "Towards a Better Understanding of the Impact of Experimental Components on Defect Prediction Modelling", "context": [{"sec": "sec4b", "text": " [57], [64] demonstrated that it produces the most stable performance estimates when comparing to other model validation techniques like k-fold cross-validation.", "part": "1"}, {"sec": "sec6", "text": "Like any empirical studies, the settings of experimental design may impact the results of our study [57], [63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2889160.2889256", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+a+Better+Understanding+of+the+Impact+of+Experimental+Components+on+Defect+Prediction+Modelling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "C. Tantithamthavorn, A. E. Hassan, \"An Experience Report on Defect Modelling in Practice: Pitfalls and Challenges\", <em>Proceedings of the International Conference on Software Engineering: Software Engineering in Practice Track (ICSE-SEIP)</em>, pp. 286-295, 2018.", "title": "An Experience Report on Defect Modelling in Practice: Pitfalls and Challenges", "context": [{"sec": "sec4b", "text": " AUC measures the ability of classifiers in discriminating between defective and clean modules, as suggested by prior studies [18], [31], [50], [58].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183519.3183547", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+Experience+Report+on+Defect+Modelling+in+Practice%3A+Pitfalls+and+Challenges&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "C. Tantithamthavorn, A. E. Hassan, K. Matsumoto, \"The Impact of Class Rebalancing Techniques on the Performance and Interpretation of Defect Prediction Models\", <em>Transactions on Software Engineering (TSE)</em>, 2018.", "title": "The Impact of Class Rebalancing Techniques on the Performance and Interpretation of Defect Prediction Models", "context": [{"sec": "sec4b", "text": " We note that we do not rebalance the training samples to avoid any concept drifts [59].", "part": "1"}], "links": {"abstract": "Defect models that are trained on class imbalanced datasets (i.e., the proportion of defective and clean modules is not equally represented) are highly susceptible to produce inaccurate prediction models. Prior research compares the impact of class rebalancing techniques on the performance of defect models but arrives at contradictory conclusions due to the use of different choice of datasets, classification techniques, and performance measures. Such contradictory conclusions make it hard to der...", "pdfSize": "2913KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Class+Rebalancing+Techniques+on+the+Performance+and+Interpretation+of+Defect+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "C. Tantithamthavorn, J. Jiarpakdee, <em>Rnalytica: An R package of JIRA defect datasets and tool suites for explainable software analytics</em>,  [online]  Available: https://github.com/awsm-research/Rnalytica.", "title": "Rnalytica: An R package of JIRA defect datasets and tool suites for explainable software analytics", "context": [{"sec": "sec1", "text": "A new collection of highly-curated benchmark defect datasets of 32 releases that span across 9 open-source software systems using the heuristic and realistic approaches [60] and a replication package at Zenodo [74].", "part": "1"}, {"sec": "sec4b", "text": " Prior to constructing defect models, we remove irrelevant and mitigate correlated metrics [24] using the implementation as provided by the AutoSpearman function of the Rnalytica R package [60].", "part": "1"}, {"sec": "sec4b", "text": "To calculate the aforementioned predictive accuracy measures, we use the implementation as provided by the performance.calculation function of the Rnalytica R package [60].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rnalytica%3A+An+R+package+of+JIRA+defect+datasets+and+tool+suites+for+explainable+software+analytics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "C. Tantithamthavorn, S. McIntosh, A. E. Hassan, A. Ihara, K. Matsumoto, \"The Impact of Mislabelling on the Performance and Interpretation of Defect Prediction Models\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 812-823, 2015.", "title": "The Impact of Mislabelling on the Performance and Interpretation of Defect Prediction Models", "context": [{"sec": "sec1", "text": "However, such the heuristic approach is based on several assumptions [4], [6], [42], [43], [61], [72], which pose common threats to the validity of many studies.", "part": "1"}, {"sec": "sec2c", "text": " However, recent work shows that issue report mislabelling rarely impacts the precision of defect models or the interpretation of the most important software metrics [61].", "part": "1"}], "links": {"documentLink": "/document/7194628", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194628", "abstract": "The reliability of a prediction model depends on the quality of the data from which it was trained. Therefore, defect prediction models may be unreliable if they are trained using noisy data. Recent research suggests that randomly-injected noise that changes the classification (label) of software modules from defective to clean (and vice versa) can impact the performance of defect models. Yet, in reality, incorrectly labelled (i.e., mislabelled) issue reports are likely non-random. In this paper...", "pdfSize": "1131KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Mislabelling+on+the+Performance+and+Interpretation+of+Defect+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "C. Tantithamthavom, S. McIntosh, A. E. Hassan, K. Matsumoto, \"Automated Parameter Optimization of Classification Techniques for Defect Prediction Models\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 321-332, 2016.", "title": "Automated Parameter Optimization of Classification Techniques for Defect Prediction Models", "context": [{"sec": "sec4b", "text": " For each type of models, we apply 2 machine learning techniques (i.e, regression and random forest) on each training sample, since they often produce highly accurate predictions [23], [31], [62], [65].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+Parameter+Optimization+of+Classification+Techniques+for+Defect+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "\"Comments on \u201cResearcher Bias: The Use of Machine Learning in Software Defect Prediction\u201d\", <em>Transactions on Software Engineering (TSE)</em>, vol. 42, no. 11, pp. 1092-1094, 2016.", "title": "Comments on \u201cResearcher Bias: The Use of Machine Learning in Software Defect Prediction\u201d", "context": [{"sec": "sec6", "text": "Like any empirical studies, the settings of experimental design may impact the results of our study [57], [63].", "part": "1"}], "links": {"documentLink": "/document/7450669", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7450669", "abstract": "Shepperd et al. find that the reported performance of a defect prediction model shares a strong relationship with the group of researchers who construct the models. In this paper, we perform an alternative investigation of Shepperd et al.&#39;s data. We observe that (a) research group shares a strong association with other explanatory variables (i.e., the dataset and metric families that are used to build a model); (b) the strong association among these explanatory variables makes it difficult to di...", "pdfSize": "141KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Comments+on+%E2%80%9CResearcher+Bias%3A+The+Use+of+Machine+Learning+in+Software+Defect+Prediction%E2%80%9D&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "\"An Empirical Comparison of Model Validation Techniques for Defect Prediction Models\", <em>Transactions on Software Engineering (TSE)</em>, vol. 43, no. 1, pp. 1-18, 2017.", "title": "An Empirical Comparison of Model Validation Techniques for Defect Prediction Models", "context": [{"sec": "sec4b", "text": " To ensure that our conclusions are statistically sound and robust, we use the out-of-sample bootstrap validation technique to generate training samples and estimate the model performance, since Tan-tithamthavorn et al. [57], [64] demonstrated that it produces the most stable performance estimates when comparing to other model validation techniques like k-fold cross-validation.", "part": "1"}], "links": {"documentLink": "/document/7497471", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7497471", "abstract": "Defect prediction models help software quality assurance teams to allocate their limited resources to the most defect-prone modules. Model validation techniques, such as $k$ -fold cross-validation, use historical data to estimate how well a model will perform in the future. However, little is known about how accurate the estimates of model validation techniques tend to be. In this paper, we investigate the bias and variance of model validation techniques in the domain of defect prediction. Analy...", "pdfSize": "2074KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+Empirical+Comparison+of+Model+Validation+Techniques+for+Defect+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "\"The Impact of Automated Parameter Optimization on Defect Prediction Models\" in Transactions on Software Engineering (TSE), Press, 2018.", "title": "The Impact of Automated Parameter Optimization on Defect Prediction Models", "context": [{"sec": "sec4b", "text": " For each type of models, we apply 2 machine learning techniques (i.e, regression and random forest) on each training sample, since they often produce highly accurate predictions [23], [31], [62], [65].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Impact+of+Automated+Parameter+Optimization+on+Defect+Prediction+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "P. Thongtanunam, S. McIntosh, A. E. Hassan, H. Iida, \"Revisiting Code Ownership and its Relationship with Software Quality in the Scope of Modern Code Review\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 1039-1050, 2016.", "title": "Revisiting Code Ownership and its Relationship with Software Quality in the Scope of Modern Code Review", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}, {"sec": "sec4a", "text": "Ownership metrics describe the relationship between the ownership of modules and software quality [8], [49], [66].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884852", "abstract": "Code ownership establishes a chain of responsibility for modules in large software systems. Although prior work uncovers a link between code ownership heuristics and software quality, these heuristics rely solely on the authorship of code changes. In addition to authoring code changes, developers also make important contributions to a module by reviewing code changes. Indeed, recent work shows that reviewers are highly active in modern code review processes, often suggesting alternative solution...", "pdfSize": "503KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Revisiting+Code+Ownership+and+its+Relationship+with+Software+Quality+in+the+Scope+of+Modern+Code+Review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "\"Review Participation in Modern Code Review\", <em>Empirical Software Engineering (EMSE)</em>, vol. 22, no. 2, pp. 768-817, 2017.", "title": "Review Participation in Modern Code Review", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-016-9452-6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Review+Participation+in+Modern+Code+Review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "B. Turhan, T. Menzies, A. B. Bener, J. Di Stefano, \"On the relative value of cross-company and within-company data for defect prediction\", <em>Empirical Software Engineering</em>, vol. 14, no. 5, pp. 540-578, 2009.", "title": "On the relative value of cross-company and within-company data for defect prediction", "context": [{"sec": "sec6c", "text": " However, there are a variety of defect prediction scenarios in the literature (e.g., cross-project defect prediction [13], [68], [76], just-in-time defect prediction [25], heterogenous defect prediction [41]).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-008-9103-7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+relative+value+of+cross-company+and+within-company+data+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "B. Vasilescu, Y. Yu, H. Wang, P. Devanbu, V. Filkov, \"Quality and productivity outcomes relating to continuous integration in github\", <em>Proceedings of the International Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 805-816, 2015.", "title": "Quality and productivity outcomes relating to continuous integration in github", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786850", "abstract": "Software processes comprise many steps; coding is followed by building, integration testing, system testing, deployment, operations, among others. Software process integration and automation have been areas of key concern in software engineering, ever since the pioneering work of Osterweil; market pressures for Agility, and open, decentralized, software development have provided additional pressures for progress in this area. But do these innovations actually help projects? Given the numerous co...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quality+and+productivity+outcomes+relating+to+continuous+integration+in+github&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "C. Vassallo, F. Palomba, A. Bacchelli, H. C. Gall, \"Continuous code quality: Are we (really) doing that?\", <em>Proceedings of the International Conference on Automated Software Engineering (ASE)</em>, pp. 790-795, 2018.", "title": "Continuous code quality: Are we (really) doing that?", "context": [{"sec": "sec1", "text": " For example, prior studies statistically analyze defect datasets to investigate the impact that code attributes [34]\u2013[40], object-oriented design [5], development activities [50], [55], code smells [26], [27], [46], continuous integration practices [69], [70], code review practices [33], [52], [66], [67], and human factors [7], [8], [12], [39], [49] have on software quality.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3238147.3240729", "abstract": "Continuous Integration (CI) is a software engineering practice where developers constantly integrate their changes to a project through an automated build process. The goal of CI is to provide developers with prompt feedback on several quality dimensions after each change. Indeed, previous studies provided empirical evidence on a positive association between properly following CI principles and source code quality. A core principle behind CI is Continuous Code Quality (also known as CCQ, which i...", "pdfSize": "121KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+code+quality%3A+Are+we+%28really%29+doing+that%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}, {"order": "71", "text": "S. Wang, T. Liu, L. Tan, \"Automatically Learning Semantic Features for Defect Prediction\", <em>Proceedings of the International Conference on Software Engineering (ICSE)</em>, pp. 297-308, 2016.", "title": "Automatically Learning Semantic Features for Defect Prediction", "context": [{"sec": "sec1", "text": " For example, prior studies develop defect prediction models that learn historical defect characteristics in order to predict the most defective modules [10], [19], [22], [36], [71], [73].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884804", "abstract": "Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the ...", "pdfSize": "1876KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+Learning+Semantic+Features+for+Defect+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref71"}, {"order": "72", "text": "R. Wu, H. Zhang, S. Kim, S. C. Cheung, \"ReLink: Recovering Links between Bugs and Changes\", <em>Proceedings of the International Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 15-25, 2011.", "title": "ReLink: Recovering Links between Bugs and Changes", "context": [{"sec": "sec1", "text": "However, such the heuristic approach is based on several assumptions [4], [6], [42], [43], [61], [72], which pose common threats to the validity of many studies.", "part": "1"}, {"sec": "sec2c", "text": " To address this challenge, prior studies [42], [72] introduce the textual similarity approaches between issue reports and commit messages to automatically recover the missing links between issue reports to the corresponding code changes.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025120", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ReLink%3A+Recovering+Links+between+Bugs+and+Changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref72"}, {"order": "73", "text": "X. Xia, D. Lo, S. J. Pan, N. Nagappan, X. Wang, \"Hydra: Massively compositional model for cross-project defect prediction\", <em>Transactions on software Engineering (TSE)</em>, vol. 42, no. 10, pp. 977, 2016.", "title": "Hydra: Massively compositional model for cross-project defect prediction", "context": [{"sec": "sec1", "text": " For example, prior studies develop defect prediction models that learn historical defect characteristics in order to predict the most defective modules [10], [19], [22], [36], [71], [73].", "part": "1"}], "links": {"documentLink": "/document/7435328", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7435328", "abstract": "Most software defect prediction approaches are trained and applied on data from the same project. However, often a new project does not have enough training data. Cross-project defect prediction, which uses data from other projects to predict defects in a particular project, provides a new perspective to defect prediction. In this work, we propose a HYbrid moDel Reconstruction Approach (HYDRA) for cross-project defect prediction, which includes two phases: genetic algorithm (GA) phase and ensemb...", "pdfSize": "820KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hydra%3A+Massively+compositional+model+for+cross-project+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref73"}, {"order": "74", "text": "S. Yatish, J. Jiarpakdee, P. Thongtanunam, C. Tantithamtha-Vorn, <em>Replication Package for ICSE2019 Mining Software Defects: Should We Consider Affected Releases?</em>, 2019,  [online]  Available: https://doi.org/10.5281/zenodo.2549359.", "title": "Replication Package for ICSE2019 Mining Software Defects: Should We Consider Affected Releases?", "context": [{"sec": "sec1", "text": "A new collection of highly-curated benchmark defect datasets of 32 releases that span across 9 open-source software systems using the heuristic and realistic approaches [60] and a replication package at Zenodo [74].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Replication+Package+for+ICSE2019+Mining+Software+Defects%3A+Should+We+Consider+Affected+Releases%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref74"}, {"order": "75", "text": "T. Zimmermann, N. Nagappan, \"Predicting subsystem failures using dependency graph complexities\", <em>Proceedings of the International Symposium on Software Reliability Engineering (ISSRE)</em>, pp. 227-236, 2007.", "title": "Predicting subsystem failures using dependency graph complexities", "context": [{"sec": "sec1", "text": " The widely-used heuristic approach to identify post-release defects is based on the extraction of specific keywords and issue IDs in commit logs in the Version Control System (VCS) using regular expression [15], [17], [25], [56], [75] within a specific post-release window period (e.g., 6 months).", "part": "1"}, {"sec": "sec2a", "text": "Post-release defects are defined as modules that are changed to address a defect report within a post-release window period (e.g., 6 months) [15], [17], [25], [56], [75].", "part": "1"}, {"sec": "sec4a", "text": " Similar to prior studies [15], [17], [25], [56], [75], we apply a collection of regular expression patterns on commit logs in VCS to search for specific keywords and issue IDs within the 6-month period after the release of interest to identify post-release defect counts of each module.", "part": "1"}, {"sec": "sec4b", "text": "For defect count models, we use the Mean Absolute Error (MAE) and the Standardized Accuracy (SA), as suggested by prior work [30], [53], [54], [75].", "part": "1"}], "links": {"documentLink": "/document/4402214", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4402214", "abstract": "In any software project, developers need to be aware of existing dependencies and how they affect their system. We investigated the architecture and dependencies of Windows Server 2003 to show how to use the complexity of a subsystem's dependency graph to predict the number of failures at statistically significant levels. Such estimations can help to allocate software quality resources to the parts of a product that need it most, and as early as possible.", "pdfSize": "443KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+subsystem+failures+using+dependency+graph+complexities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref75"}, {"order": "76", "text": "T. Zimmermann, N. Nagappan, H. Gall, E. Giger, B. Murphy, \"Cross-project Defect Prediction\", <em>Proceedings of the joint meeting of the European Software Engineering Conference and the Foundations of Software Engineering (ESEC/FSE)</em>, pp. 91-100, 2009.", "title": "Cross-project Defect Prediction", "context": [{"sec": "sec4b", "text": " Similar to prior studies [3], [76], we use the default probability value of 0.5 as a threshold value to compute the confusion matrix for threshold-dependent measures, i.e., if a module has a predicted probability above 0.5, it is considered defective; otherwise, the module is considered clean.", "part": "1"}, {"sec": "sec4b", "text": " Thus, developers often prioritize their limited resources on the most defective modules [50], [76].", "part": "1"}, {"sec": "sec6c", "text": " However, there are a variety of defect prediction scenarios in the literature (e.g., cross-project defect prediction [13], [68], [76], just-in-time defect prediction [25], heterogenous defect prediction [41]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1595696.1595713", "abstract": "Prediction of software defects works well within projects as long as there is a sufficient amount of data available to train any models. However, this is rarely the case for new software projects and for many companies. So far, only a few have studies focused on transferring prediction models from one project to another. In this paper, we study cross-project defect prediction models on a large scale. For 12 real-world applications, we ran 622 cross-project predictions. Our results indicate that ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cross-project+Defect+Prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref76"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811982", "articleId": "8811982", "startPage": "654", "endPage": "665", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 149}}
{"title": "LEOPARD: Identifying Vulnerable Code for Vulnerability Assessment Through Program Metrics", "authors": [{"name": "Xiaoning Du", "affiliation": "Nanyang Technological University, Singapore", "firstName": "Xiaoning", "lastName": "Du", "id": "37086945232"}, {"name": "Bihuan Chen", "affiliation": "Fudan University, China", "firstName": "Bihuan", "lastName": "Chen", "id": "37600014600"}, {"name": "Yuekang Li", "affiliation": "Nanyang Technological University, Singapore", "firstName": "Yuekang", "lastName": "Li", "id": "37086952696"}, {"name": "Jianmin Guo", "affiliation": "Tsinghua University, China", "firstName": "Jianmin", "lastName": "Guo", "id": "37086950599"}, {"name": "Yaqin Zhou", "affiliation": "Nanyang Technological University, Singapore", "firstName": "Yaqin", "lastName": "Zhou", "id": "37086952671"}, {"name": "Yang Liu", "affiliation": "Nanyang Technological University, Singapore", "firstName": "Yang", "lastName": "Liu", "id": "37086052698"}, {"name": "Yu Jiang", "affiliation": "Tsinghua University, China", "firstName": "Yu", "lastName": "Jiang", "id": "37086490590"}], "abstract": "Identifying potentially vulnerable locations in a code base is critical as a pre-step for effective vulnerability assessment; i.e., it can greatly help security experts put their time and effort to where it is needed most. Metric-based and pattern-based methods have been presented for identifying vulnerable code. The former relies on machine learning and cannot work well due to the severe imbalance between non-vulnerable and vulnerable code or lack of features to characterize vulnerabilities. The latter needs the prior knowledge of known vulnerabilities and can only identify similar but not new types of vulnerabilities. In this paper, we propose and implement a generic, lightweight and extensible framework, LEOPARD, to identify potentially vulnerable functions through program metrics. LEOPARD requires no prior knowledge about known vulnerabilities. It has two steps by combining two sets of systematically derived metrics. First, it uses complexity metrics to group the functions in a target application into a set of bins. Then, it uses vulnerability metrics to rank the functions in each bin and identifies the top ones as potentially vulnerable. Our experimental results on 11 real-world projects have demonstrated that, LEOPARD can cover 74.0% of vulnerable functions by identifying 20% of functions as vulnerable and outperform machine learning-based and static analysis-based techniques. We further propose three applications of LEOPARD for manual code review and fuzzing, through which we discovered 22 new bugs in real applications like PHP, radare2 and FFmpeg, and eight of them are new vulnerabilities.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Measurement", "Complexity theory", "Security", "Computer bugs", "Fuzzing", "Machine learning", "Manuals"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["learning (artificial intelligence)", "program diagnostics", "security of data", "software metrics"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["pattern-based methods", "LEOPARD", "program metrics", "systematically derived metrics", "complexity metrics", "vulnerability metrics", "manual code review", "vulnerability assessment", "metric-based method", "vulnerable code identification", "machine learning-based technique"]}, {"type": "Author Keywords ", "kwd": ["Program Metric, Vulnerability, Fuzzing"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00024", "ref": [{"order": "1", "text": " [online]  Available: https://github.com/cesanta/mjs.", "context": [{"sec": "sec4f", "text": " The three projects are mjs [1] (a Javascript engine for embedded systems), xed [2] (the disassembler used in Intel-Pin) and radare2 [3] (a popular open source reverse engineering framework).", "part": "1"}], "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Pin - a dynamic binary instrumentation tool</em>,  [online]  Available: https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool.", "title": "Pin - a dynamic binary instrumentation tool", "context": [{"sec": "sec4f", "text": " The three projects are mjs [1] (a Javascript engine for embedded systems), xed [2] (the disassembler used in Intel-Pin) and radare2 [3] (a popular open source reverse engineering framework).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pin+-+a+dynamic+binary+instrumentation+tool&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>radare2everse engineering framework</em>,  [online]  Available: https://github.com/radare/radare2.", "title": "radare2everse engineering framework", "context": [{"sec": "sec4f", "text": " The three projects are mjs [1] (a Javascript engine for embedded systems), xed [2] (the disassembler used in Intel-Pin) and radare2 [3] (a popular open source reverse engineering framework).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=radare2everse+engineering+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>American fuzzy lop</em>, 2017,  [online]  Available: http://lcamtuf.coredump.cx/afl/.", "title": "American fuzzy lop", "context": [{"sec": "sec3", "text": " Specifically, greybox fuzzers (e.g., AFL [4] and its variants [13], [14]) have gained the popularity and been proven to be practical for finding vulnerabilities in real-world applications.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=American+fuzzy+lop&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>Flawfinder</em>, 2017,  [online]  Available: https://www.dwheeler.com/flawfinder/.", "title": "Flawfinder", "context": [{"sec": "sec6", "text": " Initially, code scanners (e.g., Flawfinder [5], PScan [8], RATS [9] and ITS4 [64]) were proposed to match vulnerability patterns.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Flawfinder&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Leopard</em>, 2017,  [online]  Available: https://sites.google.com/site/leopardsite2017/.", "title": "Leopard", "context": [{"sec": "sec4", "text": " More details of the implementation and evaluation are available at our website [6].", "part": "1"}, {"sec": "sec4a", "text": " As an example, we display the CVE list, available patches and corresponding patched functions of Libav at our website [6].", "part": "1"}, {"sec": "sec4b", "text": " The result of \\$\\mathtt BIND\\$ is omitted for space limitations but is available on our website [6].", "part": "1"}, {"sec": "sec4b", "text": " Details of the function distribution among bins can be found at our website [6].", "part": "1"}, {"sec": "sec4c", "text": " The legends are only shown in Fig. 4a and omitted in others for clarity; and the result of \\$\\mathtt B I ND\\$ is omitted but available on the website [6].", "part": "1"}, {"sec": "sec4c", "text": " We put the results of ManualUp (which is much worse than Leopard) at our website [6], and only show results of ManualDown in this section.", "part": "1"}, {"sec": "sec4c", "text": " Hence, we omitted the results and put them at our website [6].", "part": "1"}, {"sec": "sec4e", "text": " The detailed results are reported at our website [6].", "part": "1"}, {"sec": "sec4f", "text": " Detailed discussion about the aforementioned case can be found at our website [6].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Leopard&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>National vulnerability database</em>, 2017,  [online]  Available: https://nvd.nist.gov/.", "title": "National vulnerability database", "context": [{"sec": "sec4a", "text": " To obtain the ground truth for evaluating the effectiveness of Leopard, we first manually identified the list of vulnerabilities that were disclosed before July 2018 in the 11 projects from two vulnerability database websites: CVE Details [11] and National Vulnerability Database [7], i.e., we collected all the vulnerabilities reported for the given version of the project from its release date to July 2018.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=National+vulnerability+database&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Pscan</em>, 2017,  [online]  Available: http://deployingradius.com/pscan/.", "title": "Pscan", "context": [{"sec": "sec6", "text": " Initially, code scanners (e.g., Flawfinder [5], PScan [8], RATS [9] and ITS4 [64]) were proposed to match vulnerability patterns.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pscan&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "Rats, 2017,  [online]  Available: https://code.google.com/archive/p/rough-auditing-tool-for-security/.", "title": "Rats", "context": [{"sec": "sec6", "text": " Initially, code scanners (e.g., Flawfinder [5], PScan [8], RATS [9] and ITS4 [64]) were proposed to match vulnerability patterns.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rats&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "<em>Cppcheck</em>, 2018,  [online]  Available: http://cppcheck.sourceforge.net/.", "title": "Cppcheck", "context": [{"sec": "sec4c", "text": " We also applied two popular static software scanner tools to investigate their vulnerability prediction capability on our dataset, including an open source tool, Cppcheck [10], and a commercial tool.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cppcheck&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "<em>Cvedetails</em>, 2018,  [online]  Available: http.//www.cvedctails.com/.", "title": "Cvedetails", "context": [{"sec": "sec2c", "text": " The above mentioned types account for more than 70% of all vulnerabilities [11].", "part": "1"}, {"sec": "sec4a", "text": " To obtain the ground truth for evaluating the effectiveness of Leopard, we first manually identified the list of vulnerabilities that were disclosed before July 2018 in the 11 projects from two vulnerability database websites: CVE Details [11] and National Vulnerability Database [7], i.e., we collected all the vulnerabilities reported for the given version of the project from its release date to July 2018.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cvedetails&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "D. Babi\u0107, L. Martignoni, S. McCamant, D. Song, \"Statically-directed dynamic automated test generation\", <em>ISSTA</em>, pp. 12-22, 2011.", "title": "Statically-directed dynamic automated test generation", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Statically-directed+dynamic+automated+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "M. B\u00f6hme, V.-T. Pham, M.-D. Nguyen, A. Roychoudhury, \"Directed greybox fuzzing\", <em>CCS</em>, pp. 2329-2344, 2017.", "title": "Directed greybox fuzzing", "context": [{"sec": "sec3", "text": " Specifically, greybox fuzzers (e.g., AFL [4] and its variants [13], [14]) have gained the popularity and been proven to be practical for finding vulnerabilities in real-world applications.", "part": "1"}, {"sec": "sec3", "text": " Recently, directed greybox fuzzers (e.g., AFLGo [13] and Hawkeye [20]) are proposed to guide the fuzzing execution towards a predefined vulnerable function (a.k.a. target site) to either reproduce the vulnerability or check whether a patched function is still vulnerable [13].", "part": "1"}, {"sec": "sec3", "text": " But still, directed fuzzing has been shown as an effective technique to reproduce vulnerabilities [13].", "part": "1"}, {"sec": "sec3", "text": " To demonstrate the idea, we utilize a directed fuzzing tool, Hawkeye [20], which is built upon an extensible fuzzing framework FOT [19] and reported to outperform ALFGo [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3133956.3134020", "abstract": "Existing Greybox Fuzzers (GF) cannot be effectively directed, for instance, towards problematic changes or patches, towards critical system calls or dangerous locations, or towards functions in the stack-trace of a reported vulnerability that we wish to reproduce. In this paper, we introduce Directed Greybox Fuzzing (DGF) which generates inputs with the objective of reaching a given set of target program locations efficiently. We develop and evaluate a simulated annealing-based power schedule th...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Directed+greybox+fuzzing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "M. B\u00f6hme, V.-T. Pham, A. Roychoudhury, \"Coverage-based greybox fuzzing as markov chain\", <em>CCS</em>, pp. 1032-1043, 2016.", "title": "Coverage-based greybox fuzzing as markov chain", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}, {"sec": "sec2a", "text": "Leopard is designed to support and facilitate confirmative vulnerability assessments, e.g., to guide security experts during automatic fuzzing [14], [50], [66], [67] or manual auditing by providing potentially vulnerable function list and the corresponding metrics information.", "part": "1"}, {"sec": "sec3", "text": " Specifically, greybox fuzzers (e.g., AFL [4] and its variants [13], [14]) have gained the popularity and been proven to be practical for finding vulnerabilities in real-world applications.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2976749.2978428", "abstract": "Coverage-based Greybox Fuzzing (CGF) is a random testing approach that requires no program analysis. A new test is generated by slightly mutating a seed input. If the test exercises a new and interesting path, it is added to the set of seeds; otherwise, it is discarded. We observe that most tests exercise the same few &#34;high-frequency&#34; paths and develop strategies to explore significantly more paths with the same number of tests by gravitating towards low-frequency paths. We explain the challenge...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coverage-based+greybox+fuzzing+as+markov+chain&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "F. Camilo, A. Meneely, M. Nagappan, \"Do bugs foreshadow vulnerabilities?: A study of the chromium project\", <em>MSR</em>, pp. 269-279, 2015.", "title": "Do bugs foreshadow vulnerabilities?: A study of the chromium project", "context": [{"sec": "sec1", "text": " Moreover, while an empirical connection between vulnerabilities and bugs exist, the connection is considerably weak due to the differences between vulnerabilities and bugs [15].", "part": "1"}], "links": {"documentLink": "/document/7180086", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180086", "abstract": "As developers face ever-increasing pressure to engineer secure software, researchers are building an understanding of security-sensitive bugs (i.e. Vulnerabilities). Research into mining software repositories has greatly increased our understanding of software quality via empirical study of bugs. However, conceptually vulnerabilities are different from bugs: they represent abusive functionality as opposed to wrong or insufficient functionality commonly associated with traditional, non-security b...", "pdfSize": "934KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+bugs+foreshadow+vulnerabilities%3F%3A+A+study+of+the+chromium+project&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "C. Catal, B. Diri, \"A systematic review of software fault prediction studies\", <em>Expert Syst. Appl.</em>, vol. 36, no. 4, pp. 7346-7354, 2009.", "title": "A systematic review of software fault prediction studies", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec6", "text": " Inspired by bug prediction [16], [28], [30], [38], [49], a number of advances have been made in applying machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.eswa.2008.10.027", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+review+of+software+fault+prediction+studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "S. K. Cha, M. Woo, D. Brumley, \"Program-adaptive mutational fuzzing\", <em>SP</em>, pp. 725-741, 2015.", "title": "Program-adaptive mutational fuzzing", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}], "links": {"documentLink": "/document/7163057", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7163057", "abstract": "We present the design of an algorithm to maximize the number of bugs found for black-box mutational fuzzing given a program and a seed input. The major intuition is to leverage white-box symbolic analysis on an execution trace for a given program-seed pair to detect dependencies among the bit positions of an input, and then use this dependency relation to compute a probabilistically optimal mutation ratio for this program-seed pair. Our result is promising: we found an average of 38.6% more bugs...", "pdfSize": "389KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program-adaptive+mutational+fuzzing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "M. Chandramohan, Y. Xue, Z. Xu, Y. Liu, C. Y. Cho, H. B. K. Tan, \"Bingo: Cross-architecture cross-os binary search\", <em>FSE</em>, pp. 678-689, 2016.", "title": "Bingo: Cross-architecture cross-os binary search", "context": [{"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950350", "abstract": "Binary code search has received much attention recently due to its impactful applications, e.g., plagiarism detection, malware detection and software vulnerability auditing. However, developing an effective binary code search tool is challenging due to the gigantic syntax and structural differences in binaries resulted from different compilers, architectures and OSs. In this paper, we propose BINGO \u2014 a scalable and robust binary search engine supporting various architectures and OSs. The key con...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bingo%3A+Cross-architecture+cross-os+binary+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "H. Chen, Y. Li, B. Chen, Y. Xue, Y. Liu, \"Fot: A versatile configurable extensible fuzzing framework\", <em>ESEC/FSE</em>, pp. 867-870, 2018.", "title": "Fot: A versatile, configurable, extensible fuzzing framework", "context": [{"sec": "sec3", "text": " To demonstrate the idea, we utilize a directed fuzzing tool, Hawkeye [20], which is built upon an extensible fuzzing framework FOT [19] and reported to outperform ALFGo [13].", "part": "1"}, {"sec": "sec4f", "text": " We used Leopard to generate function level scores for three real-world open-source projects and utilized the scores to provide guidance to FOT [19].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3264593", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fot%3A+A+versatile%2C+configurable%2C+extensible+fuzzing+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "H. Chen, Y. Xue, Y. Li, B. Chen, X. Xie, X. Wu, Y. Liu, \"Hawkeye: Towards a desired directed grey-box fuzzer\", <em>CCS</em>, pp. 2095-2108, 2018.", "title": "Hawkeye: Towards a desired directed grey-box fuzzer", "context": [{"sec": "sec3", "text": " Recently, directed greybox fuzzers (e.g., AFLGo [13] and Hawkeye [20]) are proposed to guide the fuzzing execution towards a predefined vulnerable function (a.k.a. target site) to either reproduce the vulnerability or check whether a patched function is still vulnerable [13].", "part": "1"}, {"sec": "sec3", "text": " To demonstrate the idea, we utilize a directed fuzzing tool, Hawkeye [20], which is built upon an extensible fuzzing framework FOT [19] and reported to outperform ALFGo [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3243734.3243849", "abstract": "Grey-box fuzzing is a practically effective approach to test real-world programs. However, most existing grey-box fuzzers lack directedness, i.e. the capability of executing towards user-specified target sites in the program. To emphasize existing challenges in directed fuzzing, we propose Hawkeye to feature four desired properties of directed grey-box fuzzers. Owing to a novel static analysis on the program under test and the target sites, Hawkeye precisely collects the information such as the ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hawkeye%3A+Towards+a+desired+directed+grey-box+fuzzer&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "I. Chowdhury, M. Zulkernine, \"Using complexity coupling and cohesion metrics as early indicators of vulnerabilities\", <em>J. Syst. Archit.</em>, vol. 57, no. 3, pp. 294-313, 2011.", "title": "Using complexity, coupling, and cohesion metrics as early indicators of vulnerabilities", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " In particular, researchers started by leveraging complexity metrics [21], [44], [45], [55], [56] to predict vulnerable files.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.sysarc.2010.06.003", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+complexity%2C+coupling%2C+and+cohesion+metrics+as+early+indicators+of+vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "G. Coldwind, <em>How to find vulnerabilities?</em>, 2017,  [online]  Available: http://gynvael.coldwind.pl/?lang=en\u2026id=659.", "title": "How to find vulnerabilities?", "context": [{"sec": "sec3", "text": " Instead of auditing all the functions [22], security experts can focus on only those potentially vulnerable functions that are identified by Leopard.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+find+vulnerabilities%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "J. Dahse, T. Holz, \"Simulation of built-in php features for precise static code analysis\", <em>NDSS</em>, 2014.", "title": "Simulation of built-in php features for precise static code analysis", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2014.23262", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Simulation+of+built-in+php+features+for+precise+static+code+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "D. Evans, D. Larochelle, \"Improving security using extensible lightweight static analysis\", <em>IEEE Softw.</em>, vol. 19, no. 1, pp. 42-51, 2002.", "title": "Improving security using extensible lightweight static analysis", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "links": {"documentLink": "/document/976940", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=976940", "abstract": "Most security attacks exploit instances of well-known classes of implementation flaws. Developers could detect and eliminate many of these flaws before deploying the software, yet these problems persist with disturbing frequency-not because the security community doesn&#39;t sufficiently understand them but because techniques for preventing them have not been integrated into the software development process. This article describes an extensible tool that uses lightweight static analysis to detect co...", "pdfSize": "596KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+security+using+extensible+lightweight+static+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "W. Fu, T. Menzies, \"Revisiting unsupervised learning for defect prediction\", <em>FSE</em>, pp. 72-83, 2017.", "title": "Revisiting unsupervised learning for defect prediction", "context": [{"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106257", "abstract": "Collecting quality data from software projects can be time-consuming and expensive. Hence, some researchers explore &#34;unsupervised&#34; approaches to quality prediction that does not require labelled data. An alternate technique is to use &#34;supervised&#34; approaches that learn models from project data labelled with, say, &#34;defective&#34; or &#34;not-defective&#34;. Most researchers use these supervised models since, it is argued, they can exploit more knowledge of the projects.  At FSE-16, Yang et al. reported startl...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Revisiting+unsupervised+learning+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "M. Gegick, L. Williams, J. Osborne, M. Vouk, \"Prioritizing software security fortification throughcode-level metrics\", <em>QoP</em>, pp. 31-38, 2008.", "title": "Prioritizing software security fortification throughcode-level metrics", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1456362.1456370", "abstract": "Limited resources preclude software engineers from finding and fixing all vulnerabilities in a software system. We create predictive models to identify which components are likely to have the most security risk. Software engineers can use these models to make measurement-based risk management decisions and to prioritize software security fortification efforts, such as redesign and additional inspection and testing. We mined and analyzed data from a large commercial telecommunications software sy...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Prioritizing+software+security+fortification+throughcode-level+metrics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "P. Godefroid, M. Y. Levin, D. A. Molnar, \"Automated whitebox fuzz testing\", <em>NDSS</em>, 2008.", "title": "Automated whitebox fuzz testing", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+whitebox+fuzz+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "T. Gyimothy, R. Ferenc, I. Siket, \"Empirical validation of object-oriented metrics on open source software for fault prediction\", <em>IEEE Trans. Softw. Eng.</em>, vol. 31, no. 10, pp. 897-910, 2005.", "title": "Empirical validation of object-oriented metrics on open source software for fault prediction", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec6", "text": " Inspired by bug prediction [16], [28], [30], [38], [49], a number of advances have been made in applying machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}], "links": {"documentLink": "/document/1542070", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1542070", "abstract": "Open source software systems are becoming increasingly important these days. Many companies are investing in open source projects and lots of them are also using such software in their own work. But, because open source software is often developed with a different management style than the industrial ones, the quality and reliability of the code needs to be studied. Hence, the characteristics of the source code of these projects need to be measured to obtain more information about it. This paper...", "pdfSize": "1628KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Empirical+validation+of+object-oriented+metrics+on+open+source+software+for+fault+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "B. Hackett, M. Das, D. Wang, Z. Yang, \"Modular checking for buffer overflows in the large\", <em>ICSE</em>, pp. 232-241, 2006.", "title": "Modular checking for buffer overflows in the large", "context": [{"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134319", "abstract": "We describe an ongoing project, the deployment of a modular checker to statically find and prevent every buffer overflow in future versions of a Microsoft product. Lightweight annotations specify requirements for safely using each buffer, and functions are checked individually to ensure they obey these requirements and do not overflow. Our focus is on the incremental deployment of this technology: by layering the annotation language, using aggressive inference techniques, and slicing warnings by...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modular+checking+for+buffer+overflows+in+the+large&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "T. Hall, S. Beecham, D. Bowes, D. Gray, S. Counsell, \"A systematic literature review on fault prediction performance in software engineering\", <em>IEEE Trans. Softw. Eng.</em>, vol. 38, no. 6, pp. 1276-1304, 2012.", "title": "A systematic literature review on fault prediction performance in software engineering", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec6", "text": " Inspired by bug prediction [16], [28], [30], [38], [49], a number of advances have been made in applying machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}], "links": {"documentLink": "/document/6035727", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6035727", "abstract": "Background: The accurate prediction of where faults are likely to occur in code can help direct test effort, reduce costs, and improve the quality of software. Objective: We investigate how the context of models, the independent variables used, and the modeling techniques applied influence the performance of fault prediction models. Method: We used a systematic literature review to identify 208 fault prediction studies published from January 2000 to December 2010. We synthesize the quantitative ...", "pdfSize": "6095KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+literature+review+on+fault+prediction+performance+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "A. Hovsepyan, R. Scandariato, W. Joosen, \"Is newer always better?: The case of vulnerability prediction models\", <em>ESEM</em>, pp. 26:1-26:6, 2016.", "title": "Is newer always better?: The case of vulnerability prediction models", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2961111.2962612", "abstract": "Finding security vulnerabilities in the source code as early as possible is becoming more and more essential. In this respect, vulnerability prediction models have the potential to help the security assurance activities by identifying code locations that deserve the most attention. In this paper, we investigate whether prediction models behave like milk (i.e., they turn with time) or wine (i.e., the improve with time) when used to predict future vulnerabilities. Our findings indicate that the re...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+newer+always+better%3F%3A+The+case+of+vulnerability+prediction+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "Q. Huang, X. Xia, D. Lo, \"Supervised vs unsupervised models: A holistic look at effort-aware just-in-time defect prediction\", <em>ICSME</em>, pp. 159-170, 2017.", "title": "Supervised vs unsupervised models: A holistic look at effort-aware just-in-time defect prediction", "context": [{"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"documentLink": "/document/8094418", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8094418", "abstract": "Effort-aware just-in-time (JIT) defect prediction aims at finding more defective software changes with limited code inspection cost. Traditionally, supervised models have been used; however, they require sufficient labelled training data, which is difficult to obtain, especially for new projects. Recently, Yang et al. proposed an unsupervised model (LT) and applied it to projects with rich historical bug data. Interestingly, they reported that, under the same inspection cost (i.e., 20 percent of...", "pdfSize": "253KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supervised+vs+unsupervised+models%3A+A+holistic+look+at+effort-aware+just-in-time+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "N. Jovanovic, C. Kruegel, E. Kirda, \"Pixy: A static analysis tool for detecting web application vulnerabilities (short paper)\", <em>SP</em>, pp. 258-263, 2006.", "title": "Pixy: A static analysis tool for detecting web application vulnerabilities (short paper)", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pixy%3A+A+static+analysis+tool+for+detecting+web+application+vulnerabilities+%28short+paper%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "J. R. Larus, T. Ball, M. Das, R. DeLine, M. Fahndrich, J. Pincus, S. K. Rajamani, R. Venkatapathy, \"Righting software\", <em>IEEE Softw.</em>, vol. 21, no. 3, pp. 92-100, 2004.", "title": "Righting software", "context": [{"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"documentLink": "/document/1293079", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1293079", "abstract": "What tools do we use to develop and debug software? Most of us rely on a full-screen editor to write code, a compiler to translate it, a source-level debugger to correct it, and a source-code control system to archive and share it. These tools originated in the 1970s, when the change from batch to interactive programming stimulated the development of innovative languages, tools, environments, and other utilities we take for granted. Microsoft Research has developed two generations of tools, some...", "pdfSize": "343KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Righting+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "S. Lekies, B. Stock, M. Johns, \"25 million flows later: Large-scale detection of dom-based\", <em>CCS</em>, pp. 1193-1204, 2013.", "title": "25 million flows later: Large-scale detection of dom-based", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516703", "abstract": "In recent years, the Web witnessed a move towards sophis- ticated client-side functionality. This shift caused a signifi- cant increase in complexity of deployed JavaScript code and thus, a proportional growth in potential client-side vulnera- bilities, with DOM-based Cross-site Scripting being a high impact representative of such security issues. In this paper, we present a fully automated system to detect and validate DOM-based XSS vulnerabilities, consisting of a taint-aware JavaScript engine...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=25+million+flows+later%3A+Large-scale+detection+of+dom-based&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "J. Liu, Y. Zhou, Y. Yang, H. Lu, B. Xu, \"Code churn: A neglected metric in effort-aware just-in-time defect prediction\", <em>ESEM</em>, pp. 11-19, 2017.", "title": "Code churn: A neglected metric in effort-aware just-in-time defect prediction", "context": [{"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"documentLink": "/document/8169980", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8169980", "abstract": "Background: An increasing research effort has devoted to just-in-time (JIT) defect prediction. A recent study by Yang et al. at FSE&#39;16 leveraged individual change metrics to build unsupervised JIT defect prediction model. They found that many unsupervised models performed similarly to or better than the state-of-the-art supervised models in effort-aware JIT defect prediction. Goal: In Yang et al.&#39;s study, code churn (i.e. the change size of a code change) was neglected when building unsupervised...", "pdfSize": "464KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+churn%3A+A+neglected+metric+in+effort-aware+just-in-time+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "V. B. Livshits, M. S. Lam, \"Finding security vulnerabilities in java applications with static analysis\", <em>USENIX Security</em>, 2005.", "title": "Finding security vulnerabilities in java applications with static analysis", "context": [{"sec": "sec1", "text": " The patterns are formulated based on the syntax or semantics abstraction of a certain type of vulnerabilities, e.g., missing security checks on security-critical objects [59], [74], security properties [63], code structures [72], and vulnerability specifications [37], [71].", "part": "1"}, {"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+security+vulnerabilities+in+java+applications+with+static+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "R. Malhotra, \"A systematic review or machine learing techniques for software fault prediction\", <em>Appl. Soft Comput.</em>, vol. 27, no. C, pp. 504-518, 2015.", "title": "A systematic review or machine learing techniques for software fault prediction", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec6", "text": " Inspired by bug prediction [16], [28], [30], [38], [49], a number of advances have been made in applying machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.asoc.2014.11.023", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+review+or+machine+learing+techniques+for+software+fault+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "T. J. McCabe, \"A complexity measure\", <em>IEEE Trans. Softw. Eng.</em>, vol. 2, no. 4, pp. 308-320, 1976.", "title": "A complexity measure", "context": [{"sec": "sec2b", "text": " Cyclomatic complexity [39] is a widely-used metric to measure the complexity, but without reflection of the loop structures.", "part": "1"}, {"sec": "sec2b", "text": "Function metric (C1) captures the standard cyclomatic complexity [39] of a function, i.e., the number of linearly independent paths through a function.", "part": "1"}], "links": {"documentLink": "/document/1702388", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1702388", "abstract": "This paper describes a graph-theoretic complexity measure and illustrates how it can be used to manage and control program complexity. The paper first explains how the graph-theory concepts apply and gives an intuitive explanation of the graph concepts in programming terms. The control graphs of several actual Fortran programs are then presented to illustrate the correlation between intuitive complexity and the graph-theoretic complexity. Several properties of the graph-theoretic complexity are ...", "pdfSize": "2407KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+complexity+measure&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "G. McGraw, Software Security: Building Security, Addison-Wesley Professional, 2006.", "title": "Software Security: Building Security", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}], "links": {"documentLink": "/document/4021964", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4021964", "abstract": "Summary form only given. Software security has come a long way in the last few years, but we&#39;ve really only just begun. I will present a detailed approach to getting past theory and putting software security into practice. The three pillars of software security are applied risk management, software security best practices (which I call touchpoints), and knowledge. By describing a manageably small set of touchpoints based around the software artifacts that you already produce, I avoid religious w...", "pdfSize": "61KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+Security%3A+Building+Security&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "I. Medeiros, N. Neves, M. Correia, \"Dekant: A static analysis tool that learns to detect web application vulnerabilities\", <em>ISSTA</em>, pp. 1-11, 2016.", "title": "Dekant: A static analysis tool that learns to detect web application vulnerabilities", "context": [{"sec": "sec6", "text": "Besides, several attempts have been made to automatically infer vulnerability patterns (e.g., [41], [62], [73]).", "part": "1"}, {"sec": "sec6", "text": " While promising, these approaches only support specific types of vulnerabilities, e.g., missing-checking vulnerabilities for [62] and taint-style vulnerabilities for [41], [73].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931041", "abstract": "The state of web security remains troubling as web applications continue to be favorite targets of hackers. Static analysis tools are important mechanisms for programmers to deal with this problem as they search for vulnerabilities automatically in the application source code, allowing programmers to remove them. However, developing these tools requires explicitly coding knowledge about how to discover each kind of vulnerability. This paper presents a new approach in which static analysis tools ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dekant%3A+A+static+analysis+tool+that+learns+to+detect+web+application+vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "G. Meng, Y. Liu, J. Zhang, A. Pokluda, R. Boutaba, \"Collaborative security: A survey and taxonomy\", <em>ACM Comput. Surv.</em>, vol. 48, no. 1, pp. 1:1-1:42, 2015.", "title": "Collaborative security: A survey and taxonomy", "context": [{"sec": "sec1", "text": "Vulnerabilities are one of the key threats to software security [42].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2785733", "abstract": "Security is oftentimes centrally managed. An alternative trend of using collaboration in order to improve security has gained momentum over the past few years. Collaborative security is an abstract concept that applies to a wide variety of systems and has been used to solve security issues inherent in distributed environments. Thus far, collaboration has been used in many domains such as intrusion detection, spam filtering, botnet resistance, and vulnerability detection. In this survey, we focus...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Collaborative+security%3A+A+survey+and+taxonomy&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "P. Morrison, K. Herzig, B. Murphy, L. Williams, \"Challenges with applying vulnerability prediction models\", <em>HotSoS</em>, pp. 4:1-4:9, 2015.", "title": "Challenges with applying vulnerability prediction models", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2746194.2746198", "abstract": "Vulnerability prediction models (VPM) are believed to hold promise for providing software engineers guidance on where to prioritize precious verification resources to search for vulnerabilities. However, while Microsoft product teams have adopted defect prediction models, they have not adopted vulnerability prediction models (VPMs). The goal of this research is to measure whether vulnerability prediction models built using standard recommendations perform well enough to provide actionable result...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Challenges+with+applying+vulnerability+prediction+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "S. Moshtari, A. Sami, \"Evaluating and comparing complexity coupling and a new proposed set of coupling metrics in cross-project vulnerability prediction\", <em>SAC</em>, pp. 1415-1421, 2016.", "title": "Evaluating and comparing complexity, coupling and a new proposed set of coupling metrics in cross-project vulnerability prediction", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec2c", "text": " Existing metric-based techniques [44], [45] rarely employ any vulnerability-oriented metrics, and make no differentiation between complexity metrics and vulnerability metrics.", "part": "1"}, {"sec": "sec6", "text": " In particular, researchers started by leveraging complexity metrics [21], [44], [45], [55], [56] to predict vulnerable files.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2851613.2851777", "abstract": "Software security is an important concern in the world moving towards Information Technology. Detecting software vulnerabilities is a difficult and resource consuming task. Therefore, automatic vulnerability prediction would help development teams to predict vulnerability-prone components and prioritize security inspection efforts. Software source code metrics and data mining techniques have been recently used to predict vulnerability-prone components. Some of previous studies used a set of unit...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+and+comparing+complexity%2C+coupling+and+a+new+proposed+set+of+coupling+metrics+in+cross-project+vulnerability+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "S. Moshtari, A. Sami, M. Azimi, \"Using complexity metrics to improve software security\", <em>Computer Fraud and Security</em>, vol. 2013, no. 5, pp. 8-17, 2013.", "title": "Using complexity metrics to improve software security", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec2c", "text": " Existing metric-based techniques [44], [45] rarely employ any vulnerability-oriented metrics, and make no differentiation between complexity metrics and vulnerability metrics.", "part": "1"}, {"sec": "sec6", "text": " In particular, researchers started by leveraging complexity metrics [21], [44], [45], [55], [56] to predict vulnerable files.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S1361-3723(13)70045-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+complexity+metrics+to+improve+software+security&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "J. Nam, S. Kim, \"Clami: Defect prediction on unlabeled datasets (t)\", <em>ASE</em>, pp. 452-463, 2015.", "title": "Clami: Defect prediction on unlabeled datasets (t)", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec4c", "text": " A recent study [80] on 42 existing cross-project defect prediction models and two state-of-the-art unsupervised defect prediction models [46], [78] has indicated that, simply ranking functions based on source lines of code (SLOC) in an increasing (i.e., ManualUp) or decreasing (i.e., ManualDown) order can achieve comparable or even superior prediction performance compared to most defect prediction models.", "part": "1"}, {"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"documentLink": "/document/7372033", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372033", "abstract": "Defect prediction on new projects or projects with limited historical data is an interesting problem in software engineering. This is largely because it is difficult to collect defect information to label a dataset for training a prediction model. Cross-project defect prediction (CPDP) has tried to address this problem by reusing prediction models built by other projects that have enough historical data. However, CPDP does not always build a strong prediction model because of the different distr...", "pdfSize": "1127KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Clami%3A+Defect+prediction+on+unlabeled+datasets+%28t%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "S. Neuhaus, T. Zimmermann, C. Holler, A. Zeller, \"Predicting vulnerable software components\", <em>CCS</em>, pp. 529-540, 2007.", "title": "Predicting vulnerable software components", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+vulnerable+software+components&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "V. H. Nguyen, L. M. S. Tran, \"Predicting vulnerable software components with dependency graphs\", <em>MetriSec</em>, pp. 3:1-3:8, 2010.", "title": "Predicting vulnerable software components with dependency graphs", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1853919.1853923", "abstract": "Security metrics and vulnerability prediction for software have gained a lot of interests from the community. Many software security metrics have been proposed e.g., complexity metrics, cohesion and coupling metrics. In this paper, we propose a novel code metric based on dependency graphs to predict vulnerable components. To validate the efficiency of the proposed metric, we conduct a prediction model which targets the JavaScript Engine of Firefox. In this experiment, our prediction model has ob...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+vulnerable+software+components+with+dependency+graphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "D. Radjenovic, M. Hericko, R. Torkar, A. Zivkovic, \"Software fault prediction metrics: A systematic literature review\", <em>Information and Software Technology</em>, vol. 55, no. 8, pp. 1397-1418, 2013.", "title": "Software fault prediction metrics: A systematic literature review", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec6", "text": " Inspired by bug prediction [16], [28], [30], [38], [49], a number of advances have been made in applying machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2013.02.009", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+fault+prediction+metrics%3A+A+systematic+literature+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "S. Rawat, V. Jain, A. Kumar, L. Cojocar, C. Giuffrida, H. Bos, \"Vuzzer: Application-aware evolutionary fuzzing\", <em>NDSS</em>, 2017.", "title": "Vuzzer: Application-aware evolutionary fuzzing", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}, {"sec": "sec2a", "text": "Leopard is designed to support and facilitate confirmative vulnerability assessments, e.g., to guide security experts during automatic fuzzing [14], [50], [66], [67] or manual auditing by providing potentially vulnerable function list and the corresponding metrics information.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2017.23404", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Vuzzer%3A+Application-aware+evolutionary+fuzzing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "P. Saxena, S. Hanna, P. Poosankam, D. Song, \"Flax: Systematic discovery of client-side validation vulnerabilities in rich web applications\", <em>NDSS</em>, 2010.", "title": "Flax: Systematic discovery of client-side validation vulnerabilities in rich web applications", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Flax%3A+Systematic+discovery+of+client-side+validation+vulnerabilities+in+rich+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "R. Scandariato, J. Walden, A. Hovsepyan, W. Joosen, \"Predicting vulnerable software components via text mining\", <em>IEEE Trans. Softw. Eng.</em>, vol. 40, no. 10, pp. 993-1006, 2014.", "title": "Predicting vulnerable software components via text mining", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"documentLink": "/document/6860243", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6860243", "abstract": "This paper presents an approach based on machine learning to predict which components of a software application contain security vulnerabilities. The approach is based on text mining the source code of the components. Namely, each component is characterized as a series of terms contained in its source code, with the associated frequencies. These features are used to forecast whether each component is likely to contain vulnerabilities. In an exploratory validation with 20 Android applications, we...", "pdfSize": "881KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+vulnerable+software+components+via+text+mining&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "U. Shankar, K. Talwar, J. S. Foster, D. Wagner, \"Detecting format string vulnerabilities with type qualifiers\", <em>USENIX Security</em>, 2001.", "title": "Detecting format string vulnerabilities with type qualifiers", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+format+string+vulnerabilities+with+type+qualifiers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "Y. Shin, A. Meneely, L. Williams, J. A. Osborne, \"Evaluating complexity code churn and developer activity metrics as indicators of software vulnerabilities\", <em>IEEE Trans. Softw. Eng.</em>, vol. 37, no. 6, pp. 772-787, 2011.", "title": "Evaluating complexity, code churn, and developer activity metrics as indicators of software vulnerabilities", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"documentLink": "/document/5560680", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5560680", "abstract": "Security inspection and testing require experts in security who think like an attacker. Security experts need to know code locations on which to focus their testing and inspection efforts. Since vulnerabilities are rare occurrences, locating vulnerable code locations can be a challenging task. We investigated whether software metrics obtained from source code and development history are discriminative and predictive of vulnerable code locations. If so, security experts can use this prediction to...", "pdfSize": "2307KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+complexity%2C+code+churn%2C+and+developer+activity+metrics+as+indicators+of+software+vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "Y. Shin, L. Williams, \"An empirical model to predict security vulnerabilities using code complexity metrics\", <em>ESEM</em>, pp. 315-317, 2008.", "title": "An empirical model to predict security vulnerabilities using code complexity metrics", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " In particular, researchers started by leveraging complexity metrics [21], [44], [45], [55], [56] to predict vulnerable files.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1414004.1414065", "abstract": "Complexity is often hypothesized to be the enemy of software security. If this hypothesis is true, complexity metrics may be used to predict the locale of security problems and can be used to prioritize inspection and testing efforts. We performed statistical analysis on nine complexity metrics from the JavaScript Engine in the Mozilla application framework to find differences in code metrics between vulnerable and nonvulnerable code and to predict vulnerabilities. Our initial results show that ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+model+to+predict+security+vulnerabilities+using+code+complexity+metrics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "Y. Shin, L. Williams, \"Is complexity really the enemy of software security?\", <em>QoP</em>, pp. 47-50, 2008.", "title": "Is complexity really the enemy of software security?", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " In particular, researchers started by leveraging complexity metrics [21], [44], [45], [55], [56] to predict vulnerable files.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1456362.1456372", "abstract": "Software complexity is often hypothesized to be the enemy of software security. We performed statistical analysis on nine code complexity metrics from the JavaScript Engine in the Mozilla application framework to investigate if this hypothesis is true. Our initial results show that the nine complexity measures have weak correlation (\u03c1=0.30 at best) with security problems for Mozilla JavaScript Engine. The study should be replicated on more products with design and code-level metrics. It may be n...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+complexity+really+the+enemy+of+software+security%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "Y. Shin, L. Williams, \"An initial study on the use of execution complexity metrics as indicators of software vulnerabilities\", <em>SESS</em>, pp. 1-7, 2011.", "title": "An initial study on the use of execution complexity metrics as indicators of software vulnerabilities", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1988630.1988632", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+initial+study+on+the+use+of+execution+complexity+metrics+as+indicators+of+software+vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "Y. Shin, L. Williams, \"Can traditional fault prediction models be used for vulnerability prediction?\u2019\", <em>Empirical Software Engineering</em>, vol. 18, no. 1, pp. 25-59, 2013.", "title": "Can traditional fault prediction models be used for vulnerability prediction?\u2019", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-011-9190-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Can+traditional+fault+prediction+models+be+used+for+vulnerability+prediction%3F%E2%80%99&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "S. Son, K. S. McKinley, V. Shmatikov, \"Rolecast: Finding missing security checks when you do not know what checks are\", <em>OOPSLA</em>, pp. 1069-1084, 2011.", "title": "Rolecast: Finding missing security checks when you do not know what checks are", "context": [{"sec": "sec1", "text": " The patterns are formulated based on the syntax or semantics abstraction of a certain type of vulnerabilities, e.g., missing security checks on security-critical objects [59], [74], security properties [63], code structures [72], and vulnerability specifications [37], [71].", "part": "1"}, {"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2048066.2048146", "abstract": "Web applications written in languages such as PHP and JSP are notoriously vulnerable to accidentally omitted authorization checks and other security bugs. Existing techniques that find missing security checks in library and system code assume that (1) security checks can be recognized syntactically and (2) the same pattern of checks applies universally to all programs. These assumptions do not hold for Web applications. Each Web application uses different variables and logic to check the user&#39;s ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rolecast%3A+Finding+missing+security+checks+when+you+do+not+know+what+checks+are&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "N. Stephens, J. Grosen, C. Salls, A. Dutcher, R. Wang, J. Corbetta, Y. Shoshitaishvili, C. Kruegel, G. Vigna, \"Driller: Augmenting fuzzing through selective symbolic execution\", <em>NDSS</em>, 2016.", "title": "Driller: Augmenting fuzzing through selective symbolic execution", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Driller%3A+Augmenting+fuzzing+through+selective+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "L. Szekeres, M. Payer, T. Wei, D. Song, \"Sok: Eternal war in memory\", <em>SP</em>, pp. 48-62, 2013.", "title": "Sok: Eternal war in memory", "context": [{"sec": "sec2c", "text": " Most critical types of vulnerabilities in C/C++ programs are directly or indirectly caused by memory management errors [61] and/or missing checks on some sensitive variables [74] (e.g., pointers).", "part": "1"}], "links": {"documentLink": "/document/6547101", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6547101", "abstract": "Memory corruption bugs in software written in low-level languages like C or C++ are one of the oldest problems in computer security. The lack of safety in these languages allows attackers to alter the program&#39;s behavior or take full control over it by hijacking its control flow. This problem has existed for more than 30 years and a vast number of potential solutions have been proposed, yet memory corruption attacks continue to pose a serious threat. Real world exploits show that all currently de...", "pdfSize": "338KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sok%3A+Eternal+war+in+memory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "L. Tan, X. Zhang, X. Ma, W. Xiong, Y. Zhou, \"Autoises: Automatically inferring security specifications and detecting violations\", <em>USENIX Security</em>, pp. 379-394, 2008.", "title": "Autoises: Automatically inferring security specifications and detecting violations", "context": [{"sec": "sec6", "text": "Besides, several attempts have been made to automatically infer vulnerability patterns (e.g., [41], [62], [73]).", "part": "1"}, {"sec": "sec6", "text": " While promising, these approaches only support specific types of vulnerabilities, e.g., missing-checking vulnerabilities for [62] and taint-style vulnerabilities for [41], [73].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Autoises%3A+Automatically+inferring+security+specifications+and+detecting+violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "J. Vanegue, S. K. Lahiri, \"Towards practical reactive security audit using extended static checkers\", <em>SP</em>, pp. 33-47, 2013.", "title": "Towards practical reactive security audit using extended static checkers", "context": [{"sec": "sec1", "text": " The patterns are formulated based on the syntax or semantics abstraction of a certain type of vulnerabilities, e.g., missing security checks on security-critical objects [59], [74], security properties [63], code structures [72], and vulnerability specifications [37], [71].", "part": "1"}, {"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"documentLink": "/document/6547100", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6547100", "abstract": "This paper describes our experience of performing reactive security audit of known security vulnerabilities in core operating system and browser COM components, using an extended static checker HAVOCLITE. We describe the extensions made to the tool to be applicable on such large C++ components, along with our experience of using an extended static checker in the large. We argue that the use of such checkers as a configurable static analysis in the hands of security auditors can be an effective t...", "pdfSize": "263KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+practical+reactive+security+audit+using+extended+static+checkers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "J. Viega, J. T. Bloch, Y. Kohno, G. McGraw, \"Its 4: A static vulnerability scanner for c and c++ code\", <em>ACSAC</em>, pp. 257-267, 2000.", "title": "Its 4: A static vulnerability scanner for c and c++ code", "context": [{"sec": "sec6", "text": " Initially, code scanners (e.g., Flawfinder [5], PScan [8], RATS [9] and ITS4 [64]) were proposed to match vulnerability patterns.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Its+4%3A+A+static+vulnerability+scanner+for+c+and+c%2B%2B+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "J. Walden, J. Stuckman, R. Scandariato, \"Predicting vulnerable components: Software metrics vs text mining\", <em>ISSRE</em>, pp. 23-33, 2014.", "title": "Predicting vulnerable components: Software metrics vs text mining", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"documentLink": "/document/6982351", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6982351", "abstract": "Building secure software is difficult, time-consuming, and expensive. Prediction models that identify vulnerability prone software components can be used to focus security efforts, thus helping to reduce the time and effort required to secure software. Several kinds of vulnerability prediction models have been proposed over the course of the past decade. However, these models were evaluated with differing methodologies and datasets, making it difficult to determine the relative strengths and wea...", "pdfSize": "211KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+vulnerable+components%3A+Software+metrics+vs+text+mining&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "T. Wang, T. Wei, G. Gu, W. Zou, \"Taintscope: A checksum-aware directed fuzzing tool for automatic software vulnerability detection\", <em>SP</em>, pp. 497-512, 2010.", "title": "Taintscope: A checksum-aware directed fuzzing tool for automatic software vulnerability detection", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}, {"sec": "sec2a", "text": "Leopard is designed to support and facilitate confirmative vulnerability assessments, e.g., to guide security experts during automatic fuzzing [14], [50], [66], [67] or manual auditing by providing potentially vulnerable function list and the corresponding metrics information.", "part": "1"}], "links": {"documentLink": "/document/5504701", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5504701", "abstract": "Fuzz testing has proven successful in finding security vulnerabilities in large programs. However, traditional fuzz testing tools have a well-known common drawback: they are ineffective if most generated malformed inputs are rejected in the early stage of program running, especially when target programs employ checksum mechanisms to verify the integrity of inputs. In this paper, we present TaintScope, an automatic fuzzing system using dynamic taint analysis and symbolic execution techniques, to ...", "pdfSize": "351KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Taintscope%3A+A+checksum-aware+directed+fuzzing+tool+for+automatic+software+vulnerability+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "M. Woo, S. K. Cha, S. Gottlieb, D. Brumley, \"Scheduling black-box mutational fuzzing\", <em>CCS</em>, pp. 511-522, 2013.", "title": "Scheduling black-box mutational fuzzing", "context": [{"sec": "sec1", "text": " Security experts usually leverage guided fuzzing (e.g., [14], [50], [66], [67]), symbolic execution (e.g., [12], [17], [27], [60]) or manual auditing to hunt vulnerabilities.", "part": "1"}, {"sec": "sec2a", "text": "Leopard is designed to support and facilitate confirmative vulnerability assessments, e.g., to guide security experts during automatic fuzzing [14], [50], [66], [67] or manual auditing by providing potentially vulnerable function list and the corresponding metrics information.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516736", "abstract": "Black-box mutational fuzzing is a simple yet effective technique to find bugs in software. Given a set of program-seed pairs, we ask how to schedule the fuzzings of these pairs in order to maximize the number of unique bugs found at any point in time. We develop an analytic framework using a mathematical model of black-box mutational fuzzing and use it to evaluate 26 existing and new randomized online scheduling algorithms. Our experiments show that one of our new scheduling algorithms outperfor...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scheduling+black-box+mutational+fuzzing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "X. Xie, B. Chen, Y. Liu, W. Le, X. Li, \"Proteus: Computing disjunctive loop summary via path dependency analysis\", <em>FSE</em>, pp. 61-72, 2016.", "title": "Proteus: Computing disjunctive loop summary via path dependency analysis", "context": [{"sec": "sec2b", "text": " Loops are challenging in program analysis [68] and hinder vulnerability analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950340", "abstract": "Loops are challenging structures for program analysis, especially when loops contain multiple paths with complex interleaving executions among these paths. In this paper, we first propose a classification of multi-path loops to understand the complexity of the loop execution, which is based on the variable updates on the loop conditions and the execution order of the loop paths. Secondly, we propose a loop analysis framework, named Proteus, which takes a loop program and a set of variables of in...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Proteus%3A+Computing+disjunctive+loop+summary+via+path+dependency+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "Y. Xie, A. Aiken, \"Static detection of security vulnerabilities in scripting languages\", <em>USENIX Security</em>, 2006.", "title": "Static detection of security vulnerabilities in scripting languages", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+detection+of+security+vulnerabilities+in+scripting+languages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "Z. Xu, B. Chen, M. Chandramohan, Y. Liu, F. Song, \"Spain: Security patch analysis for binaries - towards understanding the pain and pills\", <em>ICSE</em>, 2017.", "title": "Spain: Security patch analysis for binaries - towards understanding the pain and pills", "context": [{"sec": "sec4c", "text": " Furthermore, some vulnerabilities are previously patched in history, secretly patched [70] or currently unexposed, and it is impossible to confirm whether they are indeed false positives.", "part": "1"}], "links": {"documentLink": "/document/7985685", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985685", "abstract": "Software vulnerability is one of the major threats to software security. Once discovered, vulnerabilities are often fixed by applying security patches. In that sense, security patches carry valuable information about vulnerabilities, which could be used to discover, understand and fix (similar) vulnerabilities. However, most existing patch analysis approaches work at the source code level, while binary-level patch analysis often heavily relies on a lot of human efforts and expertise. Even worse,...", "pdfSize": "268KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Spain%3A+Security+patch+analysis+for+binaries+-+towards+understanding+the+pain+and+pills&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}, {"order": "71", "text": "F. Yamaguchi, N. Golde, D. Arp, K. Rieck, \"Modeling and discovering vulnerabilities with code property graphs\", <em>SP</em>, pp. 590-604, 2014.", "title": "Modeling and discovering vulnerabilities with code property graphs", "context": [{"sec": "sec1", "text": " The patterns are formulated based on the syntax or semantics abstraction of a certain type of vulnerabilities, e.g., missing security checks on security-critical objects [59], [74], security properties [63], code structures [72], and vulnerability specifications [37], [71].", "part": "1"}, {"sec": "sec4", "text": " Specifically, we used Joern [71] to extract the values of complexity and vulnerability metrics, given the source code of an application.", "part": "1"}, {"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"documentLink": "/document/6956589", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6956589", "abstract": "The vast majority of security breaches encountered today are a direct result of insecure code. Consequently, the protection of computer systems critically depends on the rigorous identification of vulnerabilities in software, a tedious and error-prone process requiring significant expertise. Unfortunately, a single flaw suffices to undermine the security of a system and thus the sheer amount of code to audit plays into the attacker&#39;s cards. In this paper, we present a method to effectively mine ...", "pdfSize": "310KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+and+discovering+vulnerabilities+with+code+property+graphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref71"}, {"order": "72", "text": "F. Yamaguchi, M. Lottmann, K. Rieck, \"Generalized vulnerability extrapolation using abstract syntax trees\", <em>ACSAC</em>, pp. 359-368, 2012.", "title": "Generalized vulnerability extrapolation using abstract syntax trees", "context": [{"sec": "sec1", "text": " The patterns are formulated based on the syntax or semantics abstraction of a certain type of vulnerabilities, e.g., missing security checks on security-critical objects [59], [74], security properties [63], code structures [72], and vulnerability specifications [37], [71].", "part": "1"}, {"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2420950.2421003", "abstract": "The discovery of vulnerabilities in source code is a key for securing computer systems. While specific types of security flaws can be identified automatically, in the general case the process of finding vulnerabilities cannot be automated and vulnerabilities are mainly discovered by manual analysis. In this paper, we propose a method for assisting a security analyst during auditing of source code. Our method proceeds by extracting abstract syntax trees from the code and determining structural pa...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generalized+vulnerability+extrapolation+using+abstract+syntax+trees&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref72"}, {"order": "73", "text": "F. Yamaguchi, A. Maier, H. Gascon, K. Rieck, \"Automatic inference of search patterns for taint-style vulnerabilities\", <em>SP</em>, pp. 797-812, 2015.", "title": "Automatic inference of search patterns for taint-style vulnerabilities", "context": [{"sec": "sec6", "text": "Besides, several attempts have been made to automatically infer vulnerability patterns (e.g., [41], [62], [73]).", "part": "1"}, {"sec": "sec6", "text": " While promising, these approaches only support specific types of vulnerabilities, e.g., missing-checking vulnerabilities for [62] and taint-style vulnerabilities for [41], [73].", "part": "1"}], "links": {"documentLink": "/document/7163061", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7163061", "abstract": "Taint-style vulnerabilities are a persistent problem in software development, as the recently discovered &#34;Heart bleed&#34; vulnerability strikingly illustrates. In this class of vulnerabilities, attacker-controlled data is passed unsanitized from an input source to a sensitive sink. While simple instances of this vulnerability class can be detected automatically, more subtle defects involving data flow across several functions or project-specific APIs are mainly discovered by manual auditing. Differ...", "pdfSize": "326KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+inference+of+search+patterns+for+taint-style+vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref73"}, {"order": "74", "text": "F. Yamaguchi, C. Wressnegger, H. Gascon, K. Rieck, \"Chucky Exposing missing checks in source code for vulnerability discovery\", <em>CCS</em>, pp. 499-510, 2013.", "title": "Chucky Exposing missing checks in source code for vulnerability discovery", "context": [{"sec": "sec1", "text": " The patterns are formulated based on the syntax or semantics abstraction of a certain type of vulnerabilities, e.g., missing security checks on security-critical objects [59], [74], security properties [63], code structures [72], and vulnerability specifications [37], [71].", "part": "1"}, {"sec": "sec2c", "text": " Most critical types of vulnerabilities in C/C++ programs are directly or indirectly caused by memory management errors [61] and/or missing checks on some sensitive variables [74] (e.g., pointers).", "part": "1"}, {"sec": "sec6", "text": "Since then, security researchers have started to leverage more advanced static analysis techniques for pattern-based vulnerability identification (e.g., [18], [29], [34], [37], [59], [63], [71], [72], [74]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Chucky+Exposing+missing+checks+in+source+code+for+vulnerability+discovery&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref74"}, {"order": "75", "text": "M. Yan, Y. Fang, D. Lo, X. Xia, X. Zhang, \"File-level defect prediction: Unsupervised vs. supervised models\", <em>ESEM</em>, pp. 344-353, 2017.", "title": "File-level defect prediction: Unsupervised vs. supervised models", "context": [{"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"documentLink": "/document/8170121", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8170121", "abstract": "Background: Software defect models can help software quality assurance teams to allocate testing or code review resources. A variety of techniques have been used to build defect prediction models, including supervised and unsupervised methods. Recently, Yang et al. [1] surprisingly find that unsupervised models can perform statistically significantly better than supervised models in effort-aware change-level defect prediction. However, little is known about relative performance of unsupervised a...", "pdfSize": "1017KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=File-level+defect+prediction%3A+Unsupervised+vs.+supervised+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref75"}, {"order": "76", "text": "M. Yan, X. Zhang, C. Liu, L. Xu, M. Yang, D. Yang, \"Automated change-prone class prediction on unlabeled dataset using unsupervised method\", <em>Information and Software Technology</em>, vol. 92, pp. 1-16, 2017.", "title": "Automated change-prone class prediction on unlabeled dataset using unsupervised method", "context": [{"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2017.07.003", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+change-prone+class+prediction+on+unlabeled+dataset+using+unsupervised+method&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref76"}, {"order": "77", "text": "Y. Yang, Y. Zhou, J. Liu, Y. Zhao, H. Lu, L. Xu, B. Xu, H. Leung, \"Effort-aware just-in-time defect prediction: simple unsupervised models could be better than supervised models\", <em>FSE</em>, pp. 157-168, 2016.", "title": "Effort-aware just-in-time defect prediction: simple unsupervised models could be better than supervised models", "context": [{"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950353", "abstract": "Unsupervised models do not require the defect data to build the prediction models and hence incur a low building cost and gain a wide application range. Consequently, it would be more desirable for practitioners to apply unsupervised models in effort-aware just-in-time (JIT) defect prediction if they can predict defect-inducing changes well. However, little is currently known on their prediction effectiveness in this context. We aim to investigate the predictive power of simple unsupervised mode...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effort-aware+just-in-time+defect+prediction%3A+simple+unsupervised+models+could+be+better+than+supervised+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref77"}, {"order": "78", "text": "F. Zhang, Q. Zheng, Y. Zou, A. E. Hassan, \"Cross-project defect prediction using a connectivity-based unsupervised classifier\", <em>ICSE</em>, pp. 309-320, 2016.", "title": "Cross-project defect prediction using a connectivity-based unsupervised classifier", "context": [{"sec": "sec1", "text": " Metric-based techniques, inspired by bug prediction [16], [28], [30], [38], [46], [49], [78], leverage supervised or unsupervised machine learning to predict vulnerable code mostly at the granularity level of a source file.", "part": "1"}, {"sec": "sec4c", "text": " A recent study [80] on 42 existing cross-project defect prediction models and two state-of-the-art unsupervised defect prediction models [46], [78] has indicated that, simply ranking functions based on source lines of code (SLOC) in an increasing (i.e., ManualUp) or decreasing (i.e., ManualDown) order can achieve comparable or even superior prediction performance compared to most defect prediction models.", "part": "1"}, {"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884839", "abstract": "Defect prediction on projects with limited historical data has attracted great interest from both researchers and practitioners. Cross-project defect prediction has been the main area of progress by reusing classifiers from other projects. However, existing approaches require some degree of homogeneity (e.g., a similar distribution of metric values) between the training projects and the target project. Satisfying the homogeneity requirement often requires significant effort (currently a very act...", "pdfSize": "308KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cross-project+defect+prediction+using+a+connectivity-based+unsupervised+classifier&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref78"}, {"order": "79", "text": "Y. Zhang, D. Lo, X. Xia, B. Xu, J. Sun, S. Li, \"Combining software metrics and text features for vulnerable file prediction\", <em>ICECCS</em>, pp. 40-49, 2015.", "title": "Combining software metrics and text features for vulnerable file prediction", "context": [{"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"documentLink": "/document/7384228", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7384228", "abstract": "In recent years, to help developers reduce time and effort required to build highly secure software, a number of prediction models which are built on different kinds of features have been proposed to identify vulnerable source code files. In this paper, we propose a novel approach VULPREDICTOR to predict vulnerable files, it analyzes software metrics and text mining together to build a composite prediction model. VULPREDICTOR first builds 6 underlying classifiers on a training set of vulnerable ...", "pdfSize": "449KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combining+software+metrics+and+text+features+for+vulnerable+file+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref79"}, {"order": "80", "text": "Y. Zhou, Y. Yang, H. Lu, L. Chen, Y. Li, Y. Zhao, J. Qian, B. Xu, \"How far we have progressed in the journey? an examination of cross-project defect prediction\", <em>ACM Trans. on Softw. Eng. and Meth.</em>, vol. 27, no. 1, pp. 1, 2018.", "title": "How far we have progressed in the journey? an examination of cross-project defect prediction", "context": [{"sec": "sec4c", "text": " A recent study [80] on 42 existing cross-project defect prediction models and two state-of-the-art unsupervised defect prediction models [46], [78] has indicated that, simply ranking functions based on source lines of code (SLOC) in an increasing (i.e., ManualUp) or decreasing (i.e., ManualDown) order can achieve comparable or even superior prediction performance compared to most defect prediction models.", "part": "1"}, {"sec": "sec6", "text": " Then, advances have been made to use unsupervised machine learning to predict bugs [25], [32], [36], [46], [75], [76], [77], [78], [80] using the similar set of complexity metrics.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183339", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+far+we+have+progressed+in+the+journey%3F+an+examination+of+cross-project+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref80"}, {"order": "81", "text": "T. Zimmermann, N. Nagappan, L. Williams, \"Searching for a needle in a haystack: Predicting security vulnerabilities for windows vista\", <em>ICST</em>, pp. 421-428, 2010.", "title": "Searching for a needle in a haystack: Predicting security vulnerabilities for windows vista", "context": [{"sec": "sec1", "text": " As only a few vulnerabilities are scattered across a large code base, vulnerability hunting is a very challenging task that requires intensive knowledge and is comparable to finding \u201ca needle in a haystack\u201d [81].", "part": "1"}, {"sec": "sec1", "text": " Following security experts' belief that complexity is the enemy of software security [40], they use complexity metrics [21], [44], [45], [55], [56] as features, or combine them with code churn metrics [26], [54], [58], token frequency metrics [31], [52], [65], [79], dependency metrics [43], [47], [48], [81], developer activity metrics [54], [58] and execution complexity metrics [57].", "part": "1"}, {"sec": "sec6", "text": " Then, they attempted to combine complexity metrics with more metrics such as code churn metrics and token frequency metrics [26], [31], [43], [47], [48], [52], [54], [54], [57], [58], [58], [65], [79], [81].", "part": "1"}], "links": {"documentLink": "/document/5477059", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5477059", "abstract": "Many factors are believed to increase the vulnerability of software system; for example, the more widely deployed or popular is a software system the more likely it is to be attacked. Early identification of defects has been a widely investigated topic in software engineering research. Early identification of software vulnerabilities can help mitigate these attacks to a large degree by focusing better security verification efforts in these components. Predicting vulnerabilities is complicated by...", "pdfSize": "321KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Searching+for+a+needle+in+a+haystack%3A+Predicting+security+vulnerabilities+for+windows+vista&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref81"}, {"order": "82", "text": "M. Zitser, R. Lippmann, T. Leek, \"Testing static analysis tools using exploitable buffer overflows from open source code\", <em>FSE</em>, pp. 97-106, 2004.", "title": "Testing static analysis tools using exploitable buffer overflows from open source code", "context": [{"sec": "sec6", "text": " Researchers have attempted to detect specific types of vulnerabilities via static analysis; e.g., buffer overflows [24], [82], format string vulnerabilities [24], [53], SQL injections [23], [33], [69], cross-site scripting [23], [33], [35] and client-side validation vulnerabilities [51].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1029894.1029911", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+static+analysis+tools+using+exploitable+buffer+overflows+from+open+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref82"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812029", "articleId": "8812029", "startPage": "60", "endPage": "71", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 152}}
{"title": "On Learning Meaningful Code Changes Via Neural Machine Translation", "authors": [{"name": "Michele Tufano", "affiliation": "The College of William and Mary", "firstName": "Michele", "lastName": "Tufano", "id": "37085345503"}, {"name": "Jevgenija Pantiuchina", "affiliation": "Universit\u00e0 della Svizzera italiana (USI)", "firstName": "Jevgenija", "lastName": "Pantiuchina", "id": "37086522872"}, {"name": "Cody Watson", "affiliation": "The College of William and Mary", "firstName": "Cody", "lastName": "Watson", "id": "37086585350"}, {"name": "Gabriele Bavota", "affiliation": "Universit\u00e0 della Svizzera italiana (USI)", "firstName": "Gabriele", "lastName": "Bavota", "id": "37598376400"}, {"name": "Denys Poshyvanyk", "affiliation": "The College of William and Mary", "firstName": "Denys", "lastName": "Poshyvanyk", "id": "37295294800"}], "abstract": "Recent years have seen the rise of Deep Learning (DL) techniques applied to source code. Researchers have exploited DL to automate several development and maintenance tasks, such as writing commit messages, generating comments and detecting vulnerabilities among others. One of the long lasting dreams of applying DL to source code is the possibility to automate non-trivial coding activities. While some steps in this direction have been taken (e.g., learning how to fix bugs), there is still a glaring lack of empirical evidence on the types of code changes that can be learned and automatically applied by DL. Our goal is to make this first important step by quantitatively and qualitatively investigating the ability of a Neural Machine Translation (NMT) model to learn how to automatically apply code changes implemented by developers during pull requests. We train and experiment with the NMT model on a set of 236k pairs of code components before and after the implementation of the changes provided in the pull requests. We show that, when applied in a narrow enough context (i.e., small/medium-sized pairs of methods before/after the pull request changes), NMT can automatically replicate the changes implemented by developers during pull requests in up to 36% of the cases. Moreover, our qualitative analysis shows that the model is capable of learning and replicating a wide variety of meaningful code changes, especially refactorings and bug-fixing activities. Our results pave the way for novel research in the area of DL on code, such as the automatic learning and applications of refactoring.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Vocabulary", "Crawlers", "Computer bugs", "Java", "Data mining", "Software engineering", "Task analysis"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["language translation", "learning (artificial intelligence)", "program debugging", "program testing", "public domain software", "software maintenance", "statistical analysis"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["pull requests", "pull request changes", "bug-fixing activities", "source code", "maintenance tasks", "nontrivial coding activities", "NMT model", "code components", "code changes", "vulnerabilities detection", "neural machine translation model", "qualitative analysis"]}, {"type": "Author Keywords ", "kwd": ["Neural-Machine Translation", "Empirical Study"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00021", "ref": [{"order": "1", "text": "<em>Android: Abstract Method</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/libcore/+/675863.", "title": "Android: Abstract Method", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Abstract+Method&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Android: Add Catch Block</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/libcore/+/283122.", "title": "Android: Add Catch Block", "context": [{"sec": "sec4d1", "text": "This category of changes is further specialized into several subcategories (see Fig. 1) including (i) the addition/delation of thrown exceptions; (ii) the addition of try - catch/finally blocks [2]; (iii) narrowing or broadening the scope of the try block by moving the existing statements inside/outside the block [9]; (iv) changing the exception type in the catch clause to a narrower type (e.g., replacing Throwable with RuntimeException).", "part": "1"}, {"sec": "sec4d1", "text": " Add try-catch block [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Add+Catch+Block&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Android: Add Final</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/libcore/+/321410/1/.", "title": "Android: Add Final", "context": [{"sec": "sec4c1", "text": " Existing method declared as final [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Add+Final&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Android: Added Null Check</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/frameworks/base/+/382232.", "title": "Android: Added Null Check", "context": [{"sec": "sec4d2", "text": " Added null check [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Added+Null+Check&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>Android: Broadening Visibility</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/tools/base/+/110627/6/.", "title": "Android: Broadening Visibility", "context": [{"sec": "sec4c4", "text": " Broadening [5] and narrowing [19] method visibility.", "part": "1"}, {"sec": "sec4c4", "text": " An example of a method, for which our model recommended to broaden its visibility from private to public, is the of method from the Key Android class [5].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Broadening+Visibility&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Android: Change Operand</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/frameworks/base/+/98463/2/.", "title": "Android: Change Operand", "context": [{"sec": "sec4d2", "text": " Change comparison operand [6].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Change+Operand&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>Android: Merging Catch Blocks</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/libcore/+/244295/4/.", "title": "Android: Merging Catch Blocks", "context": [{"sec": "sec4c5", "text": " This includes: (i) braces added to if statements with the only goal of clearly delimiting their scope; (ii) the merging of two statements defining (e.g., String address;) and initializing (e.g., address=getAddess (); a variable into a single statement doing both (e.g., String address=getAddess ();) (iii) the addition/removal of the this qualifier, to match the project's coding standards; (iv) reducing the verbosity of a generic declaration by using the Java diamond operator (e.g., Map < String, List < String > > mapping=new HashMap < String, List < String > > () becomes Map < String, List < String > > mapping=new HashMap < >); (v) remove redundant else keywords from if statements (i.e., when the code delimited by the else statement would be executed in any case); (vi) refactoring anonymous classes implementing one method to lambda expressions, to make the code more readable [22]; (vii) simplifying boolean expressions (e.g., if(x==true) becomes if (x), where \\$\\mathrm{x}\\$ is a boolean variable); and (viii) merging two catch blocks capturing different exceptions into one catch block capturing both exceptions using the or operator [7].", "part": "1"}, {"sec": "sec4c5", "text": " Merging catch blocks capturing different exceptions [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Merging+Catch+Blocks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Android: Move Synchronization</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/libcore/+/40261/2/.", "title": "Android: Move Synchronization", "context": [{"sec": "sec4d4", "text": " These include its removal from a code block [11], from a method signature [10], and moving the keyword from the method signature to a code block or vice versa [8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Move+Synchronization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "<em>Android: Narrow Catch Block</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/libcore/+1148551.", "title": "Android: Narrow Catch Block", "context": [{"sec": "sec4d1", "text": "This category of changes is further specialized into several subcategories (see Fig. 1) including (i) the addition/delation of thrown exceptions; (ii) the addition of try - catch/finally blocks [2]; (iii) narrowing or broadening the scope of the try block by moving the existing statements inside/outside the block [9]; (iv) changing the exception type in the catch clause to a narrower type (e.g., replacing Throwable with RuntimeException).", "part": "1"}, {"sec": "sec4d1", "text": " Narrowed the scope of try block [9].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Narrow+Catch+Block&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "<em>Android: Remove Synchronized From Signature</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/frameworks/base/+/11487112/.", "title": "Android: Remove Synchronized From Signature", "context": [{"sec": "sec4d4", "text": " These include its removal from a code block [11], from a method signature [10], and moving the keyword from the method signature to a code block or vice versa [8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Remove+Synchronized+From+Signature&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "<em>Android: Remove Synchronized</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/frameworks/base/+/143346.", "title": "Android: Remove Synchronized", "context": [{"sec": "sec4d4", "text": " These include its removal from a code block [11], from a method signature [10], and moving the keyword from the method signature to a code block or vice versa [8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Remove+Synchronized&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "<em>Android: Rename Parameter</em>,  [online]  Available: https://android-review.googlesource.com/c/toolchain/jack/+/264513/2/.", "title": "Android: Rename Parameter", "context": [{"sec": "sec4c3", "text": " Rename parameter [12].", "part": "1"}, {"sec": "sec4c3", "text": " A second example of renaming, is the renamed parameter proposed for the endTrace(JMethod type) method in a PR impacting the AbstractTracerBrush class in the Android repository [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Rename+Parameter&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "<em>Android: Return Value</em>,  [online]  Available: https://android-review.googlesource.com/c/platform/tools/base/+/155460/6/.", "title": "Android: Return Value", "context": [{"sec": "sec4d3", "text": " This includes simple cases in which a boolean return value was changes from false to true (see e.g., [13]), as well as less obvious code transformations in which a constant return value was replaced with a field storing the current return value, e.g., return \u201crefs/my/config\u201d; converted into return ref;, where ref is a variable initialized in the constructor [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android%3A+Return+Value&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "<em>Gerrit - Android</em>,  [online]  Available: https://android-review.googlesource.com/.", "title": "Gerrit - Android", "context": [{"sec": "sec1", "text": "We mine three large Gerrit [17] code review repositories, namely Android [14], Google Source [15], and Ovirt [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gerrit+-+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "<em>Gerrit - Google Source</em>,  [online]  Available: https://gerrit-review.googlesource.com/.", "title": "Gerrit - Google Source", "context": [{"sec": "sec1", "text": "We mine three large Gerrit [17] code review repositories, namely Android [14], Google Source [15], and Ovirt [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gerrit+-+Google+Source&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>Gerrit - Ovirt</em>,  [online]  Available: https://gerrit.ovirt.org/.", "title": "Gerrit - Ovirt", "context": [{"sec": "sec1", "text": "We mine three large Gerrit [17] code review repositories, namely Android [14], Google Source [15], and Ovirt [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gerrit+-+Ovirt&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "<em>Gerrit</em>,  [online]  Available: https://www.gerritcodereview.com.", "title": "Gerrit", "context": [{"sec": "sec1", "text": "We mine three large Gerrit [17] code review repositories, namely Android [14], Google Source [15], and Ovirt [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gerrit&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>Google: Broader Generic Type</em>,  [online]  Available: https://gerrit-review.googlesource.com/c/gerrit/+/127039.", "title": "Google: Broader Generic Type", "context": [{"sec": "sec4c2", "text": " Method returns a broader generic type [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google%3A+Broader+Generic+Type&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>Google: Narrowing Visibility</em>,  [online]  Available: https://gerrit-review.googlesource.com/c/gerrit/+/99660/4/.", "title": "Google: Narrowing Visibility", "context": [{"sec": "sec4c4", "text": " Broadening [5] and narrowing [19] method visibility.", "part": "1"}, {"sec": "sec4c4", "text": "The visibility was instead narrowed from public to private in the context of a refactoring performed by a developer to make \u201cmore methods private\u201d [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google%3A+Narrowing+Visibility&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "<em>Google: Return Value</em>,  [online]  Available: https://gerrit-review.googlesource.com/c/gerrit/+/139770.", "title": "Google: Return Value", "context": [{"sec": "sec4d3", "text": " This includes simple cases in which a boolean return value was changes from false to true (see e.g., [13]), as well as less obvious code transformations in which a constant return value was replaced with a field storing the current return value, e.g., return \u201crefs/my/config\u201d; converted into return ref;, where ref is a variable initialized in the constructor [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google%3A+Return+Value&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>On learning meaningful code changes via neural machine translation Replication Package</em>,  [online]  Available: https://sites.google.com/view/learning-codechanges.", "title": "On learning meaningful code changes via neural machine translation Replication Package", "context": [{"sec": "sec1", "text": " To foster research in this direction, we make publicly available the complete datasets, source code, tools, and raw data used in our experiments [21].", "part": "1"}, {"sec": "sec4b", "text": " The complete list is available in our replication package [21].", "part": "1"}, {"sec": "sec4b", "text": " Yet, the complete set of perfect predictions and their classification is available in our replication package [21].", "part": "1"}, {"sec": "sec5", "text": " Distribution and data can be accessed in our replication package [21].", "part": "1"}, {"sec": "sec7", "text": " In that sense, we hope that the public availability of the source code of our infrastructure and of the data and tools we used [21], can help in fostering research in this field.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+learning+meaningful+code+changes+via+neural+machine+translation+Replication+Package&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>Ovirt: Anonymous Class To Lambda</em>,  [online]  Available: https://gerrit.ovirt.org/#/c/50859/.", "title": "Ovirt: Anonymous Class To Lambda", "context": [{"sec": "sec4c5", "text": " This includes: (i) braces added to if statements with the only goal of clearly delimiting their scope; (ii) the merging of two statements defining (e.g., String address;) and initializing (e.g., address=getAddess (); a variable into a single statement doing both (e.g., String address=getAddess ();) (iii) the addition/removal of the this qualifier, to match the project's coding standards; (iv) reducing the verbosity of a generic declaration by using the Java diamond operator (e.g., Map < String, List < String > > mapping=new HashMap < String, List < String > > () becomes Map < String, List < String > > mapping=new HashMap < >); (v) remove redundant else keywords from if statements (i.e., when the code delimited by the else statement would be executed in any case); (vi) refactoring anonymous classes implementing one method to lambda expressions, to make the code more readable [22]; (vii) simplifying boolean expressions (e.g., if(x==true) becomes if (x), where \\$\\mathrm{x}\\$ is a boolean variable); and (viii) merging two catch blocks capturing different exceptions into one catch block capturing both exceptions using the or operator [7].", "part": "1"}, {"sec": "sec4c5", "text": " Anonymous class replaced with lambda expression [22].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ovirt%3A+Anonymous+Class+To+Lambda&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>Ovirt: Flipped Parameters</em>,  [online]  Available: https://gerrit.ovirt.org/#/c/63570/.", "title": "Ovirt: Flipped Parameters", "context": [{"sec": "sec4d5", "text": " parameters in assertEquals [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ovirt%3A+Flipped+Parameters&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "<em>Ovirt: Redundant Super</em>,  [online]  Available: https://gerrit.ovirt.org/#/c/45678/.", "title": "Ovirt: Redundant Super", "context": [{"sec": "sec4c1", "text": " Removed unnecessary \u201csuper\u201d specifier [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ovirt%3A+Redundant+Super&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "<em>Ovirt: Rename Method</em>,  [online]  Available: https://gerrit.ovirt.org/#/c/14147/.", "title": "Ovirt: Rename Method", "context": [{"sec": "sec4c3", "text": " Rename method [25].", "part": "1"}, {"sec": "sec4c3", "text": " One example of correctly learned rename method, is the one fixing a typo from the OnSucess method in the Ovirt system [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ovirt%3A+Rename+Method&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "C. V. Alexandru, \"Guided code synthesis using deep neural networks\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2016</em>, pp. 1068-1070, 2016.", "title": "Guided code synthesis using deep neural networks", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2983951", "abstract": "Can we teach computers how to program? Recent advances in neural network research reveal that certain neural networks are able not only to learn the syntax, grammar and semantics of arbitrary character sequences, but also synthesize new samples `in the style of' the original training data. We explore the adaptation of these techniques to code classification, comprehension and completion.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guided+code+synthesis+using+deep+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "M. Allamanis, E. T. Barr, C. Bird, C. Sutton, \"Suggesting accurate method and class names\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering ser. ESEC/FSE 2015</em>, pp. 38-49, 2015.", "title": "Suggesting accurate method and class names", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec4c3", "text": " Indeed, good identifiers improve readability, understandability and maintainability of source code [27], [46].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786849", "abstract": "Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names. However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilisti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Suggesting+accurate+method+and+class+names&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "M. Allamanis, E. T. Barr, C. Bird, C. Sutton, \"Suggesting accurate method and class names\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering ser. ESEC/FSE 2015</em>, pp. 38-49, 2015.", "title": "Suggesting accurate method and class names", "context": [{"sec": "sec6", "text": " Allamanis et al. uses a log-bilinear neural network to understand the context of a method or class and recommends a representative name that has not appeared in the training corpus [28].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786849", "abstract": "Descriptive names are a vital part of readable, and hence maintainable, code. Recent progress on automatically suggesting names for local variables tantalizes with the prospect of replicating that success with method and class names. However, suggesting names for methods and classes is much more difficult. This is because good method and class names need to be functionally descriptive, but suggesting such names requires that the model goes beyond local context. We introduce a neural probabilisti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Suggesting+accurate+method+and+class+names&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "M. Allamanis, H. Peng, C. A. Sutton, \"A convolutional attention network for extreme summarization of source code\", <em>CoRR</em>, vol. abs/1602.03001, 2016.", "title": "A convolutional attention network for extreme summarization of source code", "context": [{"sec": "sec6", "text": " To this point Allamanis et al. uses an Attentional Neural Network (ANN) with a convoluation layer in order to summarize pieces of source code into short, functional descriptions [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+convolutional+attention+network+for+extreme+summarization+of+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "D. Bahdanau, K. Cho, Y. Bengio, \"Neural machine translation by jointly learning to align and translate\", <em>CoRR</em>, vol. abs/1409.0473, 2014.", "title": "Neural machine translation by jointly learning to align and translate", "context": [{"sec": "sec2d1", "text": "To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33].", "part": "1"}, {"sec": "sec2d1", "text": " In particular, we adopt a bi-directional RNN Encoder [30], which is formed by a backward and a forward RNN.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Neural+machine+translation+by+jointly+learning+to+align+and+translate&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "J. Berkman, <em>Machine learning vs. deep learning</em>, August 2018,  [online]  Available: https://www.datascience.com/blog/machine-learning-and-deep-learning-what-is-the-difference.", "title": "Machine learning vs. deep learning", "context": [{"sec": "sec1", "text": " Second, DL has become a useful tool due to its ability to learn categorization of data through the hidden layer architecture, making it especially proficient in feature detection [31].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Machine+learning+vs.+deep+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "D. Britz, A. Goldie, M. Luong, Q. V. Le, \"Massive exploration of neural machine translation architectures\", <em>CoRR</em>, vol. abs/1703.03906, 2017.", "title": "Massive exploration of neural machine translation architectures", "context": [{"sec": "sec2d1", "text": "To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33].", "part": "1"}, {"sec": "sec2d1", "text": " The RNNs process the sentence both from left-to-right and right-to-left, and are able to create sentence representations taking into account both past and future inputs [32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18653/v1/D17-1151", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Massive+exploration+of+neural+machine+translation+architectures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "K. Cho, B. Van Merrienboer, \u00c7. Gulcehre, F. Bougares, H. Schwenk, Y. Bengio, \"Learning phrase representations using RNN encoder-decoder for statistical machine translation\", <em>CoRR</em>, vol. abs/1406.1078, 2014.", "title": "Learning phrase representations using RNN encoder-decoder for statistical machine translation", "context": [{"sec": "sec2d1", "text": "To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33].", "part": "1"}, {"sec": "sec2d3", "text": "We tested ten configurations of the encoder-decoder architecture with different combinations of RNN Cells (LSTM [45] and GRU [33]), number of layers (1, 2, 4) and units (256, 512) for the encoder/decoder, and the embedding size (256, 512).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3115/v1/D14-1179", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+phrase+representations+using+RNN+encoder-decoder+for+statistical+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "M. Choetkiertikul, H. K. Dam, T. Tran, T. T. M. Pham, A. Ghose, T. Menzies, \"A deep learning model for estimating story points\", <em>IEEE Transactions on Software Engineering</em>, pp. 1-1, 2018.", "title": "A deep learning model for estimating story points", "context": [{"sec": "sec6", "text": " Choetkiertikul et al. proposes a DL architecture of long short-term memory and recurring highway network that aims to predict the effort estimation of a coding task [34].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+deep+learning+model+for+estimating+story+points&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "C. S. Corley, K. Damevski, N. A. Kraft, \"Exploring the use of deep learning for feature location\", <em>2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 556-560, Sept 2015.", "title": "Exploring the use of deep learning for feature location", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"documentLink": "/document/7332513", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7332513", "abstract": "Deep learning models can infer complex patterns present in natural language text. Relative to n-gram models, deep learning models can capture more complex statistical patterns based on smaller training corpora. In this paper we explore the use of a particular deep learning model, document vectors (DVs), for feature location. DVs seem well suited to use with source code, because they both capture the influence of context on each term in a corpus and map terms into a continuous semantic space that...", "pdfSize": "415KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+the+use+of+deep+learning+for+feature+location&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "H. K. Dam, T. Tran, J. Grundy, A. Ghose, \"Deepsoft: A vision for a deep model of software\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2016</em>, pp. 944-947, 2016.", "title": "Deepsoft: A vision for a deep model of software", "context": [{"sec": "sec6", "text": " Further expanding upon the powerful, predictive capabilities of these models, Dam et al. presents DeepSoft, which is a DL-based architecture used for modeling software, code generation and software risk prediction [36].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2983985", "abstract": "Although software analytics has experienced rapid growth as a research area, it has not yet reached its full potential for wide industrial adoption. Most of the existing work in software analytics still relies heavily on costly manual feature engineering processes, and they mainly address the traditional classification problems, as opposed to predicting future events. We present a vision for DeepSoft, an end-to-end generic framework for modeling software and its development process to predict fu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deepsoft%3A+A+vision+for+a+deep+model+of+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "J. Deshmukh, A. K. M, S. Printder, S. Sengupta, N. Dubash, \"Towards accurate duplicate bug retrieval using deep learning techniques\", <em>2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 115-124, Sept 2017.", "title": "Towards accurate duplicate bug retrieval using deep learning techniques", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"documentLink": "/document/8094414", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8094414", "abstract": "Duplicate Bug Detection is the problem of identifying whether a newly reported bug is a duplicate of an existing bug in the system and retrieving the original or similar bugs from the past. This is required to avoid costly rediscovery and redundant work. In typical software projects, the number of duplicate bugs reported may run into the order of thousands, making it expensive in terms of cost and time for manual intervention. This makes the problem of duplicate or similar bug detection an impor...", "pdfSize": "716KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+accurate+duplicate+bug+retrieval+using+deep+learning+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "J. Falleri, F. Morandat, X. Blanc, M. Martinez, M. Monperrus, \"Fine-grained and accurate source code differencing\", <em>ACM/IEEE International Conference on Automated Software Engineering ASE '14</em>, pp. 313-324, 2014.", "title": "Fine-grained and accurate source code differencing", "context": [{"sec": "sec1", "text": " We extract method-level AST edit operations from these PRs using fine-grained source code differencing [38].", "part": "1"}, {"sec": "sec2b", "text": " In the first step, we rely on GumTreeDiff [38] to establish the file-to-file mapping, performed using semantic anchors, between pre- and post-PR files and disregarding any file added/removed during the code review process.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2642937.2642982", "abstract": "At the heart of software evolution is a sequence of edit actions, called an edit script, made to a source code file. Since software systems are stored version by version, the edit script has to be computed from these versions, which is known as a complex task. Existing approaches usually compute edit scripts at the text granularity with only add line and delete line actions. However, inferring syntactic changes from such an edit script is hard. Since moving code is a frequent action performed wh...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fine-grained+and+accurate+source+code+differencing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "P. Godefroid, H. Peleg, R. Singh, \"Learn&fuzz: Machine learning for input fuzzing\", <em>CoRR</em>, vol. abs/1701.07232, 2017.", "title": "Learn&fuzz: Machine learning for input fuzzing", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"documentLink": "/document/8115618", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115618", "abstract": "Fuzzing consists of repeatedly testing an application with modified, or fuzzed, inputs with the goal of finding security vulnerabilities in input-parsing code. In this paper, we show how to automate the generation of an input grammar suitable for input fuzzing using sample inputs and neural-network-based statistical machine-learning techniques. We present a detailed case study with a complex input format, namely PDF, and a large complex security-critical parser for this format, namely, the PDF p...", "pdfSize": "400KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learn%26fuzz%3A+Machine+learning+for+input+fuzzing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "X. Gu, H. Zhang, S. Kim, \"Deep code search\", <em>Proceedings of the 40th International Conference on Software Engineering ser. ICSE '18</em>, pp. 933-944, 2018.", "title": "Deep code search", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec6", "text": " This implementation uses NNs and natural language to embed code snippets with natural language descriptions into a high-dimensional vector space, helping developers locate source code based on natural language queries [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180167", "abstract": "To implement a program functionality, developers can reuse previously written code snippets by searching through a large-scale codebase. Over the years, many code search tools have been proposed to help developers. The existing approaches often treat source code as textual documents and utilize information retrieval models to retrieve relevant code snippets that match a given query. These approaches mainly rely on the textual similarity between source code and natural language query. They lack a...", "pdfSize": "677KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+code+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "X. Gu, H. Zhang, D. Zhang, S. Kim, \"Deep api learning\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2016</em>, pp. 631-642, 2016.", "title": "Deep api learning", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec6", "text": " The learned semantics allow the model to associate natural language queries with a sequence of API usages [41].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950334", "abstract": "Developers often wonder how to implement a certain functionality (e.g., how to parse XML files) using APIs. Obtaining an API usage sequence based on an API-related natural language query is very helpful in this regard. Given a query, existing approaches utilize information retrieval models to search for matching API sequences. These approaches treat queries and APIs as bags-of-words and lack a deep understanding of the semantics of the query. We propose DeepAPI, a deep learning based approach to...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+api+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "J. Guo, J. Cheng, J. Cleland-Huang, \"Semantically enhanced software traceability using deep learning techniques\", <em>Proceedings of the 39th International Conference on Software Engineering ser. ICSE '17</em>, pp. 3-14, 2017.", "title": "Semantically enhanced software traceability using deep learning techniques", "context": [{"sec": "sec6", "text": " Guo et al. develops a DL approach using RNNs and word embeddings to learn the sentence semantics of requirement artifacts, which helps to create traceability links in software projects [42].", "part": "1"}], "links": {"documentLink": "/document/7985645", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985645", "abstract": "In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts, however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links, however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into th...", "pdfSize": "1398KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semantically+enhanced+software+traceability+using+deep+learning+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "R. Gupta, S. Pal, A. Kanade, S. K. Shevade, \"Deepfix: Fixing common c language errors by deep learning\", <em>AAAI</em>, 2017.", "title": "Deepfix: Fixing common c language errors by deep learning", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deepfix%3A+Fixing+common+c+language+errors+by+deep+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "Z. Han, X. Li, Z. Xing, H. Liu, Z. Feng, \"Learning to predict severity of software vulnerability using only vulnerability description\", <em>2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 125-136, Sept 2017.", "title": "Learning to predict severity of software vulnerability using only vulnerability description", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"documentLink": "/document/8094415", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8094415", "abstract": "Software vulnerabilities pose significant security risks to the host computing system. Faced with continuous disclosure of software vulnerabilities, system administrators must prioritize their efforts, triaging the most critical vulnerabilities to address first. Many vulnerability scoring systems have been proposed, but they all require expert knowledge to determine intricate vulnerability metrics. In this paper, we propose a deep learning approach to predict multi-class severity level of softwa...", "pdfSize": "593KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+to+predict+severity+of+software+vulnerability+using+only+vulnerability+description&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "S. Hochreiter, J. Schmidhuber, \"Long short-term memory\", <em>Neural Comput.</em>, vol. 9, no. 8, pp. 1735-1780, Nov. 1997.", "title": "Long short-term memory", "context": [{"sec": "sec2d3", "text": "We tested ten configurations of the encoder-decoder architecture with different combinations of RNN Cells (LSTM [45] and GRU [33]), number of layers (1, 2, 4) and units (256, 512) for the encoder/decoder, and the embedding size (256, 512).", "part": "1"}], "links": {"documentLink": "/document/6795963", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6795963", "abstract": "Learning to store information over extended time intervals by recurrent backpropagation takes a very long time, mostly because of insufficient, decaying error backflow. We briefly review Hochreiter&#39;s (1991) analysis of this problem, then address it by introducing a novel, efficient, gradient based method called long short-term memory (LSTM). Truncating the gradient where this does not do harm, LSTM can learn to bridge minimal time lags in excess of 1000 discrete-time steps by enforcing constant ...", "pdfSize": "237KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Long+short-term+memory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "E. W. H\u00d8st, B. M. \u00d8stvold, S. Drossopoulou, \"Debugging method names\" in ECOOP 2009 - Object-Oriented Programming, Berlin, Heidelberg:Springer Berlin Heidelberg, pp. 294-317, 2009.", "title": "Debugging method names", "context": [{"sec": "sec4c3", "text": " Indeed, good identifiers improve readability, understandability and maintainability of source code [27], [46].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Debugging+method+names&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "S. Jiang, A. Armaly, C. McMillan, \"Automatically generating commit messages from diffs using neural machine translation\", <em>2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 135-146, Oct 2017.", "title": "Automatically generating commit messages from diffs using neural machine translation", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}], "links": {"documentLink": "/document/8115626", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115626", "abstract": "Commit messages are a valuable resource in comprehension of software evolution, since they provide a record of changes such as feature additions and bug repairs. Unfortunately, programmers often neglect to write good commit messages. Different techniques have been proposed to help programmers by automatically writing these messages. These techniques are effective at describing what changed, but are often verbose and lack context for understanding the rationale behind a change. In contrast, human...", "pdfSize": "732KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+generating+commit+messages+from+diffs+using+neural+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "N. Kalchbrenner, P. Blunsom, \"Recurrent continuous translation models\", <em>Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing</em>, pp. 1700-1709, October 2013.", "title": "Recurrent continuous translation models", "context": [{"sec": "sec2d1", "text": "To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Recurrent+continuous+translation+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "A. N. Lam, A. T. Nguyen, H. A. Nguyen, T. N. Nguyen, \"Combining deep learning with information retrieval to localize buggy files for bug reports (n)\", <em>2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 476-481, Nov 2015.", "title": "Combining deep learning with information retrieval to localize buggy files for bug reports (n)", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec6", "text": " They use a revised Vector Space Model to create a representation the DL model can use to relate terms in a bug report to source code tokens [49].", "part": "1"}], "links": {"documentLink": "/document/7372035", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372035", "abstract": "Bug localization refers to the automated process of locating the potential buggy files for a given bug report. To help developers focus their attention to those files is crucial. Several existing automated approaches for bug localization from a bug report face a key challenge, called lexical mismatch, in which the terms used in bug reports to describe a bug are different from the terms and code tokens used in source files. This paper presents a novel approach that uses deep neural network (DNN) ...", "pdfSize": "258KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combining+deep+learning+with+information+retrieval+to+localize+buggy+files+for+bug+reports+%28n%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "S.-R. Lee, M.-J. Heo, C.-G. Lee, M. Kim, G. Jeong, \"Applying deep learning based automatic bug triager to industrial projects\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering ser. ESEC/FSE 2017</em>, pp. 926-931, 2017.", "title": "Applying deep learning based automatic bug triager to industrial projects", "context": [{"sec": "sec6", "text": " This approach uses word2vec to embed a summary and a description which the CNN then assigns to a developer [50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3117776", "abstract": "Finding the appropriate developer for a bug report, so called `Bug Triage&#39;, is one of the bottlenecks in the bug resolution process. To address this problem, many approaches have proposed various automatic bug triage techniques in recent studies. We argue that most previous studies focused on open source projects only and did not consider deep learning techniques. In this paper, we propose to use Convolutional Neural Network and word embedding to build an automatic bug triager. The results of th...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Applying+deep+learning+based+automatic+bug+triager+to+industrial+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "L. Li, H. Feng, W. Zhuang, N. Meng, B. Ryder, \"Cclearner: A deep learning-based clone detection approach\", <em>2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 249-260, Sept 2017.", "title": "Cclearner: A deep learning-based clone detection approach", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"documentLink": "/document/8094426", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8094426", "abstract": "Programmers produce code clones when developing software. By copying and pasting code with or without modification, developers reuse existing code to improve programming productivity. However, code clones present challenges to software maintenance: they may require consistent application of the same or similar bug fixes or program changes to multiple code locations. To simplify the maintenance process, various tools have been proposed to automatically detect clones [1], [2], [3], [4], [5], [6]. ...", "pdfSize": "611KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cclearner%3A+A+deep+learning-based+clone+detection+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "M. Luong, H. Pham, C. D. Manning, \"Effective approaches to attention-based neural machine translation\", <em>CoRR</em>, vol. abs/1508.04025, 2015.", "title": "Effective approaches to attention-based neural machine translation", "context": [{"sec": "sec2d1", "text": "To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18653/v1/D15-1166", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+approaches+to+attention-based+neural+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "H. Mi, Z. Wang, A. Ittycheriah, \"Vocabulary manipulation for neural machine translation\", <em>CoRR</em>, vol. abs/1605.03209, 2016.", "title": "Vocabulary manipulation for neural machine translation", "context": [{"sec": "sec2c", "text": " This problem has been addressed by artificially limiting the vocabulary size, considering only most common words, assigning special tokens (e.g., UNK) to rare words or by learning subword units and splitting the words into constituent tokens [53], [67].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18653/v1/P16-2021", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Vocabulary+manipulation+for+neural+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "K. Moran, C. Bernal-C\u00e1rdenas, M. Curcio, R. Bonett, D. Poshyvanyk, \"Machine learning-based prototyping of graphical user interfaces for mobile apps\", <em>CoRR</em>, vol. abs/1802.02312, 2018.", "title": "Machine learning-based prototyping of graphical user interfaces for mobile apps", "context": [{"sec": "sec6", "text": " In this approach, a deep CNN is used to help classify GUI components which can later be used to generate a mock GUI for a specific app [54].", "part": "1"}], "links": {"abstract": "It is common practice for developers of user-facing software to transform a mock-up of a graphical user interface (GUI) into code. This process takes place both at an application&#39;s inception and in an evolutionary context as GUI changes keep pace with evolving features. Unfortunately, this practice is challenging and time-consuming. In this paper, we present an approach that automates this process by enabling accurate prototyping of GUIs via three tasks: detection, classification, and assembly. ...", "pdfSize": "3996KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Machine+learning-based+prototyping+of+graphical+user+interfaces+for+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "<em>How many words are there in the english language?</em>, August 2018,  [online]  Available: https://en.oxforddictionaries.com/explore/how-many-words-are-there-in-the-english-language/.", "title": "How many words are there in the english language?", "context": [{"sec": "sec2c", "text": " In comparison, the Oxford English Dictionary contains entries for 171,476 words [55].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+many+words+are+there+in+the+english+language%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "T. Parr, The Definitive ANTLR 4 Reference, Pragmatic Bookshelf, 2013.", "title": "The Definitive ANTLR 4 Reference", "context": [{"sec": "sec2c", "text": " The source code of a method is fed to a lexer, built on top of ANTLR [56], which tokenizes the raw code into a stream of tokens.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Definitive+ANTLR+4+Reference&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "V. Raychev, M. Vechev, E. Yahav, \"Code completion with statistical language models\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI'14</em>, pp. 419-428, 2014.", "title": "Code completion with statistical language models", "context": [{"sec": "sec1", "text": "The achieved results indicate that, in its best configuration, the NMT model is able to inject the same code transformations that are implemented by developers in PRs in 16\u201336% of cases, depending on the number of possible solutions that it is required to produce using beam search [57].", "part": "1"}, {"sec": "sec2d2", "text": " To this aim, we employ a decoding strategy called a Beam Search used in previous applications of DL [57].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2666356.2594321", "abstract": "We address the problem of synthesizing code completions for programs using APIs. Given a program with holes, we synthesize completions for holes with the most likely sequences of method calls. Our main idea is to reduce the problem of code completion to a natural-language processing problem of predicting probabilities of sentences. We design a simple and scalable static analysis that extracts sequences of method calls from a large codebase, and index these into a statistical language model. We t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+completion+with+statistical+language+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "S. Romansky, N. C. Borle, S. Chowdhury, A. Hindle, R. Greiner, \"Deep green: Modelling time-series of software energy consumption\", <em>2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 273-283, Sept 2017.", "title": "Deep green: Modelling time-series of software energy consumption", "context": [{"sec": "sec6", "text": " Due to the power of these representations, many works have applied these models to solve SE problems [39] [26] [37] [35] [51] [44] [58] [43].", "part": "1"}], "links": {"documentLink": "/document/8094428", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8094428", "abstract": "Inefficient mobile software kills battery life. Yet, developers lack the tools necessary to detect and solve energy bugs in software. In addition, developers are usually tasked with the creation of software features and triaging existing bugs. This means that most developers do not have the time or resources to research, build, or employ energy debugging tools. We present a new method for predicting software energy consumption to help debug software energy issues. Our approach enables developers...", "pdfSize": "1782KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+green%3A+Modelling+time-series+of+software+energy+consumption&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "S. Scalabrino, M. Linares-Vasquez, D. Poshyvanyk, R. Oliveto, \"Improving code readability models with textual features\", <em>2016 IEEE 24th International Conference on Program Comprehension (ICPC)</em>, May 2016.", "title": "Improving code readability models with textual features", "context": [{"sec": "sec4c5", "text": "Readable code is easier to understand and maintain [59].", "part": "1"}], "links": {"documentLink": "/document/7503707", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7503707", "abstract": "Code reading is one of the most frequent activities in software maintenance; before implementing changes, it is necessary to fully understand source code often written by other developers. Thus, readability is a crucial aspect of source code that may significantly influence program comprehension effort. In general, models used to estimate software readability take into account only structural aspects of source code, e.g., line length and a number of comments. However, source code is a particular...", "pdfSize": "1560KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+code+readability+models+with+textual+features&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "I. Sutskever, O. Vinyals, Q. V. Le, \"Sequence to sequence learning with neural networks\", <em>CoRR</em>, vol. abs/1409.3215, 2014.", "title": "Sequence to sequence learning with neural networks", "context": [{"sec": "sec2d1", "text": "To build such models, we rely on an RNN Encoder-Decoder architecture with attention mechanism [30], [52], [32], commonly adopted in NMT tasks [48], [60], [33].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sequence+to+sequence+learning+with+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "M. Tufano, C. Watson, G. Bavota, M. Di Penta, M. White, D. Poshyvanyk, \"Deep learning similarities from different representations of source code\", <em>Proceedings of the 15th International Conference on Mining Software Repositories ser. MSR '18</em>, pp. 542-553, 2018.", "title": "Deep learning similarities from different representations of source code", "context": [{"sec": "sec6", "text": " Using a similar encoding, Tufano et al. encodes methods into four different representations, then the DL model evaluates how similar two pieces of code are based on their multiple representations [61].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3196398.3196431", "abstract": "Assessing the similarity between code components plays a pivotal role in a number of Software Engineering (SE) tasks, such as clone detection, impact analysis, refactoring, etc. Code similarity is generally measured by relying on manually defined or hand-crafted features, e.g., by analyzing the overlap among identifiers or comparing the Abstract Syntax Trees of two code components. These features represent a best guess at what SE researchers can utilize to exploit and reliably assess code simila...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+learning+similarities+from+different+representations+of+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "M. Tufano, C. Watson, G. Bavota, M. Di Penta, M. White, D. Poshyvanyk, \"An empirical investigation into learning bug-fixing patches in the wild via neural machine translation\", <em>Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering ser. ASE 2018</em>, pp. 832-837, 2018.", "title": "An empirical investigation into learning bug-fixing patches in the wild via neural machine translation", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec1", "text": " [62] showed that DL can be used to automate bug-fixing activities.", "part": "1"}, {"sec": "sec6", "text": " Another recent work by Tufano et al. applies NMT to bug-fixing patches the wild [62].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3238147.3240732", "abstract": "Millions of open-source projects with numerous bug fixes are available in code repositories. This proliferation of software development histories can be leveraged to learn how to fix common programming bugs. To explore such a potential, we perform an empirical study to assess the feasibility of using Neural Machine Translation techniques for learning bug-fixing patches for real defects. We mine millions of bug-fixes from the change histories of GitHub repositories to extract meaningful examples ...", "pdfSize": "274KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+investigation+into+learning+bug-fixing+patches+in+the+wild+via+neural+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "S. Wang, T. Liu, L. Tan, \"Automatically learning semantic features for defect prediction\", <em>Proceedings of the 38th International Conference on Software Engineering ser. ICSE '16</em>, pp. 297-308, 2016.", "title": "Automatically learning semantic features for defect prediction", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec6", "text": " The network then predicts if the commit will be defective [63].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884804", "abstract": "Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the ...", "pdfSize": "1876KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+learning+semantic+features+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "M. White, M. Tufano, C. Vendome, D. Poshyvanyk, \"Deep learning code fragments for code clone detection\", <em>Proceedings of the 31st IEEE/ACM International Conference on Automated Software Engineering ser. ASE 2016</em>, pp. 87-98, 2016.", "title": "Deep learning code fragments for code clone detection", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec6", "text": "White et al. uses representation learning via a recursive autoencoder for the task of clone detection [64].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970326", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+learning+code+fragments+for+code+clone+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "M. White, C. Vendome, M. Linares-V\u00e1squez, D. Poshyvanyk, \"Toward deep learning software repositories\", <em>Proceedings of the 12th Working Conference on Mining Software Repositories ser. MSR '15</em>, pp. 334-345, 2015.", "title": "Toward deep learning software repositories", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}, {"sec": "sec6", "text": " They show that DL models make code suggestions based upon contextual features learned by the model rather than the predictive power of the past \\$n\\$ tokens [65].", "part": "1"}], "links": {"documentLink": "/document/7180092", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180092", "abstract": "Deep learning subsumes algorithms that automatically learn compositional representations. The ability of these models to generalize well has ushered in tremendous advances in many fields such as natural language processing (NLP). Recent research in the software engineering (SE) community has demonstrated the usefulness of applying NLP techniques to software corpora. Hence, we motivate deep learning for software language modeling, highlighting fundamental differences between state-of-the-practice...", "pdfSize": "227KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Toward+deep+learning+software+repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "E. Wong, J. Yang, L. Tan, \"Autocomment: Mining question and answer sites for automatic comment generation\", <em>2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 562-567, Nov 2013.", "title": "Autocomment: Mining question and answer sites for automatic comment generation", "context": [{"sec": "sec1", "text": "Several works recently focused on the use of advanced machine learning techniques on source code with the goal of (semi)automating several non-trivial tasks, including code completion [65], generation of commit messages [47], method names [27], code comments [66], defect prediction [63], bug localization [49] and fixing [62], clone detection [64], code search [40], and learning API templates [41].", "part": "1"}], "links": {"documentLink": "/document/6693113", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693113", "abstract": "Code comments improve software maintainability. To address the comment scarcity issue, we propose a new automatic comment generation approach, which mines comments from a large programming Question and Answer (Q&A) site. Q&A sites allow programmers to post questions and receive solutions, which contain code segments together with their descriptions, referred to as code-description mappings.We develop AutoComment to extract such mappings, and leverage them to generate description comments automat...", "pdfSize": "212KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Autocomment%3A+Mining+question+and+answer+sites+for+automatic+comment+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "Y. Wu, M. Schuster, Z. Chen, Q. V. Le, M. Norouzi, W. Macherey, M. Krikun, Y. Cao, Q. Gao, K. Macherey, J. Klingner, A. Shah, M. Johnson, X. Liu, L. Kaiser, S. Gouws, Y. Kato, T. Kudo, H. Kazawa, K. Stevens, G. Kurian, N. Patil, W. Wang, C. Young, J. Smith, J. Riesa, A. Rudnick, O. Vinyals, G. Corrado, M. Hughes, J. Dean, \"Google's neural machine translation system: Bridging the gap between human and machine translation\", <em>CoRR</em>, vol. abs/1609.08144, 2016.", "title": "Google's neural machine translation system: Bridging the gap between human and machine translation", "context": [{"sec": "sec1", "text": " Specifically, Neural Machine Translation (NMT) has become a premier method for the translation of different languages, surpassing that of human interpretation [67].", "part": "1"}, {"sec": "sec2c", "text": " This problem has been addressed by artificially limiting the vocabulary size, considering only most common words, assigning special tokens (e.g., UNK) to rare words or by learning subword units and splitting the words into constituent tokens [53], [67].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google%27s+neural+machine+translation+system%3A+Bridging+the+gap+between+human+and+machine+translation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811910", "articleId": "8811910", "startPage": "25", "endPage": "36", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 170}}
{"title": "FastLane: Test Minimization for Rapidly Deployed Large-Scale Online Services", "authors": [{"name": "Adithya Abraham Philip", "affiliation": "Microsoft Research, India", "firstName": "Adithya Abraham", "lastName": "Philip", "id": "37086441831"}, {"name": "Ranjita Bhagwan", "affiliation": "Microsoft Research, India", "firstName": "Ranjita", "lastName": "Bhagwan", "id": "37444156400"}, {"name": "Rahul Kumar", "affiliation": "Microsoft Research, India", "firstName": "Rahul", "lastName": "Kumar", "id": "37086949748"}, {"name": "Chandra Sekhar Maddila", "affiliation": "Microsoft Research, India", "firstName": "Chandra Sekhar", "lastName": "Maddila", "id": "37086947115"}, {"name": "Nachiappan Nagppan", "affiliation": "Microsoft Research, Redmond", "firstName": "Nachiappan", "lastName": "Nagppan", "id": "37086947016"}], "abstract": "Today, we depend on numerous large-scale services for basic operations such as email. These services, built on the basis of Continuous Integration/Continuous Deployment (CI/CD) processes, are extremely dynamic: developers continuously commit code and introduce new features, functionality and fixes. Hundreds of commits may enter the code-base in a single day. Therefore one of the most time-critical, yet resource-intensive tasks towards ensuring code-quality is effectively testing such large code-bases. This paper presents FastLane, a system that performs data-driven test minimization. FastLane uses light-weight machine-learning models built upon a rich history of test and commit logs to predict test outcomes. Tests for which we predict outcomes need not be explicitly run, thereby saving us precious test-time and resources. Our evaluation on a large-scale email and collaboration platform service shows that our techniques can save 18.04%, i.e., almost a fifth of test-time while obtaining a test outcome accuracy of 99.99%.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Testing", "Correlation", "Minimization", "Predictive models", "Complexity theory", "Prediction algorithms", "Machine learning"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["electronic mail", "groupware", "Internet", "learning (artificial intelligence)", "program testing", "software quality"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["FastLane", "rapidly deployed large-scale online services", "code-base", "resource-intensive tasks", "code-quality", "light-weight machine-learning models", "large-scale email", "collaboration platform service", "time-critical tasks", "data-driven test minimization", "continuous integration-continuous deployment processes", "CI-CD processes", "commit logs"]}, {"type": "Author Keywords ", "kwd": ["test prioritization", "commit risk", "machine learning"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00054", "ref": [{"order": "1", "text": "A. Memon, Z. Gao, B. Nguyen, S. Dhanda, E. Nickell, R. Siemborski, J. Micco, \"Taming google-scale continuous testing\", <em>ICSE SEIP Track</em>, 2017.", "title": "Taming google-scale continuous testing", "context": [{"sec": "sec1", "text": " Several enterprise testing platforms suffer from this problem [1].", "part": "1"}, {"sec": "sec3b", "text": "The more often a file changes, the more risky it is [1], [17].", "part": "1"}, {"sec": "sec3b", "text": "Number of contributors to a file affects risk [1], [18].", "part": "1"}, {"sec": "sec8b", "text": "From an industrial stand point, in recent work at Google [1], the authors empirically leverage the relationship between Google's code, test cases, developers, programming languages, and code-change frequencies, to improve Google's CI and development processes.", "part": "1"}, {"sec": "sec8c", "text": " Recent work has analyzed test logs and described the correlation between test failures and the \u201ccloseness\u201d of code changed and frequency of code change [1].", "part": "1"}], "links": {"documentLink": "/document/7965447", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7965447", "abstract": "Growth in Google&#39;s code size and feature churn rate has seen increased reliance on continuous integration (CI) and testing to maintain quality. Even with enormous resources dedicated to testing, we are unable to regression test each code change individually, resulting in increased lag time between code check-ins and test result feedback to developers. We report results of a project that aims to reduce this time by: (1) controlling test workload without compromising quality, and (2) distilling te...", "pdfSize": "888KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Taming+google-scale+continuous+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "K. Shvachko, H. Kuang, S. Radia, R. Chansler, \"The hadoop distributed file system\", <em>Proceedings of the 2010 IEEE 26th Symposium on Mass Storage Systems and Technologies (MSST) ser. MSST \u2018 10</em>, pp. 1-10, 2010.", "title": "The hadoop distributed file system", "context": [{"sec": "sec1", "text": " However, with large CI/CD systems such as O365, we identify a new opportunity: Big Data storage and analytics systems [2], [3] are now ubiquitous.", "part": "1"}], "links": {"documentLink": "/document/5496972", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5496972", "abstract": "The Hadoop Distributed File System (HDFS) is designed to store very large data sets reliably, and to stream those data sets at high bandwidth to user applications. In a large cluster, thousands of servers both host directly attached storage and execute user application tasks. By distributing storage and computation across many servers, the resource can grow with demand while remaining economical at every size. We describe the architecture of HDFS and report on experience using HDFS to manage 25 ...", "pdfSize": "777KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+hadoop+distributed+file+system&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "M. Zaharia, M. Chowdhury, T. Das, A. Dave, J. Ma, M. McCauley, M. J. Franklin, S. Shenker, I. Stoica, \"Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing\", <em>Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation ser. NSDI'I2</em>, pp. 2-2, 2012.", "title": "Resilient distributed datasets: A fault-tolerant abstraction for in-memory cluster computing", "context": [{"sec": "sec1", "text": " However, with large CI/CD systems such as O365, we identify a new opportunity: Big Data storage and analytics systems [2], [3] are now ubiquitous.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Resilient+distributed+datasets%3A+A+fault-tolerant+abstraction+for+in-memory+cluster+computing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "S. Elbaum, M. J. Harrold, G. Rothermel, \"Test case prioritization: a family of empirical studies\", <em>IEEE Transactions on Software Engineering</em>, vol. 28, no. 10, pp. 159-182, Feb. 2002.", "title": "Test case prioritization: a family of empirical studies", "context": [{"sec": "sec1", "text": "We therefore ask the following question: Can we make high-confidence data-driven decisions towards test minimization? In other words, can we learn models and rules from past data that can guide more intelligent decisions on what subset of tests we need to run? There has been a large body of prior work in the test prioritization, selection and minimization areas [4]\u2013[8].", "part": "1"}, {"sec": "sec1", "text": " [4] which prioritizes tests based on the probability of fault existence.", "part": "1"}, {"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[16].", "part": "1"}, {"sec": "sec8b", "text": " [4] advance this further and show that fine-granularity techniques outperformed coarse-granularity techniques by a small margin.", "part": "1"}], "links": {"documentLink": "/document/988497", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=988497", "abstract": "To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of such prioritization is to increase a test suite&#39;s rate of fault detection. Previous work reported results of studies that showed that prioritization techniques can significantly improve rate of fault detection. Those studies, however, raised several additional questions: 1) Can ...", "pdfSize": "1356KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+case+prioritization%3A+a+family+of+empirical+studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "C. C. G. Rothermel, R. H. Untch, M. J. Harrold, \"Prioritizing test cases for regression testing\", <em>IEEE Transactions on Software Engineering</em>, vol. 27, no. 10, pp. 929-948, Oct. 2001.", "title": "Prioritizing test cases for regression testing", "context": [{"sec": "sec1", "text": "We therefore ask the following question: Can we make high-confidence data-driven decisions towards test minimization? In other words, can we learn models and rules from past data that can guide more intelligent decisions on what subset of tests we need to run? There has been a large body of prior work in the test prioritization, selection and minimization areas [4]\u2013[5][8].", "part": "1"}, {"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[5][8], [10]\u2013[16].", "part": "1"}, {"sec": "sec8b", "text": " [5], [7] use several techniques for using test execution information to prioritize test cases for regression testing, by ordering test cases based on their total coverage of code components; ordering based on the coverage of components not previously covered; and ordering based on their estimated ability to reveal faults.", "part": "1"}], "links": {"documentLink": "/document/962562", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=962562", "abstract": "Test case prioritization techniques schedule test cases for execution in an order that attempts to increase their effectiveness at meeting some performance goal. Various goals are possible; one involves rate of fault detection, a measure of how quickly faults are detected within the testing process. An improved rate of fault detection during testing can provide faster feedback on the system under test and let software engineers begin correcting faults earlier than might otherwise be possible. On...", "pdfSize": "920KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Prioritizing+test+cases+for+regression+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "Q. Luo, K. Moran, D. Poshyvanyk, \"A large-scale empirical comparison of static and dynamic test case prioritization techniques\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE \u201816</em>, Nov. 2016.", "title": "A large-scale empirical comparison of static and dynamic test case prioritization techniques", "context": [{"sec": "sec1", "text": "We therefore ask the following question: Can we make high-confidence data-driven decisions towards test minimization? In other words, can we learn models and rules from past data that can guide more intelligent decisions on what subset of tests we need to run? There has been a large body of prior work in the test prioritization, selection and minimization areas [4]\u2013[6][8].", "part": "1"}, {"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[6][8], [10]\u2013[16].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950344", "abstract": "The large body of existing research in Test Case Prioritization (TCP) techniques, can be broadly classified into two categories: dynamic techniques (that rely on run-time execution information) and static techniques (that operate directly on source and test code). Absent from this current body of work is a comprehensive study aimed at understanding and evaluating the static approaches and comparing them to dynamic approaches on a large set of projects. In this work, we perform the first extensiv...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+large-scale+empirical+comparison+of+static+and+dynamic+test+case+prioritization+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "G. Rothermel, M. J. Harrold, J. V. Ronne, C. Hong, \"Empirical studies of test-suite reduction. software testing verification and reliability\", <em>Software Testing Verification and Reliability</em>, 2002.", "title": "Empirical studies of test-suite reduction. software testing, verification and reliability", "context": [{"sec": "sec1", "text": "We therefore ask the following question: Can we make high-confidence data-driven decisions towards test minimization? In other words, can we learn models and rules from past data that can guide more intelligent decisions on what subset of tests we need to run? There has been a large body of prior work in the test prioritization, selection and minimization areas [4]\u2013[7][8].", "part": "1"}, {"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[7][8], [10]\u2013[16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[16].", "part": "1"}, {"sec": "sec8b", "text": " In their seminal work Rothermel et al. [5], [7] use several techniques for using test execution information to prioritize test cases for regression testing, by ordering test cases based on their total coverage of code components; ordering based on the coverage of components not previously covered; and ordering based on their estimated ability to reveal faults.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stvr.256", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Empirical+studies+of+test-suite+reduction.+software+testing%2C+verification+and+reliability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "A. Vahabzadeh, A. Stocco, A. Mesbah, \"Fine-grained test minimization\", <em>ACM/IEEE 40th International Conference on Software Engineering</em>, 2018.", "title": "Fine-grained test minimization", "context": [{"sec": "sec1", "text": "We therefore ask the following question: Can we make high-confidence data-driven decisions towards test minimization? In other words, can we learn models and rules from past data that can guide more intelligent decisions on what subset of tests we need to run? There has been a large body of prior work in the test prioritization, selection and minimization areas [4]\u2013[8].", "part": "1"}, {"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[16].", "part": "1"}, {"sec": "sec7a", "text": " The properties we observe and build upon - commit risk prediction, inter-test correlation, and intra-test correlation - are inherent to several large-scale software development processes [8], [28].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[16].", "part": "1"}, {"sec": "sec8b", "text": " [8] have recently proposed a technique that uses code instrumentation to analyze and remove fine-grained redundancy within tests.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.29007/qd4q", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fine-grained+test+minimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "A. Hindle, D. M. German, R. Holt, \"What do alrge commits tell us? a taxonomical study of large commits\", <em>Proceedings of MSR</em>, 2008.", "title": "What do alrge commits tell us? a taxonomical study of large commits", "context": [{"sec": "sec1", "text": " This, by itself, is not a new finding: prior work has found this to hold for large open-source software repositories [9].", "part": "1"}, {"sec": "sec3b", "text": " We choose such features based on previous findings that certain types of file changes are more likely to cause bugs than others [9].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+do+alrge+commits+tell+us%3F+a+taxonomical+study+of+large+commits&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "L. Zhang, \"Hybrid regression test selection\", <em>Proceedings of ICSE</em>, 2018.", "title": "Hybrid regression test selection", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[16].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180198", "abstract": "Regression testing is crucial but can be extremely costly. Regression Test Selection (RTS) aims to reduce regression testing cost by only selecting and running the tests that may be affected by code changes. To date, various RTS techniques analyzing at different granularities (e.g., at the basic-block, method, and file levels) have been proposed. RTS techniques working on finer granularities may be more precise in selecting tests, while techniques working on coarser granularities may have lower ...", "pdfSize": "315KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hybrid+regression+test+selection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "J. Black, E. Melachrinoudis, D. Kaeli, \"Bi-criteria models for all-uses test suite reduction\", <em>Proceedings. 26th International Conference on Software Engineering</em>, pp. 106-115, May 2004.", "title": "Bi-criteria models for all-uses test suite reduction", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[11][16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[11][16].", "part": "1"}], "links": {"documentLink": "/document/1317433", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1317433", "abstract": "Using bi-criteria decision making analysis, a new model for test suite minimization has been developed that pursues two objectives: minimizing a test suite with regard to a particular level of coverage while simultaneously maximizing error detection rates. This new representation makes it possible to achieve significant reductions in test suite size without experiencing a decrease in error detection rates. Using the all-uses inter-procedural data flow testing criterion, two binary integer linear...", "pdfSize": "321KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bi-criteria+models+for+all-uses+test+suite+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "M. J. Harrold, R. Gupta, M. L. Soffa, \"A methodology for controlling the size of a test suite\", <em>ACM Trans. Softw. Eng. Methodol.</em>, vol. 2, no. 3, pp. 270-285, Jul. 1993.", "title": "A methodology for controlling the size of a test suite", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[12][16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[12][16].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/152388.152391", "abstract": "This paper presents a technique to select a representative set of test cases from a test suite that provides the same coverage as the entire test suite. This selection is performed by identifying, and then eliminating, the redundant and obsolete test cases in the test suite. The representative set replaces the original test suite and thus, potentially produces a smaller test suite. The representative set can also be used to identify those test cases that should be rerun to test the program after...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+methodology+for+controlling+the+size+of+a+test+suite&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. A. Jones, M. J. Harrold, \"Test-suite reduction and prioritization for modified condition/decision coverage\", <em>IEEE Transactions on Software Engineering</em>, vol. 29, no. 3, pp. 195-209, March 2003.", "title": "Test-suite reduction and prioritization for modified condition/decision coverage", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[13][16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[13][16].", "part": "1"}], "links": {"documentLink": "/document/1183927", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1183927", "abstract": "Software testing is particularly expensive for developers of high-assurance software, such as software that is produced for commercial airborne systems. One reason for this expense is the Federal Aviation Administration&#39;s requirement that test suites be modified condition/decision coverage (MC/DC) adequate. Despite its cost, there is evidence that MC/DC is an effective verification technique and can help to uncover safety faults. As the software is modified and new test cases are added to the te...", "pdfSize": "1195KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test-suite+reduction+and+prioritization+for+modified+condition%2Fdecision+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "T. Chen, M. Lau, \"A new heuristic for test suite reduction\", <em>Information and Software Technology</em>, vol. 40, no. 5, pp. 347-354, 1998.", "title": "A new heuristic for test suite reduction", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[14][16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[14][16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0950-5849(98)00050-0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+new+heuristic+for+test+suite+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "S. Yoo, M. Harman, \"Regression testing minimization selection and prioritization: A survey\", <em>Softw. Test. Verif. Reliab.</em>, vol. 22, no. 2, pp. 67-120, Mar. 2012.", "title": "Regression testing minimization, selection and prioritization: A survey", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[15][16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[15][16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stv.430", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Regression+testing+minimization%2C+selection+and+prioritization%3A+A+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "D. Jeffrey, N. Gupta, \"Improving fault detection capability by selectively retaining test cases during test suite reduction\", <em>IEEE Transactions on Software Engineering</em>, vol. 33, no. 2, pp. 108-123, Feb 2007.", "title": "Improving fault detection capability by selectively retaining test cases during test suite reduction", "context": [{"sec": "sec2b", "text": " A large amount of previous work targets the problem of test selection, i.e., how we can use code-coverage metrics and static analysis techniques to prune the set of tests to run for a given commit [4]\u2013[8], [10]\u2013[16].", "part": "1"}, {"sec": "sec8b", "text": "A large body of work concentrates on the problem of test selection and minimization [7], [8], [10]\u2013-[16].", "part": "1"}], "links": {"documentLink": "/document/4052586", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4052586", "abstract": "Software testing is a critical part of software development. As new test cases are generated over time due to software modifications, test suite sizes may grow significantly. Because of time and resource constraints for testing, test suite minimization techniques are needed to remove those test cases from a suite that, due to code modifications over time, have become redundant with respect to the coverage of testing requirements for which they were generated. Prior work has shown that test suite...", "pdfSize": "7007KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+fault+detection+capability+by+selectively+retaining+test+cases+during+test+suite+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "N. Nagappan, T. Ball, \"Using software dependencies and churn metrics to predict field failures: An empirical case study\", <em>Proceedings of ESEM</em>, 2007.", "title": "Using software dependencies and churn metrics to predict field failures: An empirical case study", "context": [{"sec": "sec3b", "text": "The more often a file changes, the more risky it is [1], [17].", "part": "1"}, {"sec": "sec8a", "text": " [17] have shown how code churn correlates with field failures.", "part": "1"}], "links": {"documentLink": "/document/4343764", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4343764", "abstract": "Commercial software development is a complex task that requires a thorough understanding of the architecture of the software system. We analyze the Windows Server 2003 operating system in order to assess the relationship between its software dependencies, churn measures and post-release failures. Our analysis indicates the ability of software dependencies and churn measures to be efficient predictors of post-release failures. Further, we investigate the relationship between the software dependen...", "pdfSize": "173KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+software+dependencies+and+churn+metrics+to+predict+field+failures%3A+An+empirical+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "C. Bird, N. Nagappan, B. Murphy, H. Gall, P. T. Devanbu, \"Don't touch my code!: examining the effects of ownership on software quality\", <em>Proceedings of FSE</em>, 2011.", "title": "Don't touch my code!: examining the effects of ownership on software quality", "context": [{"sec": "sec3b", "text": "Number of contributors to a file affects risk [1], [18].", "part": "1"}, {"sec": "sec3b", "text": " For each file, we also leverage previous work on ownership to record the developers who are major and minor owners [18] of the file, and their percentage of ownership.", "part": "1"}, {"sec": "sec8a", "text": " [18] have shown that code ownership (or the lack thereof) has a direct correlation with software defects.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025119", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Don%27t+touch+my+code%21%3A+examining+the+effects+of+ownership+on+software+quality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>Microsoft. Fasttree (gradient boosted trees)</em>,  [online]  Available: https://docs.microsoft.com/en-us/machine-learning-server/r-reference/microsoftml/rxfasttrees.", "title": "Microsoft. Fasttree (gradient boosted trees)", "context": [{"sec": "sec3b", "text": " The FastTree [19] algorithm, a fast implementation of gradient-boosted decision trees [20], achieved good precision, Fl-score and AUC values, while remaining easily interpretable.", "part": "1"}, {"sec": "sec6b", "text": " FastLane uses FastTree [19], as the interpretability of the decision trees allows us to reason about the model's predictions.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Microsoft.+Fasttree+%28gradient+boosted+trees%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J. H. Friedman, \"Greedy function approximation: A gradient boosting machine\", <em>Annals of Statistics</em>, vol. 29, pp. 1189-1232, 2000.", "title": "Greedy function approximation: A gradient boosting machine", "context": [{"sec": "sec3b", "text": " The FastTree [19] algorithm, a fast implementation of gradient-boosted decision trees [20], achieved good precision, Fl-score and AUC values, while remaining easily interpretable.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1214/aos/1013203451", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Greedy+function+approximation%3A+A+gradient+boosting+machine&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "R. Agrawal, R. Srikant, \"Fast algorithms for mining association rules in large databases\", <em>Proceedings of the 20th International Conference on Very Large Data Bases ser. VLDB \u201894</em>, pp. 487-499, 1994.", "title": "Fast algorithms for mining association rules in large databases", "context": [{"sec": "sec3c", "text": "An alternative approach would be to use rule-mining algorithms such as Apriori [21] to discover not just test-pairs but larger clusters of tests that pass and fail together.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fast+algorithms+for+mining+association+rules+in+large+databases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>Microsoft. Ml.net machine learning framework</em>,  [online]  Available: https://www.microsoft.com/net/learn/apps/machine-Iearning-and-ai/ml-dotnet.", "title": "Microsoft. Ml.net machine learning framework", "context": [{"sec": "sec5", "text": " Net library [22] to build our machine-learning models and evaluate them.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Microsoft.+Ml.net+machine+learning+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "C. M. Bishop, Pattern Recognition and Machine Learning (Information Science and Statistics), Berlin, Heidelberg:Springer-Verlag, 2006.", "title": "Pattern Recognition and Machine Learning (Information Science and Statistics)", "context": [{"sec": "sec6a", "text": " We believe this approach is more suitable than standard cross-validation [23] because system properties change with time.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pattern+Recognition+and+Machine+Learning+%28Information+Science+and+Statistics%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "S. Shalev-Shwartz, Y. Singer, N. Srebro, A. Cotter, \"Pegasos: primal estimated sub-gradient solver for svm\", <em>Mathematical Programming</em>, vol. 127, no. 1, pp. 3-30, Mar 2011.", "title": "Pegasos: primal estimated sub-gradient solver for svm", "context": [], "links": {"crossRefLink": "https://doi.org/10.1007/s10107-010-0420-4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pegasos%3A+primal+estimated+sub-gradient+solver+for+svm&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "C. Jose, P. Goyal, P. Aggrwal, M. Varma, \"Local deep kernel learning for efficient non-linear svm prediction\", <em>Proceedings of the 30th International Conference on International Conference on Machine Learning - Volume 28 ser. ICML'13. JMLR.org</em>, pp. III-486-III-494, 2013.", "title": "Local deep kernel learning for efficient non-linear svm prediction", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Local+deep+kernel+learning+for+efficient+non-linear+svm+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "T. Chen, C. Guestrin, \"Xgboost: A scalable tree boosting system\", <em>Proceedings of the 22Nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining ser. KDD \u201816</em>, pp. 785-794, 2016.", "title": "Xgboost: A scalable tree boosting system", "context": [], "links": {"acmLink": "https://doi.org/10.1145/2939672.2939785", "abstract": "Tree boosting is a highly effective and widely used machine learning method. In this paper, we describe a scalable end-to-end tree boosting system called XGBoost, which is used widely by data scientists to achieve state-of-the-art results on many machine learning challenges. We propose a novel sparsity-aware algorithm for sparse data and weighted quantile sketch for approximate tree learning. More importantly, we provide insights on cache access patterns, data compression and sharding to build a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Xgboost%3A+A+scalable+tree+boosting+system&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "C. Tantithamthavorn, A. E. Hassan, K. Matsumoto, \"The impact of class rebalancing techniques on the performance and interpretation of defect prediction models\", 2018,  [online]  Available: http://arxiv.org/abs/1801.10269.", "title": "The impact of class rebalancing techniques on the performance and interpretation of defect prediction models", "context": [{"sec": "sec6b", "text": " Also, a model with an AUC greater than 0.7 for a given classification problem is considered suitable to use for that problem [27].", "part": "1"}], "links": {"abstract": "Defect models that are trained on class imbalanced datasets (i.e., the proportion of defective and clean modules is not equally represented) are highly susceptible to produce inaccurate prediction models. Prior research compares the impact of class rebalancing techniques on the performance of defect models but arrives at contradictory conclusions due to the use of different choice of datasets, classification techniques, and performance measures. Such contradictory conclusions make it hard to der...", "pdfSize": "2913KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+class+rebalancing+techniques+on+the+performance+and+interpretation+of+defect+prediction+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "F. Rahman, P. Devanbu, \"How and why process metrics are better\", <em>Proceedings of ICSE</em>, 2013.", "title": "How, and why, process metrics are better", "context": [{"sec": "sec7a", "text": " The properties we observe and build upon - commit risk prediction, inter-test correlation, and intra-test correlation - are inherent to several large-scale software development processes [8], [28].", "part": "1"}, {"sec": "sec8a", "text": " Past research has also shown that process-level features are more effective at predicting software defects than code-level features [28], [33].", "part": "1"}], "links": {"documentLink": "/document/7190081", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7190081", "abstract": "Defect prediction techniques could potentially help us to focus quality-assurance efforts on the most defect-prone files. Modern statistical tools make it very easy to quickly build and deploy prediction models. Software metrics are at the heart of prediction models; understanding how and especially why different types of metrics are effective is very important for successful model deployment. In this paper we analyze the applicability and efficacy of process and code metrics from several differ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How%2C+and+why%2C+process+metrics+are+better&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Q. Luo, F. Hariri, L. Eloussi, D. Marinov, \"An empirical analysis of flaky tests\", <em>Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2014</em>, pp. 643-653, 2014.", "title": "An empirical analysis of flaky tests", "context": [{"sec": "sec7b", "text": "Prior work [29], [30] has investigated the problem of flaky tests and these could affect the validity of our models and rules.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635920", "abstract": "Regression testing is a crucial part of software development. It checks that software changes do not break existing functionality. An important assumption of regression testing is that test outcomes are deterministic: an unmodified test is expected to either always pass or always fail for the same code under test. Unfortunately, in practice, some tests often called flaky tests\u2014have non-deterministic outcomes. Such tests undermine the regression testing as they make it difficult to rely on test r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+analysis+of+flaky+tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "A. Vahabzadeh, A. M. Fard, A. Mesbah, \"An empirical study of bugs in test code\", <em>2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 101-110, Sept 2015.", "title": "An empirical study of bugs in test code", "context": [{"sec": "sec7b", "text": "Prior work [29], [30] has investigated the problem of flaky tests and these could affect the validity of our models and rules.", "part": "1"}], "links": {"documentLink": "/document/7332456", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7332456", "abstract": "Testing aims at detecting (regression) bugs in production code. However, testing code is just as likely to contain bugs as the code it tests. Buggy test cases can silently miss bugs in the production code or loudly ring false alarms when the production code is correct. We present the first empirical study of bugs in test code to characterize their prevalence and root cause categories. We mine the bug repositories and version control systems of 211 Apache Software Foundation (ASF) projects and fi...", "pdfSize": "600KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+bugs+in+test+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "T. Zimmermann, R. Premraj, A. Zeller, \"Predicting defects for Eclipse\", <em>Proceedings of PROMISE</em>, 2007.", "title": "Predicting defects for Eclipse", "context": [{"sec": "sec8a", "text": " Zimmermann et al. have shown that defects can be attributed at component or file-level [31], [32].", "part": "1"}], "links": {"documentLink": "/document/4273265", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4273265", "abstract": "We have mapped defects from the bug database of eclipse (one of the largest open-source projects) to source code locations. The resulting data set lists the number of pre- and post-release defects for every package and file in the eclipse releases 2.0, 2.1, and 3.0. We additionally annotated the data with common complexity metrics. All data is publicly available and can serve as a benchmark for defect prediction models.", "pdfSize": "168KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+defects+for+Eclipse&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "S. Kim, T. Zimmermann, E. J. W., Z. Zeller, \"Predicting faults from cached history\", <em>Proceedings of ICSE</em>, 2007.", "title": "Predicting faults from cached history", "context": [{"sec": "sec8a", "text": " Zimmermann et al. have shown that defects can be attributed at component or file-level [31], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+faults+from+cached+history&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "R. Moser, W. Pedrycz, G. Succi, \"A comparative analysis of the efficiency of change metrics and statis code attributes for defect prediction\", <em>Proceedings of ICSE</em>, 2008.", "title": "A comparative analysis of the efficiency of change metrics and statis code attributes for defect prediction", "context": [{"sec": "sec8a", "text": " Past research has also shown that process-level features are more effective at predicting software defects than code-level features [28], [33].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+comparative+analysis+of+the+efficiency+of+change+metrics+and+statis+code+attributes+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "S. R. Chidamber, C. F. Kemerer, \"A metrics suite for object oriented design\", <em>IEEE Transactions on Software Engineering</em>, vol. 20, no. 6, pp. 476-493, Jun. 1994.", "title": "A metrics suite for object oriented design", "context": [{"sec": "sec8a", "text": " Basili et al. investigated the ability of the classic CK Object-oriented design metrics [34] to predict fault-proneness [35].", "part": "1"}], "links": {"documentLink": "/document/295895", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=295895", "abstract": "Given the central role that software development plays in the delivery and application of information technology, managers are increasingly focusing on process improvement in the software development area. This demand has spurred the provision of a number of new and/or improved approaches to software development, with perhaps the most prominent being object-orientation (OO). In addition, the focus on process improvement has increased the demand for software measures, or metrics with which to man...", "pdfSize": "1901KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+metrics+suite+for+object+oriented+design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "V. R. Basili, L. C. Briand, W. L. Melo, \"A validation of object-oriented design metrics as quality indicators\", <em>IEEE Transactions on Software Engineering</em>, vol. 22, no. 10, pp. 751-761, 1996.", "title": "A validation of object-oriented design metrics as quality indicators", "context": [{"sec": "sec8a", "text": " Basili et al. investigated the ability of the classic CK Object-oriented design metrics [34] to predict fault-proneness [35].", "part": "1"}], "links": {"documentLink": "/document/544352", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=544352", "abstract": "This paper presents the results of a study in which we empirically investigated the suite of object-oriented (OO) design metrics introduced in (Chidamber and Kemerer, 1994). More specifically, our goal is to assess these metrics as predictors of fault-prone classes and, therefore, determine whether they can be used as early quality indicators. This study is complementary to the work described in (Li and Henry, 1993) where the same suite of metrics had been used to assess frequencies of maintenan...", "pdfSize": "1508KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+validation+of+object-oriented+design+metrics+as+quality+indicators&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "F. Jaafar, S. Hassaine, Y.-G. Gu\u00e9h\u00e9neuc, S. Hamel, B. Adams, \"On the relationship between program evolution and fault-proneness: An empirical study\", <em>Software Maintenance and Reengineering (CSMR)2013 17th European Conference</em>, pp. 15-24, 2013.", "title": "On the relationship between program evolution and fault-proneness: An empirical study", "context": [{"sec": "sec8a", "text": " [36] investigating the effect of time found that classes having a specific lifetime model are significantly less fault-prone than other classes, and faults fixed by maintaining co-evolved classes, are significantly more frequent than others.", "part": "1"}], "links": {"documentLink": "/document/6498451", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6498451", "abstract": "Over the years, many researchers have studied the evolution and maintenance of object-oriented source code in order to understand the possibly costly erosion of the software. However, many studies thus far did not link the evolution of classes to faults. Since (1) some classes evolve independently, other classes have to do it together with others (co-evolution), and (2) not all classes are meant to last forever, but some are meant for experimentation or to try out an idea that was then dropped o...", "pdfSize": "358KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+relationship+between+program+evolution+and+fault-proneness%3A+An+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "D. Hao, X. Wu, L. Zhang, \"An empirical study of execution-data classification based on machine learning\", <em>SEKE</em>, 2012.", "title": "An empirical study of execution-data classification based on machine learning", "context": [{"sec": "sec8b", "text": " It is also important to note that FastLane differs from work on code execution classification [37], which tries to classify the outcome of a program execution as a pass or fail after it has completed, while FastLane predicts the outcome of a test before it has completed.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+execution-data+classification+based+on+machine+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "A. Srivastava, J. Thiagarajan, \"Predicting defects using change genealogies\", <em>Proceedings of the 2002 ACM SIGSOFT international symposium on Software testing and analysis ser. ISSTA \u201802</em>, 2002.", "title": "Predicting defects using change genealogies", "context": [{"sec": "sec8b", "text": " Work at Microsoft [38] describes Echelon, a test prioritization system that works on binary code to scale to large binaries and to enable the testing of large systems like Windows.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+defects+using+change+genealogies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "J. Andrews, \"Testing using log file analysis: Tools methods and issues\", <em>Proceedings of the 13th IEEE international conference on Automated software engineering ser. ASE'98</em>, 1998.", "title": "Testing using log file analysis: Tools, methods, and issues", "context": [{"sec": "sec8c", "text": "Andrews [39] first investigated the use of log files for testing, presenting a framework for automatically analyzing log files, and defining a language for specifying analyzer programs.", "part": "1"}], "links": {"documentLink": "/document/732614", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=732614", "abstract": "Large software systems often keep log files of events. Such log files can be analyzed to check whether a run of a program reveals faults in the system. We discuss how such log files can be used in software testing. We present a framework for automatically analyzing log files, and describe a language for specifying analyzer programs and an implementation of that language. The language permits compositional, compact specifications of software, which act as test oracles; we discuss the use and effi...", "pdfSize": "67KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+using+log+file+analysis%3A+Tools%2C+methods%2C+and+issues&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812033", "articleId": "8812033", "startPage": "408", "endPage": "418", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 97}}
{"title": "DLFinder: Characterizing and Detecting Duplicate Logging Code Smells", "authors": [{"name": "Zhenhao Li", "affiliation": "Concordia University, Canada", "firstName": "Zhenhao", "lastName": "Li", "id": "37086941387"}, {"name": "Tse-Hsun Chen", "affiliation": "Concordia University, Canada", "firstName": "Tse-Hsun", "lastName": "Chen", "id": "37085566723"}, {"name": "Jinqiu Yang", "affiliation": "Concordia University, Canada", "firstName": "Jinqiu", "lastName": "Yang", "id": "37086944177"}, {"name": "Weiyi Shang", "affiliation": "Concordia University, Canada", "firstName": "Weiyi", "lastName": "Shang", "id": "37314640200"}], "abstract": "Developers rely on software logs for a wide variety of tasks, such as debugging, testing, program comprehension, verification, and performance analysis. Despite the importance of logs, prior studies show that there is no industrial standard on how to write logging statements. Recent research on logs often only considers the appropriateness of a log as an individual item (e.g., one single logging statement); while logs are typically analyzed in tandem. In this paper, we focus on studying duplicate logging statements, which are logging statements that have the same static text message. Such duplications in the text message are potential indications of logging code smells, which may affect developers' understanding of the dynamic view of the system. We manually studied over 3K duplicate logging statements and their surrounding code in four large-scale open source systems: Hadoop, CloudStack, ElasticSearch, and Cassandra. We uncovered five patterns of duplicate logging code smells. For each instance of the code smell, we further manually identify the problematic (i.e., require fixes) and justifiable (i.e., do not require fixes) cases. Then, we contact developers in order to verify our manual study result. We integrated our manual study result and developers' feedback into our automated static analysis tool, DLFinder, which automatically detects problematic duplicate logging code smells. We evaluated DLFinder on the four manually studied systems and two additional systems: Camel and Wicket. In total, combining the results of DLFinder and our manual analysis, we reported 82 problematic code smell instances to developers and all of them have been fixed.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Manuals", "Static analysis", "Cloud computing", "Debugging", "Tools", "Semantics", "Java"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["cloud computing", "data handling", "parallel processing", "program debugging", "program diagnostics", "public domain software"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["DLFinder", "duplicate logging code smells", "software logs", "single logging statement", "duplicate logging statements", "problematic duplicate logging code", "static text message", "dynamic view", "open source systems", "Hadoop", "CloudStack", "ElasticSearch", "Cassandra", "developers feedback"]}, {"type": "Author Keywords ", "kwd": ["log", "code smell", "duplicate log", "static analysis", "empirical study"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00032", "ref": [{"order": "1", "text": "<em>Changes to JobHistory makes it backward incompatible</em>,  [online]  Available: https://issues.apache.org/jira/browse/HADOOP-4190.", "title": "Changes to JobHistory makes it backward incompatible", "context": [{"sec": "sec3", "text": " Inconsistent log messages may cause problems during log analysis [1], [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Changes+to+JobHistory+makes+it+backward+incompatible&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Log4j</em>,  [online]  Available: http://logging.apache.org/log4j/2.x/.", "title": "Log4j", "context": [{"sec": "sec1", "text": " The logging statement is at the error level, which is the level for recording failed operations [2].", "part": "1"}, {"sec": "sec2", "text": " The studied systems use the widely used Java logging libraries (e.g., Log4j [2] and SLF4J [3]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Log4j&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>imple logging facade for Java (SLF4J)</em>,  [online]  Available: http://www.slf4j.org.", "title": "imple logging facade for Java (SLF4J)", "context": [{"sec": "sec2", "text": " The studied systems use the widely used Java logging libraries (e.g., Log4j [2] and SLF4J [3]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=imple+logging+facade+for+Java+%28SLF4J%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "S. L. Abebe, S. Haiduc, P. Tonella, A. Marcus, \"The effect of lexicon bad smells on concept location in source code\", <em>2011 IEEE 11th International Working Conference on Source Code Analysis and Manipulation</em>, pp. 125-134, Sept 2011.", "title": "The effect of lexicon bad smells on concept location in source code", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"documentLink": "/document/6065171", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6065171", "abstract": "Experienced programmers choose identifier names carefully, in the attempt to convey information about the role and behavior of the labeled code entity in a concise and expressive way. In fact, during program understanding the names given to code entities represent one of the major sources of information used by developers. We conjecture that lexicon bad smells, such as, extreme contractions, inconsistent term use, odd grammatical structure, etc., can hinder the execution of maintenance tasks whi...", "pdfSize": "355KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+effect+of+lexicon+bad+smells+on+concept+location+in+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "I. Ahmed, C. Brindescu, U. A. Mannan, C. Jensen, A. Sarma, \"An empirical examination of the relationship between code smells and merge conflicts\", <em>Proceedings of the 11th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement ser. ESEM \u201817</em>, pp. 58-67, 2017.", "title": "An empirical examination of the relationship between code smells and merge conflicts", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"documentLink": "/document/8170085", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8170085", "abstract": "Background: Merge conflicts are a common occurrence in software development. Researchers have shown the negative impact of conflicts on the resulting code quality and the development workflow. Thus far, no one has investigated the effect of bad design (code smells) on merge conflicts. Aims: We posit that entities that exhibit certain types of code smells are more likely to be involved in a merge conflict. We also postulate that code elements that are both &#34;smelly&#34; and involved in a merge conflic...", "pdfSize": "377KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+examination+of+the+relationship+between+code+smells+and+merge+conflicts&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "H. Barringer, A. Groce, K. Havelund, M. H. Smith, \"Formal analysis of log files\", <em>JACIC</em>, vol. 7, no. 11, pp. 365-390, 2010.", "title": "Formal analysis of log files", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2514/1.49356", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Formal+analysis+of+log+files&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "S. Boslaugh, P. Watters, Statistics in a Nutshell: A Desktop Quick Reference ser. In a Nutshell (O\u2018Reilly), O'Reilly Media, 2008.", "title": "Statistics in a Nutshell: A Desktop Quick Reference, ser. In a Nutshell (O\u2018Reilly)", "context": [{"sec": "sec3", "text": "Phase I: The first two authors manually studied 289 randomly sampled (based on 95% confidence level and 5% confidence interval [7]) sets of duplicate logging statements and the surrounding code to derive an initial list of duplicate logging code smell patterns.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Statistics+in+a+Nutshell%3A+A+Desktop+Quick+Reference%2C+ser.+In+a+Nutshell+%28O%E2%80%98Reilly%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "D. Budgen, Software Design, Addison-Wesley, 2003.", "title": "Software Design", "context": [{"sec": "sec1", "text": " We follow prior code smell studies [8], [17], and consider duplicate logging code smell as a \u201csurface indication that usually corresponds to a deeper problem in the system\u201d.", "part": "1"}, {"sec": "sec3", "text": " Similar to prior code smell studies [8], [17], we consider duplicate logging code smells as a \u201csurface indication that usually corresponds to a deeper problem in the system\u201d.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+Design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "N. Busany, S. Maoz, \"Behavioral log analysis with statistical guarantees\", <em>Proceedings of the 38th International Conference on Software Engineering ser. ICSE \u201816</em>, pp. 877-887, 2016.", "title": "Behavioral log analysis with statistical guarantees", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Behavioral+log+analysis+with+statistical+guarantees&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "C. Chapman, P. Wang, K. T. Stolee, \"Exploring regular expression comprehension\", <em>2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 405-416, Oct 2017.", "title": "Exploring regular expression comprehension", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"documentLink": "/document/8115653", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115653", "abstract": "The regular expression (regex) is a powerful tool employed in a large variety of software engineering tasks. However, prior work has shown that regexes can be very complex and that it could be difficult for developers to compose and understand them. This work seeks to identify code smells that impact comprehension. We conduct an empirical study on 42 pairs of behaviorally equivalent but syntactically different regexes using 180 participants and evaluate the understandability of various regex lan...", "pdfSize": "238KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+regular+expression+comprehension&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "B. Chen, Z. M. (Jack) Jiang, \"Characterizing logging practices in java-based open source software projects - a replication study in apche software foundation\", <em>Empirical Software Engineering</em>, vol. 22, no. 1, pp. 330-374, Feb 2017.", "title": "Characterizing logging practices in java-based open source software projects - a replication study in apche software foundation", "context": [{"sec": "sec7", "text": "There are several studies on characterizing the logging practices in software systems [11], [18], [50], Yuan et al. [50] conducted a quantitative characteristics study on log messages for large-scale open source C/C++ systems.", "part": "1"}, {"sec": "sec7", "text": " [11] replicated the study by Yuan et al. [50] on Java open-source projects.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-016-9429-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+logging+practices+in+java-based+open+source+software+projects+-+a+replication+study+in+apche+software+foundation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "B. Chen, Z. M. J. Jiang, \"Characterizing and detecting anti-patterns in the logging code\", <em>Proceedings of the 39th International Conference on Software Engineering ser. ICSE \u201817</em>, pp. 71-81, 2017.", "title": "Characterizing and detecting anti-patterns in the logging code", "context": [{"sec": "sec1", "text": " A few recent studies [12], [20] aim to detect potential problems in logging statements.", "part": "1"}, {"sec": "sec2", "text": "We identify duplicate logging statements from four large-scale open source Java systems: Hadoop, CloudStack, ElasticSearch, and Cassandra, which are commonly used in prior studies for log-related research [12], [20], [28].", "part": "1"}, {"sec": "sec7", "text": " [12] concluded five categories of logging anti-patterns from code changes, and implemented a tool to detect the anti-patterns.", "part": "1"}], "links": {"documentLink": "/document/7985651", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985651", "abstract": "Snippets of logging code are output statements (e.g., LOG.info or System.out.println) that developers insert into a software system. Although more logging code can provide more execution context of the system&#39;s behavior during runtime, it is undesirable to instrument the system with too much logging code due to maintenance overhead. Furthermore, excessive logging may cause unexpected side-effects like performance slow-down or high disk I/O bandwidth. Recent studies show that there are no well-de...", "pdfSize": "1276KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+and+detecting+anti-patterns+in+the+logging+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "B. Chen, J. Song, P. Xu, X. Hu, Z. M. J. Jiang, \"An automated approach to estimating code coverage measures via execution logs\", <em>Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering ASE 2018</em>, pp. 305-316, September 3\u20137, 2018.", "title": "An automated approach to estimating code coverage measures via execution logs", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3238147.3238214", "abstract": "Software testing is a widely used technique to ensure the quality of software systems. Code coverage measures are commonly used to evaluate and improve the existing test suites. Based on our industrial and open source studies, existing state-of-the-art code coverage tools are only used during unit and integration testing due to issues like engineering challenges, performance overhead, and incomplete results. To resolve these issues, in this paper we have proposed an automated approach, called Lo...", "pdfSize": "325KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+automated+approach+to+estimating+code+coverage+measures+via+execution+logs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "T.-H. Chen, W. Shang, A. E. Hassan, M. Nasser, P. Flora, \"Cacheop-timizer: Helping developers configure caching frameworks for hibernate-based database-centric web applications\", <em>Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2016</em>, pp. 666-677, 2016.", "title": "Cacheop-timizer: Helping developers configure caching frameworks for hibernate-based database-centric web applications", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}, {"sec": "sec1", "text": " However, these studies often only consider the appropriateness of one single logging statement as an individual item; while logs are typically analyzed in tandem [14], [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cacheop-timizer%3A+Helping+developers+configure+caching+frameworks+for+hibernate-based+database-centric+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "T.-H. Chen, M. D. Syer, W. Shang, Z. M. Jiang, A. E. Hassan, M. Nasser, P. Flora, \"Analytics-driven load testing: An industrial experience report on load testing of large-scale systems\", <em>Proceedings of the 39th International Conference on Software Engineering: Software Engineering in Practice Track</em>, pp. 243-252, 2017.", "title": "Analytics-driven load testing: An industrial experience report on load testing of large-scale systems", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "links": {"documentLink": "/document/7965448", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7965448", "abstract": "Assessing how large-scale software systems behave under load is essential because many problems cannot be uncovered without executing tests of large volumes of concurrent requests. Load-related problems can directly affect the customer-perceived quality of systems and often cost companies millions of dollars. Load testing is the standard approach for assessing how a system behaves under load. However, designing, executing and analyzing a load test can be very difficult due to the scale of the te...", "pdfSize": "331KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analytics-driven+load+testing%3A+An+industrial+experience+report+on+load+testing+of+large-scale+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "T.-H. Chen, S. W. Thomas, A. E. Hassan, \"A survey on the use of topic models when mining software repositories\", <em>Empirical Software Engineering</em>, vol. 21, no. 5, pp. 1843-1919, 2016.", "title": "A survey on the use of topic models when mining software repositories", "context": [{"sec": "sec4", "text": " Hence, DLFinder analyzes the text in both the log message and the class-method name (i.e., concatenation of class name and method name) to detect LM by applying commonly used text analysis approaches [16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-015-9402-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+on+the+use+of+topic+models+when+mining+software+repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Fowler, K. Beck, Refactoring: Improving the Design of Existing Code ser., Addison-Wesley object technology series, 1999.", "title": "Refactoring: Improving the Design of Existing Code, ser.", "context": [{"sec": "sec1", "text": " We follow prior code smell studies [8], [17], and consider duplicate logging code smell as a \u201csurface indication that usually corresponds to a deeper problem in the system\u201d.", "part": "1"}, {"sec": "sec3", "text": " Similar to prior code smell studies [8], [17], we consider duplicate logging code smells as a \u201csurface indication that usually corresponds to a deeper problem in the system\u201d.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Refactoring%3A+Improving+the+Design+of+Existing+Code%2C+ser.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Q. Fu, J. Zhu, W. Hu, J.-G. Lou, R. Ding, Q. Lin, D. Zhang, T. Xie, \"Where do developers log? an empirical study on logging practices in industry\", <em>Proceedings of the 36th International Conference on Software Engineering ser. ICSE-SEIP \u201814</em>, pp. 24-33, 2014.", "title": "Where do developers log? an empirical study on logging practices in industry", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}, {"sec": "sec1", "text": "Even though developers have been analyzing logs for decades [24], there exists no industrial standard on how to write logging statements [18], [35].", "part": "1"}, {"sec": "sec3", "text": " As shown in prior studies [18], [28], [54], logging decisions, such as log messages and log levels, are often associated with the structure and semantics of the surrounding code.", "part": "1"}, {"sec": "sec7", "text": "There are several studies on characterizing the logging practices in software systems [11], [18], [50], Yuan et al. [50] conducted a quantitative characteristics study on log messages for large-scale open source C/C++ systems.", "part": "1"}, {"sec": "sec7", "text": " [18] studied where developers in Microsoft add logging statements in the code and summarized several typical logging strategies.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2591062.2591175", "abstract": "System logs are widely used in various tasks of software system management. It is crucial to avoid logging too little or too much. To achieve so, developers need to make informed decisions on where to log and what to log in their logging practices during development. However, there exists no work on studying such logging practices in industry or helping developers make informed decisions. To fill this significant gap, in this paper, we systematically study the logging practices of developers in ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Where+do+developers+log%3F+an+empirical+study+on+logging+practices+in+industry&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "A. E. Hassan, D. J. Martin, P. Flora, P. Mansfield, D. Dietz, \"An Industrial Case Study of Customizing Operational Profiles Using Log Compression\", <em>ICSE \u201808: Proceedings of the 30th international conference on Software engineering</em>, pp. 713-723, 2008.", "title": "An Industrial Case Study of Customizing Operational Profiles Using Log Compression", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+Industrial+Case+Study+of+Customizing+Operational+Profiles+Using+Log+Compression&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "M. Hassani, W. Shang, E. Shihab, N. Tsantalis, \"Studying and detecting log-related issues\", <em>Empirical Software Engineering</em>, 2018.", "title": "Studying and detecting log-related issues", "context": [{"sec": "sec1", "text": " A few recent studies [12], [20] aim to detect potential problems in logging statements.", "part": "1"}, {"sec": "sec2", "text": "We identify duplicate logging statements from four large-scale open source Java systems: Hadoop, CloudStack, ElasticSearch, and Cassandra, which are commonly used in prior studies for log-related research [12], [20], [28].", "part": "1"}, {"sec": "sec3", "text": " Inconsistent log messages may cause problems during log analysis [1], [20].", "part": "1"}, {"sec": "sec7", "text": " [20] identified seven root-causes of the log-related issues from log-related bug reports.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-018-9603-z", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Studying+and+detecting+log-related+issues&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "F. Hermans, M. Pinzger, A. van Deursen, \"Detecting and refactoring code smells in spreadsheet formulas\", <em>Empirical Software Engineering</em>, vol. 20, no. 2, pp. 549-575, 2015.", "title": "Detecting and refactoring code smells in spreadsheet formulas", "context": [{"sec": "sec7", "text": " To mitigate the impact of code smells, studies have been proposed to detect code smells [21], [32]\u2013[34], [40].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-013-9296-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+and+refactoring+code+smells+in+spreadsheet+formulas&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Z. M. Jiang, A. E. Hassan, G. Hamann, P. Flora, \"Automatic identification of load testing problems\", <em>Proceedings of 24th International Conference on Software Maintenance (ICSM)</em>, pp. 307-316, 2008.", "title": "Automatic identification of load testing problems", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "links": {"documentLink": "/document/4658079", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4658079", "abstract": "Many software applications must provide services to hundreds or thousands of users concurrently. These applications must be load tested to ensure that they can function correctly under high load. Problems in load testing are due to problems in the load environment, the load generators, and the application under test. It is important to identify and address these problems to ensure that load testing results are correct and these problems are resolved. It is difficult to detect problems in a load ...", "pdfSize": "225KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+identification+of+load+testing+problems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "B. Johnson, Y. Song, E. Murphy-Hill, R. Bowdidge, \"Why don't software developers use static analysis tools to find bugs?\", <em>Proceedings of the 2013 International Conference on Software Engineering ser. ICSE \u201813</em>, pp. 672-681, 2013.", "title": "Why don't software developers use static analysis tools to find bugs?", "context": [{"sec": "sec3", "text": " Similar to some code smells studied in prior research [23], [42], developers may be reluctant to fix DP due to additional maintenance overheads but limited supports (i.e., need to manually fix hundreds of DP instances).", "part": "1"}], "links": {"documentLink": "/document/6606613", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6606613", "abstract": "Using static analysis tools for automating code inspections can be beneficial for software engineers. Such tools can make finding bugs, or software defects, faster and cheaper than manual inspections. Despite the benefits of using static analysis tools to find bugs, research suggests that these tools are underused. In this paper, we investigate why developers are not widely using static analysis tools and how current tools could potentially be improved. We conducted interviews with 20 developers...", "pdfSize": "1134KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+don%27t+software+developers+use+static+analysis+tools+to+find+bugs%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "S. Kabinna, C.-P. Bezemer, W. Shang, A. E. Hassan, \"Logging library migrations: A case study for the apache software foundation projects\", <em>Proceedings of the 13th International Conference on Mining Software Repositories ser. MSR \u201816</em>, pp. 154-164, 2016.", "title": "Logging library migrations: A case study for the apache software foundation projects", "context": [{"sec": "sec1", "text": "Even though developers have been analyzing logs for decades [24], there exists no industrial standard on how to write logging statements [18], [35].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2901739.2901769", "abstract": "Developers leverage logs for debugging, performance monitoring and load testing. The increased dependence on logs has lead to the development of numerous logging libraries which help developers in logging their code. As new libraries emerge and current ones evolve, projects often migrate from an older library to another one. In this paper we study logging library migrations within Apache Software Foundation (ASF) projects. From our manual analysis of JIRA issues, we find that 33 out of 223 (i.e....", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Logging+library+migrations%3A+A+case+study+for+the+apache+software+foundation+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "T. Kamiya, S. Kusumoto, K. Inoue, \"Ccfinder: A multilinguistic token-based code clone detection system for large scale source code\", <em>IEEE Transactions on Software Engineering</em>, vol. 28, no. 7, pp. 654-670, 2002.", "title": "Ccfinder: A multilinguistic token-based code clone detection system for large scale source code", "context": [{"sec": "sec7", "text": " There are many studies that focus on studying and detecting code clones [25], [26].", "part": "1"}], "links": {"documentLink": "/document/1019480", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1019480", "abstract": "A code clone is a code portion in source files that is identical or similar to another. Since code clones are believed to reduce the maintainability of software, several code clone detection techniques and tools have been proposed. This paper proposes a new clone detection technique, which consists of the transformation of input source text and a token-by-token comparison. For its implementation with several useful optimization techniques, we have developed a tool, named CCFinder (Code Clone Fin...", "pdfSize": "4706KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ccfinder%3A+A+multilinguistic+token-based+code+clone+detection+system+for+large+scale+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "C. Kapser, M. W. Godfrey, \"Cloning considered harmful\", <em>Reverse Engineering Working Conference</em>, vol. 0, pp. 19-28, 2006.", "title": "Cloning considered harmful", "context": [{"sec": "sec7", "text": " There are many studies that focus on studying and detecting code clones [25], [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cloning+considered+harmful&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "P. Kruchten, R. L. Nord, I. Ozkaya, \"Technical debt: From metaphor to theory and practice\", <em>IEEE Softw.</em>, vol. 29, no. 6, pp. 18-21, 2012.", "title": "Technical debt: From metaphor to theory and practice", "context": [{"sec": "sec4", "text": " DP instances can be viewed more as technical debts [27] and our goal is to propose an approach to detect DP instances to raise developers' awareness regarding this issue.", "part": "1"}], "links": {"documentLink": "/document/6336722", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6336722", "abstract": "The metaphor of technical debt in software development was introduced two decades ago to explain to nontechnical stakeholders the need for what we call now \"refactoring.\" As the term is being used to describe a wide range of phenomena, this paper proposes an organization of the technical debt landscape, and introduces the papers on technical debt contained in the issue.", "pdfSize": "936KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Technical+debt%3A+From+metaphor+to+theory+and+practice&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "H. Li, T. -H. P. Chen, W. Shang, A. E. Hassan, \"Studying software logging using topic models\", <em>Empirical Software Engineering</em>, Jan 2018.", "title": "Studying software logging using topic models", "context": [{"sec": "sec2", "text": "We identify duplicate logging statements from four large-scale open source Java systems: Hadoop, CloudStack, ElasticSearch, and Cassandra, which are commonly used in prior studies for log-related research [12], [20], [28].", "part": "1"}, {"sec": "sec3", "text": " As shown in prior studies [18], [28], [54], logging decisions, such as log messages and log levels, are often associated with the structure and semantics of the surrounding code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-018-9595-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Studying+software+logging+using+topic+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "H. Li, W. Shang, A. E. Hassan, \"Which log level should developers choose for a new logging statement?\", <em>Empirical Software Engineering</em>, vol. 22, no. 4, pp. 1684-1716, Aug 2017.", "title": "Which log level should developers choose for a new logging statement?", "context": [{"sec": "sec2", "text": " Log levels represent the verbosity level of the log and can be used to reduce logging overheads in production (e.g., only logging info level or above)[29], [50].", "part": "1"}, {"sec": "sec3", "text": " The extra logging statements at debug level help developers debug the occurred exception and reduces logging overhead in production [29] (i.e., logging statements at debug level are turned off).", "part": "1"}, {"sec": "sec3", "text": "Log levels (e.g., fatal, error, info, debug, or trace) allow developers to specify the verbosity of the log message and to reduce logging overhead when needed (e.g., debug is usually disabled in production)[29].", "part": "1"}, {"sec": "sec3", "text": " The developer replied: \u201cI think it should probably be an ERROR level, and I missed it in the review (could make an argument either way, I do not feel strongly that it should be ERROR level vs INFO level.\u201d Our opinions (i.e., from us and prior studies [29], [50]) differ from that of developers' regarding whether such inconsistencies are problematic.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-016-9456-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Which+log+level+should+developers+choose+for+a+new+logging+statement%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "U. A. Mannan, I. Ahmed, R. A. M. Almurshed, D. Dig, C. Jensen, \"Understanding code smells in android applications\", <em>Proceedings of the International Conference on Mobile Software Engineering and Systems</em>, pp. 225-234, 2016.", "title": "Understanding code smells in android applications", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2897073.2897094", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+code+smells+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "M. L. McHugh, \"Interrater reliability: the kappa statistic\", <em>Biochemia Medica</em>, vol. 22, no. 3, pp. 276-282, 2012.", "title": "Interrater reliability: the kappa statistic", "context": [{"sec": "sec3", "text": " The results of this phase have a Cohens kappa of 0.806, which is a substantial-level of agreement [31].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.11613/BM.2012.031", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Interrater+reliability%3A+the+kappa+statistic&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "H. V. Nguyen, H. A. Nguyen, T. T. Nguyen, A. T. Nguyen, T. N. Nguyen, \"Detection of embedded code smells in dynamic web applications\", <em>Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering ser. ASE 2012</em>, pp. 282-285, 2012.", "title": "Detection of embedded code smells in dynamic web applications", "context": [{"sec": "sec7", "text": " To mitigate the impact of code smells, studies have been proposed to detect code smells [21], [32]\u2013[34], [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2351676.2351724", "abstract": "In dynamic Web applications, there often exists a type of code smells, called embedded code smells, that violate important principles in software development such as software modularity and separation of concerns, resulting in much maintenance effort. Detecting and fixing those code smells is crucial yet challenging since the code with smells is embedded and generated from the server-side code. We introduce WebScent, a tool to detect such embedded code smells. WebScent first detects the smells i...", "pdfSize": "646KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detection+of+embedded+code+smells+in+dynamic+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "F. Palomba, G. Bavota, M. D. Penta, R. Oliveto, A. D. Lucia, D. Poshyvanyk, \"Detecting bad smells in source code using change history information\", <em>2013 28th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 268-278, Nov 2013.", "title": "Detecting bad smells in source code using change history information", "context": [{"sec": "sec7", "text": " To mitigate the impact of code smells, studies have been proposed to detect code smells [21], [32]\u2013[33][34], [40].", "part": "1"}], "links": {"documentLink": "/document/6693086", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693086", "abstract": "Code smells represent symptoms of poor implementation choices. Previous studies found that these smells make source code more difficult to maintain, possibly also increasing its fault-proneness. There are several approaches that identify smells based on code analysis techniques. However, we observe that many code smells are intrinsically characterized by how code elements change over time. Thus, relying solely on structural information may not be sufficient to detect all the smells accurately. W...", "pdfSize": "586KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+bad+smells+in+source+code+using+change+history+information&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "C. Parnin, C. G\u00f6rg, O. Nnadi, \"A catalogue of lightweight visualizations to support code smell inspection\", <em>Proceedings of the 4th ACM Symposium on Software Visualization ser. SoftVis \u201808</em>, pp. 77-86, 2008.", "title": "A catalogue of lightweight visualizations to support code smell inspection", "context": [{"sec": "sec7", "text": " To mitigate the impact of code smells, studies have been proposed to detect code smells [21], [32]\u2013[34], [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1409720.1409733", "abstract": "Preserving the integrity of software systems is essential in ensuring future product success. Commonly, companies allocate only a limited budget toward perfective maintenance and instead pressure developers to focus on implementing new features. Traditional techniques, such as code inspection, consume many staff resources and attention from developers. Metrics automate the process of checking for problems but produce voluminous, imprecise, and incongruent results. An opportunity exists for visua...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+catalogue+of+lightweight+visualizations+to+support+code+smell+inspection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "A. Pecchia, M. Cinque, G. Carrozza, D. Cotroneo, \"Industry practices and event logging: Assessment of a critical software development process\", <em>Proceedings of th 37th International Conference on Software Engineering ser. ICSE \u201815</em>, pp. 169-178, 2015.", "title": "Industry practices and event logging: Assessment of a critical software development process", "context": [{"sec": "sec1", "text": "Even though developers have been analyzing logs for decades [24], there exists no industrial standard on how to write logging statements [18], [35].", "part": "1"}], "links": {"documentLink": "/document/7202961", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7202961", "abstract": "Practitioners widely recognize the importance of event logging for a variety of tasks, such as accounting, system measurements and troubleshooting. Nevertheless, in spite of the importance of the tasks based on the logs collected under real workload conditions, event logging lacks systematic design and implementation practices. The implementation of the logging mechanism strongly relies on the human expertise. This paper proposes a measurement study of event logging practices in a critical indus...", "pdfSize": "1132KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Industry+practices+and+event+logging%3A+Assessment+of+a+critical+software+development+process&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "H. Pinjia, Z. Chen, S. He, M. R. Lyu, \"Characterizing the natural language descriptions in software logging statements\", <em>Proceedings of the 33rd IEEE international conference on Automated software engineering</em>, pp. 1-11, 2018.", "title": "Characterizing the natural language descriptions in software logging statements", "context": [{"sec": "sec1", "text": " Prior studies often focus on recommending where logging statements should be added into the code (i.e., where-to-log) [53], [54], and what information should be added in logging statements (i.e., what-to-log) [36], [41], [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+the+natural+language+descriptions+in+software+logging+statements&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "M. F. Porter, \"An algorithm for suffix stripping\", <em>Program</em>, vol. 14, no. 3, pp. 130-137, 1980.", "title": "An algorithm for suffix stripping", "context": [{"sec": "sec4", "text": " DLFinder detects instances of LM using four steps: 1) For each logging statement, DLFinder splits class-method name into a set of words (i.e., name set) and splits log message into a set of words (i.e., log set) by leveraging naming conventions (e.g., camel cases) and converting the words to lower cases. 2) DLFinder applies stemming on all the words using Porter Stemmer [37]. 3) DLFinder removes stop words in the log message for each system.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1108/eb046814", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+algorithm+for+suffix+stripping&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "F. Rahman, C. Bird, P. Devanbu, \"Clones: What is that smell?\", <em>2010 7th IEEE Working Conference on Mining Software Repositories (MSR 2010)</em>, pp. 72-81, May 2010.", "title": "Clones: What is that smell?", "context": [{"sec": "sec7", "text": " Duplicate code (or code clones) is a kind of code smells which may be caused by developers copying and pasting a piece of code from one place to another [38], [52].", "part": "1"}], "links": {"documentLink": "/document/5463343", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5463343", "abstract": "Clones are generally considered bad programming practice in software engineering folklore. They are identified as a bad smell and a major contributor to project maintenance difficulties. Clones inherently cause code bloat, thus increasing project size and maintenance costs. In this work, we try to validate the conventional wisdom empirically to see whether cloning makes code more defect prone. This paper analyses relationship between cloning and defect proneness. We find that, first, the great m...", "pdfSize": "194KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Clones%3A+What+is+that+smell%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "I. K. Ratol, M. P. Robillard, \"Detecting fragile comments\", <em>2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 112-122, Oct 2017.", "title": "Detecting fragile comments", "context": [{"sec": "sec5", "text": " Moreover, we plan to find a better summarization of the surrounding code of the logging statements by utilizing the state-of-the-art research on code summarization [39].", "part": "1"}], "links": {"documentLink": "/document/8115624", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115624", "abstract": "Refactoring is a common software development practice and many simple refactorings can be performed automatically by tools. Identifier renaming is a widely performed refactoring activity. With tool support, rename refactorings can rely on the program structure to ensure correctness of the code transformation. Unfortunately, the textual references to the renamed identifier present in the unstructured comment text cannot be formally detected through the syntax of the language, and are thus fragile...", "pdfSize": "151KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+fragile+comments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "J. Schumacher, N. Zazworka, F. Shull, C. Seaman, M. Shaw, \"Building empirical support for automated code smell detection\", <em>Proceedings of the 2010 ACM-IEEE International Symposium on Empirical Software Engineering and Measurement ser. ESEM \u201810</em>, pp. 8:1-8:10, 2010.", "title": "Building empirical support for automated code smell detection", "context": [{"sec": "sec7", "text": " To mitigate the impact of code smells, studies have been proposed to detect code smells [21], [32]\u2013[34], [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1852786.1852797", "abstract": "Identifying refactoring opportunities in software systems is an important activity in today&#39;s agile development environments. The concept of code smells has been proposed to characterize different types of design shortcomings in code. Additionally, metric-based detection algorithms claim to identify the &#34;smelly&#34; components automatically. This paper presents results for an empirical study performed in a commercial environment. The study investigates the way professional software developers detect...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Building+empirical+support+for+automated+code+smell+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "W. Shang, M. Nagappan, A. E. Hassan, Z. M. Jiang, \"Understanding log lines using development knowledge\", <em>Proceedings of the 2014 IEEE International Conference on Software Maintenance and Evolution ser. ICSME \u201814</em>, pp. 21-30, 2014.", "title": "Understanding log lines using development knowledge", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}, {"sec": "sec1", "text": " Prior studies often focus on recommending where logging statements should be added into the code (i.e., where-to-log) [53], [54], and what information should be added in logging statements (i.e., what-to-log) [36], [41], [51].", "part": "1"}, {"sec": "sec1", "text": " Since developers rely on logs for debugging and program comprehension [41], such duplicate logging statements may negatively affect developers' activities in maintenance and quality assurance.", "part": "1"}, {"sec": "sec2", "text": " We focus on studying the log message because such semantic information is crucial for log understanding and system maintenance [41], [50].", "part": "1"}, {"sec": "sec3", "text": " Since log messages record a higher level abstraction of the program [41], we find that even though there are no clones among a parent method and its overridden methods, such methods may still contain duplicate logging statements.", "part": "1"}], "links": {"documentLink": "/document/6976068", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6976068", "abstract": "Logs are generated by output statements that developers insert into the code. By recording the system behaviour during runtime, logs play an important role in the maintenance of large software systems. The rich nature of logs has introduced a new market of log management applications (e.g., Splunk, XpoLog and log stash) that assist in storing, querying and analyzing logs. Moreover, recent research has demonstrated the importance of logs in operating, understanding and improving software systems....", "pdfSize": "581KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+log+lines+using+development+knowledge&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "D. Silva, N. Tsantalis, M. T. Valente, \"Why we refactor? confessions of github contributors\", <em>Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE \u201816</em>, pp. 858-870, 2016.", "title": "Why we refactor? confessions of github contributors", "context": [{"sec": "sec3", "text": " Similar to some code smells studied in prior research [23], [42], developers may be reluctant to fix DP due to additional maintenance overheads but limited supports (i.e., need to manually fix hundreds of DP instances).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950305", "abstract": "Refactoring is a widespread practice that helps developers to improve the maintainability and readability of their code. However, there is a limited number of studies empirically investigating the actual motivations behind specific refactoring operations applied by developers. To fill this gap, we monitored Java projects hosted on GitHub to detect recently applied refactorings, and asked the developers to explain the reasons behind their decision to refactor the code. By applying thematic analys...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+we+refactor%3F+confessions+of+github+contributors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "D. I. K. Sjberg, A. Yamashita, B. C. D. Anda, A. Mockus, T. Dyb, \"Quantifying the effect of code smells on maintenance effort\", <em>IEEE Transactions on Software Engineering</em>, vol. 39, no. 8, pp. 1144-1156, Aug 2013.", "title": "Quantifying the effect of code smells on maintenance effort", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"documentLink": "/document/6392174", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6392174", "abstract": "Context: Code smells are assumed to indicate bad design that leads to less maintainable code. However, this assumption has not been investigated in controlled studies with professional software developers. Aim: This paper investigates the relationship between code smells and maintenance effort. Method: Six developers were hired to perform three maintenance tasks each on four functionally equivalent Java systems originally implemented by different companies. Each developer spent three to four wee...", "pdfSize": "2705KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quantifying+the+effect+of+code+smells+on+maintenance+effort&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "M. Tufano, F. Palomba, G. Bavota, R. Oliveto, M. D. Penta, A. D. Lucia, D. Poshyvanyk, \"When and why your code starts to smell bad\", <em>2015 IEEE/ACM 37th IEEE International Conference on Software Engineering</em>, vol. 1, pp. 403-414, May 2015.", "title": "When and why your code starts to smell bad", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"documentLink": "/document/7675424", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7675424", "abstract": "In past and recent years, the issues related to managing technical debt received significant attention by researchers from both industry and academia. There are several factors that contribute to technical debt. One of these is represented by code bad smells, i.e., symptoms of poor design and implementation choices. While the repercussions of smells on code quality have been empirically assessed, there is still only anecdotal evidence on when and why bad smells are introduced. To fill this gap, ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+and+why+your+code+starts+to+smell+bad&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "X. Xiao, S. Han, C. Zhang, D. Zhang, X. Feng, S. Park, \"Uncovering javascript performance code smells relevant to type mutations\" in Programming Languages and Systems, pp. 335-355, 2015.", "title": "Uncovering javascript performance code smells relevant to type mutations", "context": [{"sec": "sec7", "text": "Code smells can be indications of bad design and implementation choices, which may affect software systems' maintainability [5], [30], [43], [44], understandability [4], [10], and performance [45].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-26529-2_18", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Uncovering+javascript+performance+code+smells+relevant+to+type+mutations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "J. Yang, L. Tan, \"SWordNet: Inferring semantically related words from software context\", <em>Empirical Software Engineering</em>, vol. 19, no. 6, pp. 1856-1886, 2014.", "title": "SWordNet: Inferring semantically related words from software context", "context": [{"sec": "sec4", "text": " Hence, we obtain the stop words by finding the top 50 most frequent words (each of our four studied systems has an average of 3,178 unique words in the static text messages) across all log messages in a system [46]. 4) For every logging statement, between the name set (i.e., from the class-method name) and its associated log set, DLFinder counts the number of common words shared by both sets.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-013-9264-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SWordNet%3A+Inferring+semantically+related+words+from+software+context&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "K. Yao, G. B. d. Pdua, W. Shang, S. Sporea, A. Toma, S. Sajedi, \"Log4perf: Suggesting logging locations for web-based systems performance monitoring\", <em>Proceedings of the 2018 ACM/SPEC International Conference on Performance Engineering ser. ICPE '18</em>, pp. 21-30, 2018.", "title": "Log4perf: Suggesting logging locations for web-based systems performance monitoring", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3184407.3184416", "abstract": "Performance assurance activities are an essential step in the release cycle of software systems. Logs have become one of the most important sources of information that is used to monitor, understand and improve software performance. However, developers often face the challenge of making logging decisions, i.e., neither logging too little and logging too much is desirable. Although prior research has proposed techniques to assist in logging decisions, those automated logging guidance techniques a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Log4perf%3A+Suggesting+logging+locations+for+web-based+systems+performance+monitoring&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "D. Yuan, Y. Luo, X. Zhuang, G. R. Rodrigues, X. Zhao, Y. Zhang, P. U. Jain, M. Stumm, \"Simple testing can prevent most critical failures: An analysis of production failures in distributed data-intensive systems\", <em>Proceedings of the 11th USENIX Conference on Operating Systems Design and Implementation ser. OSDI\u2019 14</em>, pp. 249-265, 2014.", "title": "Simple testing can prevent most critical failures: An analysis of production failures in distributed data-intensive systems", "context": [{"sec": "sec3", "text": "Developers usually rely on logs for error diag- nostics when exceptions occur [48].", "part": "1"}, {"sec": "sec3", "text": " The rationale may be that generic exceptions, once occurred, are often not expected by developers [48], so it is important that developers log more error-diagnostic information.", "part": "1"}, {"sec": "sec3", "text": " Generic exceptions may be more unexpected to developers [48], so developers may use a log level of higher verbosity (e.g., error level) to record exception messages.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Simple+testing+can+prevent+most+critical+failures%3A+An+analysis+of+production+failures+in+distributed+data-intensive+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "D. Yuan, H. Mai, W. Xiong, L. Tan, Y. Zhou, S. Pasupathy, \"Sherlog: Error diagnosis by connecting clues from run-time logs\", <em>Proceedings of the 15th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 143-154, 2010.", "title": "Sherlog: Error diagnosis by connecting clues from run-time logs", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1736020.1736038", "abstract": "Computer systems often fail due to many factors such as software bugs or administrator errors. Diagnosing such production run failures is an important but challenging task since it is difficult to reproduce them in house due to various reasons: (1) unavailability of users&#39; inputs and file content due to privacy concerns; (2) difficulty in building the exact same execution environment; and (3) non-determinism of concurrent executions on multi-processors. Therefore, programmers often have to diagn...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sherlog%3A+Error+diagnosis+by+connecting+clues+from+run-time+logs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "D. Yuan, S. Park, Y. Zhou, \"Characterizing logging practices in open-source software\", <em>ICSE 2012: Proceedings of the 2012 International Conference on Software Engineering</em>, pp. 102-112, 2012.", "title": "Characterizing logging practices in open-source software", "context": [{"sec": "sec2", "text": " We focus on studying the log message because such semantic information is crucial for log understanding and system maintenance [41], [50].", "part": "1"}, {"sec": "sec2", "text": " Log levels represent the verbosity level of the log and can be used to reduce logging overheads in production (e.g., only logging info level or above)[29], [50].", "part": "1"}, {"sec": "sec3", "text": " A prior study [50] shows that log level is frequently modified by developers in order to find the most adequate level.", "part": "1"}, {"sec": "sec3", "text": " A prior study [50] suggests that logging statements that appear in syntactically similar code, but with inconsistent log levels, are likely problematic.", "part": "1"}, {"sec": "sec3", "text": " The developer replied: \u201cI think it should probably be an ERROR level, and I missed it in the review (could make an argument either way, I do not feel strongly that it should be ERROR level vs INFO level.\u201d Our opinions (i.e., from us and prior studies [29], [50]) differ from that of developers' regarding whether such inconsistencies are problematic.", "part": "1"}, {"sec": "sec5", "text": " Different from a prior study [50], we found that all IL instances are not problematic in the six evaluated systems.", "part": "1"}, {"sec": "sec7", "text": "There are several studies on characterizing the logging practices in software systems [11], [18], [50], Yuan et al.", "part": "1"}, {"sec": "sec7", "text": " [50] conducted a quantitative characteristics study on log messages for large-scale open source C/C++ systems.", "part": "1"}, {"sec": "sec7", "text": " [50] on Java open-source projects.", "part": "1"}], "links": {"documentLink": "/document/6227202", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227202", "abstract": "Software logging is a conventional programming practice. While its efficacy is often important for users and developers to understand what have happened in the production run, yet software logging is often done in an arbitrary manner. So far, there have been little study for understanding logging practices in real world software. This paper makes the first attempt (to the best of our knowledge) to provide a quantitative characteristic study of the current log messages within four pieces of large...", "pdfSize": "952KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+logging+practices+in+open-source+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "D. Yuan, J. Zheng, S. Park, Y. Zhou, S. Savage, \"Improving software diagnosability via log enhancement\", <em>ASPLOS \u201811: Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems</em>, pp. 3-14, 2011.", "title": "Improving software diagnosability via log enhancement", "context": [{"sec": "sec1", "text": " Developers use the generated logs to assist in various tasks, such as debugging [18], [49], [51], testing [13], [15], [22], program comprehension [19], [41], system verification [6], [9], and performance analysis [14], [47].", "part": "1"}, {"sec": "sec1", "text": " Prior studies often focus on recommending where logging statements should be added into the code (i.e., where-to-log) [53], [54], and what information should be added in logging statements (i.e., what-to-log) [36], [41], [51].", "part": "1"}, {"sec": "sec1", "text": " However, these studies often only consider the appropriateness of one single logging statement as an individual item; while logs are typically analyzed in tandem [14], [51].", "part": "1"}, {"sec": "sec7", "text": " [51] proposed an approach that can automatically insert additional variables into logging statements to enhance the error diagnostic information.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1950365.1950369", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+software+diagnosability+via+log+enhancement&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "M. Zhang, T. Hall, N. Baddoo, \"Code bad smells: a review of current knowledge\", <em>Journal of Software Maintenance</em>, vol. 23, no. 3, pp. 179-202, 2011.", "title": "Code bad smells: a review of current knowledge", "context": [{"sec": "sec7", "text": " Duplicate code (or code clones) is a kind of code smells which may be caused by developers copying and pasting a piece of code from one place to another [38], [52].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/smr.521", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+bad+smells%3A+a+review+of+current+knowledge&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "X. Zhao, K. Rodrigues, Y. Luo, M. Stumm, D. Yuan, Y. Zhou, \"Log20: Fully automated optimal placement of log printing statements under specified overhead threshold\", <em>Proceedings of the 26th Symposium on Operating Systems Principles ser. SOSP \u201817</em>, pp. 565-581, 2017.", "title": "Log20: Fully automated optimal placement of log printing statements under specified overhead threshold", "context": [{"sec": "sec1", "text": " Prior studies often focus on recommending where logging statements should be added into the code (i.e., where-to-log) [53], [54], and what information should be added in logging statements (i.e., what-to-log) [36], [41], [51].", "part": "1"}, {"sec": "sec7", "text": " [53] proposed a tool that determines how to optimally place logging statements given a performance overhead threshold.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3132747.3132778", "abstract": "When systems fail in production environments, log data is often the only information available to programmers for postmortem debugging. Consequently, programmers&#39; decision on where to place a log printing statement is of crucial importance, as it directly affects how effective and efficient postmortem debugging can be. This paper presents Log20, a tool that determines a near optimal placement of log printing statements under the constraint of adding less than a specified amount of performance ov...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Log20%3A+Fully+automated+optimal+placement+of+log+printing+statements+under+specified+overhead+threshold&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "J. Zhu, P. He, Q. Fu, H. Zhang, M. R. Lyu, D. Zhang, \"Learning to log: Helping developers make informed logging decisions\", <em>Proceedings of the 37th International Conference on Software Engineering ser. ICSE \u201815</em>, pp. 415-425, 2015.", "title": "Learning to log: Helping developers make informed logging decisions", "context": [{"sec": "sec1", "text": " Prior studies often focus on recommending where logging statements should be added into the code (i.e., where-to-log) [53], [54], and what information should be added in logging statements (i.e., what-to-log) [36], [41], [51].", "part": "1"}, {"sec": "sec3", "text": " As shown in prior studies [18], [28], [54], logging decisions, such as log messages and log levels, are often associated with the structure and semantics of the surrounding code.", "part": "1"}, {"sec": "sec7", "text": " [54] provided a tool for suggesting log placement using machine learning techniques.", "part": "1"}], "links": {"documentLink": "/document/7675425", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7675425", "abstract": "Logging is a common programming practice of practical importance to collect system runtime information for postmortem analysis. Strategic logging placement is desired to cover necessary runtime information without incurring unintended consequences (e.g., performance overhead, trivial logs). However, in current practice, there is a lack of rigorous specifications for developers to govern their logging behaviours. Logging has become an important yet tough decision which mostly depends on the domai...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+to+log%3A+Helping+developers+make+informed+logging+decisions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811945", "articleId": "8811945", "startPage": "152", "endPage": "163", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 74}}
{"title": "FLOSS Participants' Perceptions About Gender and Inclusiveness: A Survey", "authors": [{"name": "Amanda Lee", "affiliation": "The University of Alabama, United States of America", "firstName": "Amanda", "lastName": "Lee", "id": "37086143378"}, {"name": "Jeffrey C. Carver", "affiliation": "The University of Alabama, United States of America", "firstName": "Jeffrey C.", "lastName": "Carver", "id": "37271665200"}], "abstract": "Background: While FLOSS projects espouse openness and acceptance for all, in practice, female contributors often face discriminatory barriers to contribution. Aims: In this paper, we examine the extent to which these problems still exist. We also study male and female contributors' perceptions of other contributors. Method: We surveyed participants from 15 FLOSS projects, asking a series of open-ended, closed-ended, and behavioral scale questions to gather information about the issue of gender in FLOSS projects. Results: Though many of those we surveyed expressed a positive sentiment towards females who participate in FLOSS projects, some were still strongly against their inclusion. Often, the respondents who were against inclusiveness also believed their own sentiments were the prevailing belief in the community, contrary to our findings. Others did not see the purpose of attempting to be inclusive, expressing the sentiment that a discussion of gender has no place in FLOSS. Conclusions: FLOSS projects have started to move forwards in terms of gender acceptance. However, there is still a need for more progress in the inclusion of gender-diverse contributors.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Computer science", "Software", "Face", "Data mining", "Software engineering", "Cognition", "IEEE Fellows"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["gender issues", "public domain software", "sentiment analysis", "social aspects of automation"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["gender-diverse contributors", "inclusiveness", "female contributors", "FLOSS projects", "gender acceptance", "FLOSS participant perceptions", "positive sentiment", "male contributor perceptions", "female contributor perceptions"]}, {"type": "Author Keywords ", "kwd": ["FLOSS", "gender", "survey", "Open Source"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00077", "ref": [{"order": "1", "text": "P. L. Benson, S. Vincent, \"Development and validation of the sexist attitudes toward women scale (satws)\", <em>Psychology of Women Quarterly</em>, vol. 5, no. 2, pp. 276-291, 1980.", "title": "Development and validation of the sexist attitudes toward women scale (satws)", "context": [{"sec": "sec3b", "text": " The gender perceptions questions from the survey are based off of ones found in [1].", "part": "1"}, {"sec": "sec6", "text": " To mitigate this threat, we used an established behavioral scale for sexist behavior as the base for our behavioral scale [1].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.1471-6402.1980.tb00962.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Development+and+validation+of+the+sexist+attitudes+toward+women+scale+%28satws%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "A. Bosu, J. C. Carver, \"How do social interaction networks influence peer impressions formation? a case study\", <em>IFIP International Conference on Open Source Systems</em>, pp. 31-40, 2014.", "title": "How do social interaction networks influence peer impressions formation? a case study", "context": [{"sec": "sec3a", "text": " To ensure completeness, we combined the results from the new mining process and the results from a previous mining exercise in 2015 [2].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-55128-4_4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+social+interaction+networks+influence+peer+impressions+formation%3F+a+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "J. P. Byrnes, D. C. Miller, W. D. Schafer, \"Gender differences in risk taking: a meta-analysis\", <em>Psychological bulletin</em>, vol. 125, no. 3, 1999.", "title": "Gender differences in risk taking: a meta-analysis", "context": [{"sec": "sec5a3", "text": " However, because females are more risk-adverse [3], they may not even attempt FLOSS contributions if the technical barriers seem too high [14].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0033-2909.125.3.367", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+differences+in+risk+taking%3A+a+meta-analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "S. Daniel, R. Agarwal, K. J. Stewart, \"The effects of diversity in global distributed collectives: A study of open source project success\", <em>Information Systems Research</em>, vol. 24, no. 2, pp. 312-333, 2013.", "title": "The effects of diversity in global, distributed collectives: A study of open source project success", "context": [{"sec": "sec1", "text": " Because FLOSS projects can greatly benefit from the diversity of female contributors and from potential new contributors, it is crucial to better understand the sources of the problem and find ways to improve it [4].", "part": "1"}, {"sec": "sec2b", "text": " Because diversity can improve a project through new perspectives and ideas [4], [26], this low representation of female FLOSS participants is detrimental to the FLOSS movement.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/isre.1120.0435", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+effects+of+diversity+in+global%2C+distributed+collectives%3A+A+study+of+open+source+project+success&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "P. Eckert, S. McConnell-Ginet, Language and gender, Cambridge University Press, 2013.", "title": "Language and gender", "context": [{"sec": "sec2b", "text": " This type of practical politeness attracts and retains more female participants as opposed to the harsher, higher expectations that come from the male-oriented attitudes [5], [8] often pervasive in FLOSS projects.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1017/CBO9781139245883", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Language+and+gender&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "N. S. Foundation, \"Women minorities and persons with disabilities in science and engineering\", <em>NSF 17\u2013310</em>, 2017.", "title": "Women, minorities, and persons with disabilities in science and engineering", "context": [{"sec": "sec1", "text": " Compared with approximately 25% of computer science professionals who are female [6], [25], this number is dismally low.", "part": "1"}, {"sec": "sec2b", "text": " Even though 24.5% of software engineers employed in 2017 were female [6], only 1-5% of open source developers are female [7], [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Women%2C+minorities%2C+and+persons+with+disabilities+in+science+and+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "R. Ghosh, A. Glott, B. Krieger, B. Robles, \"Free/libre and open source software: Survey and study part iv: Survey of developers\", <em>International Institute of Infometrics / Merit</em>, 2002.", "title": "Free/libre and open source software: Survey and study, part iv: Survey of developers", "context": [{"sec": "sec2b", "text": " Even though 24.5% of software engineers employed in 2017 were female [6], only 1-5% of open source developers are female [7], [25].", "part": "1"}, {"sec": "sec3a", "text": " While the number of female responses is low, our rate of 10.9% of respondents being female is much higher than the typical 1-5% proportion of females in FLOSS [7].", "part": "1"}, {"sec": "sec6", "text": " However, FLOSS projects typically have only 1\u20135% female contributors [7], [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Free%2Flibre+and+open+source+software%3A+Survey+and+study%2C+part+iv%3A+Survey+of+developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "S. Herring, <em>Gender and Power in Online Communication</em>, pp. 202-228, 2008.", "title": "Gender and Power in Online Communication", "context": [{"sec": "sec2b", "text": " This type of practical politeness attracts and retains more female participants as opposed to the harsher, higher expectations that come from the male-oriented attitudes [5], [8] often pervasive in FLOSS projects.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+and+Power+in+Online+Communication&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "A. Kofink, \"Contributions of the under-appreciated: Gender bias in an open-source ecology\", <em>Companion Proceedings of the 2015 ACM SIG-PLAN International Conference on Systems Programming Languages and Applications: Software for Humanity SPLASH Companion 2015</em>, pp. 83-84, 2015.", "title": "Contributions of the under-appreciated: Gender bias in an open-source ecology", "context": [{"sec": "sec2c", "text": " However, those female contributors who were familiar with the projects were slightly more likely to have their code accepted than male contributors, whether or not they revealed their gender [9], [24].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2814189.2815369", "abstract": "Female software developers account for only a small portion of the total developer community. This inequality is caused by subtle beliefs and sometimes interactions between different genders and society, referred to as implicit biases and explicit behavior, respectively. In this study, I mined user contribution acceptance from a popular software collaboration service. The contributions of female developers were accepted into open-source projects with roughly equivalent success to those of males,...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Contributions+of+the+under-appreciated%3A+Gender+bias+in+an+open-source+ecology&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "K. Lakhani, R. Wolf, Why Hackers Do What They Do: Understanding Motivation and Effort in Free/Open Source Software Projects, Cambridge:MIT Press, 2005.", "title": "Why Hackers Do What They Do: Understanding Motivation and Effort in Free/Open Source Software Projects", "context": [{"sec": "sec4", "text": " This intrinsic motivation is also most commonly found in long-term contributors [10]\u2013[20], [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+Hackers+Do+What+They+Do%3A+Understanding+Motivation+and+Effort+in+Free%2FOpen+Source+Software+Projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "A. Lee, J. C. Carver, \"Are one-time contributors different? a comparison to core and periphery developers in floss repositories\", <em>ACM/IEEE International Symposium on Empirical Software Engineering and Measurement</em>, pp. 1-10, Nov 2017.", "title": "Are one-time contributors different? a comparison to core and periphery developers in floss repositories", "context": [{"sec": "sec2a", "text": " First, we need to understand what motivates FLOSS contributors and what barriers they face during contribution (topics we have explored more generally in our previous works [11], [12]).", "part": "1"}], "links": {"documentLink": "/document/8169979", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8169979", "abstract": "Context: Free/Libre Open Source Software (FLOSS) communities consist of different types of contributors. Core contributors and peripheral contributors work together to create a successful project, each playing a different role. One-Time Contributors (OTCs), who are on the very fringe of the peripheral developers, are largely unstudied despite offering unique insights into the development process. In a prior survey, we identified OTCs and discovered their motivations and barriers. Aims: The objec...", "pdfSize": "253KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+one-time+contributors+different%3F+a+comparison+to+core+and+periphery+developers+in+floss+repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "A. Lee, J. C. Carver, A. Bosu, \"Understanding the impressions motivations and barriers of one time code contributors to floss projects: a survey\", <em>Proceedings of the 39th International Conference on Software Engineering</em>, pp. 187-197, 2017.", "title": "Understanding the impressions, motivations, and barriers of one time code contributors to floss projects: a survey", "context": [{"sec": "sec2a", "text": " First, we need to understand what motivates FLOSS contributors and what barriers they face during contribution (topics we have explored more generally in our previous works [11], [12]).", "part": "1"}, {"sec": "sec3a", "text": "Using a Java script similar to the one used in previous papers [12], we extracted the email addresses of contributors who had either requested or performed a code review through Gerrit.", "part": "1"}, {"sec": "sec6", "text": " While it would be preferable to obtain a higher response rate, based on past surveys, a low response rate is common when surveying FLOSS projects using this method of recruitment [12].", "part": "1"}], "links": {"documentLink": "/document/7985661", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985661", "abstract": "Successful Free/Libre Open Source Software (FLOSS) projects must attract and retain high-quality talent. Researchers have invested considerable effort in the study of core and peripheral FLOSS developers. To this point, one critical subset of developers that have not been studied are One-Time code Contributors (OTC) - those that have had exactly one patch accepted. To understand why OTCs have not contributed another patch and provide guidance to FLOSS projects on retaining OTCs, this study seeks...", "pdfSize": "194KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+the+impressions%2C+motivations%2C+and+barriers+of+one+time+code+contributors+to+floss+projects%3A+a+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "U. Mellstrom, \"The intersection of gender race and cultural boundaries or why is computer science in malaysia dominated by women?\", <em>Social Studies of Science</em>, vol. 39, no. 6, pp. 885-907, 2009.", "title": "The intersection of gender, race and cultural boundaries, or why is computer science in malaysia dominated by women?", "context": [{"sec": "sec2e", "text": " As a result, the majority of computer scientists in Malaysia are female [13].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/0306312709334636", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+intersection+of+gender%2C+race+and+cultural+boundaries%2C+or+why+is+computer+science+in+malaysia+dominated+by+women%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "C. Mendez, H. S. Padala, Z. Steine-Hanson, C. Hilderbrand, A. Horvath, C. Hill, L. Simpson, N. Patil, A. Sarma, M. Burnett, \"Open source barriers to entry revisited: A sociotechnical perspective\", <em>Proceedings of the 40th International Conference on Software Engineering ICSE \u201818</em>, pp. 1004-1015, 2018.", "title": "Open source barriers to entry, revisited: A sociotechnical perspective", "context": [{"sec": "sec5a3", "text": " However, because females are more risk-adverse [3], they may not even attempt FLOSS contributions if the technical barriers seem too high [14].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180241", "abstract": "Research has revealed that significant barriers exist when entering Open-Source Software (OSS) communities and that women disproportionately experience such barriers. However, this research has focused mainly on social/cultural factors, ignoring the environment itself - the tools and infrastructure. To shed some light onto how tools and infrastructure might somehow factor into OSS barriers to entry, we conducted a field study with five teams of software professionals, who worked through five use...", "pdfSize": "1345KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Open+source+barriers+to+entry%2C+revisited%3A+A+sociotechnical+perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "E. Moon, \"Gendered patterns of politeness in free/libre open source software development\", <em>2013 46th Hawaii International Conference on System Sciences</em>, pp. 3168-3177, Jan 2013.", "title": "Gendered patterns of politeness in free/libre open source software development", "context": [{"sec": "sec2b", "text": " This approach attracted more females [15].", "part": "1"}, {"sec": "sec5c3", "text": " This result agrees with the results of a previous study that females created a more socially-equivalent community, even in the context of FLOSS [15].", "part": "1"}, {"sec": "sec5c3", "text": " Females form social structures as a preventative measure against aggressiveness [15].", "part": "1"}], "links": {"documentLink": "/document/6480226", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6480226", "abstract": "In this paper, a qualitative case study of women-dominated Free/Libre Open Source Software (FLOSS) project is conducted to explore factors which successfully involve and sustain women FLOSS participants by drawing on Brown and Levinson&#39;s politeness theory. The culture and norms of FLOSS appear to be formulated by what is privileged/marginalized by men in the context of FLOSS, and such men&#39;s valuing is likely to threaten women FLOSS participants&#39; face. Our findings are 1) in the FLOSS context, th...", "pdfSize": "288KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gendered+patterns+of+politeness+in+free%2Flibre+open+source+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "D. Nafus, \"patches don\u2018t have gender\u2019: What is not open in open source software\", <em>New Media & Society</em>, vol. 14, no. 4, pp. 669-683, 2012.", "title": "patches don\u2018t have gender\u2019: What is not open in open source software", "context": [{"sec": "sec2a", "text": " While this concept of relying on anonymity was one of the original claims of FLOSS, other research has shown that simply relying on anonymity to provide a non-sexist environment is a naive approach which does not work in practice [16].", "part": "1"}, {"sec": "sec2b", "text": "Perhaps this way of thinking is because, to a certain group of male contributors, the absence of women poses fewer problems than actually changing the culture so that it is inclusive towards women [16].", "part": "1"}, {"sec": "sec2b", "text": " However, as gender can become a serious issue for a female newcomer who attempts to join a project, it is necessary to acknowledge the problem before we can attempt to assuage the issues that arise from gender-bias [16], [24].", "part": "1"}, {"sec": "sec2b", "text": " As Nafus described, \u201csexism [in FLOSS projects]is as constant as it is extreme\u201d [16].", "part": "1"}, {"sec": "sec2d", "text": " As FLOSS projects are male-dominated, the masculine becomes the \u2018normal\u2019 and the feminine is seen as \u2018abnormal.\u2019 If female contributors do express their femininity, they may be treated as a romantic interest or as a mother figure rather than as an equal contributor in the project [16].", "part": "1"}, {"sec": "sec5b1", "text": "This result suggests that the attitude of FLOSS participants towards females is improving, as compared to previous studies [16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/1461444811422887", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=patches+don%E2%80%98t+have+gender%E2%80%99%3A+What+is+not+open+in+open+source+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "W. E. Powell, D. S. Hunsinger, B. D. Medlin, \"Gender differences within the open source community: An exploratory study\", <em>Journal of Information Technology</em>, vol. 21, no. 4, pp. 29-37, 2010.", "title": "Gender differences within the open source community: An exploratory study", "context": [{"sec": "sec2b", "text": " These respondents also reported negative emotions of feeling alienated and outnumbered by their male peers [17].", "part": "1"}, {"sec": "sec2d", "text": "Regardless of whether they chose to contribute anonymously, females contributors are expected to masculinize themselves to fit in with FLOSS projects, rather than be allowed to express their femininity [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+differences+within+the+open+source+community%3A+An+exploratory+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "B. Rasmussen, T. Hapnes, \"Excluding women from the technologies of the future?: A case study of the culture of computer science\", <em>Futures</em>, vol. 23, no. 10, pp. 1107-1119, 1991.", "title": "Excluding women from the technologies of the future?: A case study of the culture of computer science", "context": [{"sec": "sec2c", "text": " In this syndrome, being capable computer scientists, females consider themselves frauds, an opinion that may be shared by male contributors [18], [26].", "part": "1"}, {"sec": "sec2e", "text": " Those who do major in computer science tend to view themselves as the minority, a view often shared by fellow students [18].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0016-3287(91)90075-D", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Excluding+women+from+the+technologies+of+the+future%3F%3A+A+case+study+of+the+culture+of+computer+science&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J. Reagle, \"free as in sexist?\u201d free culture and the gender gap\", <em>first monday</em>, vol. 18, no. 1, 2012.", "title": "free as in sexist?\u201d free culture and the gender gap", "context": [{"sec": "sec2b", "text": " However, this line of reasoning uses the very concepts of freedom and openness that are meant to be inclusive to all as a way to dismiss the validity of the concerns of the marginalized group [19].", "part": "1"}, {"sec": "sec2b", "text": " Other barriers to female participation include a lack of female mentors, perspectives, and role models, mysogynistic fellow project members, and a highly-masculinized, aggressive method of discourse through which contributors defend their code [19].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.5210/fm.v18i1.4291", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=free+as+in+sexist%3F%E2%80%9D+free+culture+and+the+gender+gap&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "P. Setia, B. Rajagopalan, V. Sambamurthy, R. Calantone, \"How peripheral developers contribute to open-source software development\", <em>Info. Sys. Research</em>, vol. 23, no. 1, pp. 144-163, Mar. 2012.", "title": "How peripheral developers contribute to open-source software development", "context": [{"sec": "sec4", "text": " This intrinsic motivation is also most commonly found in long-term contributors [10]\u2013[20], [21].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/isre.1100.0311", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+peripheral+developers+contribute+to+open-source+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "S. K. Shah, \"Motivation governance and the viability of hybrid forms in open source software development\", <em>Manage. Sci.</em>, vol. 52, no. 7, pp. 1000-1014, July 2006.", "title": "Motivation, governance, and the viability of hybrid forms in open source software development", "context": [{"sec": "sec4", "text": " This intrinsic motivation is also most commonly found in long-term contributors [10]\u2013[20], [21].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/mnsc.1060.0553", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Motivation%2C+governance%2C+and+the+viability+of+hybrid+forms+in+open+source+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "I. Steinmacher, T. Conte, M. A. Gerosa, D. Redmiles, \"Social barriers faced by newcomers placing their first contribution in open source software projects\", <em>Proceedings of the 18th ACM Conference on Computer Supported Cooperative Work & Social Computing CSCW \u201815</em>, pp. 1379-1392, 2015.", "title": "Social barriers faced by newcomers placing their first contribution in open source software projects", "context": [{"sec": "sec5a3", "text": " Previous works identified several of these barriers [22].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2675133.2675215", "abstract": "Newcomers&#39; seamless onboarding is important for online communities that depend upon leveraging the contribution of outsiders. Previous studies investigated aspects of the joining process and motivation in open collaboration communities, but few have focused on identifying and understanding the critical barriers newcomers face when placing their first contribution, a period that frequently leads to dropout. This is important for Open Source Software (OSS) projects, which receive contributions fro...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Social+barriers+faced+by+newcomers+placing+their+first+contribution+in+open+source+software+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "K. Talwar, <em>legenderary: Algorithms for determining gender from name.</em>, 2012.", "title": "legenderary: Algorithms for determining gender from name.", "context": [{"sec": "sec3a", "text": " We filtered the emails with a gender-identifying algorithm to select only female contributors, as according to the algorithm [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=legenderary%3A+Algorithms+for+determining+gender+from+name.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "J. Terrell, A. Kofink, J. Middleton, C. Rainear, E. Murphy-Hill, C. Parnin, J. Stallings, \"Gender differences and bias in open source: pull request acceptance of women versus men\", <em>PeerJ Computer Science</em>, vol. 3, May 2017.", "title": "Gender differences and bias in open source: pull request acceptance of women versus men", "context": [{"sec": "sec2b", "text": " However, as gender can become a serious issue for a female newcomer who attempts to join a project, it is necessary to acknowledge the problem before we can attempt to assuage the issues that arise from gender-bias [16], [24].", "part": "1"}, {"sec": "sec2c", "text": " Kofink et al. showed one dramatic illustration of this perception problem in which female contributors on GitHub who chose to identify their gender were more likely to have their code rejected when contributing to a new project [24].", "part": "1"}, {"sec": "sec2c", "text": " However, those female contributors who were familiar with the projects were slightly more likely to have their code accepted than male contributors, whether or not they revealed their gender [9], [24].", "part": "1"}, {"sec": "sec5a3", "text": " Prior research has shown that female contributors overprepare for contributing to FLOSS [24].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.7717/peerj-cs.111", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+differences+and+bias+in+open+source%3A+pull+request+acceptance+of+women+versus+men&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "B. Vasilescu, A. Capiluppi, A. Serebrenik, \"Gender representation and online participation: A quantitative study of stackoverflow\", <em>2012 International Conference on Social Informatics</em>, pp. 332-338, Dec 2012.", "title": "Gender, representation and online participation: A quantitative study of stackoverflow", "context": [{"sec": "sec1", "text": " Compared with approximately 25% of computer science professionals who are female [6], [25], this number is dismally low.", "part": "1"}, {"sec": "sec2b", "text": " Even though 24.5% of software engineers employed in 2017 were female [6], only 1-5% of open source developers are female [7], [25].", "part": "1"}, {"sec": "sec2b", "text": "Despite this inequity, male FLOSS contributors often downplay the lack of females as a \u201cnon-problem\u201d or by suggesting that females simply do not want to contribute [25].", "part": "1"}, {"sec": "sec6", "text": " However, FLOSS projects typically have only 1\u20135% female contributors [7], [25].", "part": "1"}], "links": {"documentLink": "/document/6542459", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6542459", "abstract": "Online communities are flourishing as social meeting web-spaces for users and peer community members. Different online communities require different levels of competence for participants to join, and scattered evidence suggests that women can be overly under-represented. Moreover, anecdotal evidence of the Q&, A website Stack Overflow suggests that women withdraw from unfriendly online communities. Due to the lack of empirical evidence on the matter, this paper provides a quantitative study of t...", "pdfSize": "273KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender%2C+representation+and+online+participation%3A+A+quantitative+study+of+stackoverflow&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "B. Vasilescu, D. Posnett, B. Ray, M. G. van, den Brand, A. Serebrenik, P. Devanbu, V. Filkov, \"Gender and tenure diversity in github teams\", <em>Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems CHI \u2019 15</em>, pp. 3789-3798, 2015.", "title": "Gender and tenure diversity in github teams", "context": [{"sec": "sec2a", "text": " A study by Vasilescu et al. found almost half of project members thought they could identify the genders of almost all contributors, even those who used pseudonyms [26].", "part": "1"}, {"sec": "sec2b", "text": " Because diversity can improve a project through new perspectives and ideas [4], [26], this low representation of female FLOSS participants is detrimental to the FLOSS movement.", "part": "1"}, {"sec": "sec2b", "text": "Contrary to what many male FLOSS participants think, the culture of FLOSS projects is very unfriendly towards females [26].", "part": "1"}, {"sec": "sec2c", "text": " In this syndrome, being capable computer scientists, females consider themselves frauds, an opinion that may be shared by male contributors [18], [26].", "part": "1"}, {"sec": "sec5b", "text": " This result aligns with an earlier study that found project members tended to be aware of the genders of other contributors [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2702123.2702549", "abstract": "Software development is usually a collaborative venture. Open Source Software (OSS) projects are no exception; indeed, by design, the OSS approach can accommodate teams that are more open, geographically distributed, and dynamic than commercial teams. This, we find, leads to OSS teams that are quite diverse. Team diversity, predominantly in offline groups, is known to correlate with team output, mostly with positive effects. How about in OSS? Using GitHub, the largest publicly available collecti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+and+tenure+diversity+in+github+teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "B. C. Wilson, \"A study of factors promoting success in computer science including gender differences\", <em>Computer Science Education</em>, vol. 12, no. 1\u20132, pp. 141-164, 2002.", "title": "A study of factors promoting success in computer science including gender differences", "context": [{"sec": "sec2e", "text": " Wilson also found comfort predicted female success [27].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1076/csed.12.1.141.8211", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+study+of+factors+promoting+success+in+computer+science+including+gender+differences&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812068", "articleId": "8812068", "startPage": "677", "endPage": "687", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 76}}
{"title": "Class Imbalance Evolution and Verification Latency in Just-in-Time Software Defect Prediction", "authors": [{"name": "George G. Cabral", "affiliation": "University of Birmingham (UK) and Federal Rural University of Pernambuco (Brazil)", "firstName": "George G.", "lastName": "Cabral", "id": "37870998000"}, {"name": "Leandro L. Minku", "affiliation": "University of Birmingham (UK)", "firstName": "Leandro L.", "lastName": "Minku", "id": "37568476300"}, {"name": "Emad Shihab", "affiliation": "Concordia University (Canada)", "firstName": "Emad", "lastName": "Shihab", "id": "37322955000"}, {"name": "Suhaib Mujahid", "affiliation": "Concordia University (Canada)", "firstName": "Suhaib", "lastName": "Mujahid", "id": "37086170205"}], "abstract": "Just-in-Time Software Defect Prediction (JIT-SDP) is an SDP approach that makes defect predictions at the software change level. Most existing JIT-SDP work assumes that the characteristics of the problem remain the same over time. However, JIT-SDP may suffer from class imbalance evolution. Specifically, the imbalance status of the problem (i.e., how much underrepresented the defect-inducing changes are) may be intensified or reduced over time. If occurring, this could render existing JIT-SDP approaches unsuitable, including those that re-build classifiers over time using only recent data. This work thus provides the first investigation of whether class imbalance evolution poses a threat to JIT-SDP. This investigation is performed in a realistic scenario by taking into account verification latency -- the often overlooked fact that labeled training examples arrive with a delay. Based on 10 GitHub projects, we show that JIT-SDP suffers from class imbalance evolution, significantly hindering the predictive performance of existing JIT-SDP approaches. Compared to state-of-the-art class imbalance evolution learning approaches, the predictive performance of JIT-SDP approaches was up to 97.2% lower in terms of g-mean. Hence, it is essential to tackle class imbalance evolution in JIT-SDP. We then propose a novel class imbalance evolution approach for the specific context of JIT-SDP. While maintaining top ranked g-means, this approach managed to produce up to 63.59% more balanced recalls on the defect-inducing and clean classes than state-of-the-art class imbalance evolution approaches. We thus recommend it to avoid overemphasizing one class over the other in JIT-SDP.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software", "Training", "Machine learning algorithms", "Machine learning", "Prediction algorithms", "Delays"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["learning (artificial intelligence)", "pattern classification", "safety-critical software", "sampling methods", "software fault tolerance"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["SDP approach", "predictive performance", "class imbalance evolution approach", "just-in-time software defect prediction", "JIT-SDP approaches", "top ranked g-means"]}, {"type": "Author Keywords ", "kwd": ["Software defect prediction", "class imbalance", "verification latency", "online learning", "concept drift", "ensembles"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00076", "ref": [{"order": "1", "text": "A. Mockus, D. M. Weiss, \"Predicting risk of software changes\", <em>Bell Labs Technical Journal</em>, vol. 5, no. 2, pp. 169-180, 2000.", "title": "Predicting risk of software changes", "context": [{"sec": "sec1", "text": "Reducing the number of software defects (and their high debugging cost) is a challenging problem, specially considering that software teams have limited testing resources [1], [2], and often face strong pressure towards rapid delivery [1], [3].", "part": "1"}, {"sec": "sec1", "text": " For instance, Lucent [1], BlackBerry [6] and Cisco [7] have adopted this type of approach.", "part": "1"}], "links": {"documentLink": "/document/6772130", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6772130", "abstract": "Reducing the number of software failures is one of the most challenging problems of software production. We assume that software development proceeds as a series of changes and model the probability that a change to software will cause a failure. We use predictors based on the properties of a change itself. Such predictors include size in lines of code added, deleted, and unmodified; diffusion of the change and its component subchanges, as reflected in the number of files, modules, and subsystem...", "pdfSize": "9962KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+risk+of+software+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "Y. Kamei, T. Fukushima, S. McIntosh, K. Yamashita, N. Ubayashi, A. E. Hassan, \"Studying just-in-time defect prediction using cross-project models\", <em>Empirical Software Engineering (EMSE)</em>, vol. 21, no. 5, pp. 2072-2106, 2015.", "title": "Studying just-in-time defect prediction using cross-project models", "context": [{"sec": "sec1", "text": "Reducing the number of software defects (and their high debugging cost) is a challenging problem, specially considering that software teams have limited testing resources [1], [2], and often face strong pressure towards rapid delivery [1], [3].", "part": "1"}, {"sec": "sec1", "text": " JIT-SDP is known to be a class imbalanced problem, where defect-inducing software changes are typically a minority compared to clean software changes [5], [7], [2].", "part": "1"}, {"sec": "sec1", "text": " If it actually does evolve over time, existing JIT-SDP approaches (e.g., [5], [2], [7]\u2013) are likely to become unsuitable (perform poorly) over time, because they would be assuming the wrong level of class imbalance.", "part": "1"}, {"sec": "sec3d", "text": "In JIT-SDP, resampling is typically used to tackle class imbalance [5], [2], [7].", "part": "1"}, {"sec": "sec3d", "text": " For instance, Kamei et al. [5], [2] applied an undersampling technique that randomly eliminates clean class examples to balance the number of training examples from both classes.", "part": "1"}, {"sec": "sec5", "text": " These dimensions have shown to perform well in JIT-SDP research [5], [2], [8], and lead to 14 metrics used as input features to describe software changes in this study.", "part": "1"}, {"sec": "sec6c", "text": " It thus corresponds to the resampling strategy typically used in the JIT-SDP literature [5], [2].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-015-9400-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Studying+just-in-time+defect+prediction+using+cross-project+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "N. Nan, D. E. Harter, \"Impact of budget and schedule pressure on software development cycle time and effort\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 35, no. 5, pp. 624-637, 2009.", "title": "Impact of budget and schedule pressure on software development cycle time and effort", "context": [{"sec": "sec1", "text": "Reducing the number of software defects (and their high debugging cost) is a challenging problem, specially considering that software teams have limited testing resources [1], [2], and often face strong pressure towards rapid delivery [1], [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Impact+of+budget+and+schedule+pressure+on+software+development+cycle+time+and+effort&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "T. Hall, S. Beecham, D. Bowes, D. Gray, S. Counsell, \"A systematic literature review on fault prediction performance in software engineering\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 38, no. 6, pp. 1276-1304, 2012.", "title": "A systematic literature review on fault prediction performance in software engineering", "context": [{"sec": "sec1", "text": " Therefore, machine learning approaches have been proposed for predicting defects in software source code [4].", "part": "1"}], "links": {"documentLink": "/document/6035727", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6035727", "abstract": "Background: The accurate prediction of where faults are likely to occur in code can help direct test effort, reduce costs, and improve the quality of software. Objective: We investigate how the context of models, the independent variables used, and the modeling techniques applied influence the performance of fault prediction models. Method: We used a systematic literature review to identify 208 fault prediction studies published from January 2000 to December 2010. We synthesize the quantitative ...", "pdfSize": "6095KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+literature+review+on+fault+prediction+performance+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "Y. Kamei, E. Shihab, B. Adams, A. E. Hassan, A. Mockus, A. Sinha, N. Ubayashi, \"A large-scale empirical study of just-in-time quality assurance\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 39, no. 6, pp. 757-773, 2013.", "title": "A large-scale empirical study of just-in-time quality assurance", "context": [{"sec": "sec1", "text": " These are advantages over both (1) code debugging after a defect report is produced and (2) more conventional SDP, which is concerned with predicting defects in software components (e.g., files or packages)[5].", "part": "1"}, {"sec": "sec1", "text": " JIT-SDP is known to be a class imbalanced problem, where defect-inducing software changes are typically a minority compared to clean software changes [5], [7], [2].", "part": "1"}, {"sec": "sec1", "text": " If it actually does evolve over time, existing JIT-SDP approaches (e.g., [5], [2], [7]\u2013) are likely to become unsuitable (perform poorly) over time, because they would be assuming the wrong level of class imbalance.", "part": "1"}, {"sec": "sec3a", "text": " [5].", "part": "1"}, {"sec": "sec3d", "text": "In JIT-SDP, resampling is typically used to tackle class imbalance [5], [2], [7].", "part": "1"}, {"sec": "sec3d", "text": " [5], [2] applied an undersampling technique that randomly eliminates clean class examples to balance the number of training examples from both classes.", "part": "1"}, {"sec": "sec5", "text": " These dimensions have shown to perform well in JIT-SDP research [5], [2], [8], and lead to 14 metrics used as input features to describe software changes in this study.", "part": "1"}, {"sec": "sec5", "text": " [5]\u2018s work.", "part": "1"}, {"sec": "sec6c", "text": " It thus corresponds to the resampling strategy typically used in the JIT-SDP literature [5], [2].", "part": "1"}], "links": {"documentLink": "/document/6341763", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6341763", "abstract": "Defect prediction models are a well-known technique for identifying defect-prone files or packages such that practitioners can allocate their quality assurance efforts (e.g., testing and code reviews). However, once the critical files or packages have been identified, developers still need to spend considerable time drilling down to the functions or even code snippets that should be reviewed or tested. This makes the approach too time consuming and impractical for large software systems. Instead...", "pdfSize": "2140KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+large-scale+empirical+study+of+just-in-time+quality+assurance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "E. Shihab, A. E. Hassan, B. Adams, Z. M. Jiang, \"An industrial study on the risk of software changes\", <em>Proceedings of the 20th ACM SIGSOFT International Symposium on the Foundations of Software Engineering (FSE)</em>, pp. 1-11, 2012.", "title": "An industrial study on the risk of software changes", "context": [{"sec": "sec1", "text": " For instance, Lucent [1], BlackBerry [6] and Cisco [7] have adopted this type of approach.", "part": "1"}, {"sec": "sec3a", "text": " [6] studied risky (defect - inducing) changes-as deemed by the developers who committed them.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2393596.2393670", "abstract": "Modelling and understanding bugs has been the focus of much of the Software Engineering research today. However, organizations are interested in more than just bugs. In particular, they are more concerned about managing risk, i.e., the likelihood that a code or design change will cause a negative impact on their products and processes, regardless of whether or not it introduces a bug. In this paper, we conduct a year-long study involving more than 450 developers of a large enterprise, spanning m...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+industrial+study+on+the+risk+of+software+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "M. Tan, L. Tan, S. Dara, C. Mayeux, \"Online defect prediction for imbalanced data\", <em>Proceedings of the 37th International Conference on Software Engineering (ICSE)</em>, pp. 99-108, 2015.", "title": "Online defect prediction for imbalanced data", "context": [{"sec": "sec1", "text": " For instance, Lucent [1], BlackBerry [6] and Cisco [7] have adopted this type of approach.", "part": "1"}, {"sec": "sec1", "text": " JIT-SDP is known to be a class imbalanced problem, where defect-inducing software changes are typically a minority compared to clean software changes [5], [7], [2].", "part": "1"}, {"sec": "sec1", "text": " If it actually does evolve over time, existing JIT-SDP approaches (e.g., [5], [2], [7]\u2013) are likely to become unsuitable (perform poorly) over time, because they would be assuming the wrong level of class imbalance.", "part": "1"}, {"sec": "sec1", "text": " Ignoring verification latency means training JIT-SDP models on data not yet available in practice, leading to invalid studies and over-optimistic estimations of predictive performance [7].", "part": "1"}, {"sec": "sec1", "text": " [7].", "part": "1"}, {"sec": "sec3b", "text": " [7] found that ignoring verification latency leads to over-optimistic estimates of the predictive performance.", "part": "1"}, {"sec": "sec3c", "text": " [7] investigated JIT-SDP in an updatable learning scenario, where additional training examples can be received over time.", "part": "1"}, {"sec": "sec3c", "text": " [7] do not meet these requirements.", "part": "1"}, {"sec": "sec3d", "text": "In JIT-SDP, resampling is typically used to tackle class imbalance [5], [2], [7].", "part": "1"}, {"sec": "sec3d", "text": " [7] investigated the effect of different resampling techniques on JIT-SDP while taking the chronology of the data and verification latency into account, including oversampling techniques that replicate minority class examples.", "part": "1"}, {"sec": "sec6c", "text": " [7]'s JIT-SDP work.", "part": "1"}], "links": {"documentLink": "/document/7202954", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7202954", "abstract": "Many defect prediction techniques are proposed to improve software reliability. Change classification predicts defects at the change level, where a change is the modifications to one file in a commit. In this paper, we conduct the first study of applying change classification in practice. We identify two issues in the prediction process, both of which contribute to the low prediction performance. First, the data are imbalanced -- there are much fewer buggy changes than clean changes. Second, the...", "pdfSize": "685KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Online+defect+prediction+for+imbalanced+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "S. McIntosh, Y. Kamei, \"Are fix-inducing changes a moving target? a longitudinal case study of just-in-time defect prediction\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 44, no. 5, pp. 412-428, 2018.", "title": "Are fix-inducing changes a moving target? a longitudinal case study of just-in-time defect prediction", "context": [{"sec": "sec1", "text": " However, as recently shown by McIntosh and Kamei [8], the characteristics (input feature values) of defect-inducing software changes fluctuate during the lifecycle of a software.", "part": "1"}, {"sec": "sec1", "text": " Even the recent approach of rebuilding classifiers using only recent data, recommended to cope with fluctuations in the characteristics of defect-inducing software changes [8], would struggle to obtain good predictive performance.", "part": "1"}, {"sec": "sec3c", "text": " Recently, McIntosh and Kamei [8] examined the impact of concept drift affecting \\$p(x\\vert y)\\$ in the specific context of JIT-SDP.", "part": "1"}, {"sec": "sec3c", "text": "However, McIntosh and Kamei [8] did not investigate class imbalance evolution, which requires different strategies to avoid reduction in predictive performance [15].", "part": "1"}, {"sec": "sec5", "text": " These dimensions have shown to perform well in JIT-SDP research [5], [2], [8], and lead to 14 metrics used as input features to describe software changes in this study.", "part": "1"}, {"sec": "sec6c", "text": " Finally, OOB-SW trains an OOB ensemble on a sliding window - the strategy recommended by McIntosh and Kamei [8].", "part": "1"}, {"sec": "sec7a", "text": " This means that the training examples are potentially obsolete and misleading when they arrive for training [8].", "part": "1"}, {"sec": "sec7a", "text": " In fact, McIntosh and Kamei's [8] recommended using changes produced within the past 90 days, as older changes can be detrimental to predictive performance due to concept drift in \\$p(x\\vert y)\\$.", "part": "1"}], "links": {"documentLink": "/document/7898457", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7898457", "abstract": "Just-In-Time (JIT) models identify fix-inducing code changes. JIT models are trained using techniques that assume that past fix-inducing changes are similar to future ones. However, this assumption may not hold, e.g., as system complexity tends to accrue, expertise may become more important as systems age. In this paper, we study JIT models as systems evolve. Through a longitudinal case study of 37,524 changes from the rapidly evolving Qt and OpenStack systems, we find that fluctuations in the p...", "pdfSize": "2291KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+fix-inducing+changes+a+moving+target%3F+a+longitudinal+case+study+of+just-in-time+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "G. Ditzler, M. Roveri, C. Alippi, R. Polikar, \"Learning in nonstationary environments: A survey\", <em>IEEE Computational Intelligence Magazine</em>, vol. 10, no. 4, pp. 12-25, 2015.", "title": "Learning in nonstationary environments: A survey", "context": [{"sec": "sec1", "text": " Algorithms that can learn new training examples separately over time are often referred to as online learning algorithms [9].", "part": "1"}, {"sec": "sec1", "text": " This term refers to the fact that the labels associated to training examples arrive with delays [9].", "part": "1"}, {"sec": "sec3c", "text": " [9], learning in the presence of concept drift requires \u201capproaches that can monitor and track the underlying changes, and adapt a model to accommodate those changes accordingly.\u201d The approaches investigated by Tan et al. [7] do not meet these requirements.", "part": "1"}], "links": {"documentLink": "/document/7296710", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7296710", "abstract": "The prevalence of mobile phones, the internet-of-things technology, and networks of sensors has led to an enormous and ever increasing amount of data that are now more commonly available in a streaming fashion [1]-[5]. Often, it is assumed - either implicitly or explicitly - that the process generating such a stream of data is stationary, that is, the data are drawn from a fixed, albeit unknown probability distribution. In many real-world scenarios, however, such an assumption is simply not true...", "pdfSize": "2019KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+in+nonstationary+environments%3A+A+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S. Wang, L. L. Minku, X. Yao, \"Resampling-based ensemble methods for online class imbalance learning\", <em>IEEE Transactions on Knowledge and Data Engineering (TKDE)</em>, vol. 27, no. 5, pp. 1356-1368, 2015.", "title": "Resampling-based ensemble methods for online class imbalance learning", "context": [{"sec": "sec1", "text": "However, our study also reveals that the existing machine learning algorithms for class imbalance evolution [10] suffer from overemphasising one class (defect-inducing or clean) over the other in JIT-SDP.", "part": "1"}, {"sec": "sec3e", "text": " [10] proposed two online class imbalance learning approaches for coping with class imbalance evolution: Improved Undersampling Online Bagging (UOB) and Improved Oversampling Online Bagging (OOB).", "part": "1"}, {"sec": "sec6c", "text": " OOB and UOB [10] are two state-of-the-art online class imbalance learning approaches explained in Section III-E.", "part": "1"}, {"sec": "sec8", "text": " This strategy has shown to be effective and easily automated\u2025 The parameter values investigated included values that were used in previous work that investigated online class imbalance learning in the machine learning literature [10].", "part": "1"}], "links": {"documentLink": "/document/6871400", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6871400", "abstract": "Online class imbalance learning is a new learning problem that combines the challenges of both online learning and class imbalance learning. It deals with data streams having very skewed class distributions. This type of problems commonly exists in real-world applications, such as fault diagnosis of real-time control monitoring systems and intrusion detection in computer networks. In our earlier work, we defined class imbalance online, and proposed two learning algorithms OOB and UOB that build ...", "pdfSize": "793KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Resampling-based+ensemble+methods+for+online+class+imbalance+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "S. Kim, E. J. W., Y. Zhang, \"Classifying software changes: Clean or buggy?\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 34, no. 2, pp. 181-196, 2008.", "title": "Classifying software changes: Clean or buggy?", "context": [{"sec": "sec3a", "text": " [11].", "part": "1"}], "links": {"documentLink": "/document/4408585", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4408585", "abstract": "This paper introduces a new technique for predicting latent software bugs, called change classification. Change classification uses a machine learning classifier to determine whether a new software change is more similar to prior buggy changes or clean changes. In this manner, change classification predicts the existence of bugs in software changes. The classifier is trained using features (in the machine learning sense) extracted from the revision history of a software project stored in its sof...", "pdfSize": "4329KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Classifying+software+changes%3A+Clean+or+buggy%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "J. Sliwcrski, T. Zimmermann, A. Zeller, \"When do changes induce fixes?\", <em>Proceedings of the 17th International Workshop on Mining Software Repositories</em>, pp. 1-5, 2005.", "title": "When do changes induce fixes?", "context": [{"sec": "sec3a", "text": "Several other studies investigated the characteristics of defect-inducing software changes and potential metrics (input features) for predicting them, including the day of the week [12] or the time of the day [13] the change was committed, and metrics for identifying changes that require a lot of effort to fix [14].", "part": "1"}, {"sec": "sec5", "text": " Commit Guru applies the SZZ algorithm [12] to identify defect-inducing changes and their associated bug fixing commits.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+do+changes+induce+fixes%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. Eyolfson, L. Tan, P. Lam, \"Do time of day and developer experience affect commit bugginess?\", <em>Proceedings of the 8th Working Conference on Mining Software Repositories (MSR)</em>, pp. 153-162, 2011.", "title": "Do time of day and developer experience affect commit bugginess?", "context": [{"sec": "sec3a", "text": "Several other studies investigated the characteristics of defect-inducing software changes and potential metrics (input features) for predicting them, including the day of the week [12] or the time of the day [13] the change was committed, and metrics for identifying changes that require a lot of effort to fix [14].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985441.1985464", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+time+of+day+and+developer+experience+affect+commit+bugginess%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "A. T. Misirli, E. Shihab, Y. Kamei, \"Studying high impact fix-inducing changes\", <em>Empirical Software Engineering Journal (EMSE)</em>, vol. 21, no. 2, pp. 605-641, 2016.", "title": "Studying high impact fix-inducing changes", "context": [{"sec": "sec3a", "text": "Several other studies investigated the characteristics of defect-inducing software changes and potential metrics (input features) for predicting them, including the day of the week [12] or the time of the day [13] the change was committed, and metrics for identifying changes that require a lot of effort to fix [14].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-015-9370-z", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Studying+high+impact+fix-inducing+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "S. Wang, L. L. Minku, X. Yao, \"A systematic study of online class imbalance learning with concept drift\", <em>IEEE Transactions on Neural Networks and Learning Systems (TNNLS)</em>, 2018.", "title": "A systematic study of online class imbalance learning with concept drift", "context": [{"sec": "sec3c", "text": "Concept drift is a change in the data generation process, affecting the underlying probabilities of the data [15].", "part": "1"}, {"sec": "sec3c", "text": "However, McIntosh and Kamei [8] did not investigate class imbalance evolution, which requires different strategies to avoid reduction in predictive performance [15].", "part": "1"}, {"sec": "sec3e", "text": "Class imbalance evolution started to be investigated only very recently by the machine learning community [15].", "part": "1"}, {"sec": "sec3e", "text": "UOB and OOB are the state-of-the-art for dealing with class imbalance evolution [15], making them good candidates to tackle that in JIT-SDP.", "part": "1"}, {"sec": "sec6c", "text": "The evaluation metrics used for the comparison are the recalls on the clean \\$(R_{0})\\$ and defect-inducing \\$(R_{1})\\$ classes, and the g-mean \\$(\\sqrt{Rec_{0}\\times Rec_{1}})\\$ These are the most commonly used metrics in the online class imbalance literature [15].", "part": "1"}, {"sec": "sec7b", "text": " Such large variations in the imbalance status of the problem are likely to disturb machine learning algorithms that are unable to adapt rapidly to them [15].", "part": "1"}, {"sec": "sec7b", "text": " Classifiers unable to continuously adapt to that are likely to become unsuitable [15].", "part": "1"}, {"sec": "sec8", "text": " These are the most commonly used metrics in the online class imbalance literature [15].", "part": "1"}], "links": {"documentLink": "/document/8246564", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8246564", "abstract": "As an emerging research topic, online class imbalance learning often combines the challenges of both class imbalance and concept drift. It deals with data streams having very skewed class distributions, where concept drift may occur. It has recently received increased research attention; however, very little work addresses the combined problem where both class imbalance and concept drift coexist. As the first systematic study of handling concept drift in class-imbalanced data streams, this paper...", "pdfSize": "3829KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+study+of+online+class+imbalance+learning+with+concept+drift&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "J. Ekanayake, J. Tappolet, H. C. Gall, A. Bernstein, \"Tracking concept drift of software projects using defect prediction quality\", <em>Proceedings of the 6th Working Conference on Mining Software Repositories (MSR)</em>, pp. 51-60, 2009.", "title": "Tracking concept drift of software projects using defect prediction quality", "context": [{"sec": "sec3c", "text": " [16] studied four open source projects and showed that SDP classifiers' performance significantly varies over time, suggesting that SDP suffers from concept drift.", "part": "1"}], "links": {"documentLink": "/document/5069480", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5069480", "abstract": "Defect prediction is an important task in the mining of software repositories, but the quality of predictions varies strongly within and across software projects. In this paper we investigate the reasons why the prediction quality is so fluctuating due to the altering nature of the bug (or defect) fixing process. Therefore, we adopt the notion of a concept drift, which denotes that the defect prediction model has become unsuitable as set of influencing features has changed - usually due to a cha...", "pdfSize": "287KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracking+concept+drift+of+software+projects+using+defect+prediction+quality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Z. Mahmood, D. Bowes, P. Lane, T. Hall, \"What is the impact of imbalance on software defect prediction performance?\", <em>Proceedings of the 11th International Conference on Predictive Models and Data Analytics in Software Engineering (PROMISE)</em>, pp. 4.1-4.4, 2015.", "title": "What is the impact of imbalance on software defect prediction performance?", "context": [{"sec": "sec3d", "text": " [17] showed that the predictive performance of SDP classifiers (in terms of Mathews Correlation Coefficient) gets worse as the data get more imbalanced.", "part": "1"}, {"sec": "sec7b", "text": " As machine learning algorithms tend to struggle with more imbalanced SDP problems [17], classifiers unable to identify and tackle such class imbalance evolution may become unsuitable.", "part": "1"}, {"sec": "sec7b", "text": " For instance, for Camel, the ratio of defect-inducing examples started at around 40% and decreased to less than 10% by the end of the period analysed, having become more than four times smaller, and thus increasing the challenge posed by class imbalance [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2810146.2810150", "abstract": "Software defect prediction performance varies over a large range. Menzies suggested there is a ceiling effect of 80% Recall [8]. Most of the data sets used are highly imbalanced. This paper asks, what is the empirical effect of using different datasets with varying levels of imbalance on predictive performance? We use data synthesised by a previous meta-analysis of 600 fault prediction models and their results. Four model evaluation measures (the Mathews Correlation Coefficient (MCC), F-Measure,...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+is+the+impact+of+imbalance+on+software+defect+prediction+performance%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "S. Wang, X. Yao, \"Using class imbalance learning for software defect prediction\", <em>IEEE Transactions on Reliability (TR)</em>, vol. 62, no. 2, pp. 434-443, 2013.", "title": "Using class imbalance learning for software defect prediction", "context": [{"sec": "sec3d", "text": " Wang and Yao [18] provided a comprehensive study of different class imbalance learning techniques in the context of SDP, including resampling, threshold moving, and ensembles.", "part": "1"}], "links": {"documentLink": "/document/6509481", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6509481", "abstract": "To facilitate software testing, and save testing costs, a wide range of machine learning methods have been studied to predict defects in software modules. Unfortunately, the imbalanced nature of this type of data increases the learning difficulty of such a task. Class imbalance learning specializes in tackling classification problems with imbalanced distributions, which could be helpful for defect prediction, but has not been investigated in depth so far. In this paper, we study the issue of if ...", "pdfSize": "1050KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+class+imbalance+learning+for+software+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "Y. Kamei, A. Monden, S. Matsumoto, T. Kakimoto, K. Matsumoto, \"The effects of over and under sampling on fault-prone module detection\", <em>Proceedings of the 1st International Symposium on Empirical Software Engineering and Measurement (ESEM)</em>, pp. 196-204, 2007.", "title": "The effects of over and under sampling on fault-prone module detection", "context": [{"sec": "sec3d", "text": " [19] investigated the use of four resampling methods for fault prone module detection and showed that, when associated to linear discriminant analysis and logistic regression analysis, there is a performance improvement irrespective of the resampling method.", "part": "1"}], "links": {"documentLink": "/document/4343747", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4343747", "abstract": "The goal of this paper is to improve the prediction performance of fault-prone module prediction models (fault-proneness models) by employing over/under sampling methods, which are preprocessing procedures for a fit dataset. The sampling methods are expected to improve prediction performance when the fit dataset is unbalanced, i.e. there exists a large difference between the number of fault-prone modules and not-fault-prone modules. So far, there has been no research reporting the effects of app...", "pdfSize": "395KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+effects+of+over+and+under+sampling+on+fault-prone+module+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "K. E. Bennin, J. Keung, P. Phannachitta, A. Monden, S. Mensah, \"Mahakil: Diversity based oversampling approach to alleviate the class imbalance issue in software defect prediction\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 44, no. 6, pp. 534-550, June 2018.", "title": "Mahakil: Diversity based oversampling approach to alleviate the class imbalance issue in software defect prediction", "context": [{"sec": "sec3d", "text": " [20] introduced a synthetic oversampling approach based on the chromosomal theory of inheritance that, according to their experiments, overcame four other resampling techniques.", "part": "1"}], "links": {"documentLink": "/document/7990590", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7990590", "abstract": "Highly imbalanced data typically make accurate predictions difficult. Unfortunately, software defect datasets tend to have fewer defective modules than non-defective modules. Synthetic oversampling approaches address this concern by creating new minority defective modules to balance the class distribution before a model is trained. Notwithstanding the successes achieved by these approaches, they mostly result in over-generalization (high rates of false alarms) and generate near-duplicated data i...", "pdfSize": "1508KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mahakil%3A+Diversity+based+oversampling+approach+to+alleviate+the+class+imbalance+issue+in+software+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "N. C. Oza, \"Online bagging and boosting\", <em>Proceedings of the 2005 IEEE International Conference on Systems Man and Cybernetics</em>, vol. 3, pp. 2340-2345, 2005.", "title": "Online bagging and boosting", "context": [{"sec": "sec3e", "text": " Both UOB and OOB maintain an Online Bagging ensemble [21] composed of \\$n\\$ Hoeffding trees [22] as base classifiers.", "part": "1"}], "links": {"documentLink": "/document/1571498", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1571498", "abstract": "Bagging and boosting are two of the most well-known ensemble learning methods due to their theoretical performance guarantees and strong experimental results. However, these algorithms have been used mainly in batch mode, i.e., they require the entire training set to be available at once and, in some cases, require random access to the data. In this paper, we present online versions of bagging and boosting that require only one pass through the training data. We build on previously presented wor...", "pdfSize": "505KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Online+bagging+and+boosting&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "P. Domingos, G. Hulten, \"Mining high-speed data streams\", <em>Proceedings of the 6th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD)</em>, pp. 71-80, 2000.", "title": "Mining high-speed data streams", "context": [{"sec": "sec3e", "text": " Both UOB and OOB maintain an Online Bagging ensemble [21] composed of \\$n\\$ Hoeffding trees [22] as base classifiers.", "part": "1"}, {"sec": "sec6d", "text": "All approaches use Hoeffding trees [22] as base learners, as explained in Sections III-E and IV.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/347090.347107", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+high-speed+data+streams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "P. Zhang, X. Zhu, J. Tan, L. Guo, \"Classifier and cluster ensembles for mining concept drifting data streams\", <em>Proceedings of the 2010 IEEE International Conference on Data Mining (ICDM)</em>, pp. 1175-1180, 2010.", "title": "Classifier and cluster ensembles for mining concept drifting data streams", "context": [{"sec": "sec3f", "text": " [23] assume that some training examples become available in a timely manner, whereas others never have their labels revealed.", "part": "1"}], "links": {"documentLink": "/document/5694104", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5694104", "abstract": "Ensemble learning is a commonly used tool for building prediction models from data streams, due to its intrinsic merits of handling large volumes stream data. Despite of its extraordinary successes in stream data mining, existing ensemble models, in stream data environments, mainly fall into the ensemble classifiers category, without realizing that building classifiers requires labor intensive labeling process, and it is often the case that we may have a small number of labeled samples to train ...", "pdfSize": "236KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Classifier+and+cluster+ensembles+for+mining+concept+drifting+data+streams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "K. B. Dyer, R. Capo, R. Polikar, \"Compose: A semi-supervised learning framework for initially labeled non-stationary streaming data\", <em>IEEE Transactions on Neural Networks and Learning Systems (TNNLS)</em>, vol. 25, no. 1, pp. 12-26, 2013.", "title": "Compose: A semi-supervised learning framework for initially labeled non-stationary streaming data", "context": [{"sec": "sec3f", "text": " [24] assume that labeled training examples are available only during an initial learning stage.", "part": "1"}], "links": {"documentLink": "/document/6604410", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6604410", "abstract": "An increasing number of real-world applications are associated with streaming data drawn from drifting and nonstationary distributions that change over time. These applications demand new algorithms that can learn and adapt to such changes, also known as concept drift. Proper characterization of such data with existing approaches typically requires substantial amount of labeled instances, which may be difficult, expensive, or even impractical to obtain. In this paper, we introduce compacted obje...", "pdfSize": "4805KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Compose%3A+A+semi-supervised+learning+framework+for+initially+labeled+non-stationary+streaming+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "A. D. Pozzolo, G. Boracchi, O. Caelen, C. Alippi, G. Bonternpi, \"Credit card fraud detection: a realistic modeling and a novel learning strategy\", <em>IEEE Transactions on Neural Networks and Learning Systems (TNNLS)</em>, vol. 29, no. 8, pp. 3784-3797, 2018.", "title": "Credit card fraud detection: a realistic modeling and a novel learning strategy", "context": [{"sec": "sec3f", "text": " [25] is a very recent work in the context of credit card fraud detection.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Credit+card+fraud+detection%3A+a+realistic+modeling+and+a+novel+learning+strategy&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "M. Shepperd, Q. Song, Z. Sun, C. Mair, \"Data quality: Some comments on the nasa software defect datasets\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 39, no. 9, pp. 1208-1215, 2013.", "title": "Data quality: Some comments on the nasa software defect datasets", "context": [{"sec": "sec4", "text": " As explained in Section I, unbalanced predictive performances are undesirable in JIT-SDP. (3) SDP frequently has noisy or outlier training examples, containing exactly the same input feature values but different labels [26].", "part": "1"}], "links": {"documentLink": "/document/6464273", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6464273", "abstract": "Background--Self-evidently empirical analyses rely upon the quality of their data. Likewise, replications rely upon accurate reporting and using the same rather than similar versions of datasets. In recent years, there has been much interest in using machine learners to classify software modules into defect-prone and not defect-prone categories. The publicly available NASA datasets have been extensively used as part of this research. Objective--This short note investigates the extent to which pu...", "pdfSize": "1235KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+quality%3A+Some+comments+on+the+nasa+software+defect+datasets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "C. Rosen, B. Grawi, E. Shihab, \"Commit guru: analytics and risk prediction of software commits\", <em>Proceedings of the 10th Joint Meeting on Foundations of Software Engineering (FSE)</em>, pp. 966-969, 2015.", "title": "Commit guru: analytics and risk prediction of software commits", "context": [{"sec": "sec5", "text": " To obtain defect-inducing software changes, we use Guru [27], a tool that analyzes and provides change level analytics.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2803183", "abstract": "Software quality is one of the most important research sub-areas of software engineering. Hence, a plethora of research has focused on the prediction of software quality. Much of the software analytics and prediction work has proposed metrics, models and novel approaches that can predict quality with high levels of accuracy. However, adoption of such techniques remain low; one of the reasons for this low adoption of the current analytics and prediction technique is the lack of actionable and pub...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Commit+guru%3A+analytics+and+risk+prediction+of+software+commits&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "H. He, E. A. Garcia, \"Learning from imbalanced data\", <em>IEEE Transactions on Knowledge and Data Engineering (TKDE)</em>, vol. 21, no. 9, pp. 1263-1284, 2009.", "title": "Learning from imbalanced data", "context": [{"sec": "sec6c", "text": " Different from precision and F-measure, they are robust to the class imbalance problem [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+from+imbalanced+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "J. Gama, R. Sebastiao, P. P. Rodrigues, \"On evaluating stream learning algorithms\", <em>Machine Learning</em>, vol. 90, no. 3, pp. 317-346, 2013.", "title": "On evaluating stream learning algorithms", "context": [{"sec": "sec6c", "text": " All metrics are computed in a prequential way, as recommended for online learning studies in the presence of concept drift [29].", "part": "1"}, {"sec": "sec8", "text": " They were calculated prequentially with fading factors, as recommended for online learning studies [29].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10994-012-5320-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+evaluating+stream+learning+algorithms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "N. Mittas, L. Angelis, \"Ranking and clustering software cost estimation models through a multiple comparisons algorithm\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 39, no. 4, pp. 537-551, 2013.", "title": "Ranking and clustering software cost estimation models through a multiple comparisons algorithm", "context": [{"sec": "sec6d", "text": " Scott-Knott was recommended by Mittas and Angelis [30] because it can (1) separate different approaches into non-overlapping groups and (2) reduce the number of statistical tests performed, being a powerful test.", "part": "1"}], "links": {"documentLink": "/document/6235961", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6235961", "abstract": "Software Cost Estimation can be described as the process of predicting the most realistic effort required to complete a software project. Due to the strong relationship of accurate effort estimations with many crucial project management activities, the research community has been focused on the development and application of a vast variety of methods and models trying to improve the estimation procedure. From the diversity of methods emerged the need for comparisons to determine the best model. ...", "pdfSize": "2590KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ranking+and+clustering+software+cost+estimation+models+through+a+multiple+comparisons+algorithm&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "T. Menzies, Y. Yang, G. Mathew, B. Boehm, J. Hihn, \"Negative results for software effort estimation\", <em>Empirical Software Engineering (EMSE)</em>, vol. 22, no. 5, pp. 2658-2683, 2017.", "title": "Negative results for software effort estimation", "context": [{"sec": "sec6d", "text": " [31], Scott-Knott was run with non-parametric bootstrap sampling, making the test non-parametric.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-016-9472-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Negative+results+for+software+effort+estimation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "A. Vargha, H. D. Delaney, \"A critique and improvement of the cl common language effect size statistics of mcgraw and wong\", <em>Journal of Educational and Behavioral Statistics</em>, vol. 25, no. 2, pp. 101-132, 2000.", "title": "A critique and improvement of the cl common language effect size statistics of mcgraw and wong", "context": [{"sec": "sec6d", "text": " In addition, Vargha and Delaney's nonparametric A12 effect size [32] was used to ensure that groups can only be split if medium or large effect sizes exist between them.", "part": "1"}, {"sec": "sec6d", "text": " As suggested by Vargha and Delaney [32], \\$A12 \\geq 0.56, \\geq 0.64\\ \\mathrm{and}\\ \\geq 0.71\\$ are considered small, medium and large, respectively.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+critique+and+improvement+of+the+cl+common+language+effect+size+statistics+of+mcgraw+and+wong&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "C. Tantithamthavorn, S. McIntosh, A. E. Hassan, K. Matsumoto, \"An empirical comparison of model validation techniques for defect prediction models\", <em>IEEE Transactions on Software Engineering (TSE)</em>, vol. 43, no. 1, pp. 1-18, 2017.", "title": "An empirical comparison of model validation techniques for defect prediction models", "context": [{"sec": "sec6d", "text": " [33], [34], even though they used Cohen's parametric effect size.", "part": "1"}], "links": {"documentLink": "/document/7497471", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7497471", "abstract": "Defect prediction models help software quality assurance teams to allocate their limited resources to the most defect-prone modules. Model validation techniques, such as $k$ -fold cross-validation, use historical data to estimate how well a model will perform in the future. However, little is known about how accurate the estimates of model validation techniques tend to be. In this paper, we investigate the bias and variance of model validation techniques in the domain of defect prediction. Analy...", "pdfSize": "2074KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+comparison+of+model+validation+techniques+for+defect+prediction+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "\"The impact of automated parameter optimization on defect prediction models\", <em>IEEE Transactions on Software Engineering (TSE)</em>, pp. 1-1, 2018.", "title": "The impact of automated parameter optimization on defect prediction models", "context": [{"sec": "sec6d", "text": " The use of effect size with Scott-Knott has also been recommended by Tantithamthavorn et al. [33], [34], even though they used Cohen's parametric effect size.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+automated+parameter+optimization+on+defect+prediction+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "T. Menzies, M. Shepperd, \"Special issue on repeatable results in software engineering prediction\", <em>Empirical Software Engineering (EMSE)</em>, vol. 17, pp. 1-17, 2012.", "title": "Special issue on repeatable results in software engineering prediction", "context": [{"sec": "sec8", "text": "When using machine learning approaches, poor parameter choices can highly influence the results [35], [36].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-011-9193-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Special+issue+on+repeatable+results+in+software+engineering+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "L. Song, L. L. Minku, X. Yao, \"The impact of parameter tuning on software effort estimation using learning machines\", <em>Proceedings of the 9th International Conference on Predictive Models in Software Engineering (PROMISE)</em>, pp. 1-10, 2013.", "title": "The impact of parameter tuning on software effort estimation using learning machines", "context": [{"sec": "sec8", "text": "When using machine learning approaches, poor parameter choices can highly influence the results [35], [36].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2499393.2499394", "abstract": "Background: The use of machine learning approaches for software effort estimation (SEE) has been studied for more than a decade. Most studies performed comparisons of different learning machines on a number of data sets. However, most learning machines have more than one parameter that needs to be tuned, and it is unknown to what extent parameter settings may affect their performance in SEE. Many works seem to make an implicit assumption that parameter settings would not change the outcomes sign...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+parameter+tuning+on+software+effort+estimation+using+learning+machines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812072", "articleId": "8812072", "startPage": "666", "endPage": "676", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 134}}
{"title": "Learning to Prioritize Test Programs for Compiler Testing", "authors": [{"name": "Junjie Chen", "affiliation": "Key Lab. of High Confidence Software Technol., Peking Univ., Beijing, China", "firstName": "Junjie", "lastName": "Chen", "id": "37085992325"}, {"name": "Yanwei Bai", "affiliation": "Key Lab. of High Confidence Software Technol., Peking Univ., Beijing, China", "firstName": "Yanwei", "lastName": "Bai", "id": "37085772778"}, {"name": "Dan Hao", "affiliation": "Key Lab. of High Confidence Software Technol., Peking Univ., Beijing, China", "firstName": "Dan", "lastName": "Hao", "id": "37265034100"}, {"name": "Yingfei Xiong", "affiliation": "Key Lab. of High Confidence Software Technol., Peking Univ., Beijing, China", "firstName": "Yingfei", "lastName": "Xiong", "id": "37085346278"}, {"name": "Hongyu Zhang", "affiliation": "Univ. of Newcastle, Newcastle, NSW, Australia", "firstName": "Hongyu", "lastName": "Zhang", "id": "37085775558"}, {"name": "Bing Xie", "affiliation": "Key Lab. of High Confidence Software Technol., Peking Univ., Beijing, China", "firstName": "Bing", "lastName": "Xie", "id": "37085365933"}], "abstract": "Compiler testing is a crucial way of guaranteeing the reliability of compilers (and software systems in general). Many techniques have been proposed to facilitate automated compiler testing. These techniques rely on a large number of test programs (which are test inputs of compilers) generated by some test-generation tools (e.g., CSmith). However, these compiler testing techniques have serious efficiency problems as they usually take a long period of time to find compiler bugs. To accelerate compiler testing, it is desirable to prioritize the generated test programs so that the test programs that are more likely to trigger compiler bugs are executed earlier. In this paper, we propose the idea of learning to test, which learns the characteristics of bug-revealing test programs from previous test programs that triggered bugs. Based on the idea of learning to test, we propose LET, an approach to prioritizing test programs for compiler testing acceleration. LET consists of a learning process and a scheduling process. In the learning process, LET identifies a set of features of test programs, trains a capability model to predict the probability of a new test program for triggering compiler bugs and a time model to predict the execution time of a test program. In the scheduling process, LET prioritizes new test programs according to their bug-revealing probabilities in unit time, which is calculated based on the two trained models. Our extensive experiments show that LET significantly accelerates compiler testing. In particular, LET reduces more than 50% of the testing time in 24.64% of the cases, and reduces between 25% and 50% of the testing time in 36.23% of the cases.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Computer bugs", "Testing", "Program processors", "Life estimation", "Feature extraction", "Training", "Predictive models"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["learning (artificial intelligence)", "program compilers", "program testing", "scheduling", "software reliability"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["compiler reliability", "software systems", "automated compiler testing", "test-generation tools", "compiler bugs", "bug-revealing test programs", "LET", "learning process", "scheduling process", "time model", "bug-revealing probabilities"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.70", "ref": [{"order": "1", "text": "V. Le, M. Afshari, Z. Su, \"Compiler validation via equivalence modulo inputs\", <em>Proceedings of the 35th Conference on Programming Language Design and Implementation</em>, pp. 25, 2014.", "title": "Compiler validation via equivalence modulo inputs", "context": [{"sec": "sec1", "text": " Compiler testing is an effective and widely-recognized way of ensuring the correctness of compilers [1].", "part": "1"}, {"sec": "sec1", "text": "Over the years, many techniques [2], [1], [3]\u2013[5] have been proposed to facilitate automated compiler testing.", "part": "1"}, {"sec": "sec1", "text": " [1] spent eleven months on detecting 147 C compiler bugs.", "part": "1"}, {"sec": "sec1", "text": "We evaluate LET using two compiler testing techniques (DOL [3] and EMI [1]), two subjects (GCC and LLVM), and two application scenarios (cross-compiler and cross-version scenarios).", "part": "1"}, {"sec": "sec3a", "text": "The test programs we use in both learning and scheduling processes are C programs randomly generated by CSmith [2], which is commonly used in the literature of C compiler testing [1], [3].", "part": "1"}, {"sec": "sec3d1", "text": "In this study, we consider two compiler testing techniques to accelerate, i.e., Different Optimization Level (DOL) [3] and Equivalence Modulo Inputs (EMI) [1].", "part": "1"}, {"sec": "sec3d1", "text": " [1], which generates some equivalent variants for any given test program and determines whether a compiler contains bugs by comparing the results produced by the original test program and its variants44In fact, EMI has three instantiations, namely Orion [1], Athena [17], and Hermes [18].", "part": "1"}, {"sec": "fn4", "text": "In fact, EMI has three instantiations, namely Orion [1], Athena [17], and Hermes [18].", "type": "footnote"}, {"sec": "sec3g", "text": " [1] did in their implementation.", "part": "1"}, {"sec": "sec3g", "text": " To reduce the threat resulting from compilers, we use all the C compilers that have been used in the literature on compiler testing [2], [1], [3].", "part": "1"}, {"sec": "sec3g", "text": " To reduce the threat resulting from test programs, we use C test programs randomly generated by CSmith as the prior work did [1]\u2013[3].", "part": "1"}, {"sec": "sec5a", "text": " [1] also demonstrated new test programs perform better than the regression test suite using EMI.", "part": "1"}, {"sec": "sec5a", "text": " Besides, existing compiler testing techniques [2], [1], [3] also use new test programs to test compilers.", "part": "1"}, {"sec": "sec6a", "text": " Moreover, compiler testing suffers from the test oracle problem as it is hard to tell the expected outputs of a compiler given some test programs [3], [1], [23]\u2013[25].", "part": "1"}, {"sec": "sec6a", "text": " [1], [17], [18] proposed to generate some equivalent variants for each original C program, which determines whether a compiler has bugs by comparing the results produced by the original program and its variants.", "part": "1"}, {"sec": "sec6a", "text": " This technique is called Equivalence Modulo Inputs, which has three instantiations: Orion [1], Athena [17], and Hermes [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Compiler+validation+via+equivalence+modulo+inputs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "X. Yang, Y. Chen, E. Eide, J. Regehr, \"Finding and understanding bugs in c compilers\", <em>Proceedings of the 32nd Conference on Programming Language Design and Implementation</em>, pp. 283-294, 2011.", "title": "Finding and understanding bugs in c compilers", "context": [{"sec": "sec1", "text": "Over the years, many techniques [2], [1], [3]\u2013[5] have been proposed to facilitate automated compiler testing.", "part": "1"}, {"sec": "sec1", "text": " [2] spent three years on detecting 325 C compiler bugs, and Le et al. [1] spent eleven months on detecting 147 C compiler bugs.", "part": "1"}, {"sec": "sec1", "text": "Since only a subset of test programs are able to trigger compiler bugs [3], [2], intuitively, compiler testing can be accelerated by running these test programs earlier.", "part": "1"}, {"sec": "sec2a1", "text": " In this paper we utilize a characteristic of the random test generation tool CSmith [2], one of the most widely-used random C program generator.", "part": "1"}, {"sec": "fn2", "text": "As our approach is implemented to accelerate compiler testing by using the test programs generated by CSmith [2], we directly extract the values of features (including the two types of features) from each test program during the test-generation process of CSmith.", "type": "footnote"}, {"sec": "sec3a", "text": "The test programs we use in both learning and scheduling processes are C programs randomly generated by CSmith [2], which is commonly used in the literature of C compiler testing [1], [3].", "part": "1"}, {"sec": "sec3g", "text": " To reduce the threat resulting from compilers, we use all the C compilers that have been used in the literature on compiler testing [2], [1], [3].", "part": "1"}, {"sec": "sec3g", "text": " To reduce the threat resulting from test programs, we use C test programs randomly generated by CSmith as the prior work did [1]\u2013[2][3].", "part": "1"}, {"sec": "sec5a", "text": " Besides, existing compiler testing techniques [2], [1], [3] also use new test programs to test compilers.", "part": "1"}, {"sec": "sec6a", "text": " [2], [33] proposed and implemented a tool, called CSmith, to randomly generate C programs without undefined behaviors for testing C compilers, and Regehr et al. [34] proposed test case reduction for C compiler bugs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1993498.1993532", "abstract": "Compilers should be correct. To improve the quality of C compilers, we created Csmith, a randomized test-case generation tool, and spent three years using it to find compiler bugs. During this period we reported more than 325 previously unknown bugs to compiler developers. Every compiler we tested was found to crash and also to silently generate wrong code when presented with valid input. In this paper we present our compiler-testing tool and the results of our bug-hunting study. Our first contr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+and+understanding+bugs+in+c+compilers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "J. Chen, W. Hu, D. Hao, Y. Xiong, H. Zhang, L. Zhang, B. Xie, \"An empirical comparison of compiler testing techniques\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 180-190, 2016.", "title": "An empirical comparison of compiler testing techniques", "context": [{"sec": "sec1", "text": "Over the years, many techniques [2], [1], [3]\u2013[5] have been proposed to facilitate automated compiler testing.", "part": "1"}, {"sec": "sec1", "text": "Since only a subset of test programs are able to trigger compiler bugs [3], [2], intuitively, compiler testing can be accelerated by running these test programs earlier.", "part": "1"}, {"sec": "sec1", "text": "We evaluate LET using two compiler testing techniques (DOL [3] and EMI [1]), two subjects (GCC and LLVM), and two application scenarios (cross-compiler and cross-version scenarios).", "part": "1"}, {"sec": "sec3a", "text": "The test programs we use in both learning and scheduling processes are C programs randomly generated by CSmith [2], which is commonly used in the literature of C compiler testing [1], [3].", "part": "1"}, {"sec": "sec3d1", "text": "In this study, we consider two compiler testing techniques to accelerate, i.e., Different Optimization Level (DOL) [3] and Equivalence Modulo Inputs (EMI) [1].", "part": "1"}, {"sec": "sec3d1", "text": "DOL is an effective compiler testing technique, which determines whether a compiler contains bugs by comparing the results produced by the same test program with different optimization levels (i.e., -O0, -O1, -Os, -O2 and -O3) [3].", "part": "1"}, {"sec": "sec3e", "text": " To solve this problem, we use the Correcting Commits technique used in previous work [3].", "part": "1"}, {"sec": "sec3g", "text": " To reduce the threat resulting from compilers, we use all the C compilers that have been used in the literature on compiler testing [2], [1], [3].", "part": "1"}, {"sec": "sec3g", "text": " To reduce the threat resulting from test programs, we use C test programs randomly generated by CSmith as the prior work did [1]\u2013[3].", "part": "1"}, {"sec": "sec3g", "text": " In measuring acceleration effectiveness, we use Correcting Commits to automatically identify duplicated bugs [3].", "part": "1"}, {"sec": "sec3g", "text": " However, it may not be a big threat because developers do not tend to fix many of bugs in one commit to guarantee software quality [3].", "part": "1"}, {"sec": "sec5a", "text": " Besides, existing compiler testing techniques [2], [1], [3] also use new test programs to test compilers.", "part": "1"}, {"sec": "sec6a", "text": " Moreover, compiler testing suffers from the test oracle problem as it is hard to tell the expected outputs of a compiler given some test programs [3], [1], [23]\u2013[25].", "part": "1"}, {"sec": "sec6a", "text": " [3] conducted an empirical study to compare mainstream compiler testing techniques (i.e., RDT, DOL and EMI), and Sun et al. [40] conducted a study to analyze the characteristics of the bugs in GCC and LLVM.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884878", "abstract": "Compilers, as one of the most important infrastructure of today&#39;s digital world, are expected to be trustworthy. Different testing techniques are developed for testing compilers automatically. However, it is unknown so far how these testing techniques compared to each other in terms of testing effectiveness: how many bugs a testing technique can find within a time limit. In this paper, we conduct a systematic and comprehensive empirical comparison of three compiler testing techniques, namely, Ra...", "pdfSize": "527KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+comparison+of+compiler+testing+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "V. Le, C. Sun, Z. Su, \"Randomized stress-testing of link-time optimizers\", <em>Proceedings of the 2015 International Symposium on Software Testing and Analysis</em>, pp. 327-337, 2015.", "title": "Randomized stress-testing of link-time optimizers", "context": [{"sec": "sec1", "text": "Over the years, many techniques [2], [1], [3]\u2013[4][5] have been proposed to facilitate automated compiler testing.", "part": "1"}, {"sec": "sec6a", "text": " In particular, differential testing needs two or more comparable compilers and determines whether some compilers have bugs by comparing the results produced by these compilers, which has been widely used to detect various compiler defects [5], [37], [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Randomized+stress-testing+of+link-time+optimizers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "C. Sun, V. Le, Z. Su, \"Finding and analyzing compiler warning defects\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, 2016.", "title": "Finding and analyzing compiler warning defects", "context": [{"sec": "sec1", "text": "Over the years, many techniques [2], [1], [3]\u2013[5] have been proposed to facilitate automated compiler testing.", "part": "1"}, {"sec": "sec6a", "text": " In particular, differential testing needs two or more comparable compilers and determines whether some compilers have bugs by comparing the results produced by these compilers, which has been widely used to detect various compiler defects [5], [37], [4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884879", "abstract": "Good compiler diagnostic warnings facilitate software development as they indicate likely programming mistakes or code smells. However, due to compiler bugs, the warnings may be erroneous, superfluous or missing, even for mature production compilers like GCC and Clang. In this paper, we (1) propose the first randomized differential testing technique to detect compiler warning defects and (2) describe our extensive evaluation in finding warning defects in widely-used C compilers.At the high level...", "pdfSize": "396KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+and+analyzing+compiler+warning+defects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "G. Rothermel, R.H. Untch, C. Chu, M.J. Harrold, \"Test case prioritization: an empirical study\", <em>Proceedings of the International Conference on Software Maintenance</em>, pp. 179-188, 1999.", "title": "Test case prioritization: an empirical study", "context": [{"sec": "sec1", "text": " The dominant prioritization approaches rely on structural coverage information (e.g., statement coverage and branch coverage) [6]\u2013[8], which is collected through regression testing [9], [10].", "part": "1"}, {"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[50], [9], which can be mainly classified into four groups.", "part": "1"}, {"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}, {"sec": "sec6b", "text": " The second group focuses on the algorithms used in test prioritization, including greedy algorithms (i.e., total and additional strategies [6]) and many meta heuristics algorithms [21], [55].", "part": "1"}, {"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+case+prioritization%3A+an+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "S. Elbaum, A. Malishevsky, G. Rothermel, \"Prioritizing test cases for regression testing\", <em>Proceedings of the International Symposium on Software Testing and Analysis</em>, pp. 102-112, 2000.", "title": "Prioritizing test cases for regression testing", "context": [{"sec": "sec1", "text": " The dominant prioritization approaches rely on structural coverage information (e.g., statement coverage and branch coverage) [6]\u2013[7][8], which is collected through regression testing [9], [10].", "part": "1"}, {"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[50], [9], which can be mainly classified into four groups.", "part": "1"}, {"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[7][8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/347324.348910", "abstract": "Test case prioritization techniques schedule test cases in an order that increases their effectiveness in meeting some performance goal. One performance goal, rate of fault detection, is a measure of how quickly faults are detected within the testing process; an improved rate of fault detection can provide faster feedback on the system under test, and let software engineers begin locating and correcting faults earlier than might otherwise be possible. In previous work, we reported the results of...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Prioritizing+test+cases+for+regression+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "J.A. Jones, M.J. Harrold, \"Test-suite reduction and prioritization for modified condition/decision coverage\", <em>Proceedings of the International Conference on Software Maintenance</em>, pp. 92-101, 2001.", "title": "Test-suite reduction and prioritization for modified condition/decision coverage", "context": [{"sec": "sec1", "text": " The dominant prioritization approaches rely on structural coverage information (e.g., statement coverage and branch coverage) [6]\u2013[8], which is collected through regression testing [9], [10].", "part": "1"}, {"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}], "links": {"abstract": "Software testing is particularly expensive for developers of high-assurance software, such as software that is produced for commercial airborne systems. One reason for this expense is the Federal Aviation Administration&#39;s requirement that test suites be modified condition/decision coverage (MC/DC) adequate. Despite its cost, there is evidence that MC/DC is an effective verification technique, and can help to uncover safety faults. As the software is modified and new test cases are added to the t...", "pdfSize": "268KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test-suite+reduction+and+prioritization+for+modified+condition%2Fdecision+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "D. Hao, L. Zhang, H. Mei, \"Test-case prioritization: achievements and challenges\", <em>Frontiers of Computer Science</em>, vol. 10, no. 5, pp. 769-777, 2016.", "title": "Test-case prioritization: achievements and challenges", "context": [{"sec": "sec1", "text": " The dominant prioritization approaches rely on structural coverage information (e.g., statement coverage and branch coverage) [6]\u2013[8], which is collected through regression testing [9], [10].", "part": "1"}, {"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[50], [9], which can be mainly classified into four groups.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test-case+prioritization%3A+achievements+and+challenges&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "J. Chen, Y. Bai, D. Hao, L. Zhang, L. Zhang, B. Xie, \"How do assertions impact coverage-based test-suite reduction?\", <em>Proceedings of the 10th International Conference on Software Testing Verification and Validation</em>, 2017.", "title": "How do assertions impact coverage-based test-suite reduction?", "context": [{"sec": "sec1", "text": " The dominant prioritization approaches rely on structural coverage information (e.g., statement coverage and branch coverage) [6]\u2013[8], which is collected through regression testing [9], [10].", "part": "1"}], "links": {"documentLink": "/document/7927995", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7927995", "abstract": "Code coverage is the dominant criterion in test-suite reduction. Typically, most test-suite reduction techniques repeatedly remove tests covering code that has been covered by other tests from the test suite. However, test-suite reduction based on code coverage alone may incur fault-detection capability loss, because a test detects faults if and only if its execution covers buggy code and its test oracle catches the buggy state. In other words, test oracles may also affect test-suite reduction, ...", "pdfSize": "171KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+assertions+impact+coverage-based+test-suite+reduction%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "B. Jiang, W.K. Chan, \"Input-based adaptive randomized test case prioritization: A local beam search approach\", <em>Journal of Systems and Software</em>, vol. 105, pp. 91-106, 2015.", "title": "Input-based adaptive randomized test case prioritization: A local beam search approach", "context": [{"sec": "sec1", "text": " Recently, researchers proposed some input-based prioritization approaches [11], [12], which rely on only test inputs (i.e., test programs in compiler testing) and do not require structural coverage information.", "part": "1"}, {"sec": "sec1", "text": " However, our experimental results (more details in Section IV-A) show that the existing input-based approaches [11], [12] can hardly accelerate compiler testing because of their low efficiency and effectiveness.", "part": "1"}, {"sec": "sec1", "text": " We also compare LET with two recent input-based test prioritization approaches, i.e., TB-G [12] and ARP [11].", "part": "1"}, {"sec": "sec3d2", "text": "Adaptive Random Prioritization (ARP), which selects the test input that has the maximal distance to the set of already selected test inputs [11].", "part": "1"}, {"sec": "sec4a3", "text": " Therefore, although ARP does not rely on structural coverage information and is reported to achieve acceptable effectiveness in general software [11], it cannot be applied to accelerate C compiler testing.", "part": "1"}, {"sec": "sec6b", "text": " [11] proposed an adaptive random prioritization technique, which prioritizes the execution order of test cases based on only test inputs rather than coverage information.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2015.03.066", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Input-based+adaptive+randomized+test+case+prioritization%3A+A+local+beam+search+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "J. Chen, Y. Bai, D. Hao, Y. Xiong, H. Zhang, L. Zhang, B. Xie, \"Test case prioritization for compilers: A text-vector based approach\", <em>Proceedings of the 9th International Conference on Software Testing Verification and Validation</em>, pp. 266-277, 2016.", "title": "Test case prioritization for compilers: A text-vector based approach", "context": [{"sec": "sec1", "text": " Recently, researchers proposed some input-based prioritization approaches [11], [12], which rely on only test inputs (i.e., test programs in compiler testing) and do not require structural coverage information.", "part": "1"}, {"sec": "sec1", "text": " However, our experimental results (more details in Section IV-A) show that the existing input-based approaches [11], [12] can hardly accelerate compiler testing because of their low efficiency and effectiveness.", "part": "1"}, {"sec": "sec1", "text": " We also compare LET with two recent input-based test prioritization approaches, i.e., TB-G [12] and ARP [11].", "part": "1"}, {"sec": "sec3d2", "text": "Token-vector based prioritization (TB-G) [12], which is the first test case prioritization approach for compilers.", "part": "1"}, {"sec": "sec3d2", "text": " As an existing study [12] reveals, TB-G is the most cost-effective strategy among a set of studied techniques.", "part": "1"}, {"sec": "sec3e", "text": " Note that we do not use the average percentage of detected faults (abbreviated as APFD) [20]\u2013[12], because developers usually care more about the time spent in compiler testing rather than the number of test programs used in compiler testing.", "part": "1"}, {"sec": "sec4a3", "text": "In our experiment, ARP does not accelerate compiler testing at all, which is consistent with the existing study [12].", "part": "1"}, {"sec": "sec6b", "text": " [12] proposed a text-vector based prioritization approach, which transforms each test case into a text-vector by extracting corresponding tokens.", "part": "1"}], "links": {"documentLink": "/document/7515478", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7515478", "abstract": "Test case prioritization aims to schedule the execution order of test cases so as to detect bugs as early as possible. For compiler testing, the demand for both effectiveness and efficiency imposes challenge to test case prioritization. In the literature, most existing approaches prioritize test cases by using some coverage information (e.g., statement coverage or branch coverage), which is collected with considerable extra effort. Although input-based test case prioritization relies only on tes...", "pdfSize": "293KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+case+prioritization+for+compilers%3A+A+text-vector+based+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. Dai, Q. Xu, \"Attribute selection based on information gain ratio in fuzzy rough set theory with application to tumor classification\", <em>Applied Software Computing</em>, vol. 13, no. 1, pp. 211-221, 2013.", "title": "Attribute selection based on information gain ratio in fuzzy rough set theory with application to tumor classification", "context": [{"sec": "sec2a2", "text": " Information gain ratio is a ratio of information gain to the intrinsic information, which is usually a good measure for identifying the contribution of a feature and is able to reduce the bias towards multi-valued features in existing feature selection metrics [13].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.asoc.2012.07.029", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Attribute+selection+based+on+information+gain+ratio+in+fuzzy+rough+set+theory+with+application+to+tumor+classification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "Y.K. Jain, S.K. Bhandare, \"Min max normalization based data perturbation method for privacy protection\", <em>International Journal of Computer & Communication Technology</em>, vol. 2, no. 8, pp. 45-50, 2011.", "title": "Min max normalization based data perturbation method for privacy protection", "context": [{"sec": "sec2a2", "text": " Since the features are either numeric type or Boolean type (i.e., 0 or 1), LET normalizes each value of these features into the interval [0, 1] using min-max normalization [14].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Min+max+normalization+based+data+perturbation+method+for+privacy+protection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "J.C. Platt, \"Fast training of support vector machines using sequential minimal optimization\", <em>Advances in kernel methods</em>, pp. 185-208, 1999.", "title": "Fast training of support vector machines using sequential minimal optimization", "context": [{"sec": "sec2a2", "text": " After feature selection and normalization, we adopt a machine learning algorithm, Sequential Minimal Optimization (abbreviated as SMO) algorithm [15], to build the capability model.", "part": "1"}, {"sec": "sec2a2", "text": " The SMO algorithm is a support vector machine algorithm, which speeds up standard support vector machines by breaking a very large quadratic programming optimization problem into a series of smallest possible quadratic programming optimization problems [15].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fast+training+of+support+vector+machines+using+sequential+minimal+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "C.E. Rasmussen, \"Gaussian processes in machine learning\", <em>Advanced lectures on machine learning</em>, pp. 63-71, 2004.", "title": "Gaussian processes in machine learning", "context": [{"sec": "sec2a3", "text": " Gaussian process uses lazy learning and a measure of the similarity between points (i.e., the kernel function) to predict the value for an unseen point from the training set [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gaussian+processes+in+machine+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "V. Le, C. Sun, Z. Su, \"Finding deep compiler bugs via guided stochastic program mutation\", <em>Proceedings of the 2015 International Conference on Object-Oriented Programming Systems Languages and Applications</em>, pp. 386-399, 2015.", "title": "Finding deep compiler bugs via guided stochastic program mutation", "context": [{"sec": "fn4", "text": "In fact, EMI has three instantiations, namely Orion [1], Athena [17], and Hermes [18].", "type": "footnote"}, {"sec": "sec6a", "text": " Le et al. [1], [17], [18] proposed to generate some equivalent variants for each original C program, which determines whether a compiler has bugs by comparing the results produced by the original program and its variants.", "part": "1"}, {"sec": "sec6a", "text": " This technique is called Equivalence Modulo Inputs, which has three instantiations: Orion [1], Athena [17], and Hermes [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+deep+compiler+bugs+via+guided+stochastic+program+mutation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "C. Sun, V. Le, Z. Su, \"Finding compiler bugs via live code mutation\", <em>Proceedings of International Conference on Object-Oriented Programming Systems Languages and Applications</em>, pp. 849-863, 2016.", "title": "Finding compiler bugs via live code mutation", "context": [{"sec": "fn4", "text": "In fact, EMI has three instantiations, namely Orion [1], Athena [17], and Hermes [18].", "type": "footnote"}, {"sec": "sec6a", "text": " Le et al. [1], [17], [18] proposed to generate some equivalent variants for each original C program, which determines whether a compiler has bugs by comparing the results produced by the original program and its variants.", "part": "1"}, {"sec": "sec6a", "text": " This technique is called Equivalence Modulo Inputs, which has three instantiations: Orion [1], Athena [17], and Hermes [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2983990.2984038", "abstract": "Validating optimizing compilers is challenging because it is hard to generate valid test programs (i.e., those that do not expose any undefined behavior). Equivalence Modulo Inputs (EMI) is an effective, promising methodology to tackle this problem. Given a test program with some inputs, EMI mutates the program to derive variants that are semantically equivalent w.r.t. these inputs. The state-of-the-art instantiations of EMI are Orion and Athena, both of which rely on deleting code from or inser...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+compiler+bugs+via+live+code+mutation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "M. Hall, E. Frank, G. Holmes, B. Pfahringer, P. Reutemann, I.H. Witten, \"The weka data mining software: an update\", <em>ACM SIGKDD explorations newsletter</em>, vol. 11, no. 1, pp. 10-18, 2009.", "title": "The weka data mining software: an update", "context": [{"sec": "sec3d3", "text": "To implement LET, LET-A and LET-B, we use Weka 3.6.12 [19], which is a popular environment for data mining.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1656274.1656278", "abstract": "More than twelve years have elapsed since the first public release of WEKA. In that time, the software has been rewritten entirely from scratch, evolved substantially and now accompanies a text on data mining [35]. These days, WEKA enjoys widespread acceptance in both academia and business, has an active community, and has been downloaded more than 1.4 million times since being placed on Source-Forge in April 2000. This paper provides an introduction to the WEKA workbench, reviews the history of...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+weka+data+mining+software%3A+an+update&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "D. Hao, L. Zhang, L. Zang, Y. Wang, X. Wu, T. Xie, \"To be optimal or not in test-case prioritization\", <em>IEEE Transactions on Software Engineering</em>, vol. 42, no. 5, pp. 490-505, 2015.", "title": "To be optimal or not in test-case prioritization", "context": [{"sec": "sec3e", "text": " Note that we do not use the average percentage of detected faults (abbreviated as APFD) [20]\u2013[12], because developers usually care more about the time spent in compiler testing rather than the number of test programs used in compiler testing.", "part": "1"}], "links": {"documentLink": "/document/7314957", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7314957", "abstract": "Software testing aims to assure the quality of software under test. To improve the efficiency of software testing, especially regression testing, test-case prioritization is proposed to schedule the execution order of test cases in software testing. Among various test-case prioritization techniques, the simple additional coverage-based technique, which is a greedy strategy, achieves surprisingly competitive empirical results. To investigate how much difference there is between the order produced...", "pdfSize": "704KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=To+be+optimal+or+not+in+test-case+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Z. Li, M. Harman, R. Hierons, \"Search algorithms for regression test case prioritisation\", <em>IEEE Transactions on Software Engineering</em>, vol. 33, no. 4, pp. 225-237, 2007.", "title": "Search algorithms for regression test case prioritisation", "context": [{"sec": "sec3e", "text": " Note that we do not use the average percentage of detected faults (abbreviated as APFD) [20]\u2013[21][12], because developers usually care more about the time spent in compiler testing rather than the number of test programs used in compiler testing.", "part": "1"}, {"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[50], [9], which can be mainly classified into four groups.", "part": "1"}, {"sec": "sec6b", "text": " The second group focuses on the algorithms used in test prioritization, including greedy algorithms (i.e., total and additional strategies [6]) and many meta heuristics algorithms [21], [55].", "part": "1"}], "links": {"documentLink": "/document/4123325", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4123325", "abstract": "Regression testing is an expensive, but important, process. Unfortunately, there may be insufficient resources to allow for the reexecution of all test cases during regression testing. In this situation, test case prioritization techniques aim to improve the effectiveness of regression testing by ordering the test cases so that the most beneficial are executed first. Previous work on regression test case prioritization has focused on greedy algorithms. However, it is known that these algorithms ...", "pdfSize": "3667KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Search+algorithms+for+regression+test+case+prioritisation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "W.M. McKeeman, \"Differential testing for software\", <em>Digital Technical Journal</em>, vol. 10, no. 1, pp. 100-107, 1998.", "title": "Differential testing for software", "context": [{"sec": "sec5c", "text": "First, besides the compiler testing techniques used in the evaluation, LET can be applied to accelerate other compiler testing techniques, e.g., Randomized Differential Testing (RDT) [22] by feeding the prioritized test programs to these techniques.", "part": "1"}, {"sec": "sec6a", "text": " [22] coined the term of differential testing, which is a form of random testing.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Differential+testing+for+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "J. Chen, Y. Bai, D. Hao, L. Zhang, L. Zhang, B. Xie, H. Mei, \"Supporting oracle construction via static analysis\", <em>Proceedings of the 31st International Conference on Automated Software Engineering</em>, pp. 178-189, 2016.", "title": "Supporting oracle construction via static analysis", "context": [{"sec": "sec6a", "text": " Moreover, compiler testing suffers from the test oracle problem as it is hard to tell the expected outputs of a compiler given some test programs [3], [1], [23]\u2013[25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970366", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+oracle+construction+via+static+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "A.F. Donaldson, A. Lascu, \"Metamorphic testing for (graphics) compilers\", <em>Proceedings of the 1st International Workshop on Metamorphic Testing</em>, pp. 44-47, 2016.", "title": "Metamorphic testing for (graphics) compilers", "context": [{"sec": "sec6a", "text": " Moreover, compiler testing suffers from the test oracle problem as it is hard to tell the expected outputs of a compiler given some test programs [3], [1], [23]\u2013[24][25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Metamorphic+testing+for+%28graphics%29+compilers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "C. Lidbury, A. Lascu, N. Chong, A.F. Donaldson, \"Many-core compiler fuzzing\", <em>Proceedings of the 36th Conference on Programming Language Design and Implementation</em>, pp. 65-76, 2015.", "title": "Many-core compiler fuzzing", "context": [{"sec": "sec6a", "text": " Moreover, compiler testing suffers from the test oracle problem as it is hard to tell the expected outputs of a compiler given some test programs [3], [1], [23]\u2013[25].", "part": "1"}, {"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[32].", "part": "1"}, {"sec": "sec6a", "text": " [25] developed CLsmith based on CSmith to generate programs to test OpenCL compilers, and Pflanzer et al. [36] proposed test case reduction for OpenCL.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2737986", "abstract": "We address the compiler correctness problem for many-core systems through novel applications of fuzz testing to OpenCL compilers. Focusing on two methods from prior work, random differential testing and testing via equivalence modulo inputs (EMI), we present several strategies for random generation of deterministic, communicating OpenCL kernels, and an injection mechanism that allows EMI testing to be applied to kernels that otherwise exhibit little or no dynamically-dead code. We use these meth...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Many-core+compiler+fuzzing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "K.V. Hanford, \"Automatic generation of test cases\", <em>IBM Systems Journal</em>, vol. 9, no. 4, pp. 242-257, 1970.", "title": "Automatic generation of test cases", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1147/sj.94.0242", "abstract": "The machine production of programs for testing certain aspects of programming products has been achieved. The system has been successfully used on a number of products to establish their reliability in accepting new test cases without error. The input to the system is a syntax definition in a formal notation. The construction of such a definition for a high-level language is an exacting task. It yields important bonuses by deepening knowledge of the structure of the language and showing up obscu...", "pdfSize": "1603KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+generation+of+test+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "R.L. Sauder, \"A general test data generator for cobol\", <em>Proceedings of the 1962 spring joint computer conference</em>, pp. 317-323, 1962.", "title": "A general test data generator for cobol", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1460833.1460869", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+general+test+data+generator+for+cobol&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "F. Sheridan, \"Practical testing of a c99 compiler using output comparison\", <em>Software: Practice and Experience</em>, vol. 37, no. 14, pp. 1475-1488, 2007.", "title": "Practical testing of a c99 compiler using output comparison", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/spe.812", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+testing+of+a+c99+compiler+using+output+comparison&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "C. Lindig, \"Random testing of c calling conventions\", <em>Proceedings of the 6th international symposium on Automated analysis-driven debugging</em>, pp. 3-12, 2005.", "title": "Random testing of c calling conventions", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[29][32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1085130.1085132", "abstract": "In a C compiler, function calls are difficult to implement correctly because they must respect a platform-specific calling convention. But they are governed by a simple invariant: parameters passed to a function must be received unaltered. A violation of this invariant signals an inconsistency in a compiler. We automatically test the consistency of C compilers using randomly generated programs. An inconsistency manifests itself as an assertion failure when compiling and running the generated cod...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Random+testing+of+c+calling+conventions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "E. Nagai, H. Awazu, N. Ishiura, N. Takeda, \"Random testing of c compilers targeting arithmetic optimization\", <em>Workshop on Synthesis And System Integration of Mixed Information Technologies</em>, pp. 48-53, 2012.", "title": "Random testing of c compilers targeting arithmetic optimization", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[30][32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Random+testing+of+c+compilers+targeting+arithmetic+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "E. Nagai, A. Hashimoto, N. Ishiura, \"Scaling up size and number of expressions in random testing of arithmetic optimization of c compilers\", <em>Workshop on Synthesis And System Integration of Mixed Information Technologies</em>, pp. 88-93, 2013.", "title": "Scaling up size and number of expressions in random testing of arithmetic optimization of c compilers", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[31][32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scaling+up+size+and+number+of+expressions+in+random+testing+of+arithmetic+optimization+of+c+compilers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "M.H. Palka, K. Claessen, A. Russo, J. Hughes, \"Testing an optimising compiler by generating random lambda terms\", <em>Proceedings of the 6th InternationalWorkshop on Automation of Software Test</em>, pp. 91-97, 2011.", "title": "Testing an optimising compiler by generating random lambda terms", "context": [{"sec": "sec6a", "text": "For test program generation, random test program generation is a main generation technique [26], [27], [25], [28]\u2013[32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1982595.1982615", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testing+an+optimising+compiler+by+generating+random+lambda+terms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "Y. Chen, A. Groce, C. Zhang, W.-K. Wong, X. Fern, E. Eide, J. Regehr, \"Taming compiler fuzzers\", <em>Proceedings of the 34th Conference on Programming Language Design and Implementation</em>, vol. 48, no. 6, pp. 197-208, 2013.", "title": "Taming compiler fuzzers", "context": [{"sec": "sec6a", "text": " For example, Yang et al. [2], [33] proposed and implemented a tool, called CSmith, to randomly generate C programs without undefined behaviors for testing C compilers, and Regehr et al. [34] proposed test case reduction for C compiler bugs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491956.2462173", "abstract": "Aggressive random testing tools (&#34;fuzzers&#34;) are impressively effective at finding compiler bugs. For example, a single test-case generator has resulted in more than 1,700 bugs reported for a single JavaScript engine. However, fuzzers can be frustrating to use: they indiscriminately and repeatedly find bugs that may not be severe enough to fix right away. Currently, users filter out undesirable test cases using ad hoc methods such as disallowing problematic features in tests and grepping test res...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Taming+compiler+fuzzers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "J. Regehr, Y. Chen, P. Cuoq, E. Eide, C. Ellison, X. Yang, \"Test-case reduction for c compiler bugs\", <em>Proceedings of the 33rd Conference on Programming Language Design and Implementation</em>, vol. 47, no. 6, pp. 335-346, 2012.", "title": "Test-case reduction for c compiler bugs", "context": [{"sec": "sec6a", "text": " [34] proposed test case reduction for C compiler bugs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254104", "abstract": "To report a compiler bug, one must often find a small test case that triggers the bug. The existing approach to automated test-case reduction, delta debugging, works by removing substrings of the original input; the result is a concatenation of substrings that delta cannot remove. We have found this approach less than ideal for reducing C programs because it typically yields test cases that are too large or even invalid (relying on undefined behavior). To obtain small and valid test cases consis...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test-case+reduction+for+c+compiler+bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "C. Zhao, Y. Xue, Q. Tao, L. Guo, Z. Wang, \"Automated test program generation for an industrial optimizing compiler\", <em>2009 ICSE Workshop on Automation of Software Test</em>, pp. 36-43, 2009.", "title": "Automated test program generation for an industrial optimizing compiler", "context": [{"sec": "sec6a", "text": " [35] developed an integrated tool (JTT), which automatically generates programs to test UniPhier, an embedded C++ compiler.", "part": "1"}], "links": {"documentLink": "/document/5069039", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5069039", "abstract": "This paper presents joint research and practice on automated test program generation for an industrial compiler, UniPhier, by Matsushita Electric Industrial Co., Ltd. (MEI) and Institute of Software, Chinese Academy of Sciences (ISCAS) since Sept. 2002. To meet the test requirements of MEI&#39;s engineers, we proposed an automated approach to produce test programs for UniPhier, and as a result we developed an integrated tool named JTT. Firstly, we show the script-driven test program generation proce...", "pdfSize": "265KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+test+program+generation+for+an+industrial+optimizing+compiler&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "M. Pflanzer, A.F. Donaldson, A. Lascu, \"Automatic test case reduction for opencl\", <em>Proceedings of the 4th International Workshop on OpenCL</em>, pp. 1, 2016.", "title": "Automatic test case reduction for opencl", "context": [{"sec": "sec6a", "text": " [36] proposed test case reduction for OpenCL.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2909437.2909439", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+test+case+reduction+for+opencl&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "Y. Chen, T. Su, C. Sun, Z. Su, J. Zhao, \"Coverage-directed differential testing of jvm implementations\", <em>PLDI 2016</em>, pp. 85-99.", "title": "Coverage-directed differential testing of jvm implementations", "context": [{"sec": "sec6a", "text": " In particular, differential testing needs two or more comparable compilers and determines whether some compilers have bugs by comparing the results produced by these compilers, which has been widely used to detect various compiler defects [5], [37], [4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2908080.2908095", "abstract": "Java virtual machine (JVM) is a core technology, whose reliability is critical. Testing JVM implementations requires painstaking effort in designing test classfiles (*.class) along with their test oracles. An alternative is to employ binary fuzzing to differentially test JVMs by blindly mutating seeding classfiles and then executing the resulting mutants on different JVM binaries for revealing inconsistent behaviors. However, this blind approach is not cost effective in practice because most of ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coverage-directed+differential+testing+of+jvm+implementations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "Q. Tao, W. Wu, C. Zhao, W. Shen, \"An automatic testing approach for compiler based on metamorphic testing technique\", <em>Proceedings of the 2010 Asia Pacific Software Engineering Conference</em>, pp. 270-279, 2010.", "title": "An automatic testing approach for compiler based on metamorphic testing technique", "context": [{"sec": "sec6a", "text": " [38] proposed to test compilers by constructing metamorphic relations, e.g., the equivalent relation.", "part": "1"}], "links": {"abstract": "Compilers play an important role in software development, and it is quite necessary to perform abundant testing to ensure the correctness of compilers. A critical task in compiler testing is to validate the semantic-soundness property which requires consistence between semantics of source programs and behavior of target executables. For validating this property, one main challenging issue is generation of a test oracle. Most existing approaches fall into two main categories when dealing with thi...", "pdfSize": "678KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+automatic+testing+approach+for+compiler+based+on+metamorphic+testing+technique&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "M. Boussaa, O. Barais, B. Baudry, G. Suny\u00e9, \"Notice: A framework for non-functional testing of compilers\", <em>Proceedings of the 2016 IEEE International Conference on Software Quality Reliability & Security</em>, 2016.", "title": "Notice: A framework for non-functional testing of compilers", "context": [{"sec": "sec6a", "text": " [39] proposed NOTICE, a component-based framework for non-functional testing of compilers according to user requirements.", "part": "1"}], "links": {"abstract": "Generally, compiler users apply different optimizations to generate efficient code with respect to non-functional properties such as energy consumption, execution time, etc. However, due to the huge number of optimizations provided by modern compilers, finding the best optimization sequence for a specific objective and a given program is more and more challenging. This paper proposes NOTICE, a component-based framework for non-functional testing of compilers through the monitoring of generated c...", "pdfSize": "948KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Notice%3A+A+framework+for+non-functional+testing+of+compilers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "C. Sun, V. Le, Q. Zhang, Z. Su, \"Toward understanding compiler bugs in gcc and llvm\", <em>ISSTA 2016</em>, pp. 294-305.", "title": "Toward understanding compiler bugs in gcc and llvm", "context": [{"sec": "sec6a", "text": " [40] conducted a study to analyze the characteristics of the bugs in GCC and LLVM.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931074", "abstract": "Compilers are critical, widely-used complex software. Bugs in them have significant impact, and can cause serious damage when they silently miscompile a safety-critical application. An in-depth understanding of compiler bugs can help detect and fix them. To this end, we conduct the first empirical study on the characteristics of the bugs in two main-stream compilers, GCC and LLVM. Our study is significant in scale \u2014 it exhaustively examines about 50K bugs and 30K bug fix revisions over more than...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Toward+understanding+compiler+bugs+in+gcc+and+llvm&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "H. Park, H. Ryu, J. Baik, \"Historical value-based approach for cost-cognizant test case prioritization to improve the effectiveness of regression testing\", <em>Proceedings of the International Conference on Secure Software Integration and Reliability Improvement</em>, pp. 39-46, 2008.", "title": "Historical value-based approach for cost-cognizant test case prioritization to improve the effectiveness of regression testing", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[50], [9], which can be mainly classified into four groups.", "part": "1"}, {"sec": "sec6b", "text": " The fourth group focuses on constraints that affect test prioritization, e.g., time constraints [57], and the work in this group investigates the influence of the constraints and prioritization techniques specific to some constraints [41], [62], [63], [59], [64].", "part": "1"}], "links": {"documentLink": "/document/4579792", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4579792", "abstract": "Regression testing has been used to support software testing activities and assure the acquirement of appropriate quality through several versions of a software program. Regression testing, however, is too expensive because it requires many test case executions, and the number of test cases increases sharply as the software evolves. In this paper, we propose the Historical Value-Based Approach, which is based on the use of historical information, to estimate the current cost and fault severity f...", "pdfSize": "402KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Historical+value-based+approach+for+cost-cognizant+test+case+prioritization+to+improve+the+effectiveness+of+regression+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "V. Jagannath, Q. Luo, D. Marinov, \"Change-aware preemption prioritization\", <em>Proceedings of the 2011 International Symposium on Software Testing and Analysis</em>, pp. 133-143, 2011.", "title": "Change-aware preemption prioritization", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[42][50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2001420.2001437", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Change-aware+preemption+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "P. Tonella, P. Avesani, A. Susi, \"Using the case-based ranking methodology for test case prioritization\", <em>Proceedings of the 22nd International Conference on Software Maintenance</em>, pp. 123-133, 2006.", "title": "Using the case-based ranking methodology for test case prioritization", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[43][50], [9], which can be mainly classified into four groups.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+the+case-based+ranking+methodology+for+test+case+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "B. Busjaeger, T. Xie, \"Learning for test prioritization: an industrial case study\", <em>Proceedings of the 24th International Symposium on Foundations of Software Engineering</em>, pp. 975-980, 2016.", "title": "Learning for test prioritization: an industrial case study", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[44][50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2983954", "abstract": "Modern cloud-software providers, such as Salesforce.com, increasingly adopt large-scale continuous integration environments. In such environments, assuring high developer productivity is strongly dependent on conducting testing efficiently and effectively. Specifically, to shorten feedback cycles, test prioritization is popularly used as an optimization mechanism for ranking tests to run by their likelihood of revealing failures. To apply test prioritization in industrial environments, we presen...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+for+test+prioritization%3A+an+industrial+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "H. Srikanth, S. Banerjee, L. Williams, J. Osborne, \"Towards the prioritization of system test cases\", <em>Software Testing Verification and Reliability</em>, vol. 24, no. 4, pp. 320-337, 2014.", "title": "Towards the prioritization of system test cases", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[45][50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stvr.1500", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+the+prioritization+of+system+test+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "A. Besz\u00e9des, T. Gergely, L. Schrettner, J. J\u00e1sz, L. Lang\u00f3, T. Gyim\u00f3thy, \"Code coverage-based regression test selection and prioritization in webkit\", <em>Proceedings of the 2012 28th IEEE International Conference on Software Maintenance</em>, pp. 46-55, 2012.", "title": "Code coverage-based regression test selection and prioritization in webkit", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[46][50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"abstract": "Automated regression testing is often crucial in order to maintain the quality of a continuously evolving software system. However, in many cases regression test suites tend to grow too large to be suitable for full re-execution at each change of the software. In this case selective retesting can be applied to reduce the testing cost while maintaining similar defect detection capability. One of the basic test selection methods is the one based on code coverage information, where only those tests...", "pdfSize": "394KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+coverage-based+regression+test+selection+and+prioritization+in+webkit&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "X. Qu, M.B. Cohen, K.M. Woolf, \"Combinatorial interaction regression testing: A study of test case generation and prioritization\", <em>Proceedings of the 2007 IEEE International Conference on Software Maintenance</em>, pp. 255-264, 2007.", "title": "Combinatorial interaction regression testing: A study of test case generation and prioritization", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[47][50], [9], which can be mainly classified into four groups.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combinatorial+interaction+regression+testing%3A+A+study+of+test+case+generation+and+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "J.A. Jones, M.J. Harrold, \"Test-suite reduction and prioritization for modified condition/decision coverage\", <em>IEEE Transactions on Software Engineering</em>, vol. 29, no. 3, pp. 195-209, 2003.", "title": "Test-suite reduction and prioritization for modified condition/decision coverage", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[48][50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"documentLink": "/document/1183927", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1183927", "abstract": "Software testing is particularly expensive for developers of high-assurance software, such as software that is produced for commercial airborne systems. One reason for this expense is the Federal Aviation Administration&#39;s requirement that test suites be modified condition/decision coverage (MC/DC) adequate. Despite its cost, there is evidence that MC/DC is an effective verification technique and can help to uncover safety faults. As the software is modified and new test cases are added to the te...", "pdfSize": "1195KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test-suite+reduction+and+prioritization+for+modified+condition%2Fdecision+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "Q. Luo, K. Moran, D. Poshyvanyk, \"A large-scale empirical comparison of static and dynamic test case prioritization techniques\", <em>Proceedings of 24th ACM SIGSOFT International Symposium on the Foundations of Software Engineering</em>, 2016.", "title": "A large-scale empirical comparison of static and dynamic test case prioritization techniques", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[49][50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950344", "abstract": "The large body of existing research in Test Case Prioritization (TCP) techniques, can be broadly classified into two categories: dynamic techniques (that rely on run-time execution information) and static techniques (that operate directly on source and test code). Absent from this current body of work is a comprehensive study aimed at understanding and evaluating the static approaches and comparing them to dynamic approaches on a large set of projects. In this work, we perform the first extensiv...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+large-scale+empirical+comparison+of+static+and+dynamic+test+case+prioritization+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "Q. Gao, J. Li, Y. Xiong, D. Hao, X. Xiao, K. Taneja, L. Zhang, T. Xie, \"High-confidence software evolution\", <em>Science China Information Sciences</em>, vol. 59, no. 7, pp. 071 101:1-071 101:19, 2016.", "title": "High-confidence software evolution", "context": [{"sec": "sec6b", "text": "In the literature, there is a considerable amount of research on test prioritization [6], [21], [7], [41]\u2013[50], [9], which can be mainly classified into four groups.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s11432-016-5572-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=High-confidence+software+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "H. Mei, D. Hao, L. Zhang, L. Zhang, J. Zhou, G. Rothermel, \"A static approach to prioritizing junit test cases\", <em>Transactions on Software Engineering</em>, vol. 38, no. 6, pp. 1258-1275, 2012.", "title": "A static approach to prioritizing junit test cases", "context": [{"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}], "links": {"documentLink": "/document/6363461", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6363461", "abstract": "Test case prioritization is used in regression testing to schedule the execution order of test cases so as to expose faults earlier in testing. Over the past few years, many test case prioritization techniques have been proposed in the literature. Most of these techniques require data on dynamic execution in the form of code coverage information for test cases. However, the collection of dynamic code coverage information on test cases has several associated drawbacks including cost increases and...", "pdfSize": "4358KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+static+approach+to+prioritizing+junit+test+cases&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "S. Elbaum, A. Malishevsky, G. Rothermel, \"Test case prioritization: a family of empirical studies\", <em>IEEE Transactions on Software Engineering</em>, vol. 28, no. 2, pp. 159-182, 2002.", "title": "Test case prioritization: a family of empirical studies", "context": [{"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}], "links": {"documentLink": "/document/988497", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=988497", "abstract": "To reduce the cost of regression testing, software testers may prioritize their test cases so that those which are more important, by some measure, are run earlier in the regression testing process. One potential goal of such prioritization is to increase a test suite&#39;s rate of fault detection. Previous work reported results of studies that showed that prioritization techniques can significantly improve rate of fault detection. Those studies, however, raised several additional questions: 1) Can ...", "pdfSize": "1356KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+case+prioritization%3A+a+family+of+empirical+studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "L. Mei, Z. Zhang, W.K. Chan, T.H. Tse, \"Test case prioritization for regression testing of service-oriented business applications\", <em>Proceedings of the InternationalWorld Wide Web Conference</em>, pp. 901-910, 2009.", "title": "Test case prioritization for regression testing of service-oriented business applications", "context": [{"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1526709.1526830", "abstract": "Regression testing assures the quality of modified service-oriented business applications against unintended changes. However, a typical regression test suite is large in size. Earlier execution of those test cases that may detect failures is attractive. Many existing prioritization techniques order test cases according to their respective coverage of program statements in a previous version of the application. On the other hand, industrial service-oriented business applications are typically wr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+case+prioritization+for+regression+testing+of+service-oriented+business+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "B. Korel, L. Tahat, M. Harman, \"Test prioritization using system models\", <em>Proceedings of the International Conference on Software Maintenance</em>, pp. 559-568, 2005.", "title": "Test prioritization using system models", "context": [{"sec": "sec6b", "text": " The first group focuses on the criterion used in test prioritization, including structural coverage criterion [6]\u2013[8], [51], the probability of exposing faults [52], dataflow coverage [53] and system model coverage [54].", "part": "1"}], "links": {"documentLink": "/document/1510150", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1510150", "abstract": "During regression testing, a modified system is retested using the existing test suite. Because the size of the test suite may be very large, testers are interested in detecting faults in the system as early as possible during the retesting process. Test prioritization tries to order test cases for execution so the chances of early detection of faults during retesting are increased. The existing prioritization methods are based on the code of the system. System modeling is a widely used techniqu...", "pdfSize": "193KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+prioritization+using+system+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "B. Jiang, Z. Zhang, W.K. Chan, T.H. Tse, \"Adaptive random test case prioritization\", <em>Proceedings of Automated Software Engineering</em>, pp. 257-266, 2009.", "title": "Adaptive random test case prioritization", "context": [{"sec": "sec6b", "text": " The second group focuses on the algorithms used in test prioritization, including greedy algorithms (i.e., total and additional strategies [6]) and many meta heuristics algorithms [21], [55].", "part": "1"}], "links": {"abstract": "Regression testing assures changed programs against unintended amendments. Rearranging the execution order of test cases is a key idea to improve their effectiveness. Paradoxically, many test case prioritization techniques resolve tie cases using the random selection approach, and yet random ordering of test cases has been considered as ineffective. Existing unit testing research unveils that adaptive random testing (ART) is a promising candidate that may replace random testing (RT). In this pap...", "pdfSize": "817KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adaptive+random+test+case+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "M. Qu, M.B. Cohen, K.M. Woolf, \"Combinatorial interaction regression testing: a study of test case generation and prioritization\", <em>Proceedings of the International Conference on Software Maintenance</em>, pp. 255-264, 2007.", "title": "Combinatorial interaction regression testing: a study of test case generation and prioritization", "context": [{"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combinatorial+interaction+regression+testing%3A+a+study+of+test+case+generation+and+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "S. Elbaum, A. Malishevsky, G. Rothermel, \"Incorporating varying test costs and fault severities into test case prioritization\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 329-338, 2001.", "title": "Incorporating varying test costs and fault severities into test case prioritization", "context": [{"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}, {"sec": "sec6b", "text": " The fourth group focuses on constraints that affect test prioritization, e.g., time constraints [57], and the work in this group investigates the influence of the constraints and prioritization techniques specific to some constraints [41], [62], [63], [59], [64].", "part": "1"}], "links": {"documentLink": "/document/919106", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=919106", "abstract": "Test case prioritization techniques schedule test cases for regression testing in an order that increases their ability to meet some performance goal. One performance goal, rate of fault detection, measures how quickly faults are detected within the testing process. In previous work (S. Elbaum et al., 2000; G. Rothermel et al., 1999), we provided a metric, APFD, for measuring rate of fault detection, and techniques for prioritizing test cases to improve APFD, and reported the results of experime...", "pdfSize": "1225KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Incorporating+varying+test+costs+and+fault+severities+into+test+case+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "A. Malishevsky, J.R. Ruthruff, G. Rothermel, S. Elbaum, \"Cost-cognizant test case prioritization\", <em>Tech. Rep.</em>, 2006.", "title": "Cost-cognizant test case prioritization", "context": [{"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[58][60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cost-cognizant+test+case+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "K.R. Walcott, M.L. Soffa, G.M. Kapfhammer, R.S. Roos, \"Time aware test suite prioritization\", <em>Proceedings of the International Symposium on Software Testing and Analysis</em>, pp. 1-11, 2006.", "title": "Time aware test suite prioritization", "context": [{"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[59][60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}, {"sec": "sec6b", "text": " The fourth group focuses on constraints that affect test prioritization, e.g., time constraints [57], and the work in this group investigates the influence of the constraints and prioritization techniques specific to some constraints [41], [62], [63], [59], [64].", "part": "1"}, {"sec": "sec6b", "text": " In this group, time-aware prioritization approaches [59], [64], [65] also utilize execution time of test cases.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1146238.1146240", "abstract": "Regression test prioritization is often performed in a time constrained execution environment in which testing only occurs for a fixed time period. For example, many organizations rely upon nightly building and regression testing of their applications every time source code changes are committed to a version control repository. This paper presents a regression test prioritization technique that uses a genetic algorithm to reorder test suites in light of testing time constraints. Experiment resul...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Time+aware+test+suite+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "H. Do, G. Rothermel, \"Using sensitivity analysis to create simplified economic models for regression testing\", <em>Proceedings of the International Symposium on Software Testing and Analysis</em>, pp. 51-62, 2008.", "title": "Using sensitivity analysis to create simplified economic models for regression testing", "context": [{"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1390630.1390639", "abstract": "Software engineering methodologies are subject to complex cost-benefit tradeoffs. Economic models can help practitioners and researchers assess methodologies relative to these tradeoffs. Effective economic models, however, can be established only through an iterative process of refinement involving analytical and empirical methods. Sensitivity analysis provides one such method. By identifying the factors that are most important to models, sensitivity analysis can help simplify those models; it c...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+sensitivity+analysis+to+create+simplified+economic+models+for+regression+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "H. Do, \"An empirical study of regression testing techniques incorporating context and lifecycle factors and improved cost-benefit models\", <em>Proceedings of the Symposium on the Foundations of Software Engineering</em>, pp. 141-151, Nov. 2006.", "title": "An empirical study of regression testing techniques incorporating context and lifecycle factors and improved cost-benefit models", "context": [{"sec": "sec6b", "text": " The third group focuses on the evaluation of existing test prioritization techniques [6], [56], [57]\u2013[60], [61], including measurement on the effectiveness of test prioritization techniques and the influence of some factors in test prioritization.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+regression+testing+techniques+incorporating+context+and+lifecycle+factors+and+improved+cost-benefit+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "S.-S. Hou, L. Zhang, T. Xie, J. Sun, \"Quota-constrained test-case prioritization for regression testing of service-centric systems\", <em>Proceedings of the International Conference on Software Maintenance</em>, pp. 257-266, 2008.", "title": "Quota-constrained test-case prioritization for regression testing of service-centric systems", "context": [{"sec": "sec6b", "text": " The fourth group focuses on constraints that affect test prioritization, e.g., time constraints [57], and the work in this group investigates the influence of the constraints and prioritization techniques specific to some constraints [41], [62], [63], [59], [64].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quota-constrained+test-case+prioritization+for+regression+testing+of+service-centric+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "J.M. Kim, A. Porter, \"A history-based test prioritization technique for regression testing in resource constrained environments\", <em>Proceedings of the International Conference on Software Engineering</em>, pp. 119-129, 2002.", "title": "A history-based test prioritization technique for regression testing in resource constrained environments", "context": [{"sec": "sec6b", "text": " The fourth group focuses on constraints that affect test prioritization, e.g., time constraints [57], and the work in this group investigates the influence of the constraints and prioritization techniques specific to some constraints [41], [62], [63], [59], [64].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/581339.581357", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+history-based+test+prioritization+technique+for+regression+testing+in+resource+constrained+environments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "L. Zhang, S. Hou, C. Guo, T. Xie, H. Mei, \"Time-aware test-case prioritization using integer linear programming\", <em>Proceedings of the International Symposium on Software Testing and Analysis</em>, pp. 213-224, 2009.", "title": "Time-aware test-case prioritization using integer linear programming", "context": [{"sec": "sec6b", "text": " The fourth group focuses on constraints that affect test prioritization, e.g., time constraints [57], and the work in this group investigates the influence of the constraints and prioritization techniques specific to some constraints [41], [62], [63], [59], [64].", "part": "1"}, {"sec": "sec6b", "text": " In this group, time-aware prioritization approaches [59], [64], [65] also utilize execution time of test cases.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1572272.1572297", "abstract": "Techniques for test-case prioritization re-order test cases to increase their rate of fault detection. When there is a fixed time budget that does not allow the execution of all the test cases, time-aware techniques for test-case prioritization may achieve a better rate of fault detection than traditional techniques for test-case prioritization. In this paper, we propose a novel approach to time-aware test-case prioritization using integer linear programming. To evaluate our approach, we perform...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Time-aware+test-case+prioritization+using+integer+linear+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "D. You, Z. Chen, B. Xu, B. Luo, C. Zhang, \"An empirical study on the effectiveness of time-aware test case prioritization techniques\", <em>Proceedings of the 2011 ACM Symposium on Applied Computing</em>, pp. 1451-1456, 2011.", "title": "An empirical study on the effectiveness of time-aware test case prioritization techniques", "context": [{"sec": "sec6b", "text": " In this group, time-aware prioritization approaches [59], [64], [65] also utilize execution time of test cases.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1982185.1982497", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+on+the+effectiveness+of+time-aware+test+case+prioritization+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "T.Y. Chen, H. Leung, I. Mak, \"Adaptive random testing\", <em>Advances in Computer Science-ASIAN 2004. Higher-Level Decision Making</em>, pp. 320-329, 2005.", "title": "Adaptive random testing", "context": [{"sec": "sec6b", "text": " This approach is motivated by adaptive random testing [66], [67], which is a test generation technique to spread the test inputs evenly in the input domain.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adaptive+random+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "T.Y. Chen, F.-C. Kuo, R.G. Merkel, T. Tse, \"Adaptive random testing: The art of test case diversity\", <em>Journal of Systems and Software</em>, vol. 83, no. 1, pp. 60-66, 2010.", "title": "Adaptive random testing: The art of test case diversity", "context": [{"sec": "sec6b", "text": " This approach is motivated by adaptive random testing [66], [67], which is a test generation technique to spread the test inputs evenly in the input domain.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2009.02.022", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adaptive+random+testing%3A+The+art+of+test+case+diversity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "A.E. Hassan, \"Predicting faults using the complexity of code changes\", <em>Proceedings of the 31st International Conference on Software Engineering</em>, pp. 78-88, 2009.", "title": "Predicting faults using the complexity of code changes", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"documentLink": "/document/5070510", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070510", "abstract": "Predicting the incidence of faults in code has been commonly associated with measuring complexity. In this paper, we propose complexity metrics that are based on the code change process instead of on the code. We conjecture that a complex code change process negatively affects its product, i.e., the software system. We validate our hypothesis empirically through a case study using data derived from the change history for six large open source projects. Our case study shows that our change comple...", "pdfSize": "189KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+faults+using+the+complexity+of+code+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "S. Lessmann, B. Baesens, C. Mues, S. Pietsch, \"Benchmarking classification models for software defect prediction: A proposed framework and novel findings\", <em>Transactions on Software Engineering</em>, vol. 34, no. 4, pp. 485-496, 2008.", "title": "Benchmarking classification models for software defect prediction: A proposed framework and novel findings", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[69][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"documentLink": "/document/4527256", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4527256", "abstract": "Software defect prediction strives to improve software quality and testing efficiency by constructing predictive classification models from code attributes to enable a timely identification of fault-prone modules. Several classification models have been evaluated for this task. However, due to inconsistent findings regarding the superiority of one classifier over another and the usefulness of metric-based classification in general, more research is needed to improve convergence across studies an...", "pdfSize": "3758KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Benchmarking+classification+models+for+software+defect+prediction%3A+A+proposed+framework+and+novel+findings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "X.-Y. Jing, S. Ying, Z.-W. Zhang, S.-S. Wu, J. Liu, \"Dictionary learning based software defect prediction\", <em>Proceedings of the 36th International Conference on Software Engineering</em>, pp. 414-423, 2014.", "title": "Dictionary learning based software defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[70][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568320", "abstract": "In order to improve the quality of a software system, software defect prediction aims to automatically identify defective software modules for efficient software test. To predict software defect, those classification methods with static code attributes have attracted a great deal of attention. In recent years, machine learning techniques have been applied to defect prediction. Due to the fact that there exists the similarity among different software modules, one software module can be approximat...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dictionary+learning+based+software+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}, {"order": "71", "text": "T. Lee, J. Nam, D. Han, S. Kim, H.P. In, \"Micro interaction metrics for defect prediction\", <em>Proceedings of the 19th ACM SIGSOFT Symposium and the 13th European Conference on Foundations of Software Engineering</em>, pp. 311-321, 2011.", "title": "Micro interaction metrics for defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[71][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2025113.2025156", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Micro+interaction+metrics+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref71"}, {"order": "72", "text": "A. Meneely, L. Williams, W. Snipes, J. Osborne, \"Predicting failures with developer networks and social network analysis\", <em>Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 13-23, 2008.", "title": "Predicting failures with developer networks and social network analysis", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[72][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1453101.1453106", "abstract": "Software fails and fixing it is expensive. Research in failure prediction has been highly successful at modeling software failures. Few models, however, consider the key cause of failures in software: people. Understanding the structure of developer collaboration could explain a lot about the reliability of the final product. We examine this collaboration structure with the developer network derived from code churn information that can predict failures at the file level. We conducted a case stud...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+failures+with+developer+networks+and+social+network+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref72"}, {"order": "73", "text": "F. Zhang, Q. Zheng, Y. Zou, A.E. Hassan, \"Cross-project defect prediction using a connectivity-based unsupervised classifier\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 309-320, 2016.", "title": "Cross-project defect prediction using a connectivity-based unsupervised classifier", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[73][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884839", "abstract": "Defect prediction on projects with limited historical data has attracted great interest from both researchers and practitioners. Cross-project defect prediction has been the main area of progress by reusing classifiers from other projects. However, existing approaches require some degree of homogeneity (e.g., a similar distribution of metric values) between the training projects and the target project. Satisfying the homogeneity requirement often requires significant effort (currently a very act...", "pdfSize": "308KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cross-project+defect+prediction+using+a+connectivity-based+unsupervised+classifier&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref73"}, {"order": "74", "text": "R. Moser, W. Pedrycz, G. Succi, \"A comparative analysis of the efficiency of change metrics and static code attributes for defect prediction\", <em>Proceedings of the 30th International Conference on Software Engineering</em>, pp. 181-190, 2008.", "title": "A comparative analysis of the efficiency of change metrics and static code attributes for defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[74][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368114", "abstract": "In this paper we present a comparative analysis of the predictive power of two different sets of metrics for defect prediction. We choose one set of product related and one set of process related software metrics and use them for classifying Java files of the Eclipse project as defective respective defect-free. Classification models are built using three common machine learners: logistic regression, naive Bayes, and decision trees. To allow different costs for prediction errors we perform cost-s...", "pdfSize": "268KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+comparative+analysis+of+the+efficiency+of+change+metrics+and+static+code+attributes+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref74"}, {"order": "75", "text": "T.T. Nguyen, T.N. Nguyen, T.M. Phuong, \"Topic-based defect prediction\", <em>Proceedings of the 33rd International Conference on Software Engineering</em>, pp. 932-935, 2011.", "title": "Topic-based defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[75][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985950", "abstract": "Defects are unavoidable in software development and fixing them is costly and resource-intensive. To build defect prediction models, researchers have investigated a number of factors related to the defect-proneness of source code, such as code complexity, change complexity, or socio-technical factors. In this paper, we propose a new approach that emphasizes on technical concerns/functionality of a system. In our approach, a software system is viewed as a collection of software artifacts that des...", "pdfSize": "755KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Topic-based+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref75"}, {"order": "76", "text": "B. Turhan, T. Menzies, A.B. Bener, J. Di Stefano, \"On the relative value of cross-company and within-company data for defect prediction\", <em>Empirical Software Engineering</em>, vol. 14, no. 5, pp. 540-578, 2009.", "title": "On the relative value of cross-company and within-company data for defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[76][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-008-9103-7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+relative+value+of+cross-company+and+within-company+data+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref76"}, {"order": "77", "text": "T. Zimmermann, R. Premraj, A. Zeller, \"Predicting defects for eclipse\", <em>Proceedings of the Third International Workshop on Predictor Models in Software Engineering</em>, 2007.", "title": "Predicting defects for eclipse", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[77][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"abstract": "We have mapped defects from the bug database of eclipse (one of the largest open-source projects) to source code locations. The resulting data set lists the number of pre- and post-release defects for every package and file in the eclipse releases 2.0, 2.1, and 3.0. We additionally annotated the data with common complexity metrics. All data is publicly available and can serve as a benchmark for defect prediction models.", "pdfSize": "168KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+defects+for+eclipse&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref77"}, {"order": "78", "text": "S. Wang, T. Liu, L. Tan, \"Automatically learning semantic features for defect prediction\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 297-308, 2016.", "title": "Automatically learning semantic features for defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[78][79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884804", "abstract": "Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the ...", "pdfSize": "1876KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+learning+semantic+features+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref78"}, {"order": "79", "text": "Y. Ma, G. Luo, X. Zeng, A. Chen, \"Transfer learning for cross-company software defect prediction\", <em>Information and Software Technology</em>, vol. 54, no. 3, pp. 248-256, 2012.", "title": "Transfer learning for cross-company software defect prediction", "context": [{"sec": "sec6c", "text": "There is a large amount of research on software defect prediction [68]\u2013[79], which predicts defect-prone programs (and code modules) by training classifiers based on the features extracted from historical defective code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2011.09.007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Transfer+learning+for+cross-company+software+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref79"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985706", "articleId": "7985706", "startPage": "700", "endPage": "711", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 2, "citationCountPatent": 0, "totalDownloads": 613}}
{"title": "Fuzzy Fine-Grained Code-History Analysis", "authors": [{"name": "Francisco Servant", "affiliation": "", "firstName": "Francisco", "lastName": "Servant", "id": "38235603100"}, {"name": "James A. Jones", "affiliation": "Univ. of California, Irvine, Irvine, CA, USA", "firstName": "James A.", "lastName": "Jones", "id": "37277753800"}], "abstract": "Existing software-history techniques represent source-code evolution as an absolute and unambiguous mapping of lines of code in prior revisions to lines of code in subsequent revisions. However, the true evolutionary lineage of a line of code is often complex, subjective, and ambiguous. As such, existing techniques are predisposed to, both, overestimate and underestimate true evolution lineage. In this paper, we seek to address these issues by providing a more expressive model of code evolution, the fuzzy history graph, by representing code lineage as a continuous (i.e., fuzzy) metric rather than a discrete (i.e., absolute) one. Using this more descriptive model, we additionally provide a novel multi-revision code-history analysis - fuzzy history slicing. In our experiments over three real-world software systems, we found that the fuzzy history graph provides a tunable balance of precision and recall, and an overall improved accuracy over existing code-evolution models. Furthermore, we found that the use of such a fuzzy model of history provided improved accuracy for code-history analysis tasks.", "keywords": [{"type": "IEEE Keywords", "kwd": ["History", "Analytical models", "Solids", "Computer bugs", "Measurement", "Computational modeling", "Cloning"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["fuzzy set theory", "graph theory", "program slicing", "software maintenance"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["fuzzy fine-grained code-history analysis", "code lineage", "novel multirevision code-history analysis", "fuzzy history graph", "fuzzy history slicing"]}, {"type": "Author Keywords ", "kwd": ["software engineering", "computer aided software engineering", "software maintenance", "reasoning about programs"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.74", "ref": [{"order": "1", "text": "<em>Fuzzy History Slicing Experimental Package</em>,  [online]  Available: http://people.cs.vt.edu/fservant/replication/17-ICSE-Servant-Jones.zip.", "title": "Fuzzy History Slicing Experimental Package", "context": [{"sec": "sec4a2", "text": "Confirming our description in Section II, we observed the subjective nature of actual code evolution: 31% of the sampled change hunks obtained different assessments from different developers \u2014 each change hunk was assessed by 2\u20133 developers (see sample 127 [1] for an example of varied assessment).", "part": "1"}, {"sec": "sec4a2", "text": " For example, if three developers assessed the change hunk from revision \\$r4\\$ to revision \\$r5\\$ of our example in Figure 1 and only one developer assessed line 4 from \\$r4\\$ as evolving into line 5 in \\$r5\\$, that mapping would have a weight of 0.33 in the human assessment for that change hunk [1].", "part": "1"}, {"sec": "sec8", "text": "We provide our experimental dataset as a resource for future research and for experimental replication [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fuzzy+History+Slicing+Experimental+Package&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Apache Commons IO</em>, 2002,  [online]  Available: http://commons.apache.org/proper/commons-io.", "title": "Apache Commons IO", "context": [{"sec": "sec4a1", "text": " We picked a diverse set of projects in terms of domain, size, and history: Apache Commons IO [2], which is a library to perform input and output functionality; Mozilla Rhino [40] is a JavaScript parser written in Java; and Aspectj [18] is an aspect-oriented programming framework for Java.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+Commons+IO&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "T. Apiwattanapong, A. Orso, M.J. Harrold, \"JDiff: A Differencing Technique and Tool for Object-Oriented Programs\", <em>Automated Software Engineering</em>, vol. 14, pp. 3-36, 2007.", "title": "JDiff: A Differencing Technique and Tool for Object-Oriented Programs", "context": [{"sec": "sec5", "text": " Other researchers proposed algorithms that perform the mapping over models of the program, e.g., [3], [39] allowing the detection of moved code, e.g., [15], [28] or providing techniques for specific domains, e.g., [17].", "part": "1"}, {"sec": "sec6", "text": " We intend to study in future work the accuracy improvements that may be provided by modeling fine-grained code history with semantic approaches, e.g., [3], in a fuzzy manner.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-006-0002-0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=JDiff%3A+A+Differencing+Technique+and+Tool+for+Object-Oriented+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "M. Asaduzzaman, M.C. Bullock, C.K. Roy, K.A. Schneider, \"Bug introducing changes: A case study with android\", <em>Working Conference on Mining Software Repositories</em>, pp. 116-119, 2012.", "title": "Bug introducing changes: A case study with android", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}], "links": {"documentLink": "/document/6224267", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6224267", "abstract": "Changes, a rather inevitable part of software development can cause maintenance implications if they introduce bugs into the system. By isolating and characterizing these bug introducing changes it is possible to uncover potential risky source code entities or issues that produce bugs. In this paper, we mine the bug introducing changes in the Android platform by mapping bug reports to the changes that introduced the bugs. We then use the change information to look for both potential problematic ...", "pdfSize": "146KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bug+introducing+changes%3A+A+case+study+with+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "M. Asaduzzaman, C.K. Roy, K.A. Schneider, M.D. Penta, \"LHDiff: A Language-Independent Hybrid Approach for Tracking Source Code Lines\", <em>International Conference on Software Maintenance</em>, pp. 230-239, 2013.", "title": "LHDiff: A Language-Independent Hybrid Approach for Tracking Source Code Lines", "context": [{"sec": "sec4a7", "text": " In terms of f-measure, the fuzzy history graph reached a higher value than the existing models for most change-hunk types and most similarity thresholds, specifically for similarity threshold 0.6, which is the recommended value by most techniques that build One-to-One models, e.g., [5], [9], [47].", "part": "1"}, {"sec": "sec5", "text": " [5] proposed a language-independent line-mapping technique that also detects lines that evolve into multiple others, although only when they change little and are contiguous.", "part": "1"}], "links": {"abstract": "Tracking source code lines between two different versions of a file is a fundamental step for solving a number of important problems in software maintenance such as locating bug introducing changes, tracking code fragments or defects across versions, merging file versions, and software evolution analysis. Although a number of such approaches are available in the literature, their performance is sensitive to the kind and degree of source code changes. There is also a marked lack of study on the e...", "pdfSize": "278KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=LHDiff%3A+A+Language-Independent+Hybrid+Approach+for+Tracking+Source+Code+Lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "T. Bakota, \"Tracking the Evolution of Code Clones\", <em>International Conference on Current Trends in Theory and Practice of Computer Science</em>, pp. 86-98, 2011.", "title": "Tracking the Evolution of Code Clones", "context": [{"sec": "sec1", "text": "The analysis of source-code evolution provides automatic support for a variety of software-engineering tasks, e.g., identifying bug-introducing changes [49], recommending developers to fix bugs (e.g., [42], [48]), identifying changes in third-party APIs [52], and discovering code clones [6].", "part": "1"}, {"sec": "sec2", "text": " In addition, multiple automatic code-evolution analyses have been proposed to support developers in diverse tasks, such as automatic identification of changes in third-party APIs [52], automatic discovery of code clones [6], automatic identification of bug-introducing changes (SZZ) [49], automatic recommendations of developers to fix bugs (e.g., [42], [48]), and automatic prediction of future bugs in code locations [41].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-18381-2_7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracking+the+Evolution+of+Code+Clones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "M.L. Bernardi, G. Canfora, G.A. Di Lucca, M. Di Penta, D. Distante, \"Do developers introduce bugs when they do not communicate? the case of eclipse and mozilla\", <em>European Conference on Software Maintenance and Reengineering</em>, pp. 139-148, 2012.", "title": "Do developers introduce bugs when they do not communicate? the case of eclipse and mozilla", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}], "links": {"documentLink": "/document/6178861", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6178861", "abstract": "Developers working on related artifacts often communicate each other to coordinate their changes and to make others aware of their changes. When such a communication does not occur, this could create misunderstanding and cause the introduction of bugs. This paper investigates how the level of communication between committers relates to their proneness to introduce faults. This is done by identifying committers likely responsible of bug-introducing changes, and comparing - through social network ...", "pdfSize": "448KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+developers+introduce+bugs+when+they+do+not+communicate%3F+the+case+of+eclipse+and+mozilla&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "C. Burges, T. Shaked, E. Renshaw, A. Lazier, M. Deeds, N. Hamilton, G. Hullender, \"Learning to Rank using Gradient Descent\", <em>International Conference on Machine learning</em>, pp. 89-96, 2005.", "title": "Learning to Rank using Gradient Descent", "context": [{"sec": "sec4b3", "text": " [8], as in Equation 6.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1102351.1102363", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+to+Rank+using+Gradient+Descent&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "G. Canfora, L. Cerulo, M. Di Penta, \"Tracking Your Changes: a Language-independent Approach\", <em>IEEE Software</em>, vol. 26, pp. 50-7, 2009.", "title": "Tracking Your Changes: a Language-independent Approach", "context": [{"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec4a7", "text": " In terms of f-measure, the fuzzy history graph reached a higher value than the existing models for most change-hunk types and most similarity thresholds, specifically for similarity threshold 0.6, which is the recommended value by most techniques that build One-to-One models, e.g., [5], [9], [47].", "part": "1"}, {"sec": "sec5", "text": " [9], [10], Chen et al. [11], Williams and Spacco [51] use a line-mapping technique that first performs an inexact difference of revisions, and then refines it by using an optimization algorithm.", "part": "1"}], "links": {"documentLink": "/document/4721183", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4721183", "abstract": "Versioning and bug-tracking systems are invaluable assets for large software projects that involve developers spread worldwide and numerous users reporting bugs and proposing enhancements. In addition to supporting development, versioning systems are a precious source of information for studying or monitoring a software system's evolution.", "pdfSize": "382KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracking+Your+Changes%3A+a+Language-independent+Approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "G. Canfora, L. Cerulo, M.D. Penta, \"Identifying Changed Source Code Lines from Version Repositories\", <em>International Workshop on Mining Software Repositories</em>, pp. 14-21, 2007.", "title": "Identifying Changed Source Code Lines from Version Repositories", "context": [{"sec": "sec1", "text": " Multiple techniques have been proposed to model and analyze the evolution of source code at the line-of-code level of granularity (e.g., [10], [11], [44], [47]).", "part": "1"}, {"sec": "sec1", "text": " Other techniques (e.g., [10], [44], [47]) further analyze such results to disambiguate each line in the prior revision to each line in the subsequent revision.", "part": "1"}, {"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[10][11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec5", "text": " Canfora et al. [9], [10], Chen et al. [11], Williams and Spacco [51] use a line-mapping technique that first performs an inexact difference of revisions, and then refines it by using an optimization algorithm.", "part": "1"}], "links": {"documentLink": "/document/4228651", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4228651", "abstract": "Observing the evolution of software systems at different levels of granularity has been a key issue for a number of studies, aiming at predicting defects or at studying certain phenomena, such as the presence of clones or of crosscutting concerns. Versioning systems such as CVS and SVN, however, only provide information about lines added or deleted by a contributor: any change is shown as a sequence of additions and deletions. This provides an erroneous estimate of the amount of code changed. Th...", "pdfSize": "428KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Identifying+Changed+Source+Code+Lines+from+Version+Repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "A. Chen, E. Chou, J. Wong, A.Y. Yao, Q. Zhang, S. Zhang, A. Michail, \"CVSSearch: Searching through Source Code using CVS Comments\", <em>International Conference on Software Maintenance</em>, pp. 364-373, 2001.", "title": "CVSSearch: Searching through Source Code using CVS Comments", "context": [{"sec": "sec1", "text": " Multiple techniques have been proposed to model and analyze the evolution of source code at the line-of-code level of granularity (e.g., [10], [11], [44], [47]).", "part": "1"}, {"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec5", "text": " [11], Williams and Spacco [51] use a line-mapping technique that first performs an inexact difference of revisions, and then refines it by using an optimization algorithm.", "part": "1"}], "links": {"documentLink": "/document/972749", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=972749", "abstract": "CVSSearch is a tool that searches for fragments of source code by using CVS comments. CVS is a version control system that is widely used in the open source community. Our search tool takes advantage of the fact that a CVS comment typically describes the lines of code involved in the commit and this description will typically hold for many future versions. In other words, CVSSearch allows one to better search the most recent version of the code by looking at previous versions to better understan...", "pdfSize": "504KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CVSSearch%3A+Searching+through+Source+Code+using+CVS+Comments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "M. Codoban, S.S. Ragavan, D. Dig, B. Bailey, \"Software history under the lens: a study on why and how developers examine it\", <em>International Conference on Software Maintenance</em>, pp. 1-10, 2015.", "title": "Software history under the lens: a study on why and how developers examine it", "context": [{"sec": "sec1", "text": " Furthermore, developers often need to examine and understand code evolution for a wide variety of purposes, requiring high effort [12], [37].", "part": "1"}, {"sec": "sec2", "text": " Multiple studies found industry developers to often require the study of the history of fine-grained code selections [37], for a wide variety of purposes [12], such as identifying the rationale of code [35].", "part": "1"}], "links": {"abstract": "Despite software history being indispensable for developers, there is little empirical knowledge about how they examine software history. Without such knowledge, researchers and tool builders are in danger of making wrong assumptions and building inadequate tools. In this paper we present an in-depth empirical study about the motivations developers have for examining software history, the strategies they use, and the challenges they encounter. To learn these, we interviewed 14 experienced develo...", "pdfSize": "218KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+history+under+the+lens%3A+a+study+on+why+and+how+developers+examine+it&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. Davies, D.M. German, M.W. Godfrey, A. Hindle, \"Software bertillonage: Finding the provenance of an entity\", <em>Working Conference On Mining Software Repositories</em>, pp. 183-192, 2011.", "title": "Software bertillonage: Finding the provenance of an entity", "context": [{"sec": "sec5", "text": " [13], [14] proposed \u201csoftware bertillonage\u201d to track the evolution of releases of code outside the revision-control system.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985441.1985468", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+bertillonage%3A+Finding+the+provenance+of+an+entity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "J. Davies, D.M. German, M.W. Godfrey, A. Hindle, \"Software bertillonage\", <em>Empirical Software Engineering</em>, vol. 18, no. 6, pp. 1195-1237, 2013.", "title": "Software bertillonage", "context": [{"sec": "sec5", "text": " Davies et al. [13], [14] proposed \u201csoftware bertillonage\u201d to track the evolution of releases of code outside the revision-control system.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-012-9199-7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+bertillonage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "D. Dig, K. Manzoor, R. Johnson, T.N. Nguyen, \"Refactoring-Aware Configuration Management for Object-Oriented Programs\", <em>International Conference on Software Engineering</em>, pp. 427-436, 2007.", "title": "Refactoring-Aware Configuration Management for Object-Oriented Programs", "context": [{"sec": "sec5", "text": " Other researchers proposed algorithms that perform the mapping over models of the program, e.g., [3], [39] allowing the detection of moved code, e.g., [15], [28] or providing techniques for specific domains, e.g., [17].", "part": "1"}, {"sec": "sec5", "text": " Some techniques capture code changes by monitoring the IDE, e.g., [15], [45], to model evolution with high accuracy when all developers always use the required IDE.", "part": "1"}, {"sec": "sec6", "text": " Additionally, the fuzzy history graph may address this limitation, since it allows its construction with other line mapping techniques, e.g., [15].", "part": "1"}], "links": {"abstract": "Current text based software configuration management (SCM) systems have trouble with refactorings. Refactorings result in global changes and lead to merge conflicts. A refactoring-aware SCM system reduces merge conflicts, preserves program history better and makes it easier to understand program evolution. This paper describes MolhadoRef a refactoring-aware SCM system and the merge algorithm at its core. MolhadoRef records change operations (refactorings and edits) used to produce one version, a...", "pdfSize": "174KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Refactoring-Aware+Configuration+Management+for+Object-Oriented+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "E. Duala-Ekoko, M.P. Robillard, \"Tracking code clones in evolving software\", <em>International Conference on Software Engineering</em>, pp. 158-167, 2007.", "title": "Tracking code clones in evolving software", "context": [{"sec": "sec5", "text": "Researchers proposed techniques to analyze the multi-revision evolution of code for specific purposes and at different granularities; e.g., Kim et al. [33] and Duala-Ekoko and Robillard [16] track the history of code fragments that contain code clones to study their evolution.", "part": "1"}, {"sec": "sec7", "text": " Moreover, and more importantly, this paper provides a novel theoretical fuzzy framework for modeling and analyzing code history, which also opens the door for other future fuzzy code-history analyses to emerge as well \u2014 potentially even by adapting other existing discrete approaches to a fuzzy model, e.g., automatic recommendations of developers to fix bugs [42], [48], or detection of code clones [16].", "part": "1"}], "links": {"documentLink": "/document/4222578", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222578", "abstract": "Code clones are generally considered harmful in software development, and the predominant approach is to try to eliminate them through refactoring. However, recent research has provided evidence that it may not always be practical, feasible, or cost-effective to eliminate certain clone groups. We propose a technique for tracking clones in evolving software. Our technique relies on the concept of abstract clone region descriptors (CRD), which describe clone regions within methods in a robust way ...", "pdfSize": "270KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracking+code+clones+in+evolving+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "A. Duley, C. Spandikow, M. Kim, \"A Program Differencing Algorithm for Verilog HDL\", <em>International Conference on Automated Software Engineering</em>, pp. 477-486, 2010.", "title": "A Program Differencing Algorithm for Verilog HDL", "context": [{"sec": "sec5", "text": " Other researchers proposed algorithms that perform the mapping over models of the program, e.g., [3], [39] allowing the detection of moved code, e.g., [15], [28] or providing techniques for specific domains, e.g., [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1858996.1859093", "abstract": "During code review tasks, comparing two versions of a hardware design description using existing program differencing tools such as diff is inherently limited because existing program differencing tools implicitly assume sequential execution semantics, while hardware description languages are designed to model concurrent computation. We designed a position-independent differencing algorithm to robustly handle language constructs whose relative orderings do not matter. This paper presents Vdiff, ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Program+Differencing+Algorithm+for+Verilog+HDL&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>AspectJ</em>, 2001,  [online]  Available: http://www.eclipse.org/aspectj/.", "title": "AspectJ", "context": [{"sec": "sec4a1", "text": " We picked a diverse set of projects in terms of domain, size, and history: Apache Commons IO [2], which is a library to perform input and output functionality; Mozilla Rhino [40] is a JavaScript parser written in Java; and Aspectj [18] is an aspect-oriented programming framework for Java.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=AspectJ&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J. Eyolfson, L. Tan, P. Lam, \"Do time of day and developer experience affect commit bugginess?\", <em>Working Conference on Mining Software Repositories</em>, pp. 153-162, 2011.", "title": "Do time of day and developer experience affect commit bugginess?", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985441.1985464", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+time+of+day+and+developer+experience+affect+commit+bugginess%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "B. Fluri, M. Wursch, M. Pinzger, H.C. Gall, \"Change Distilling: Tree Differencing for Fine-Grained Source Code Change Extraction\", <em>IEEE Transactions on Software Engineering</em>, vol. 33, no. 11, pp. 725-743, 2007.", "title": "Change Distilling: Tree Differencing for Fine-Grained Source Code Change Extraction", "context": [{"sec": "sec5", "text": " [20] and Spacco and Williams [50] capture differences at the statement level.", "part": "1"}], "links": {"documentLink": "/document/4339230", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4339230", "abstract": "A key issue in software evolution analysis is the identification of particular changes that occur across several versions of a program. We present change distilling, a tree differencing algorithm for fine-grained source code change extraction. For that, we have improved the existing algorithm by Chawathe et al. for extracting changes in hierarchically structured data. Our algorithm extracts changes by finding both a match between the nodes of the compared two abstract syntax trees and a minimum ...", "pdfSize": "3149KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Change+Distilling%3A+Tree+Differencing+for+Fine-Grained+Source+Code+Change+Extraction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "T. Fritz, G.C. Murphy, E. Hill, \"Does a programmer's activity indicate knowledge of code?\", <em>Foundations of Software Engineering</em>, pp. 341-350, 2007.", "title": "Does a programmer's activity indicate knowledge of code?", "context": [{"sec": "sec2e", "text": " Similarly, automatic analyses to recommend expert developers for code based on its history (e.g., [21]) would also overapproximate including Chris as an expert (as much as Bob), even if Chris never changed the code selection.", "part": "1"}, {"sec": "sec2g", "text": " Likewise, automatic analyses to recommend expert developers for code based on its history (e.g., [21]) would also underapproximate including only Bob as an expert \u2014 and therefore missing Alice, who also contributed to the selected code's history.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1287624.1287673", "abstract": "The practice of software development can likely be improved if an externalized model of each programmer&#39;s knowledge of a particular code base is available. Some tools already assume a useful form of such a model can be created from data collected during development, such as expertise recommenders that use information about who has changed each file to suggest who might answer questions about particular parts of a system. In this paper, we report on an empirical study that investigates whether a ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Does+a+programmer%27s+activity+indicate+knowledge+of+code%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "T. G\u00eerba, S. Ducasse, \"Modeling History to Analyze Software Evolution\", <em>Journal of Software Maintenance and Evolution: Research and Practice</em>, vol. 18, no. 3, pp. 207-236, 2006.", "title": "Modeling History to Analyze Software Evolution", "context": [{"sec": "sec5", "text": " Girba and Ducasse [22] proposed a code-evolution meta-model at multiple levels of granularity.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/smr.325", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+History+to+Analyze+Software+Evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "M.W. Godfrey, L. Zou, \"Using origin analysis to detect merging and splitting of source code entities\", <em>IEEE Transactions on Software Engineering</em>, vol. 31, no. 2, pp. 166-181, 2005.", "title": "Using origin analysis to detect merging and splitting of source code entities", "context": [{"sec": "sec5", "text": " Godfrey and Zou [23] and Wu et al. [52] also track the history of methods and fields and detect their splits and merges.", "part": "1"}], "links": {"documentLink": "/document/1401931", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1401931", "abstract": "Merging and splitting source code entities is a common activity during the lifespan of a software system; as developers rethink the essential structure of a system or plan for a new evolutionary direction, so must they be able to reorganize the design artifacts at various abstraction levels as seems appropriate. However, while the raw effects of such changes may be plainly evident in the new artifacts, the original context of the design changes is often lost. That is, it may be obvious which cha...", "pdfSize": "1207KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+origin+analysis+to+detect+merging+and+splitting+of+source+code+entities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "A.E. Hassan, R.C. Holt, \"C-REX: an Evolutionary Code Extractor for C\", <em>CSER Meeting</em>, 2004.", "title": "C-REX: an Evolutionary Code Extractor for C", "context": [{"sec": "sec5", "text": "Other models represent code evolution at different granularities, Hassan and Holt model code evolution at the method-level [24], [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=C-REX%3A+an+Evolutionary+Code+Extractor+for+C&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "A.E. Hassan, R.C. Holt, \"Using Development History Sticky Notes to Understand Software Architecture\", <em>International Workshop on Program Comprehension</em>, pp. 183-192, 2004.", "title": "Using Development History Sticky Notes to Understand Software Architecture", "context": [{"sec": "sec5", "text": " Hassan and Holt [25] analyze the evolution of methods to infer change rationale.", "part": "1"}, {"sec": "sec5", "text": "Other models represent code evolution at different granularities, Hassan and Holt model code evolution at the method-level [24], [25].", "part": "1"}], "links": {"abstract": "Maintenance of evolving software systems has become the most frequently performed activity by software developers. A good understanding of the software system is needed to reduce the cost and length of this activity. Various approaches and tools have been proposed to assist in this process such as code browsers, slicing techniques, etc. These techniques neglect to use a central and vital piece of data available - the historical modification records stored in source control systems. These records...", "pdfSize": "297KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+Development+History+Sticky+Notes+to+Understand+Software+Architecture&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "H. Hata, O. Mizuno, T. Kikuno, \"Historage: Fine-grained Version Control System for Java\", <em>IWPSE-EVOL'11</em>, pp. 96-100, 2011.", "title": "Historage: Fine-grained Version Control System for Java", "context": [{"sec": "sec5", "text": " [26] proposed a model for tracking the history of methods and fields that accounts for renames.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2024445.2024463", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Historage%3A+Fine-grained+Version+Control+System+for+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "K. Herzig, A. Zeller, \"Mining cause-effect-chains from version histories\", <em>International Symposium on Software Reliability Engineering</em>, pp. 60-69, 2011.", "title": "Mining cause-effect-chains from version histories", "context": [{"sec": "sec5", "text": " Herzig and Zeller [27] analyze multiple revisions of methods to predict defects.", "part": "1"}], "links": {"abstract": "Software reliability is heavily impacted by soft ware changes. How do these changes relate to each other? By analyzing the impacted method definitions and usages, we determine dependencies between changes, resulting in a change genealogy that captures how earlier changes enable and cause later ones. Model checking this genealogy reveals temporal process patterns that encode key features of the software process such as pending development activities: &#34;Whenever class A is changed, its test case is...", "pdfSize": "292KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+cause-effect-chains+from+version+histories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "J.J. Hunt, W.F. Tichy, \"Extensible Language-Aware Merging\", <em>International Conference on Software Maintenance</em>, pp. 511-520, 2002.", "title": "Extensible Language-Aware Merging", "context": [{"sec": "sec5", "text": " Other researchers proposed algorithms that perform the mapping over models of the program, e.g., [3], [39] allowing the detection of moved code, e.g., [15], [28] or providing techniques for specific domains, e.g., [17].", "part": "1"}], "links": {"abstract": "Parallel development has become standard practice in software development and maintenance. Though almost every revision control and configuration management system provides some form of merging for combining changes made in parallel, these mechanisms often yield unsatisfactory results. The authors present a new merging algorithm, that uses a fast differencing algorithm and renaming analysis to provide better merge results. The system is language aware, but not language dependent and does not req...", "pdfSize": "308KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Extensible+Language-Aware+Merging&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "K. J\u00e4rvelin, J. Kek\u00e4l\u00e4inen, \"IR Evaluation Methods for Retrieving Highly Relevant Documents\", <em>International ACM SIGIR Conference on Research and Development in Information Retrieval</em>, pp. 41-48, 2000.", "title": "IR Evaluation Methods for Retrieving Highly Relevant Documents", "context": [{"sec": "sec4b3", "text": "We measured the accuracy of SZZ by evaluating the weighted lines contained in the originating revision with the Normalized Discounted Cumulative Gain (NDCG) metric [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=IR+Evaluation+Methods+for+Retrieving+Highly+Relevant+Documents&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "Y. Kamei, S. Matsumoto, A. Monden, K.-I. Matsumoto, B. Adams, A.E. Hassan, <em>Revisiting common bug prediction findings using effort-aware models</em>, pp. 1-10, 2010.", "title": "Revisiting common bug prediction findings using effort-aware models", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}, {"sec": "sec7", "text": "In practice, these results mean that software engineers could more accurately identify past bug-introducing changes to learn from them [43], and automatic SZZ-based techniques would more accurately predict the quality of code changes, e.g., [30], [31], [34].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Revisiting+common+bug+prediction+findings+using+effort-aware+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "Y. Kamei, E. Shihab, B. Adams, A.E. Hassan, A. Mockus, A. Sinha, N. Ubayashi, \"A large-scale empirical study of just-in-time quality assurance\", <em>IEEE Transactions on Software Engineering</em>, vol. 39, no. 6, pp. 757-773, 2013.", "title": "A large-scale empirical study of just-in-time quality assurance", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}, {"sec": "sec7", "text": "In practice, these results mean that software engineers could more accurately identify past bug-introducing changes to learn from them [43], and automatic SZZ-based techniques would more accurately predict the quality of code changes, e.g., [30], [31], [34].", "part": "1"}], "links": {"documentLink": "/document/6341763", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6341763", "abstract": "Defect prediction models are a well-known technique for identifying defect-prone files or packages such that practitioners can allocate their quality assurance efforts (e.g., testing and code reviews). However, once the critical files or packages have been identified, developers still need to spend considerable time drilling down to the functions or even code snippets that should be reviewed or tested. This makes the approach too time consuming and impractical for large software systems. Instead...", "pdfSize": "2140KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+large-scale+empirical+study+of+just-in-time+quality+assurance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "M. Kim, D. Notkin, \"Program element matching for multi-version program analyses\", <em>International Workshop on Mining Software Repositories</em>, pp. 58-64, 2006.", "title": "Program element matching for multi-version program analyses", "context": [{"sec": "sec5", "text": " Finally, Kim and Notkin [32] presented a survey of techniques that track program elements between revisions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1137983.1137999", "abstract": "Multi-version program analyses require that elements of one version of a program be mapped to the elements of other versions of that program. Matching program elements between two versions of a program is a fundamental building block for multi-version program analyses and other software evolution research such as profile propagation, regression testing, and software version merging.In this paper, we survey matching techniques that can be used for multi-version program analyses and evaluate them ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program+element+matching+for+multi-version+program+analyses&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "M. Kim, V. Sazawal, D. Notkin, G. Murphy, \"An empirical study of code clone genealogies\", <em>European Software Engineering Conference Held Jointly with International Symposium on Foundations of Software Engineering</em>, pp. 187-196, 2005.", "title": "An empirical study of code clone genealogies", "context": [{"sec": "sec5", "text": " [33] and Duala-Ekoko and Robillard [16] track the history of code fragments that contain code clones to study their evolution.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1081706.1081737", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+code+clone+genealogies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "S. Kim, E.J. Whitehead, Y. Zhang, \"Classifying software changes: Clean or buggy?\", <em>IEEE Transactions on Software Engineering</em>, vol. 34, no. 2, pp. 181-196, 2008.", "title": "Classifying software changes: Clean or buggy?", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}, {"sec": "sec4c1", "text": " For researchers, such under and over approximations would introduce inaccuracies in SZZ-based research techniques, e.g., estimating the quality of code changes [34].", "part": "1"}, {"sec": "sec7", "text": "In practice, these results mean that software engineers could more accurately identify past bug-introducing changes to learn from them [43], and automatic SZZ-based techniques would more accurately predict the quality of code changes, e.g., [30], [31], [34].", "part": "1"}], "links": {"documentLink": "/document/4408585", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4408585", "abstract": "This paper introduces a new technique for predicting latent software bugs, called change classification. Change classification uses a machine learning classifier to determine whether a new software change is more similar to prior buggy changes or clean changes. In this manner, change classification predicts the existence of bugs in software changes. The classifier is trained using features (in the machine learning sense) extracted from the revision history of a software project stored in its sof...", "pdfSize": "4329KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Classifying+software+changes%3A+Clean+or+buggy%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "A.J. Ko, R. DeLine, G. Venolia, \"Information Needs in Collocated Software Development Teams\", <em>International Conference on Software Engineering</em>, pp. 344-353, 2007.", "title": "Information Needs in Collocated Software Development Teams", "context": [{"sec": "sec2", "text": " Multiple studies found industry developers to often require the study of the history of fine-grained code selections [37], for a wide variety of purposes [12], such as identifying the rationale of code [35].", "part": "1"}], "links": {"documentLink": "/document/4222596", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222596", "abstract": "Previous research has documented the fragmented nature of software development work. To explain this in more detail, we analyzed software developers&#39; day-to-day information needs. We observed seventeen developers at a large software company and transcribed their activities in go-minute sessions. We analyzed these logs for the information that developers sought, the sources that they used, and the situations th at prevented inform action from being acquired. We identified twenty-one information t...", "pdfSize": "1270KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Information+Needs+in+Collocated+Software+Development+Teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "H.W. Kuhn, \"The Hungarian Method for the Assignment Problem\", <em>Naval Research Logistics Quarterly</em>, vol. 2, no. 1\u20132, pp. 83-97, 1955.", "title": "The Hungarian Method for the Assignment Problem", "context": [{"sec": "sec5", "text": " In prior work the authors of this paper also proposed a one-to-one history graph [47] using Levenshtein [38] distance and the Kuhn-Munkres [36] algorithm.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/nav.3800020109", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Hungarian+Method+for+the+Assignment+Problem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "T.D. LaToza, B.A. Myers, \"Hard-to-Answer Questions about Code\", <em>Evaluation and Usability of Programming Languages and Tools</em>, pp. 8:1-8:6, 2010.", "title": "Hard-to-Answer Questions about Code", "context": [{"sec": "sec1", "text": " Furthermore, developers often need to examine and understand code evolution for a wide variety of purposes, requiring high effort [12], [37].", "part": "1"}, {"sec": "sec2", "text": " Multiple studies found industry developers to often require the study of the history of fine-grained code selections [37], for a wide variety of purposes [12], such as identifying the rationale of code [35].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1937117.1937125", "abstract": "To build new tools and programming languages that make it easier for professional software developers to create, debug, and understand code, it is helpful to better understand the questions that developers ask during coding activities. We surveyed professional software developers and asked them to list hard-to-answer questions that they had recently asked about code. 179 respondents reported 371 questions. We then clustered these questions into 21 categories and 94 distinct questions. The most f...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hard-to-Answer+Questions+about+Code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "V.I. Levenshtein, \"Binary Codes Capable of Correcting Deletions Insertions and Reversals\", <em>Soviet Physics Doklady</em>, vol. 10, pp. 707, 1966.", "title": "Binary Codes Capable of Correcting Deletions, Insertions and Reversals", "context": [{"sec": "sec3b", "text": "We created a technique to build the fuzzy history graph that uses a branch and bound optimization algorithm to minimize the textual difference between lines by using the Levenshtein distance [38].", "part": "1"}, {"sec": "sec4a5", "text": " In order to apply the same treatment to all the evaluated models, we discard mapped lines with similarity below the similarity threshold \u2014 calculated as one minus the Levenshtein [38] distance \u2014 after the One-to-One model and the Fuzzy History Graph are built.", "part": "1"}, {"sec": "sec5", "text": " In prior work the authors of this paper also proposed a one-to-one history graph [47] using Levenshtein [38] distance and the Kuhn-Munkres [36] algorithm.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Binary+Codes+Capable+of+Correcting+Deletions%2C+Insertions+and+Reversals&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "J.I. Maletic, M.L. Collard, <em>Supporting Source Code Difference Analysis</em>, pp. 210-219, 2004.", "title": "Supporting Source Code Difference Analysis", "context": [{"sec": "sec5", "text": " Other researchers proposed algorithms that perform the mapping over models of the program, e.g., [3], [39] allowing the detection of moved code, e.g., [15], [28] or providing techniques for specific domains, e.g., [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+Source+Code+Difference+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "<em>Mozilla Foundation. Rhino</em>, 1997,  [online]  Available: https://developer.mozilla.org/en-US/docs/Rhino.", "title": "Mozilla Foundation. Rhino", "context": [{"sec": "sec4a1", "text": " We picked a diverse set of projects in terms of domain, size, and history: Apache Commons IO [2], which is a library to perform input and output functionality; Mozilla Rhino [40] is a JavaScript parser written in Java; and Aspectj [18] is an aspect-oriented programming framework for Java.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mozilla+Foundation.+Rhino&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "N. Nagappan, T. Ball, \"Use of relative code churn measures to predict system defect density\", <em>International Conference on Software Engineering 2005</em>, pp. 284-292, 2005.", "title": "Use of relative code churn measures to predict system defect density", "context": [{"sec": "sec2", "text": " In addition, multiple automatic code-evolution analyses have been proposed to support developers in diverse tasks, such as automatic identification of changes in third-party APIs [52], automatic discovery of code clones [6], automatic identification of bug-introducing changes (SZZ) [49], automatic recommendations of developers to fix bugs (e.g., [42], [48]), and automatic prediction of future bugs in code locations [41].", "part": "1"}, {"sec": "sec2e", "text": " As a result, automatic analyses to assess risk for bugginess based on code history (e.g., [41]) would overapproximate the risk of this code selection \u2014 since it would be reported as being changed five times, even though it was changed only three times.", "part": "1"}, {"sec": "sec2g", "text": " Thus, automatic analyses to assess risk for bugginess based on code history (e.g., [41]) would underapproximate the risk of this code selection \u2014 since it would be reported as being changed only once, even though it was changed three times.", "part": "1"}], "links": {"documentLink": "/document/1553571", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1553571", "abstract": "Software systems evolve over time due to changes in requirements, optimization of code, fixes for security and reliability bugs etc. Code churn, which measures the changes made to a component over a period of time, quantifies the extent of this change. We present a technique for early prediction of system defect density using a set of relative code churn measures that relate the amount of churn to other variables such as component size and the temporal extent of churn. Using statistical regressi...", "pdfSize": "1823KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Use+of+relative+code+churn+measures+to+predict+system+defect+density&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "M. Perscheid, M. Haupt, R. Hirschfeld, H. Masuhara, \"Test-driven fault navigation for debugging reproducible failures\", <em>Information and Media Technologies</em>, vol. 7, no. 4, pp. 1377-1400, 2012.", "title": "Test-driven fault navigation for debugging reproducible failures", "context": [{"sec": "sec1", "text": "The analysis of source-code evolution provides automatic support for a variety of software-engineering tasks, e.g., identifying bug-introducing changes [49], recommending developers to fix bugs (e.g., [42], [48]), identifying changes in third-party APIs [52], and discovering code clones [6].", "part": "1"}, {"sec": "sec2", "text": " In addition, multiple automatic code-evolution analyses have been proposed to support developers in diverse tasks, such as automatic identification of changes in third-party APIs [52], automatic discovery of code clones [6], automatic identification of bug-introducing changes (SZZ) [49], automatic recommendations of developers to fix bugs (e.g., [42], [48]), and automatic prediction of future bugs in code locations [41].", "part": "1"}, {"sec": "sec7", "text": " Moreover, and more importantly, this paper provides a novel theoretical fuzzy framework for modeling and analyzing code history, which also opens the door for other future fuzzy code-history analyses to emerge as well \u2014 potentially even by adapting other existing discrete approaches to a fuzzy model, e.g., automatic recommendations of developers to fix bugs [42], [48], or detection of code clones [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test-driven+fault+navigation+for+debugging+reproducible+failures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "L. Prechelt, A. Pepper, \"Why software repositories are not used for defect-insertion circumstance analysis more often: A case study\", <em>Information and Software Technology</em>, vol. 56, no. 10, pp. 1377-1389, 2014.", "title": "Why software repositories are not used for defect-insertion circumstance analysis more often: A case study", "context": [{"sec": "sec4b", "text": " In addition, practitioners use SZZ to detect the origin of bugs in industrial systems [43].", "part": "1"}, {"sec": "sec7", "text": "In practice, these results mean that software engineers could more accurately identify past bug-introducing changes to learn from them [43], and automatic SZZ-based techniques would more accurately predict the quality of code changes, e.g., [30], [31], [34].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2014.05.001", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+software+repositories+are+not+used+for+defect-insertion+circumstance+analysis+more+often%3A+A+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "S.P. Reiss, \"Tracking Source Locations\", <em>International Conference on Software Engineering</em>, pp. 11-20, 2008.", "title": "Tracking Source Locations", "context": [{"sec": "sec1", "text": " Multiple techniques have been proposed to model and analyze the evolution of source code at the line-of-code level of granularity (e.g., [10], [11], [44], [47]).", "part": "1"}, {"sec": "sec1", "text": " Other techniques (e.g., [10], [44], [47]) further analyze such results to disambiguate each line in the prior revision to each line in the subsequent revision.", "part": "1"}, {"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec5", "text": " Reiss [44] proposed a group of line mapping techniques, some of which considered adjacent lines.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368091", "abstract": "Many programming tools require information to be associated with source locations. Current tools do this in different ways with different degrees of effectiveness. This paper is an investigation into the various approaches to maintaining source locations. It is based on an experiment that attempts to track a variety of locations over the evolution of a source file. The results demonstrate that relatively simple techniques can be very effective.", "pdfSize": "119KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracking+Source+Locations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "R. Robbes, M. Lanza, \"Improving code completion with program history\", <em>Automated Software Engineering</em>, vol. 17, no. 2, pp. 181-212, 2010.", "title": "Improving code completion with program history", "context": [{"sec": "sec5", "text": " Some techniques capture code changes by monitoring the IDE, e.g., [15], [45], to model evolution with high accuracy when all developers always use the required IDE.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-010-0064-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+code+completion+with+program+history&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "F. Servant, J.A. Jones, \"History Slicing\", <em>International Conference on Automated Software Engineering</em>, pp. 452-455, 2011.", "title": "History Slicing", "context": [{"sec": "sec2b", "text": " In past work, we defined the concept of history slicing [46], [47] to automate analysis of the correspondence of lines and changes across multiple revisions of code.", "part": "1"}, {"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec3", "text": " We create a fuzzy approach to history slicing [46], [47] that can account for the indeterminate nature and degree of evolution of lines from one revision to the next.", "part": "1"}], "links": {"documentLink": "/document/6100097", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6100097", "abstract": "To perform a number of tasks such as inferring design rationale from past code changes or assessing developer expertise for a software feature or bug, the evolution of a set of lines of code can be assessed by mining software histories. However, determining the evolution of a set of lines of code is a manual and time consuming process. This paper presents a model of this process and an approach for automating it. We call this process History Slicing. We describe the process and options for gener...", "pdfSize": "230KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=History+Slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "F. Servant, J.A. Jones, \"History Slicing: Assisting Code-Evolution Tasks\", <em>International Symposium on the Foundations of Software Engineering</em>, pp. 43:1-43:11, 2012.", "title": "History Slicing: Assisting Code-Evolution Tasks", "context": [{"sec": "sec1", "text": " Multiple techniques have been proposed to model and analyze the evolution of source code at the line-of-code level of granularity (e.g., [10], [11], [44], [47]).", "part": "1"}, {"sec": "sec1", "text": " Other techniques (e.g., [10], [44], [47]) further analyze such results to disambiguate each line in the prior revision to each line in the subsequent revision.", "part": "1"}, {"sec": "sec2b", "text": " In past work, we defined the concept of history slicing [46], [47] to automate analysis of the correspondence of lines and changes across multiple revisions of code.", "part": "1"}, {"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec3", "text": " We create a fuzzy approach to history slicing [46], [47] that can account for the indeterminate nature and degree of evolution of lines from one revision to the next.", "part": "1"}, {"sec": "sec3", "text": " While past work showed the productivity improvements provided by history slicing [47], this paper studies the accuracy of fine-grained code-history analysis, contributing: (1) a novel approach to model fine-grained code-history that recognizes the fuzzy nature of code evolution; (2) a novel algorithm to compute such fuzzy code history; (3) a novel approach to analyze fine-grained code history that leverages the different extents to which lines of code evolve; (4) an algorithm to perform the fundamental code history operation of obtaining the fuzzy evolution of a set of lines of code; and evaluations of the accuracy improvement provided by the novel fuzzy code history analysis for: (5) single code evolutions, and (6) complete code histories.", "part": "1"}, {"sec": "sec4a4", "text": " We build this evolution model using the technique proposed by Servant and Jones [47].", "part": "1"}, {"sec": "sec4a7", "text": " In terms of f-measure, the fuzzy history graph reached a higher value than the existing models for most change-hunk types and most similarity thresholds, specifically for similarity threshold 0.6, which is the recommended value by most techniques that build One-to-One models, e.g., [5], [9], [47].", "part": "1"}, {"sec": "sec5", "text": " In prior work the authors of this paper also proposed a one-to-one history graph [47] using Levenshtein [38] distance and the Kuhn-Munkres [36] algorithm.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2393596.2393646", "abstract": "Many software-engineering tasks require developers to understand the history and evolution of source code. However, today&#39;s software-development techniques and tools are not well suited for the easy and efficient procurement of such information. In this paper, we present an approach called history slicing that can automatically identify a minimal number of code modifications, across any number of revisions, for any arbitrary segment of source code at fine granularity. We also present our impleme...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=History+Slicing%3A+Assisting+Code-Evolution+Tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "F. Servant, J.A. Jones, \"WhoseFault: Automatic Developer-to-Fault Assignment through Fault Localization\", <em>International Conference on Software Engineering</em>, pp. 36-46, 2012.", "title": "WhoseFault: Automatic Developer-to-Fault Assignment through Fault Localization", "context": [{"sec": "sec1", "text": "The analysis of source-code evolution provides automatic support for a variety of software-engineering tasks, e.g., identifying bug-introducing changes [49], recommending developers to fix bugs (e.g., [42], [48]), identifying changes in third-party APIs [52], and discovering code clones [6].", "part": "1"}, {"sec": "sec2", "text": " In addition, multiple automatic code-evolution analyses have been proposed to support developers in diverse tasks, such as automatic identification of changes in third-party APIs [52], automatic discovery of code clones [6], automatic identification of bug-introducing changes (SZZ) [49], automatic recommendations of developers to fix bugs (e.g., [42], [48]), and automatic prediction of future bugs in code locations [41].", "part": "1"}, {"sec": "sec7", "text": " Moreover, and more importantly, this paper provides a novel theoretical fuzzy framework for modeling and analyzing code history, which also opens the door for other future fuzzy code-history analyses to emerge as well \u2014 potentially even by adapting other existing discrete approaches to a fuzzy model, e.g., automatic recommendations of developers to fix bugs [42], [48], or detection of code clones [16].", "part": "1"}], "links": {"documentLink": "/document/6227208", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227208", "abstract": "This paper describes a new technique, which automatically selects the most appropriate developers for fixing the fault represented by a failing test case, and provides a diagnosis of where to look for the fault. This technique works by incorporating three key components: (1) fault localization to inform locations whose execution correlate with failure, (2) history mining to inform which developers edited each line of code and when, and (3) expertise assignment to map locations to developers. To ...", "pdfSize": "433KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=WhoseFault%3A+Automatic+Developer-to-Fault+Assignment+through+Fault+Localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "J. Sliwerski, T.Z.A. Zeller, \"When do changes induce fixes?\", <em>Working Conference on Mining Software Repositories 2005</em>, vol. 1, no. 1.18, pp. 1-5, 2005.", "title": "When do changes induce fixes?", "context": [{"sec": "sec1", "text": "The analysis of source-code evolution provides automatic support for a variety of software-engineering tasks, e.g., identifying bug-introducing changes [49], recommending developers to fix bugs (e.g., [42], [48]), identifying changes in third-party APIs [52], and discovering code clones [6].", "part": "1"}, {"sec": "sec1", "text": " In our experiments, a common code-history analysis task \u2014 identifying bug-introducing changes with the SZZ approach [49] \u2014 provided higher accuracy with an underlying fuzzy history graph than with existing, absolute code-history models.", "part": "1"}, {"sec": "sec2", "text": " In addition, multiple automatic code-evolution analyses have been proposed to support developers in diverse tasks, such as automatic identification of changes in third-party APIs [52], automatic discovery of code clones [6], automatic identification of bug-introducing changes (SZZ) [49], automatic recommendations of developers to fix bugs (e.g., [42], [48]), and automatic prediction of future bugs in code locations [41].", "part": "1"}, {"sec": "sec4b", "text": " We chose to study the popular code history analysis task of identifying bug-introducing changes as proposed by the SZZ approach [49], since SZZ is an application area that represents very well the kinds of applications that would benefit from fuzzy history slicing.", "part": "1"}, {"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}, {"sec": "sec7", "text": " Also, we found that the fuzzy history graph improved the accuracy of an automatic technique for a code-history analysis task (identifying bug-introducing changes with SZZ [49]) over existing code-history models.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1083142.1083147", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+do+changes+induce+fixes%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "J. Spacco, C. Williams, \"Lightweight Techniques for Tracking Unique Program Statements\", <em>International Working Conference on Source Code Analysis and Manipulation</em>, pp. 99-108, 2009.", "title": "Lightweight Techniques for Tracking Unique Program Statements", "context": [{"sec": "sec5", "text": " Zimmermann et al. [54], Fluri et al. [20] and Spacco and Williams [50] capture differences at the statement level.", "part": "1"}], "links": {"documentLink": "/document/5279964", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5279964", "abstract": "Previous work on tracking source locations has focused on tracking lines through multiple revisions of software. In this paper, we explore a new technique for tracking statements, rather than lines, across multiple revisions of Java source code. We show that our statement-tracking technique achieves comparable accuracy for source code than the most accurate line-tracking techniques, while also safely handling all non-executable formatting changes, such as breaking a single statement across many ...", "pdfSize": "309KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lightweight+Techniques+for+Tracking+Unique+Program+Statements&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "C.C. Williams, J.W. Spacco, \"Branching and Merging in the Repository\", <em>International Working Conference on Mining Software Repositories</em>, pp. 19-22, 2008.", "title": "Branching and Merging in the Repository", "context": [{"sec": "sec2f", "text": "To address the problems introduced by the over-approximate nature of all-to-all history models, researchers developed advanced line-mapping techniques that allow for the disambiguation of lines in change hunks (e.g., [9]\u2013[11], [44], [46], [47], [51]).", "part": "1"}, {"sec": "sec5", "text": " Canfora et al. [9], [10], Chen et al. [11], Williams and Spacco [51] use a line-mapping technique that first performs an inexact difference of revisions, and then refines it by using an optimization algorithm.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1370750.1370754", "abstract": "Two of the most complex operations version control software allows a user to perform are branching and merging. Branching provides the user the ability to create a copy of the source code to allow changes to be stored in version control but outside of the trunk. Merging provides the user the ability to copy changes from a branch to the trunk. Performing a merge can be a tedious operation and one that may be error prone. In this paper, we compare file revisions found on branches with those found ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Branching+and+Merging+in+the+Repository&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "W. Wu, Y.-G. Gu\u00e9h\u00e9neuc, G. Antoniol, M. Kim, \"Aura: A hybrid approach to identify framework evolution\", <em>International Conference on Software Engineering</em>, pp. 325-334, 2010.", "title": "Aura: A hybrid approach to identify framework evolution", "context": [{"sec": "sec1", "text": "The analysis of source-code evolution provides automatic support for a variety of software-engineering tasks, e.g., identifying bug-introducing changes [49], recommending developers to fix bugs (e.g., [42], [48]), identifying changes in third-party APIs [52], and discovering code clones [6].", "part": "1"}, {"sec": "sec2", "text": " In addition, multiple automatic code-evolution analyses have been proposed to support developers in diverse tasks, such as automatic identification of changes in third-party APIs [52], automatic discovery of code clones [6], automatic identification of bug-introducing changes (SZZ) [49], automatic recommendations of developers to fix bugs (e.g., [42], [48]), and automatic prediction of future bugs in code locations [41].", "part": "1"}, {"sec": "sec5", "text": " [52] also track the history of methods and fields and detect their splits and merges.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806848", "abstract": "Software frameworks and libraries are indispensable to today&#39;s software systems. As they evolve, it is often time-consuming for developers to keep their code up-to-date, so approaches have been proposed to facilitate this. Usually, these approaches cannot automatically identify change rules for one-replaced-by-many and many-replaced-by-one methods, and they trade off recall for higher precision using one or more experimentally-evaluated thresholds. We introduce AURA, a novel hybrid approach that...", "pdfSize": "412KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Aura%3A+A+hybrid+approach+to+identify+framework+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "H. Yang, C. Wang, Q. Shi, Y. Feng, Z. Chen, \"Bug inducing analysis to prevent fault prone bug fixes\", <em>International Conference on Software Engineering and Knowledge Engineering</em>, pp. 620-625, 2014.", "title": "Bug inducing analysis to prevent fault prone bug fixes", "context": [{"sec": "sec4b", "text": " In the research literature, SZZ has been extensively applied to study the characteristics of bug-introducing changes, e.g., [4], [7], [19], [49], [53], as well as to provide automatic recommendations about the quality of code changes [30], [31], [34].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bug+inducing+analysis+to+prevent+fault+prone+bug+fixes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "T. Zimmermann, \"Fine-Grained Processing of CVS Archives with APFEL\", <em>OOPSLA workshop on Eclipse Technology eXchange</em>, pp. 16-20, 2006.", "title": "Fine-Grained Processing of CVS Archives with APFEL", "context": [{"sec": "sec5", "text": " [54], Fluri et al. [20] and Spacco and Williams [50] capture differences at the statement level.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1188835.1188839", "abstract": "In this paper, we present the APFEL plug-in that collects fine-grained changes from version archives in a database. APFEL is built upon the Eclipse infrastructure for CVS and Java. In order to describe changes, APFEL uses tokens such as method calls, exceptions, and variable usages. We demonstrate the usefulness of APFEL's database with several case studies.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fine-Grained+Processing+of+CVS+Archives+with+APFEL&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "T. Zimmermann, S. Kim, A. Zeller, E.J. Whitehead, \"Mining Version Archives for Co-changed Lines\", <em>International Workshop on Mining Software Repositories</em>, pp. 72-75, 2006.", "title": "Mining Version Archives for Co-changed Lines", "context": [{"sec": "sec1", "text": " Some existing history analyses (e.g., [55]) conservatively represent the lineage of lines of code \u2014 mapping each and every candidate line of code in the older revision to each and every candidate line of code in the newer revision.", "part": "1"}, {"sec": "sec2d", "text": " [55] proposed a model, called annotation graphs.", "part": "1"}, {"sec": "sec4a4", "text": " [55].", "part": "1"}, {"sec": "sec5", "text": " [55].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1137983.1138001", "abstract": "Files, classes, or methods have frequently been investigated in recent research on co-change. In this paper, we present a first study at the level of lines. To identify line changes across several versions, we define the annotation graph which captures how lines evolve over time. The annotation graph provides more fine-grained software evolution information such as life cycles of each line and related changes: &#34;Whenever a developer changed line 1 of version.txt she also changed line 25 of Librar...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+Version+Archives+for+Co-changed+Lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985710", "articleId": "7985710", "startPage": "746", "endPage": "757", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 285}}
{"title": "Resource-Aware Program Analysis Via Online Abstraction Coarsening", "authors": [{"name": "Kihong Heo", "affiliation": "University of Pennsylvania", "firstName": "Kihong", "lastName": "Heo", "id": "37085991661"}, {"name": "Hakjoo Oh", "affiliation": "Korea University", "firstName": "Hakjoo", "lastName": "Oh", "id": "37086051886"}, {"name": "Hongseok Yang", "affiliation": "KAIST", "firstName": "Hongseok", "lastName": "Yang", "id": "37086948648"}], "abstract": "We present a new technique for developing a resource-aware program analysis. Such an analysis is aware of constraints on available physical resources, such as memory size, tracks its resource use, and adjusts its behaviors during fixpoint computation in order to meet the constraint and achieve high precision. Our resource-aware analysis adjusts behaviors by coarsening program abstraction, which usually makes the analysis consume less memory and time until completion. It does so multiple times during the analysis, under the direction of what we call a controller. The controller constantly intervenes in the fixpoint computation of the analysis and decides how much the analysis should coarsen the abstraction. We present an algorithm for learning a good controller automatically from benchmark programs. We applied our technique to a static analysis for C programs, where we control the degree of flow-sensitivity to meet a constraint on peak memory consumption. The experimental results with 18 real-world programs show that our algorithm can learn a good controller and the analysis with this controller meets the constraint and utilizes available memory effectively.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Memory management", "Static analysis", "Reinforcement learning", "Task analysis", "Software engineering", "Benchmark testing", "Indexes"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["C language", "program diagnostics", "program verification"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["fixpoint computation", "benchmark programs", "static analysis", "real-world programs", "resource-aware program analysis", "online abstraction coarsening", "program abstraction", "C programs", "physical resources"]}, {"type": "Author Keywords ", "kwd": ["static analysis", "resource constraint", "learning"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00027", "ref": [{"order": "1", "text": "H. Oh, K. Heo, W. Lee, W. Lee, K. Yi, \"Design and Implementation of Sparse Global Analyses for C-like Languages\", <em>Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI' 12)</em>, 2012.", "title": "Design and Implementation of Sparse Global Analyses for C-like Languages", "context": [{"sec": "sec1", "text": "When a static program analysis aims at reasoning about deep semantic properties, it typically requires a huge amount of resources such as memory [1]\u2013[4].", "part": "1"}, {"sec": "sec2b", "text": " These updates are due to the assignment x = z at line 2, which propagates to x the change of z's abstract value from [1, 1] to \\$[1, \\infty]\\$.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254092", "abstract": "In this article we present a general method for achieving global static analyzers that are precise, sound, yet also scalable. Our method generalizes the sparse analysis techniques on top of the abstract interpretation framework to support relational as well as non-relational semantics properties for C-like languages. We first use the abstract interpretation framework to have a global static analyzer whose scalability is unattended. Upon this underlying sound static analyzer, we add our generaliz...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Design+and+Implementation+of+Sparse+Global+Analyses+for+C-like+Languages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "K. Heo, H. Oh, H. Yang, \"Learning a Variable-Clustering Strategy for Octagon from Labeled Data Generated by a Static Analysis\", <em>23rd International Static Analysis Symposium (SAS'16)</em>, 2016.", "title": "Learning a Variable-Clustering Strategy for Octagon from Labeled Data Generated by a Static Analysis", "context": [{"sec": "sec1", "text": "When a static program analysis aims at reasoning about deep semantic properties, it typically requires a huge amount of resources such as memory [1]\u2013[2][4].", "part": "1"}, {"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}, {"sec": "sec7a", "text": " For example, the recent techniques for controlling flow- and context-sensitivity [2], [7], [19], [20], [24] would abort, without producing any results, if there were no more memory available.", "part": "1"}, {"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}, {"sec": "sec7c", "text": " Thus, it is feasible to solve optimization problems related to learning directly by Bayesian optimization [7], boolean formula learning [7], [24], decision tree learning [2], and one-class SVM [23].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-662-53413-7_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+a+Variable-Clustering+Strategy+for+Octagon+from+Labeled+Data+Generated+by+a+Static+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "M. Naik, <em>Chord: A Program Analysis Platform for Java</em>, 2006.", "title": "Chord: A Program Analysis Platform for Java", "context": [{"sec": "sec1", "text": "When a static program analysis aims at reasoning about deep semantic properties, it typically requires a huge amount of resources such as memory [1]\u2013[3][4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Chord%3A+A+Program+Analysis+Platform+for+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "M. Bravenboer, Y. Smaragdakis, \"Strictly Declarative Specification of Sophisticated Points-to Analyses\", <em>Proceedings of the 24th ACM SIGPLAN Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA'09)</em>, 2009.", "title": "Strictly Declarative Specification of Sophisticated Points-to Analyses", "context": [{"sec": "sec1", "text": "When a static program analysis aims at reasoning about deep semantic properties, it typically requires a huge amount of resources such as memory [1]\u2013[4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1640089.1640108", "abstract": "We present the DOOP framework for points-to analysis of Java programs. DOOP builds on the idea of specifying pointer analysis algorithms declaratively, using Datalog: a logic-based language for defining (recursive) relations. We carry the declarative approach further than past work by describing the full end-to-end analysis in Datalog and optimizing aggressively using a novel technique specifically targeting highly recursive Datalog programs. As a result, DOOP achieves several benefits, includin...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Strictly+Declarative+Specification+of+Sophisticated+Points-to+Analyses&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "M. Christakis, V. W\u00fcstholz, \"Bounded abstract interpretation\", <em>Static Analysis Symposium</em>, 2016.", "title": "Bounded abstract interpretation", "context": [{"sec": "sec1", "text": " Some researchers have suggested to make the analysis store intermediate results and then resume it with more resources [5].", "part": "1"}, {"sec": "sec7b", "text": "There have been a few studies on physical resources used by a program analyzer [5], [6].", "part": "1"}, {"sec": "sec7b", "text": " The bounded abstract interpretation [5] provides one way of coping with a resource constraint.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-662-53413-7_6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bounded+abstract+interpretation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "W. Lee, H. Oh, K. Yi, \"A progress bar for static analyzers\", <em>Static Analysis Symposium</em>, 2014.", "title": "A progress bar for static analyzers", "context": [{"sec": "sec1", "text": " There has also been work on estimating the amount of resource use, such as analysis time, before the analysis begins [6].", "part": "1"}, {"sec": "sec5", "text": " In our experiments with interval analysis, we approximated the heights of elements in the lattice of intervals using the method described in [6].", "part": "1"}, {"sec": "sec7b", "text": "There have been a few studies on physical resources used by a program analyzer [5], [6].", "part": "1"}, {"sec": "sec7b", "text": " The technique by [6] estimates the analysis time, one form of physical resource, before the analysis begins.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-10936-7_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+progress+bar+for+static+analyzers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "H. Oh, H. Yang, K. Yi, \"Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation\", <em>Object-Oriented Programming Systems Languages and Applications (OOPSLA'15)</em>, 2015.", "title": "Learning a Strategy for Adapting a Program Analysis via Bayesian Optimisation", "context": [{"sec": "sec1", "text": " We compared this analysis with a baseline analysis [7] that does not control flow-sensitivity online but picks the degree of flow-sensitivity before the analysis begins.", "part": "1"}, {"sec": "sec1", "text": " When this baseline analysis was set to choose the 10% of variables for flow-sensitivity as in [7], it could not analyze 3 out of the 8 programs under the 128GB of memory budget.", "part": "1"}, {"sec": "sec2c", "text": " There already exist techniques for automatically learning a scoring function like \\$\\mathcal{M}\\$ from a codebase [7].", "part": "1"}, {"sec": "sec5", "text": " We describe an existing partially flow-sensitive analysis [7] and explain how to learn a controller by following the recipe described in the previous sections.", "part": "1"}, {"sec": "sec5", "text": "The partially flow-sensitive analysis by [7] is defined with the semantic function \\$G_{L}\\$: \\$\\mathbb{D}\\rightarrow \\mathbb{D}\\$, where \\$\\mathbb{D}=\\mathbb{C}\\rightarrow \\mathbb{S}\\$ denotes the abstract domain, i.e., maps from program points \\$(\\mathbb{C})\\$ to abstract states \\$(\\mathbb{S})\\$.", "part": "1"}, {"sec": "sec5", "text": " We use this map constructed by [7], which is available in the open-source distribution of [7].", "part": "1"}, {"sec": "sec6", "text": "Analysis Precision: How precise is our analysis that coarsens its program abstraction online with a learned controller compared with the existing offline approach [7]?.", "part": "1"}, {"sec": "sec6", "text": " We used the implementations of sparse analysis [14], partially flow-sensitive analysis [7], and a pre-trained model \\$\\mathcal{M}\\$ for ranking locations [7], which are available in the open-source distribution of Sparrow.", "part": "1"}, {"sec": "sec6", "text": " Thus, in the training phase, we set the memory budget for each program based on information that we collected by running the partially flow-sensitive analysis [7] in the Sparrow distribution, whose degree of flow-sensitivity had to be set manually.", "part": "1"}, {"sec": "sec6", "text": "Using the programs in our testing set, we compared our technique against the partially flow-sensitive analysis [7] in the Sparrow distribution.", "part": "1"}, {"sec": "sec6", "text": " We used \\$k= 10\\%\\$ as in the original work [7].", "part": "1"}, {"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}, {"sec": "sec7a", "text": " For example, the recent techniques for controlling flow- and context-sensitivity [2], [7], [19], [20], [24] would abort, without producing any results, if there were no more memory available.", "part": "1"}, {"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}, {"sec": "sec7c", "text": " Thus, it is feasible to solve optimization problems related to learning directly by Bayesian optimization [7], boolean formula learning [7], [24], decision tree learning [2], and one-class SVM [23].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2814270.2814309", "abstract": "Building a cost-effective static analyser for real-world programs is still regarded an art. One key contributor to this grim reputation is the difficulty in balancing the cost and the precision of an analyser. An ideal analyser should be adaptive to a given analysis task, and avoid using techniques that unnecessarily improve precision and increase analysis cost. However, achieving this ideal is highly nontrivial, and it requires a large amount of engineering efforts. In this paper we present a n...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+a+Strategy+for+Adapting+a+Program+Analysis+via+Bayesian+Optimisation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "D. Ernst, P. Geurts, L. Wehenkel, \"Tree-Based Batch Mode Reinforcement Learning\", <em>The Journal of Machine Learning Research</em>, vol. 6, pp. 503-556, 2005.", "title": "Tree-Based Batch Mode Reinforcement Learning", "context": [{"sec": "sec1", "text": " Our learning algorithm is inspired by batch mode reinforcement learning [8]\u2013[10].", "part": "1"}, {"sec": "sec2c", "text": " For this purpose, we have developed an algorithm by altering the batch version of a SARSA-style on-policy algorithm from reinforcement learning [8], [11].", "part": "1"}, {"sec": "sec7d", "text": "Our approach can be understood as a variant of the batch-mode reinforcement learning algorithm [8]\u2013[10].", "part": "1"}, {"sec": "sec7d", "text": " The idea of repeatedly executing a policy and improving it based on execution trajectories [11], that of accumulating all the trajectories and using them for learning [8]\u2013[10], [12], and the idea of approximating the ideal Q function and defining a policy based on the approximation, all of these are common techniques from reinforcement learning.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tree-Based+Batch+Mode+Reinforcement+Learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "M. G. Lagoudakis, R. Parr, \"Least-Squares Policy Iteration\", <em>The Journal of Machine Learning Research</em>, vol. 4, pp. 1107-1149, 2003.", "title": "Least-Squares Policy Iteration", "context": [{"sec": "sec1", "text": " Our learning algorithm is inspired by batch mode reinforcement learning [8]\u2013[9][10].", "part": "1"}, {"sec": "sec7d", "text": "Our approach can be understood as a variant of the batch-mode reinforcement learning algorithm [8]\u2013[9][10].", "part": "1"}, {"sec": "sec7d", "text": " The idea of repeatedly executing a policy and improving it based on execution trajectories [11], that of accumulating all the trajectories and using them for learning [8]\u2013[9][10], [12], and the idea of approximating the ideal Q function and defining a policy based on the approximation, all of these are common techniques from reinforcement learning.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Least-Squares+Policy+Iteration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "D. Ormoneit, S. Sen, \"Kernel-Based Reinforcement Learning\", <em>Machine Learning</em>, vol. 49, no. 2\u20133, pp. 161-178, 2002.", "title": "Kernel-Based Reinforcement Learning", "context": [{"sec": "sec1", "text": " Our learning algorithm is inspired by batch mode reinforcement learning [8]\u2013[10].", "part": "1"}, {"sec": "sec7d", "text": "Our approach can be understood as a variant of the batch-mode reinforcement learning algorithm [8]\u2013[10].", "part": "1"}, {"sec": "sec7d", "text": " The idea of repeatedly executing a policy and improving it based on execution trajectories [11], that of accumulating all the trajectories and using them for learning [8]\u2013[10], [12], and the idea of approximating the ideal Q function and defining a policy based on the approximation, all of these are common techniques from reinforcement learning.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/A:1017928328829", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Kernel-Based+Reinforcement+Learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "R. S. Sutton, A. G. Barto, Reinforcement Learning: An Introduction, MIT Press, 1998.", "title": "Reinforcement Learning: An Introduction", "context": [{"sec": "sec2c", "text": " For this purpose, we have developed an algorithm by altering the batch version of a SARSA-style on-policy algorithm from reinforcement learning [8], [11].", "part": "1"}, {"sec": "sec2c", "text": " Then, the algorithm runs the analysis under the \\$\\epsilon\\$ -noise version of \\$\\pi\\$ for some small \\$\\epsilon\\in(0,1)\\$ [11].", "part": "1"}, {"sec": "sec4b", "text": " Our variant of \\$\\pi\\$ is an instance of the well-known \\$\\epsilon\\$ -greedy exploration strategy in reinforcement learning [11].", "part": "1"}, {"sec": "sec7d", "text": " A controller in our work corresponds to a so called policy in reinforcement learning [11], [31].", "part": "1"}, {"sec": "sec7d", "text": " The idea of repeatedly executing a policy and improving it based on execution trajectories [11], that of accumulating all the trajectories and using them for learning [8]\u2013[10], [12], and the idea of approximating the ideal Q function and defining a policy based on the approximation, all of these are common techniques from reinforcement learning.", "part": "1"}], "links": {"documentLink": "/document/712192", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=712192", "pdfSize": "8KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reinforcement+Learning%3A+An+Introduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "L.-J. Lin, \"Self-Improving Reactive Agents Based on Reinforcement Learning Planning and Teaching\", <em>Machine Learning</em>, vol. 8, no. 3\u20134, pp. 293-321, 1992.", "title": "Self-Improving Reactive Agents Based on Reinforcement Learning, Planning and Teaching", "context": [{"sec": "sec2c", "text": " This accumulation is important for the efficiency of our learning algorithm, and is a well-known technique in reinforcement learning where \\$\\mathcal{D}_{2}\\$ is called replay buffer [12].", "part": "1"}, {"sec": "sec4b", "text": " A similar technique called replay buffer [12] is often used by offline algorithms in reinforcement learning.", "part": "1"}, {"sec": "sec7d", "text": " The idea of repeatedly executing a policy and improving it based on execution trajectories [11], that of accumulating all the trajectories and using them for learning [8]\u2013[10], [12], and the idea of approximating the ideal Q function and defining a policy based on the approximation, all of these are common techniques from reinforcement learning.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF00992699", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Self-Improving+Reactive+Agents+Based+on+Reinforcement+Learning%2C+Planning+and+Teaching&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "<em>Sparrow</em>,  [online]  Available: https://github.com/ropas/sparrow.", "title": "Sparrow", "context": [{"sec": "sec6", "text": "We implemented our technique on top of Sparrow, an open-source state-of-the-art static analyzer for C programs [13] implemented in OCaml.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sparrow&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "H. Oh, K. Heo, W. Lee, W. Lee, D. Park, J. Kang, K. Yi, \"Global Sparse Analysis Framework\", <em>ACM Transactions on Programming Languages and Systems</em>, vol. 36, no. 3, pp. 1-44, 2014.", "title": "Global Sparse Analysis Framework", "context": [{"sec": "sec6", "text": " We used the implementations of sparse analysis [14], partially flow-sensitive analysis [7], and a pre-trained model \\$\\mathcal{M}\\$ for ranking locations [7], which are available in the open-source distribution of Sparrow.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2590811", "abstract": "In this article, we present a general method for achieving global static analyzers that are precise and sound, yet also scalable. Our method, on top of the abstract interpretation framework, is a general sparse analysis technique that supports relational as well as nonrelational semantics properties for various programming languages. Analysis designers first use the abstract interpretation framework to have a global and correct static analyzer whose scalability is unattended. Upon this underlyin...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Global+Sparse+Analysis+Framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "<em>Ocaml garbage collector</em>,  [online]  Available: https://caml.inria.fr/pub/docs/manual-ocaml/libref/Gc.html.", "title": "Ocaml garbage collector", "context": [{"sec": "sec6", "text": " Instead of invoking a controller and coarsening abstraction in every analysis step, we triggered abstraction coarsening only when the OCaml runtime allocates memory in the major heap [15].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ocaml+garbage+collector&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vanderplas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, E. Duchesnay, \"Scikit-learn: Machine learning in Python\", <em>Journal of Machine Learning Research</em>, vol. 12, pp. 2825-2830, 2011.", "title": "Scikit-learn: Machine learning in Python", "context": [{"sec": "sec6", "text": " The decision tree algorithm in the scikit-learn package [16] was our choice of the supervised learner in Algorithm 1.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scikit-learn%3A+Machine+learning+in+Python&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "T. Ball, S. K. Rajamani, \"The SLAM Project: Debugging System Software via Static Analysis\", <em>Proceedings of the th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'02)</em>, 2002.", "title": "The SLAM Project: Debugging System Software via Static Analysis", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/503272.503274", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+SLAM+Project%3A+Debugging+System+Software+via+Static+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "E. Clarke, O. Grumberg, S. Jha, Y. Lu, H. Veith, \"Counterexample-guided Abstraction Refinement for Symbolic Model Checking\", <em>Journal of the ACM (JACM)</em>, vol. 50, no. 5, pp. 752-794, 2003.", "title": "Counterexample-guided Abstraction Refinement for Symbolic Model Checking", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/876638.876643", "abstract": "The state explosion problem remains a major hurdle in applying symbolic model checking to large hardware designs. State space abstraction, having been essential for verifying designs of industrial complexity, is typically a manual process, requiring considerable creativity and insight.In this article, we present an automatic iterative abstraction-refinement methodology that extends symbolic model checking. In our method, the initial abstract model is generated by an automatic analysis of the con...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Counterexample-guided+Abstraction+Refinement+for+Symbolic+Model+Checking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "H. Oh, W. Lee, K. Heo, H. Yang, K. Yi, \"Selective Context-sensitivity Guided by Impact Pre-analysis\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'14)</em>, 2014.", "title": "Selective Context-sensitivity Guided by Impact Pre-analysis", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}, {"sec": "sec7a", "text": " For example, the recent techniques for controlling flow- and context-sensitivity [2], [7], [19], [20], [24] would abort, without producing any results, if there were no more memory available.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2594291.2594318", "abstract": "We present a method for selectively applying context-sensitivity during interprocedural program analysis. Our method applies context-sensitivity only when and where doing so is likely to improve the precision that matters for resolving given queries. The idea is to use a pre-analysis to estimate the impact of context-sensitivity on the main analysis&#39;s precision, and to use this information to find out when and where the main analysis should turn on or off its context-sensitivity. We formalize th...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Selective+Context-sensitivity+Guided+by+Impact+Pre-analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Y. Smaragdakis, G. Kastrinis, G. Balatsouras, \"Introspective Analysis: Context-sensitivity Across the Board\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI'14)</em>, 2014.", "title": "Introspective Analysis: Context-sensitivity, Across the Board", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}, {"sec": "sec7a", "text": " For example, the recent techniques for controlling flow- and context-sensitivity [2], [7], [19], [20], [24] would abort, without producing any results, if there were no more memory available.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2594291.2594320", "abstract": "Context-sensitivity is the primary approach for adding more precision to a points-to analysis, while hopefully also maintaining scalability. An oft-reported problem with context-sensitive analyses, however, is that they are bi-modal: either the analysis is precise enough that it manipulates only manageable sets of data, and thus scales impressively well, or the analysis gets quickly derailed at the first sign of imprecision and becomes orders-of-magnitude more expensive than would be expected gi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introspective+Analysis%3A+Context-sensitivity%2C+Across+the+Board&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "M. Naik, H. Yang, G. Castelnuovo, M. Sagiv, \"Abstractions from Tests\", <em>Proceedings of the 39th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'12)</em>, 2012.", "title": "Abstractions from Tests", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2103656.2103701", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Abstractions+from+Tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "A. Gupta, R. Majumdar, A. Rybalchenko, \"From Tests to Proofs\", <em>Proceedings of the 15th International Conference on Tools and Algorithms for the Construction and Analysis of Systems (TACAS'09)</em>, 2009.", "title": "From Tests to Proofs", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-00768-2_24", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=From+Tests+to+Proofs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "K. Heo, H. Oh, K. Yi, \"Machine-Learning-Guided Selectively Unsound Static Analysis\", <em>Proceedings of the 39th International Conference on Software Engineering (ICSE'17)</em>, 2017.", "title": "Machine-Learning-Guided Selectively Unsound Static Analysis", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}, {"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}, {"sec": "sec7c", "text": " Thus, it is feasible to solve optimization problems related to learning directly by Bayesian optimization [7], boolean formula learning [7], [24], decision tree learning [2], and one-class SVM [23].", "part": "1"}], "links": {"documentLink": "/document/7985690", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985690", "abstract": "We present a machine-learning-based technique for selectively applying unsoundness in static analysis. Existing bug-finding static analyzers are unsound in order to be precise and scalable in practice. However, they are uniformly unsound and hence at the risk of missing a large amount of real bugs. By being sound, we can improve the detectability of the analyzer but it often suffers from a large number of false alarms. Our approach aims to strike a balance between these two approaches by selecti...", "pdfSize": "637KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Machine-Learning-Guided+Selectively+Unsound+Static+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "S. Jeong, M. Jeon, S. Cha, H. Oh, \"Data-driven Context-sensitivity for Points-to Analysis\", <em>Proceedings of the ACM on Programming Languages</em>, vol. 1, no. OOPSLA, pp. 100:1-100:28, 2017.", "title": "Data-driven Context-sensitivity for Points-to Analysis", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[24][26].", "part": "1"}, {"sec": "sec7a", "text": " For example, the recent techniques for controlling flow- and context-sensitivity [2], [7], [19], [20], [24] would abort, without producing any results, if there were no more memory available.", "part": "1"}, {"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}, {"sec": "sec7c", "text": " Thus, it is feasible to solve optimization problems related to learning directly by Bayesian optimization [7], boolean formula learning [7], [24], decision tree learning [2], and one-class SVM [23].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3133924", "abstract": "We present a new data-driven approach to achieve highly cost-effective context-sensitive points-to analysis for Java. While context-sensitivity has greater impact on the analysis precision and performance than any other precision-improving techniques, it is difficult to accurately identify the methods that would benefit the most from context-sensitivity and decide how much context-sensitivity should be used for them. Manually designing such rules is a nontrivial and laborious task that often del...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data-driven+Context-sensitivity+for+Points-to+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "K. Chae, H. Oh, K. Heo, H. Yang, \"Automatically generating features for learning program analysis heuristics for C-like languages\", <em>PACMPL</em>, vol. 1, no. OOPSLA, pp. 1-25, 2017.", "title": "Automatically generating features for learning program analysis heuristics for C-like languages", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[25][26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3133925", "abstract": "We present a technique for automatically generating features for data-driven program analyses. Recently data-driven approaches for building a program analysis have been developed, which mine existing codebases and automatically learn heuristics for finding a cost-effective abstraction for a given analysis task. Such approaches reduce the burden of the analysis designers, but they do not remove it completely; they still leave the nontrivial task of designing so called features to the hands of the...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+generating+features+for+learning+program+analysis+heuristics+for+C-like+languages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "G. Singh, M. P\u00fcschel, M. T. Vechev, \"Fast Numerical Program Analysis with Reinforcement Learning\", <em>30th International Conference on Computer Aided Verification (CAV'18)</em>, 2018.", "title": "Fast Numerical Program Analysis with Reinforcement Learning", "context": [{"sec": "sec7a", "text": " Well-known examples include counterexample-guided abstraction refinement (CEGAR) [17], [18], parametric program analysis based on pre-analysis [19], [20] or dynamic analysis [21], [22], and program analysis tuned by machine learning algorithms [2], [7], [23]\u2013[26].", "part": "1"}, {"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}, {"sec": "sec7d", "text": " [26] used reinforcement learning to select a series of cost-effective abstract transformers during polyhedra analysis.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-96145-3_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fast+Numerical+Program+Analysis+with+Reinforcement+Learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "R. Grigore, H. Yang, \"Abstraction Refinement Guided by a Learnt Probabilistic Model\", <em>Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'16)</em>, 2016.", "title": "Abstraction Refinement Guided by a Learnt Probabilistic Model", "context": [{"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}, {"sec": "sec7c", "text": " Grigore et al.'s work in [27] is one of the few exceptions, where they presented a method to learn a model that guides abstraction refinement during analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2837614.2837663", "abstract": "The core challenge in designing an effective static program analysis is to find a good program abstraction -- one that retains only details relevant to a given query. In this paper, we present a new approach for automatically finding such an abstraction. Our approach uses a pessimistic strategy, which can optionally use guidance from a probabilistic model. Our approach applies to parametric static analyses implemented in Datalog, and is based on counterexample-guided abstraction refinement. For ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Abstraction+Refinement+Guided+by+a+Learnt+Probabilistic+Model&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "V. Raychev, M. Vechev, A. Krause, \"Predicting program properties from \u201cbig code\u201d\", <em>Proceedings of the 42Nd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'15)</em>, 2015.", "title": "Predicting program properties from \u201cbig code\u201d", "context": [{"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2676726.2677009", "abstract": "We present a new approach for predicting program properties from massive codebases (aka &#34;Big Code&#34;). Our approach first learns a probabilistic model from existing data and then uses this model to predict properties of new, unseen programs. The key idea of our work is to transform the input program into a representation which allows us to phrase the problem of inferring program properties as structured prediction in machine learning. This formulation enables us to leverage powerful probabilistic ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+program+properties+from+%E2%80%9Cbig+code%E2%80%9D&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "O. Katz, R. El-Yaniv, E. Yahav, \"Estimating types in binaries using predictive modeling\", <em>Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL'16)</em>, 2016.", "title": "Estimating types in binaries using predictive modeling", "context": [{"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2837614.2837674", "abstract": "Reverse engineering is an important tool in mitigating vulnerabilities in binaries. As a lot of software is developed in object-oriented languages, reverse engineering of object-oriented code is of critical importance. One of the major hurdles in reverse engineering binaries compiled from object-oriented code is the use of dynamic dispatch. In the absence of debug information, any dynamic dispatch may seem to jump to many possible targets, posing a significant challenge to a reverse engineer try...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Estimating+types+in+binaries+using+predictive+modeling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "P. Bielik, V. Raychev, M. T. Vechev, \"Learning a static analyzer from data\", <em>29th International Conference on Computer Aided Verification (CAV'17)</em>, 2017.", "title": "Learning a static analyzer from data", "context": [{"sec": "sec7c", "text": " Such a data-driven approach has been pursued actively by program analysis researchers, to learn program-analysis heuristics [2], [7], [23], [24], [26], [27], also to predict program properties [28], [29], and sometimes to synthesize abstract semantics [30] as well.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-63387-9_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+a+static+analyzer+from+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "D. P. Bertsekas, J. Tsitsiklis, Neuro-Dynamic Programming, Athena Scientific, 1996.", "title": "Neuro-Dynamic Programming", "context": [{"sec": "sec7d", "text": " A controller in our work corresponds to a so called policy in reinforcement learning [11], [31].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Neuro-Dynamic+Programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "G.-R. Xue, W. Dai, Q. Yang, Y. Yu, \"Topic-bridged PLSA for cross-domain text classification\", <em>Proceedings of the 31st Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR'08)</em>, 2008.", "title": "Topic-bridged PLSA for cross-domain text classification", "context": [{"sec": "sec7d", "text": " A wide variety of techniques have been developed in the contexts of text classification [32]\u2013[34], natural language processing [35], [36], and software defect prediction [37], just to name a few.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1390334.1390441", "abstract": "In many Web applications, such as blog classification and new-sgroup classification, labeled data are in short supply. It often happens that obtaining labeled data in a new domain is expensive and time consuming, while there may be plenty of labeled data in a related but different domain. Traditional text classification ap-proaches are not able to cope well with learning across different domains. In this paper, we propose a novel cross-domain text classification algorithm which extends the tradi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Topic-bridged+PLSA+for+cross-domain+text+classification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "R. Raina, A. Y. Ng, D. Koller, \"Constructing Informative Priors Using Transfer Learning\", <em>Proceedings of the Twenty-Third International Conference on Machine Learning (ICML'06)</em>, 2006.", "title": "Constructing Informative Priors Using Transfer Learning", "context": [{"sec": "sec7d", "text": " A wide variety of techniques have been developed in the contexts of text classification [32]\u2013[33][34], natural language processing [35], [36], and software defect prediction [37], just to name a few.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1143844.1143934", "abstract": "Many applications of supervised learning require good generalization from limited labeled data. In the Bayesian setting, we can try to achieve this goal by using an informative prior over the parameters, one that encodes useful domain knowledge. Focusing on logistic regression, we present an algorithm for automatically constructing a multivariate Gaussian prior with a full covariance matrix for a given supervised learning task. This prior relaxes a commonly used but overly simplistic independenc...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Constructing+Informative+Priors+Using+Transfer+Learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "W. Dai, G.-R. Xue, Q. Yang, Y. Yu, \"Transferring Naive Bayes Classifiers for Text Classification\", <em>Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence (AAAI'07)</em>, 2007.", "title": "Transferring Naive Bayes Classifiers for Text Classification", "context": [{"sec": "sec7d", "text": " A wide variety of techniques have been developed in the contexts of text classification [32]\u2013[34], natural language processing [35], [36], and software defect prediction [37], just to name a few.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Transferring+Naive+Bayes+Classifiers+for+Text+Classification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "J. Jiang, C. Zhai, \"Instance Weighting for Domain Adaptation in NLP\", <em>Proceedings of the 45th Annual Meeting of the Association for Computational Linguistics (ACL'07)</em>, 2007.", "title": "Instance Weighting for Domain Adaptation in NLP", "context": [{"sec": "sec7d", "text": " A wide variety of techniques have been developed in the contexts of text classification [32]\u2013[34], natural language processing [35], [36], and software defect prediction [37], just to name a few.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Instance+Weighting+for+Domain+Adaptation+in+NLP&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "S. J. Pan, X. Ni, J.-T. Sun, Q. Yang, Z. Chen, \"Cross-domain Sentiment Classification via Spectral Feature Alignment\", <em>Proceedings of the 19th International Conference on World Wide Web (WWW'10)</em>, 2010.", "title": "Cross-domain Sentiment Classification via Spectral Feature Alignment", "context": [{"sec": "sec7d", "text": " A wide variety of techniques have been developed in the contexts of text classification [32]\u2013[34], natural language processing [35], [36], and software defect prediction [37], just to name a few.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1772690.1772767", "abstract": "Sentiment classification aims to automatically predict sentiment polarity (e.g., positive or negative) of users publishing sentiment data (e.g., reviews, blogs). Although traditional classification algorithms can be used to train sentiment classifiers from manually labeled text data, the labeling work can be time-consuming and expensive. Meanwhile, users often use some different words when they express sentiment in different domains. If we directly apply a classifier trained in one domain to oth...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cross-domain+Sentiment+Classification+via+Spectral+Feature+Alignment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "J. Nam, S. J. Pan, S. Kim, \"Transfer Defect Learning\", <em>Proceedings of 35th International Conference on Software Engineering (ICSE'13)</em>, 2013.", "title": "Transfer Defect Learning", "context": [{"sec": "sec7d", "text": " A wide variety of techniques have been developed in the contexts of text classification [32]\u2013[34], natural language processing [35], [36], and software defect prediction [37], just to name a few.", "part": "1"}], "links": {"documentLink": "/document/6606584", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6606584", "abstract": "Many software defect prediction approaches have been proposed and most are effective in within-project prediction settings. However, for new projects or projects with limited training data, it is desirable to learn a prediction model by using sufficient training data from existing source projects and then apply the model to some target projects (cross-project defect prediction). Unfortunately, the performance of cross-project defect prediction is generally poor, largely because of feature distri...", "pdfSize": "400KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Transfer+Defect+Learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812143", "articleId": "8812143", "startPage": "94", "endPage": "104", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 61}}
{"title": "LibD: Scalable and Precise Third-Party Library Detection in Android Markets", "authors": [{"name": "Menghao Li", "affiliation": "Key Lab. of Network Assessment Technol., Inst. of Inf. Eng., Beijing, China", "firstName": "Menghao", "lastName": "Li", "id": "37086161592"}, {"name": "Wei Wang", "affiliation": "Key Lab. of Network Assessment Technol., Inst. of Inf. Eng., Beijing, China", "firstName": "Wei", "lastName": "Wang", "id": "37086164945"}, {"name": "Pei Wang", "affiliation": "Coll. of Inf. Sci. & Technol., Pennsylvania State Univ., University Park, PA, USA", "firstName": "Pei", "lastName": "Wang", "id": "37085821340"}, {"name": "Shuai Wang", "affiliation": "Coll. of Inf. Sci. & Technol., Pennsylvania State Univ., University Park, PA, USA", "firstName": "Shuai", "lastName": "Wang", "id": "37085822476"}, {"name": "Dinghao Wu", "affiliation": "Coll. of Inf. Sci. & Technol., Pennsylvania State Univ., University Park, PA, USA", "firstName": "Dinghao", "lastName": "Wu", "id": "37896552600"}, {"name": "Jian Liu", "affiliation": "Key Lab. of Network Assessment Technol., Inst. of Inf. Eng., Beijing, China", "firstName": "Jian", "lastName": "Liu", "id": "37086163358"}, {"name": "Rui Xue", "affiliation": "State Key Lab. of Inf. Security, Inst. of Inf. Eng., Beijing, China", "firstName": "Rui", "lastName": "Xue", "id": "37086162313"}, {"name": "Wei Huo", "affiliation": "Key Lab. of Network Assessment Technol., Inst. of Inf. Eng., Beijing, China", "firstName": "Wei", "lastName": "Huo", "id": "37086161561"}], "abstract": "With the thriving of the mobile app markets, third-party libraries are pervasively integrated in the Android applications. Third-party libraries provide functionality such as advertisements, location services, and social networking services, making multi-functional app development much more productive. However, the spread of vulnerable or harmful third-party libraries may also hurt the entire mobile ecosystem, leading to various security problems. The Android platform suffers severely from such problems due to the way its ecosystem is constructed and maintained. Therefore, third-party Android library identification has emerged as an important problem which is the basis of many security applications such as repackaging detection and malware analysis. According to our investigation, existing work on Android library detection still requires improvement in many aspects, including accuracy and obfuscation resilience. In response to these limitations, we propose a novel approach to identifying third-party Android libraries. Our method utilizes the internal code dependencies of an Android app to detect and classify library candidates. Different from most previous methods which classify detected library candidates based on similarity comparison, our method is based on feature hashing and can better handle code whose package and method names are obfuscated. Based on this approach, we have developed a prototypical tool called LibD and evaluated it with an update-to-date and large-scale dataset. Our experimental results on 1,427,395 apps show that compared to existing tools, LibD can better handle multi-package third-party libraries in the presence of name-based obfuscation, leading to significantly improved precision without the loss of scalability.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Libraries", "Androids", "Humanoid robots", "Tools", "Mobile communication", "Security", "Java"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "mobile computing", "pattern classification", "security of data", "software libraries", "software tools"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["LibD tool", "precise third-party library detection", "Android markets", "mobile app markets", "security problems", "mobile ecosystem", "third-party Android library identification", "malware analysis", "repackaging detection", "internal code dependencies", "library candidate classification", "feature hashing", "multipackage third-party libraries", "name-based obfuscation"]}, {"type": "Author Keywords ", "kwd": ["Android", "third-party library", "software mining"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.38", "ref": [{"order": "1", "text": "<em>Number of apps available in leading app stores as of July 2015</em>,  [online]  Available: http://www.statista.com/statistics/276623/number-of-apps-available-in-leading-app-stores/.", "title": "Number of apps available in leading app stores as of July 2015", "context": [{"sec": "sec1", "text": " By July 2015, Android has become the largest mobile application platform in terms of the number of available apps [1].", "part": "1"}, {"sec": "sec4a", "text": " Although the official app market, Google Play, contains over a million apps [1], it employs more rigorous reviews on the uploaded apps, including both static and dynamic analysis, and presumably many malicious or vulnerable third-party libraries could have been rejected during the review process [19], [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Number+of+apps+available+in+leading+app+stores+as+of+July+2015&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "J. Lin, B. Liu, N. Sadeh, J.I. Hong, \"Modeling users mobile app privacy preferences: Restoring usability in a sea of permission settings\", <em>Proceedings of the 2014 Symposium On Usable Privacy and Security</em>, pp. 199-212, 2014.", "title": "Modeling users mobile app privacy preferences: Restoring usability in a sea of permission settings", "context": [{"sec": "sec1", "text": " A previous study shows that in some extreme cases, an Android app can refer to more than 30 different third-party libraries [2].", "part": "1"}, {"sec": "sec2", "text": " A recent study on Android libraries showed that over half of the inspected instances are protected by obfuscation techniques [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modeling+users+mobile+app+privacy+preferences%3A+Restoring+usability+in+a+sea+of+permission+settings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "K. Chen, P. Liu, Y. Zhang, \"Achieving accuracy and scalability simultaneously in detecting application clones on Android markets\", <em>Proceedings of the 36th International Conference on Software Engineering</em>, pp. 175-186, 2014.", "title": "Achieving accuracy and scalability simultaneously in detecting application clones on Android markets", "context": [{"sec": "sec1", "text": " A whitelist is typically generated through manual analysis [3], [4] and has to be constantly maintained to stay updated.", "part": "1"}, {"sec": "sec4b", "text": " In this section, we first study how many libraries can be detected regarding different thresholds and try to set a reasonable threshold by comparing with a previous whitelist approach [3].", "part": "1"}, {"sec": "sec4b", "text": "When comparing with previous work, we report that LibD can detect more third-party libraries than both whitelist and system API-based methods [3], [6].", "part": "1"}, {"sec": "sec4b1", "text": " [3] present a whitelist, including names of 72 commonly-used third-party libraries in the market.", "part": "1"}, {"sec": "sec4d1", "text": " Like the whitelist approach [3], Li et al. only provide the detected (unobfuscated) library names.", "part": "1"}, {"sec": "sec6b", "text": "Third-party library identification has been used to implement many security applications targeting the Android ecosystem, one of which is Android app clone and repackaging detection [3], [6], [14], [39]\u2013[41].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568286", "abstract": "Besides traditional problems such as potential bugs, (smartphone) application clones on Android markets bring new threats. That is, attackers clone the code from legitimate Android applications, assemble it with malicious code or advertisements, and publish these ``purpose-added&#34; app clones on the same or other markets for benefits. Three inherent and unique characteristics make app clones difficult to detect by existing techniques: a billion opcode problem caused by cross-market publishing, gap...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Achieving+accuracy+and+scalability+simultaneously+in+detecting+application+clones+on+Android+markets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "B. Liu, B. Liu, H. Jin, R. Govindan, \"Efficient privilege deescalation for ad libraries in mobile apps\", <em>Proceedings of the 13th Annual International Conference on Mobile Systems Applications and Services</em>, pp. 89-103, 2015.", "title": "Efficient privilege deescalation for ad libraries in mobile apps", "context": [{"sec": "sec1", "text": " A whitelist is typically generated through manual analysis [3], [4] and has to be constantly maintained to stay updated.", "part": "1"}, {"sec": "sec6a", "text": " Later techniques like AdDetect [35] and PEDAL [4] start to employ machine learning methods to provide more accurate and comprehensive results, but they still target advertising libraries only.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+privilege+deescalation+for+ad+libraries+in+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "J. Crussell, C. Gibler, H. Chen, \"Scalable semantics-based detection of similar Android applications\", <em>Proc. of Esorics</em>, 2013.", "title": "Scalable semantics-based detection of similar Android applications", "context": [{"sec": "sec1", "text": "The other approach is to directly extract libraries from apps without a priori knowledge about the libraries [5]\u2013[9].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+semantics-based+detection+of+similar+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "H. Wang, Y. Guo, Z. Ma, X. Chen, \"WuKong: A scalable and accurate two-phase approach to Android app clone detection\", <em>Proceedings of the 2015 International Symposium on Software Testing and Analysis</em>, pp. 71-82, 2015.", "title": "WuKong: A scalable and accurate two-phase approach to Android app clone detection", "context": [{"sec": "sec1", "text": "The other approach is to directly extract libraries from apps without a priori knowledge about the libraries [5]\u2013[6][9].", "part": "1"}, {"sec": "sec1", "text": " Compared with similar tools like LibRadar [7] and WuKong [6], LibD can not only identify a much larger number of third-party libraries from the dataset but also find them with a higher precision.", "part": "1"}, {"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}, {"sec": "sec4b", "text": " The threshold is the number of appearances of a potential library candidate in the dataset, in our research and previous studies [6], [8].", "part": "1"}, {"sec": "sec4b", "text": " For example, Wukong [6] sets the threshold as 32 while Li et al. use 10 [8].", "part": "1"}, {"sec": "sec4b", "text": "When comparing with previous work, we report that LibD can detect more third-party libraries than both whitelist and system API-based methods [3], [6].", "part": "1"}, {"sec": "sec4d2", "text": "Comparing with WuKong [6], our approach finds more libraries with the same threshold.", "part": "1"}, {"sec": "sec6a", "text": " WuKong [6] is an Android app clone detection technique which needs to filter out third-party libraries before the actual detection starts.", "part": "1"}, {"sec": "sec6b", "text": "Third-party library identification has been used to implement many security applications targeting the Android ecosystem, one of which is Android app clone and repackaging detection [3], [6], [14], [39]\u2013[41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=WuKong%3A+A+scalable+and+accurate+two-phase+approach+to+Android+app+clone+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "Z. Ma, H. Wang, Y. Guo, X. Chen, \"LibRadar: fast and accurate detection of third-party libraries in Android apps\", <em>Proceedings of the 38th International Conference on Software Engineering (Demo Track)</em>, pp. 653-656, 2016.", "title": "LibRadar: fast and accurate detection of third-party libraries in Android apps", "context": [{"sec": "sec1", "text": "The other approach is to directly extract libraries from apps without a priori knowledge about the libraries [5]\u2013[7][9].", "part": "1"}, {"sec": "sec1", "text": " Compared with similar tools like LibRadar [7] and WuKong [6], LibD can not only identify a much larger number of third-party libraries from the dataset but also find them with a higher precision.", "part": "1"}, {"sec": "sec2", "text": " A recent tool called LibRadar [7] developed an algorithm that takes obfuscated package names into consideration.", "part": "1"}, {"sec": "sec4c", "text": " We then use LibD and a state-of-the-art library detector, LibRadar [7], to detect third-party libraries in the 1,000 apps.", "part": "1"}, {"sec": "sec4c", "text": " LibRadar [7] provides an online service to detect libraries; this enables convenient comparison with LibD.", "part": "1"}, {"sec": "sec4d2", "text": " In general, WuKong reports to detect around 10,000 libraries in [7], while LibD finds 16,074 libraries with the same threshold.", "part": "1"}, {"sec": "sec6a", "text": " LibRadar [7] is an online service that implements the identification method of WuKong, with a better-performing package clustering algorithm.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=LibRadar%3A+fast+and+accurate+detection+of+third-party+libraries+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "L. Li, T.F. Bissyand\u00e9, J. Klein, Y. Le Traon, \"An investigation into the use of common libraries in Android apps\", <em>Proceedings of the 23rd IEEE International Conference on Software Analysis Evolution and Reengineering</em>, 2016.", "title": "An investigation into the use of common libraries in Android apps", "context": [{"sec": "sec1", "text": "The other approach is to directly extract libraries from apps without a priori knowledge about the libraries [5]\u2013[8][9].", "part": "1"}, {"sec": "sec2", "text": " This assumption is the basis of the pre-clustering algorithms used in similarity-based library identification [8], [9].", "part": "1"}, {"sec": "sec4b", "text": " The threshold is the number of appearances of a potential library candidate in the dataset, in our research and previous studies [6], [8].", "part": "1"}, {"sec": "sec4b", "text": " For example, Wukong [6] sets the threshold as 32 while Li et al. use 10 [8].", "part": "1"}, {"sec": "sec4d1", "text": "Li et al. detect 1,113 libraries from apps on Google Play [8].", "part": "1"}, {"sec": "sec6a", "text": " [8] investigated the usage patterns of third-party Android libraries.", "part": "1"}], "links": {"documentLink": "/document/7476661", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7476661", "abstract": "The packaging model of Android apps requires the entire code necessary for the execution of an app to be shipped into one single apk file. Thus, an analysis of Android apps often visits code which is not part of the functionality delivered by the app. Such code is often contributed by the common libraries which are used pervasively by all apps. Unfortunately, Android analyses, e.g., for piggybacking detection and malware detection, can produce inaccurate results if they do not take into account ...", "pdfSize": "250KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+investigation+into+the+use+of+common+libraries+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "K. Chen, X. Wang, Y. Chen, P. Wang, Y. Lee, X. Wang, B. Ma, A. Wang, Y. Zhang, W. Zhou, \"Following devils footprints: Cross-platform analysis of potentially harmful libraries on Android and iOS\", <em>Proceedings of the 37th IEEE Symposium on Security and Privacy</em>, 2016.", "title": "Following devils footprints: Cross-platform analysis of potentially harmful libraries on Android and iOS", "context": [{"sec": "sec1", "text": "The other approach is to directly extract libraries from apps without a priori knowledge about the libraries [5]\u2013[9].", "part": "1"}, {"sec": "sec2", "text": " This assumption is the basis of the pre-clustering algorithms used in similarity-based library identification [8], [9].", "part": "1"}, {"sec": "sec6a", "text": " [9] tried to find potentially harmful libraries in iOS as well as Android apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Following+devils+footprints%3A+Cross-platform+analysis+of+potentially+harmful+libraries+on+Android+and+iOS&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "<em>Openstack</em>,  [online]  Available: https://www.openstack.org/.", "title": "Openstack", "context": [{"sec": "sec3a", "text": " We deployed our experiment environment on OpenStack, a cloud computing platform [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Openstack&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "<em>The Java tutorial: What is a package?</em>,  [online]  Available: https://docs.oracle.com/javase/tutorial/java/concepts/package.html.", "title": "The Java tutorial: What is a package?", "context": [{"sec": "sec3b", "text": " Note that each tree node with a set of class files is actually an Android package [11]; in this research, we group package nodes on the directory tree to recover third-party library instances.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Java+tutorial%3A+What+is+a+package%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "W. Zhou, Y. Zhou, M. Grace, X. Jiang, S. Zou, \"Fast scalable detection of \u201cpiggybacked\u201cmobile applications\", <em>Proceedings of the 3rd ACM Conference on Data and Application Security and Privacy</em>, pp. 185-196, 2013.", "title": "Fast, scalable detection of \u201cpiggybacked\u201cmobile applications", "context": [{"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2435349.2435377", "abstract": "Mobile applications (or apps) are rapidly growing in number and variety. These apps provide useful features, but also bring certain privacy and security risks. For example, malicious authors may attach destructive payloads to legitimate apps to create so-called &#34;piggybacked&#34; apps and advertise them in various app markets to infect unsuspecting users. To detect them, existing approaches typically employ pair-wise comparison, which unfortunately has limited scalability. In this paper, we present a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fast%2C+scalable+detection+of+%E2%80%9Cpiggybacked%E2%80%9Cmobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. Crussell, C. Gibler, H. Chen, \"Attack of the clones: Detecting cloned applications on Android markets\", <em>Proceedings of the 17th European Symposium on Research in ComputerSecurity</em>, pp. 37-54, 2012.", "title": "Attack of the clones: Detecting cloned applications on Android markets", "context": [{"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[13][15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Attack+of+the+clones%3A+Detecting+cloned+applications+on+Android+markets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "F. Zhang, H. Huang, S. Zhu, D. Wu, P. Liu, \"ViewDroid: Towards obfuscation-resilient mobile application repackaging detection\", <em>Proceedings of the 2014 ACM Conference on Security and Privacy in Wireless and Mobile Networks</em>, pp. 25-36, 2014.", "title": "ViewDroid: Towards obfuscation-resilient mobile application repackaging detection", "context": [{"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[14][15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}, {"sec": "sec6b", "text": "Third-party library identification has been used to implement many security applications targeting the Android ecosystem, one of which is Android app clone and repackaging detection [3], [6], [14], [39]\u2013[41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ViewDroid%3A+Towards+obfuscation-resilient+mobile+application+repackaging+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "C. Zheng, S. Zhu, S. Dai, G. Gu, X. Gong, X. Han, W. Zou, \"Smart-droid: an automatic system for revealing ui-based trigger conditions in Android applications\", <em>Proceedings of the 2nd ACM Workshop on Security and Privacy in Smartphones and Mobile Devices</em>, pp. 93-104, 2012.", "title": "Smart-droid: an automatic system for revealing ui-based trigger conditions in Android applications", "context": [{"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2381934.2381950", "abstract": "User interface (UI) interactions are essential to Android applications, as many Activities require UI interactions to be triggered. This kind of UI interactions could also help malicious apps to hide their sensitive behaviors (e.g., sending SMS or getting the user&#39;s device ID) from being detected by dynamic analysis tools such as TaintDroid, because simply running the app, but without proper UI interactions, will not lead to the exposure of sensitive behaviors. In this paper we focus on the chal...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Smart-droid%3A+an+automatic+system+for+revealing+ui-based+trigger+conditions+in+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>Apktool</em>, 2016,  [online]  Available: http://ibotpeaches.github.io/Apktool/.", "title": "Apktool", "context": [{"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apktool&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "L. Adesnos, <em>Androguard</em>,  [online]  Available: https://github.com/androguard/androguard.", "title": "Androguard", "context": [{"sec": "sec3b", "text": "Same as existing work [6], [12]\u2013[15], we employ two commonly-used app analysis tool Apktool [16] and Andro-guard [17] to decompile the input apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Androguard&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>Setting the record straight on Moplus SDK and the Wormhole vulnerability</em>,  [online]  Available: http://blog.trendmicro.com/trendlabs-security-intelligence/setting-the-record-straight-on-moplus-sdk-and-the-wormhole-vulnerability/.", "title": "Setting the record straight on Moplus SDK and the Wormhole vulnerability", "context": [{"sec": "sec3d1", "text": "Actually many (security-related) mutations, e.g., the remote control vulnerability exposed in Baidu moplus SDK [18], would only update a single line of code in one specific version of the library.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Setting+the+record+straight+on+Moplus+SDK+and+the+Wormhole+vulnerability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>Android security white paper</em>,  [online]  Available: https://static.googleusercontent.com/medialenterprise.google.com/en//android/files/android-for-work-security-white-paper.pdf.", "title": "Android security white paper", "context": [{"sec": "sec4a", "text": " Although the official app market, Google Play, contains over a million apps [1], it employs more rigorous reviews on the uploaded apps, including both static and dynamic analysis, and presumably many malicious or vulnerable third-party libraries could have been rejected during the review process [19], [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+security+white+paper&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "<em>How we keep harmful apps out of Google Play and keep your Android device safe</em>,  [online]  Available: https://static.googleusercontent.com/media/source.android.com/en//security/reports/Android_WhitePaper_Final_02092016.pdf.", "title": "How we keep harmful apps out of Google Play and keep your Android device safe", "context": [{"sec": "sec4a", "text": " Although the official app market, Google Play, contains over a million apps [1], it employs more rigorous reviews on the uploaded apps, including both static and dynamic analysis, and presumably many malicious or vulnerable third-party libraries could have been rejected during the review process [19], [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+we+keep+harmful+apps+out+of+Google+Play+and+keep+your+Android+device+safe&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>Proguard</em>,  [online]  Available: https://www.guardsquare.com/proguard.", "title": "Proguard", "context": [{"sec": "sec4f2", "text": " Obfuscators (e.g., Proguard [21]) replace the library name with several meaningless strings while preserve the original directory structures.", "part": "1"}, {"sec": "sec5a", "text": " Proguard [21], the official obfuscation tool provided by the Android SDK, is considered the most popular obfuscator in the Android developer community.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Proguard&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>Dexguard</em>,  [online]  Available: https://www.guardsquare.com/dexguard.", "title": "Dexguard", "context": [{"sec": "sec5a", "text": "We have also noticed that some obfuscation tools can perform code encryption or even program control flow-based obfuscations [22]\u2013[24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dexguard&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>Dash-O</em>,  [online]  Available: https://www.preemptive.com/products/dasho/overview.", "title": "Dash-O", "context": [{"sec": "sec5a", "text": "We have also noticed that some obfuscation tools can perform code encryption or even program control flow-based obfuscations [22]\u2013[23][24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dash-O&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "<em>Dexprotector</em>,  [online]  Available: https://dexprotector.com/.", "title": "Dexprotector", "context": [{"sec": "sec5a", "text": "We have also noticed that some obfuscation tools can perform code encryption or even program control flow-based obfuscations [22]\u2013[24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dexprotector&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "S.K. Udupa, S.K. Debray, M. Madou, \"Deobfuscation: reverse engineering obfuscated code\", <em>Proccedings of the 12th Working Conference on Reverse Engineering</em>, 2005.", "title": "Deobfuscation: reverse engineering obfuscated code", "context": [{"sec": "sec5a", "text": " Actually there has been much orthogonal work proposing to deobfuscate those techniques [25], [26].", "part": "1"}], "links": {"abstract": "In recent years, code obfuscation has attracted attention as a low cost approach to improving software security by making it difficult for attackers to understand the inner workings of proprietary software systems. This paper examines techniques for automatic deobfuscation of obfuscated programs, as a step towards reverse engineering such programs. Our results indicate that much of the effects of code obfuscation, designed to increase the difficulty of static analyses, can be defeated using simp...", "pdfSize": "203KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deobfuscation%3A+reverse+engineering+obfuscated+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "D. Low, <em>Java control flow obfuscation</em>, 1998.", "title": "Java control flow obfuscation", "context": [{"sec": "sec5a", "text": " Actually there has been much orthogonal work proposing to deobfuscate those techniques [25], [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Java+control+flow+obfuscation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "T. Kamiya, S. Kusumoto, K. Inoue, \"CCFinder: A multilinguistic token-based code clone detection system for large scale source code\", <em>IEEE Trans. Softw. Eng.</em>, vol. 28, no. 7, pp. 654-670, Jul. 2002.", "title": "CCFinder: A multilinguistic token-based code clone detection system for large scale source code", "context": [{"sec": "sec5c", "text": " Syntactic features are straightforward representations of the target programs, and they have been widely used by many existing work for program similarity comparison and code clone detection [27]\u2013[29].", "part": "1"}], "links": {"documentLink": "/document/1019480", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1019480", "abstract": "A code clone is a code portion in source files that is identical or similar to another. Since code clones are believed to reduce the maintainability of software, several code clone detection techniques and tools have been proposed. This paper proposes a new clone detection technique, which consists of the transformation of input source text and a token-by-token comparison. For its implementation with several useful optimization techniques, we have developed a tool, named CCFinder (Code Clone Fin...", "pdfSize": "4706KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CCFinder%3A+A+multilinguistic+token-based+code+clone+detection+system+for+large+scale+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "Z. Li, S. Lu, S. Myagmar, Y. Zhou, \"CP-Miner: A tool for finding copy-paste and related bugs in operating system code\", <em>Proceedings of the 6th Conference on Symposium on Opearting Systems Design and Implementation</em>, 2004.", "title": "CP-Miner: A tool for finding copy-paste and related bugs in operating system code", "context": [{"sec": "sec5c", "text": " Syntactic features are straightforward representations of the target programs, and they have been widely used by many existing work for program similarity comparison and code clone detection [27]\u2013[28][29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=CP-Miner%3A+A+tool+for+finding+copy-paste+and+related+bugs+in+operating+system+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "L. Jiang, G. Misherghi, Z. Su, S. Glondu, \"DECKARD: Scalable and accurate tree-based detection of code clones\", <em>Proceedings of the 29th International Conference on Software Engineering</em>, pp. 96-105, 2007.", "title": "DECKARD: Scalable and accurate tree-based detection of code clones", "context": [{"sec": "sec5c", "text": " Syntactic features are straightforward representations of the target programs, and they have been widely used by many existing work for program similarity comparison and code clone detection [27]\u2013[29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DECKARD%3A+Scalable+and+accurate+tree-based+detection+of+code+clones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "R. Komondoor, S. Horwitz, \"Using slicing to identify duplication in source code\", <em>Proceedings of the 8th International Symposium on Static Analysis</em>, pp. 40-56, 2001.", "title": "Using slicing to identify duplication in source code", "context": [{"sec": "sec5c", "text": "On the other hand, we have also observed some program semantics-based similarity analysis work [30]\u2013[32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-47764-0_3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+slicing+to+identify+duplication+in+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "L. Luo, J. Ming, D. Wu, P. Liu, S. Zhu, \"Semantics-based obfuscation-resilient binary code similarity comparison with applications to software plagiarism detection\", <em>Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 389-400, 2014.", "title": "Semantics-based obfuscation-resilient binary code similarity comparison with applications to software plagiarism detection", "context": [{"sec": "sec5c", "text": "On the other hand, we have also observed some program semantics-based similarity analysis work [30]\u2013[31][32].", "part": "1"}, {"sec": "sec5c", "text": " However, existing semantics-based similarity work may not be very scale [31], [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635900", "abstract": "Existing code similarity comparison methods, whether source or binary code based, are mostly not resilient to obfuscations. In the case of software plagiarism, emerging obfuscation techniques have made automated detection increasingly difficult. In this paper, we propose a binary-oriented, obfuscation-resilient method based on a new concept, longest common subsequence of semantically equivalent basic blocks, which combines rigorous program semantics with longest common subsequence based fuzzy ma...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semantics-based+obfuscation-resilient+binary+code+similarity+comparison+with+applications+to+software+plagiarism+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "J. Pewny, B. Garmany, R. Gawlik, C. Rossow, T. Holz, \"Cross-architecture bug search in binary executables\", <em>Proceedings of the 2015 IEEE Symposium on Security and Privacy</em>, pp. 709-724, 2015.", "title": "Cross-architecture bug search in binary executables", "context": [{"sec": "sec5c", "text": "On the other hand, we have also observed some program semantics-based similarity analysis work [30]\u2013[32].", "part": "1"}, {"sec": "sec5c", "text": " However, existing semantics-based similarity work may not be very scale [31], [32].", "part": "1"}], "links": {"abstract": "With the general availability of closed-source software for various CPU architectures, there is a need to identify security-critical vulnerabilities at the binary level to perform a vulnerability assessment. Unfortunately, existing bug finding methods fall short in that they i) require source code, ii) only work on a single architecture (typically x86), or iii) rely on dynamic analysis, which is inherently difficult for embedded devices. In this paper, we propose a system to derive bug signature...", "pdfSize": "605KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cross-architecture+bug+search+in+binary+executables&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "T. Book, A. Pridgen, D.S. Wallach, Longitudinal analysis of Android ad library permissions, CoRR, vol. abs/1303.0857, 2013.", "title": "Longitudinal analysis of Android ad library permissions", "context": [{"sec": "sec6a", "text": " [33] and Grace et al. [34] use the whitelist-based method for detecting advertising libraries.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Longitudinal+analysis+of+Android+ad+library+permissions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "M.C. Grace, W. Zhou, X. Jiang, A.-R. Sadeghi, \"Unsafe exposure analysis of mobile in-app advertisements\", <em>Proceedings of the 5th ACM Conference on Security and Privacy in Wireless and Mobile Networks</em>, pp. 101-112, 2012.", "title": "Unsafe exposure analysis of mobile in-app advertisements", "context": [{"sec": "sec6a", "text": " [34] use the whitelist-based method for detecting advertising libraries.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2185448.2185464", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Unsafe+exposure+analysis+of+mobile+in-app+advertisements&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "A. Narayanan, L. Chen, C.K. Chan, \"Addetect: Automated detection of Android ad libraries using semantic analysis\", <em>Proceedings of the 9th IEEE International Conference on Intelligent Sensors Sensor Networks and Information Processing</em>, 2014.", "title": "Addetect: Automated detection of Android ad libraries using semantic analysis", "context": [{"sec": "sec6a", "text": " Later techniques like AdDetect [35] and PEDAL [4] start to employ machine learning methods to provide more accurate and comprehensive results, but they still target advertising libraries only.", "part": "1"}], "links": {"abstract": "Applications that run on mobile operating systems such as Android use in-app advertisement libraries for monetization. Recent research reveals that many ad libraries, including popular ones pose threats to user privacy. Some aggressive ad libraries involve in active privacy leaks with the intention of providing targeted ads. Few intrusive ad libraries are classified as adware by commercial mobile anti-virus apps. Despite such issues, semantic detection of ad libraries from Android apps remains a...", "pdfSize": "352KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Addetect%3A+Automated+detection+of+Android+ad+libraries+using+semantic+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "C. Gibler, R. Stevens, J. Crussell, H. Chen, H. Zang, H. Choi, \"Adrob: examining the landscape and impact of Android application plagiarism\", <em>Proceedings of the 11 th Annual International Conference on Mobile Systems Applications and Services</em>, pp. 431-444, 2013.", "title": "Adrob: examining the landscape and impact of Android application plagiarism", "context": [{"sec": "sec6a", "text": " AdRob [36] analyzes the network traffic generated by the advertising services in Android apps to identify which libraries are bundled, with both static and dynamic analysis.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adrob%3A+examining+the+landscape+and+impact+of+Android+application+plagiarism&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "M. Linares-V\u00e1squez, A. Holtzhauer, C. Bernal-C\u00e1rdenas, D. Poshyvanyk, \"Revisiting Android reuse studies in the context of code obfuscation and library usages\", <em>Proceedings of the 11 th Working Conference on Mining Software Repositories</em>, pp. 242-251, 2014.", "title": "Revisiting Android reuse studies in the context of code obfuscation and library usages", "context": [{"sec": "sec6a", "text": " [37], [38] extracted the package name (i.e., main package) from AndroidManifest.xml for an app.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2597073.2597109", "abstract": "In the recent years, studies of design and programming practices in mobile development are gaining more attention from researchers. Several such empirical studies used Android applications (paid, free, and open source) to analyze factors such as size, quality, dependencies, reuse, and cloning. Most of the studies use executable files of the apps (APK files), instead of source code because of availability issues (most of free apps available at the Android official market are not open-source, but ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Revisiting+Android+reuse+studies+in+the+context+of+code+obfuscation+and+library+usages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "M. Linares-V\u00e1squez, A. Holtzhauer, D. Poshyvanyk, \"On automatically detecting similar Android apps\", <em>Program Comprehension (ICPC) 2016 IEEE 24th International Conference on</em>, pp. 1-10, 2016.", "title": "On automatically detecting similar Android apps", "context": [{"sec": "sec6a", "text": "To distinguish app-specific classes from third-party-library classes, V\u00e1squez et al. [37], [38] extracted the package name (i.e., main package) from AndroidManifest.xml for an app.", "part": "1"}], "links": {"documentLink": "/document/7503721", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7503721", "abstract": "Detecting similar applications is a challenging problem, since it implies that similar high-level features and their low-level implementations can be detected and matched automatically. We propose an approach for automatically detecting Closely reLated applications in ANdroid (CLANdroid) by relying on advanced Information Retrieval techniques and five semantic anchors: identifiers, Android APIs, intents, permissions, and sensors. To evaluate CLANdroid we created a benchmark consisting of 14,450 ...", "pdfSize": "2054KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+automatically+detecting+similar+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "J. Crussell, C. Gibler, H. Chen, \"Andarwin: Scalable detection of semantically similar Android applications\", <em>Proceedings of the 18th European Symposium on Research in ComputerSecurity</em>, pp. 182-199, 2013.", "title": "Andarwin: Scalable detection of semantically similar Android applications", "context": [{"sec": "sec6b", "text": "Third-party library identification has been used to implement many security applications targeting the Android ecosystem, one of which is Android app clone and repackaging detection [3], [6], [14], [39]\u2013[41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Andarwin%3A+Scalable+detection+of+semantically+similar+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "J. Crussell, \"Attack of the clones: Detecting cloned applications on Android markets\", <em>European Symposium on Research in ComputerSecurity</em>, pp. 37-54, 2012.", "title": "Attack of the clones: Detecting cloned applications on Android markets", "context": [{"sec": "sec6b", "text": "Third-party library identification has been used to implement many security applications targeting the Android ecosystem, one of which is Android app clone and repackaging detection [3], [6], [14], [39]\u2013[40][41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Attack+of+the+clones%3A+Detecting+cloned+applications+on+Android+markets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "S. Hanna, L. Huang, E. Wu, S. Li, C. Chen, D. Song, \"Juxtapp: A scalable system for detecting code reuse among Android applications\", <em>Detection of Intrusions and Malware and Vulnerability Assessment</em>, pp. 62-81, 2012.", "title": "Juxtapp: A scalable system for detecting code reuse among Android applications", "context": [{"sec": "sec6b", "text": "Third-party library identification has been used to implement many security applications targeting the Android ecosystem, one of which is Android app clone and repackaging detection [3], [6], [14], [39]\u2013[41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Juxtapp%3A+A+scalable+system+for+detecting+code+reuse+among+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "A. Paturi, P.G. Kelley, S. Mazumdar, \"Introducing privacy threats from ad libraries to Android users through privacy granules\", <em>Proceedings of NDSS Workshop on Usable Security (USEC'15). Internet Society</em>, 2015.", "title": "Introducing privacy threats from ad libraries to Android users through privacy granules", "context": [{"sec": "sec6b", "text": " [42] and Stevens et al. [43] extracted advertising libraries from popular Android apps and studied the privacy leakage problems residing in these libraries.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/usec.2015.23008", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introducing+privacy+threats+from+ad+libraries+to+Android+users+through+privacy+granules&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "R. Stevens, C. Gibler, J. Crussell, J. Erickson, H. Chen, \"Investigating user privacy in Android ad libraries\", <em>Workshop on Mobile Security Technologies (MoST)</em>, pp. 10, 2012.", "title": "Investigating user privacy in Android ad libraries", "context": [{"sec": "sec6b", "text": " [43] extracted advertising libraries from popular Android apps and studied the privacy leakage problems residing in these libraries.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Investigating+user+privacy+in+Android+ad+libraries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "X. Jin, X. Hu, K. Ying, W. Du, H. Yin, G.N. Peri, \"Code injection attacks on HTML5-based mobile apps: Characterization detection and mitigation\", <em>Proceedings of the 2014 ACM SIGSAC Conference on Computerand Communications Security</em>, pp. 66-77, 2014.", "title": "Code injection attacks on HTML5-based mobile apps: Characterization, detection and mitigation", "context": [{"sec": "sec6b", "text": " [44] discovered that some third-party libraries providing HTML5 support for mobile developers can be easily exploited by code injection attacks.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660275", "abstract": "Due to the portability advantage, HTML5-based mobile apps are getting more and more popular.Unfortunately, the web technology used by HTML5-based mobile apps has a dangerous feature, which allows data and code to be mixed together, making code injection attacks possible. In this paper, we have conducted a systematic study on this risk in HTML5-based mobile apps. We found a new form of code injection attack, which inherits the fundamental cause of Cross-Site Scripting attack~(XSS), but it uses ma...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+injection+attacks+on+HTML5-based+mobile+apps%3A+Characterization%2C+detection+and+mitigation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "D. Sounthiraraj, J. Sahs, G. Greenwood, Z. Lin, L. Khan, \"SMV-HUNTER: Large scale automated detection of SSL/TLS man-in-the-middle vulnerabilities in Android apps\", <em>Proceedings of the 21st Annual Network and Distributed System Security Symposium</em>, 2014.", "title": "SMV-HUNTER: Large scale, automated detection of SSL/TLS man-in-the-middle vulnerabilities in Android apps", "context": [{"sec": "sec6b", "text": " SMV-HUNTER [45] analyzed the man-in-the-middle SSL/TSL vulnerabilities in Android apps and third-party libraries.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2014.23205", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SMV-HUNTER%3A+Large+scale%2C+automated+detection+of+SSL%2FTLS+man-in-the-middle+vulnerabilities+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "T. Li, X. Zhou, L. Xing, Y. Lee, M. Naveed, X. Wang, X. Han, \"Mayhem in the push clouds: Understanding and mitigating security hazards in mobile push-messaging services\", <em>Proceedings of the 2014 ACM SIGSAC Conference on Computerand Communications Security</em>, pp. 978-989, 2014.", "title": "Mayhem in the push clouds: Understanding and mitigating security hazards in mobile push-messaging services", "context": [{"sec": "sec6b", "text": " [46] found a vulnerability in a specific version of the Google cloud messaging library that leads to private data leakage.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660302", "abstract": "Push messaging is among the most important mobile-cloud services, offering critical supports to a wide spectrum of mobile apps. This service needs to coordinate complicated interactions between developer servers and their apps in a large scale, making it error prone. With its importance, little has been done, however, to understand the security risks of the service. In this paper, we report the first security analysis on those push-messaging services, which reveals the pervasiveness of subtle ye...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mayhem+in+the+push+clouds%3A+Understanding+and+mitigating+security+hazards+in+mobile+push-messaging+services&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985674", "articleId": "7985674", "startPage": "335", "endPage": "346", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 13, "citationCountPatent": 0, "totalDownloads": 1061}}
{"title": "Zero-Overhead Path Prediction with Progressive Symbolic Execution", "authors": [{"name": "Richard Rutledge", "affiliation": "Georgia Institute of Technology", "firstName": "Richard", "lastName": "Rutledge", "id": "37085569617"}, {"name": "Sunjae Park", "affiliation": "Georgia Institute of Technology", "firstName": "Sunjae", "lastName": "Park", "id": "37086953292"}, {"name": "Haider Khan", "affiliation": "Georgia Institute of Technology", "firstName": "Haider", "lastName": "Khan", "id": "37086948376"}, {"name": "Alessandro Orso", "affiliation": "Georgia Institute of Technology", "firstName": "Alessandro", "lastName": "Orso", "id": "37267738200"}, {"name": "Milos Prvulovic", "affiliation": "Georgia Institute of Technology", "firstName": "Milos", "lastName": "Prvulovic", "id": "37298065900"}, {"name": "Alenka Zajic", "affiliation": "Georgia Institute of Technology", "firstName": "Alenka", "lastName": "Zajic", "id": "37295808800"}], "abstract": "In previous work, we introduced zero-overhead profiling (ZOP), a technique that leverages the electromagnetic emissions generated by the computer hardware to profile a program without instrumenting it. Although effective, ZOP has several shortcomings: it requires test inputs that achieve extensive code coverage for its training phase; it predicts path profiles instead of complete execution traces; and its predictions can suffer unrecoverable accuracy losses. In this paper, we present zero-overhead path prediction (ZOP-2), an approach that extends ZOP and addresses its limitations. First, ZOP-2 achieves high coverage during training through progressive symbolic execution (PSE)-symbolic execution of increasingly small program fragments. Second, ZOP-2 predicts complete execution traces, rather than path profiles. Finally, ZOP-2 mitigates the problem of path mispredictions by using a stateless approach that can recover from prediction errors. We evaluated our approach on a set of benchmarks with promising results; for the cases considered, (1) ZOP-2 achieved over 90% path prediction accuracy, and (2) PSE covered feasible paths missed by traditional symbolic execution, thus boosting ZOP-2's accuracy.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Training", "Predictive models", "Instruments", "Electromagnetics", "Benchmark testing", "Task analysis", "Microsoft Windows"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["program testing", "symbol manipulation"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["symbolic execution", "path prediction accuracy", "electromagnetic emissions", "computer hardware", "extensive code coverage", "path mispredictions", "progressive symbolic execution", "zero-overhead profiling", "prediction errors", "zero-overhead path prediction", "complete execution traces", "path profiles"]}, {"type": "Author Keywords ", "kwd": ["symbolic execution", "path profiling", "tracing"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00039", "ref": [{"order": "1", "text": "R. Callan, F. Behrang, A. Zajic, M. Prvulovic, A. Orso, \"Zero-overhead Profiling via EM Emanations\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis ser. ISSTA 2016</em>, pp. 401-412, 2016.", "title": "Zero-overhead Profiling via EM Emanations", "context": [{"sec": "sec1", "text": " To address these issues, while still being able to collect accurate (partial) program traces, in previous work we developed zero-overhead profiling (ZOP) [1], a technique that can profile a program without instrumenting it by leveraging the electromagnetic (EM) emissions generated by the processing hardware during execution.", "part": "1"}, {"sec": "sec2a", "text": "Zero-overhead profiling (ZOP) [1] computes acyclic path profiles [2] for a program P by observing the electromagnetic (EM) emanations produced by a computing system during execution of (an unmodified version of) P.", "part": "1"}, {"sec": "sec3a", "text": " Based on our past experience [1], preliminary experimentation, the way ZOP-2 performs signal matching, and our domain knowledge, we selected the following points for inserting markers: entry nodes of functions, exit nodes of functions, loop heads, and target nodes of goto statements.", "part": "1"}, {"sec": "sec3c", "text": " This approach is preferable to a DFS because the latter is prone to error propagation; any misprediction is often followed by a series of consecutive mispredictions, which amplifies the initial error and may result in the algorithm getting lost [1].", "part": "1"}, {"sec": "sec4b", "text": " The first three were used to evaluate ZOP in previous work [1].", "part": "1"}, {"sec": "sec6", "text": " More recently, researchers have leveraged EM side channels for hardware Trojan detection [45], [46], malware detection [47], control flow integrity assessment [48], and software profiling [1], [49].", "part": "1"}, {"sec": "sec6", "text": " Sehatbakhsh and colleagues exploit spectral peaks in EM signals for loop-level profiling of program executions, while the approach by Callan and colleagues [1] can predict acyclic path profiles.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931065", "abstract": "This paper presents an approach for zero-overhead profiling (ZOP). ZOP accomplishes accurate program profiling with no modification to the program or system during profiling and no dedicated hardware features. To do so, ZOP records the electromagnetic (EM) emanations generated by computing systems during program execution and analyzes the recorded emanations to track a program\u2019s execution path and generate profiling information. Our approach consists of two main phases. In the training phase, ZO...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Zero-overhead+Profiling+via+EM+Emanations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "T. Ball, J. R. Larus, \"Efficient path profiling\", <em>Proceedings of the 29th Annual IEEE/ACM International Symposium on Microarchitecture 1996. MICRO-29</em>, pp. 46-57, Dec. 1996.", "title": "Efficient path profiling", "context": [{"sec": "sec1", "text": " Second, ZOP predicts acyclic path profiles [2], rather than complete execution traces.", "part": "1"}, {"sec": "sec2a", "text": "Zero-overhead profiling (ZOP) [1] computes acyclic path profiles [2] for a program P by observing the electromagnetic (EM) emanations produced by a computing system during execution of (an unmodified version of) P.", "part": "1"}, {"sec": "sec6", "text": " Software instrumentation is unfortunately expensive (e.g, they can incur 31% overhead for (acyclic) path profiling alone [2]).", "part": "1"}], "links": {"documentLink": "/document/566449", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=566449", "abstract": "A path profile determines how many times each acyclic path in a routine executes. This type of profiling subsumes the more common basic block and edge profiling, which only approximate path frequencies. Path profiles have many potential uses in program performance tuning, profile-directed compilation, and software test coverage. This paper describes a new algorithm for path profiling. This simple, fast algorithm selects and places profile instrumentation to minimize run-time overhead. Instrument...", "pdfSize": "1075KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+path+profiling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "D. A. Ramos, D. Engler, \"Under-Constrained Symbolic Execution: Correctness Checking for Real Code\", <em>24th USENIX Security Symposium (USENIX Security 15)</em>, pp. 49-64, Aug. 2015.", "title": "Under-Constrained Symbolic Execution: Correctness Checking for Real Code", "context": [{"sec": "sec1", "text": " If this fails to achieve sufficient coverage for ZOP-2 training, it proceeds to execute functions with symbolic inputs and unconstrained global state (similar to UC-KLEE [3]).", "part": "1"}, {"sec": "sec6", "text": " This degree of under-constraining has been shown to be effective for patch validation and defect detection [3].", "part": "1"}, {"sec": "sec6", "text": " Various tools have implemented lazy initialization for symbolic execution in Java (e.g., [9], [39], [40]\u2013), C/C++ (via LLVM IR [3]), and object code [41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Under-Constrained+Symbolic+Execution%3A+Correctness+Checking+for+Real+Code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Zop-2</em>,  [online]  Available: https://hub.docker.com/r/naegling/icse19-zop2.", "title": "Zop-2", "context": [{"sec": "sec1", "text": "An implementation of PSE, which is publicly available as a docker image [4] and in archival format [5].", "part": "1"}, {"sec": "sec4a", "text": " We also relied on LLVM [15] and on the STP constraint solver [16], Our implementation of PSE is publicly available as a self-contained docker image [4].", "part": "1"}, {"sec": "sec5", "text": " We also carefully tested our implementation of PSE, which is available for public inspection [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Zop-2&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "R. Rutledge, S. Park, H. Khan, A. Orso, M. Prvulovic, A. Zajic, <em>Artifact: Zero-Overhead Path Prediction with Progressive Symbolic Execution</em>, Feb. 2019.", "title": "Artifact: Zero-Overhead Path Prediction with Progressive Symbolic Execution", "context": [{"sec": "sec1", "text": "An implementation of PSE, which is publicly available as a docker image [4] and in archival format [5].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.5281/zenodo.2577372", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Artifact%3A+Zero-Overhead+Path+Prediction+with+Progressive+Symbolic+Execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "J. C. King, \"Symbolic execution and program testing\", <em>Commun. ACM</em>, vol. 19, no. 7, pp. 385-394, Jul. 1976.", "title": "Symbolic execution and program testing", "context": [{"sec": "sec2b", "text": "Symbolic execution (SE) [6] is a technique that executes a program using symbolic instead of concrete inputs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/360248.360252", "abstract": "This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may be symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and deb...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+execution+and+program+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C. Cadar, K. Sen, \"Symbolic Execution for Software Testing: Three Decades Later\", <em>Commun. ACM</em>, vol. 56, no. 2, pp. 82-90, Feb. 2013.", "title": "Symbolic Execution for Software Testing: Three Decades Later", "context": [{"sec": "sec3a", "text": " However, its effectiveness and scalability are limited in practice by several issues, and in particular by the path explosion problem-the fact that the number of feasible paths is usually exponential in the number of code branches [7].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2408776.2408795", "abstract": "The challenges---and great promise---of modern symbolic execution techniques, and the tools to help implement them.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+Execution+for+Software+Testing%3A+Three+Decades+Later&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "D. Engler, D. Dunbar, \"Under-constrained Execution: Making Automatic Code Destruction Easy and Scalable\", <em>Proceedings of the 2007 International Symposium on Software Testing and Analysis ser. ISSTA '07</em>, pp. 1-4, 2007.", "title": "Under-constrained Execution: Making Automatic Code Destruction Easy and Scalable", "context": [{"sec": "sec3a2", "text": " Intuitively, this strategy corresponds to executing a function as if it could be reached with every possible state and is equivalent to under-constrained symbolic execution [8].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1273463.1273464", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Under-constrained+Execution%3A+Making+Automatic+Code+Destruction+Easy+and+Scalable&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "S. Khurshid, C. S. Pasareanu, W. Visser, \"Generalized Symbolic Execution for Model Checking and Testing\" in Tools and Algorithms for the Construction and Analysis of Systems, Berlin, Heidelberg:Springer, pp. 553-568, Apr. 2003.", "title": "Generalized Symbolic Execution for Model Checking and Testing", "context": [{"sec": "sec3a3", "text": "Lazy Initialization: PSE uses lazy initialization [9] to construct pointer inputs for execution at an arbitrary program point.", "part": "1"}, {"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[32].", "part": "1"}, {"sec": "sec6", "text": "Lazy initialization is an important feature of generalized symbolic execution [9], as it allows the handling of unconstrained pointers or references.", "part": "1"}, {"sec": "sec6", "text": " Various tools have implemented lazy initialization for symbolic execution in Java (e.g., [9], [39], [40]\u2013), C/C++ (via LLVM IR [3]), and object code [41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generalized+Symbolic+Execution+for+Model+Checking+and+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "B. B. Yilmaz, R. L. Callan, M. Prvulovic, A. Zaji\u0107, \"Capacity of the em covert/side-channel created by the execution of instructions in a processor\", <em>IEEE Transactions on Information Forensics and Security</em>, vol. 13, no. 3, pp. 605-620, March 2018.", "title": "Capacity of the em covert/side-channel created by the execution of instructions in a processor", "context": [{"sec": "sec3c", "text": "Once the test signal is split into sampling windows, the Path Predictor searches, for each sampling window, the best match in the EME Model based on the least Euclidean distance [10], as intuitively shown in Figure 2.", "part": "1"}], "links": {"documentLink": "/document/8067449", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8067449", "abstract": "The goal of this paper is to answer how much information is \u201ctransmitted\u201d by the execution of particular sequence of instructions in a processor. Introducing such a measure would provide quantitative guidance for designing programs and computer hardware that minimizes inadvertent (side channel) information leakage, and would also help detect parts of a program or hardware design that have unusually high leakage (i.e., were designed to function as covert channel \u201ctransmitters\u201d). To answer this qu...", "pdfSize": "2678KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Capacity+of+the+em+covert%2Fside-channel+created+by+the+execution+of+instructions+in+a+processor&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "G. C. Necula, S. McPeak, S. P. Rahul, W. Weimer, \"CIL: Intermediate Language and Tools for Analysis and Transformation of C Programs\" in Compiler Construction ser. Lecture Notes in Computer Science, Berlin, Heidelberg:Springer, pp. 213-228, Apr. 2002.", "title": "CIL: Intermediate Language and Tools for Analysis and Transformation of C Programs", "context": [{"sec": "sec4a", "text": " We used CIL [11] and clang [12] to preprocess source code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-45937-5_16", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CIL%3A+Intermediate+Language+and+Tools+for+Analysis+and+Transformation+of+C+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "<em>Clang C Language Family Frontend for LLVM</em>,  [online]  Available: https://clang.llvm.org/.", "title": "Clang C Language Family Frontend for LLVM", "context": [{"sec": "sec4a", "text": " We used CIL [11] and clang [12] to preprocess source code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Clang+C+Language+Family+Frontend+for+LLVM&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "<em>NetworkX - NetworkX</em>,  [online]  Available: https://networkx.github.io/.", "title": "NetworkX - NetworkX", "context": [{"sec": "sec4a", "text": " We used a combination of clang and NetworkX [13] for control flow graph analysis.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=NetworkX+-+NetworkX&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "<em>KLEE</em>,  [online]  Available: http.//klee.github.io/.", "title": "KLEE", "context": [{"sec": "sec4a", "text": " We implemented PSE by extending the KLEE [14] symbolic execution engine.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=KLEE&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "C. Lattner, V. Adve, \"LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation\", <em>Proceedings of the International Symposium on Code Generation and Optimization: Feedback-Directed and Runtime Optimization ser. CGO '04</em>, pp. 75, 2004.", "title": "LLVM: A Compilation Framework for Lifelong Program Analysis & Transformation", "context": [{"sec": "sec4a", "text": " We also relied on LLVM [15] and on the STP constraint solver [16], Our implementation of PSE is publicly available as a self-contained docker image [4].", "part": "1"}], "links": {"documentLink": "/document/1281665", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1281665", "abstract": "We describe LLVM (low level virtual machine), a compiler framework designed to support transparent, lifelong program analysis and transformation for arbitrary programs, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. LLVM defines a common, low-level code representation in static single assignment (SSA) form, with several novel features: a simple, language-independent type-system that exposes the primitives commo...", "pdfSize": "358KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=LLVM%3A+A+Compilation+Framework+for+Lifelong+Program+Analysis+%26+Transformation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "V. Ganesh, D. L. Dill, W. Damm, H. Hermanns, \"A Decision Procedure for Bit-Vectors and Arrays\" in Computer Aided Verification ser. Lecture Notes in Computer Science, Berlin Heidelberg:Springer, pp. 519-531, 2007.", "title": "A Decision Procedure for Bit-Vectors and Arrays", "context": [{"sec": "sec4a", "text": " We also relied on LLVM [15] and on the STP constraint solver [16], Our implementation of PSE is publicly available as a self-contained docker image [4].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-73368-3_52", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Decision+Procedure+for+Bit-Vectors+and+Arrays&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "<em>Matlab</em>,  [online]  Available: http://www.mathworks.com/products/matlab.html.", "title": "Matlab", "context": [{"sec": "sec4a", "text": " We implemented our path predictor module in Matlab 2018b [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Matlab&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "C. Cadar, D. Dunbar, D. Engler, \"KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs\", <em>Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation ser. OSDI'08</em>, pp. 209-224, 2008.", "title": "KLEE: Unassisted and Automatic Generation of High-coverage Tests for Complex Systems Programs", "context": [{"sec": "sec4b", "text": " Vanilla KLEE [18].", "part": "1"}, {"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[32].", "part": "1"}, {"sec": "sec6", "text": " Guided path search heuristics select paths for exploration either randomly [18], [35] or based on the predicted likelihood of reaching a given coverage target [18], [25], [35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=KLEE%3A+Unassisted+and+Automatic+Generation+of+High-coverage+Tests+for+Complex+Systems+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "H. Do, S. Elbaum, G. Rothermel, \"Supporting Controlled Experimentation with Testing Techniques: An Infrastructure and its Potential Impact\", <em>Empirical Software Engineering</em>, vol. 10, no. 4, pp. 405-435, Oct. 2005.", "title": "Supporting Controlled Experimentation with Testing Techniques: An Infrastructure and its Potential Impact", "context": [{"sec": "sec4c", "text": " Then, for replace, schedule, and print_tokens, we randonly selected 100 inputs from the tests provided in the SIR repository [19].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-005-3861-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+Controlled+Experimentation+with+Testing+Techniques%3A+An+Infrastructure+and+its+Potential+Impact&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "<em>Avahi - service discovery for linux using mdns/dns-sd</em>,  [online]  Available: http://www.avahi.org/.", "title": "Avahi - service discovery for linux using mdns/dns-sd", "context": [{"sec": "sec4c", "text": " For mDNS, we used Avahi [20] to generate 9 inputs (i.e., mDNS queries) that target different host addresses and ask for different services, including incorrect queries. (We manually checked that the inputs exercise different aspects of the mDNS protocol.) Finally, we used ZOP-2 to perform path prediction using the generated EME Models.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Avahi+-+service+discovery+for+linux+using+mdns%2Fdns-sd&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "T. H. Cormen, C. E. Leiserson, R. L. Rivest, C. Stein, Introduction to Algorithms, The MIT Press, 2009.", "title": "Introduction to Algorithms", "context": [{"sec": "sec4c", "text": "Table II reports the path prediction accuracy for the cases considered, computed by measuring the edit distance [21] between actual and predicted paths.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introduction+to+Algorithms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "R. Callan, A. Zaji\u0107, M. Prvulovic, \"A practical methodology for measuring the side-channel signal available to the attacker for instruction-level events\", <em>Proceedings of the 47th Annual IEEE/ACM International Symposium on Microarchitecture ser. MICRO-47</em>, pp. 242-254, 2014.", "title": "A practical methodology for measuring the side-channel signal available to the attacker for instruction-level events", "context": [{"sec": "sec4c", "text": " Furthermore, we found that different m2m paths may sometime result in instruction sequences that are very similar to each other, even if they execute different parts of the program, and thus generate EM emissions that are also very similar to each other [22].", "part": "1"}], "links": {"documentLink": "/document/7011392", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7011392", "abstract": "This paper presents a new metric, which we call Signal Available to Attacker (SAVAT), that measures the side channel signal created by a specific single-instruction difference in program execution, i.e. The amount of signal made available to a potential attacker who wishes to decide whether the program has executed instruction/event A or instruction/event B. We also devise a practical methodology for measuring SAVAT in real systems using only user-level access permissions and common measurement ...", "pdfSize": "898KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+practical+methodology+for+measuring+the+side-channel+signal+available+to+the+attacker+for+instruction-level+events&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "A. Kleen, B. Strong, \"Intel processor trace on linux\", <em>Tracing Summit</em>, vol. 2015, 2015.", "title": "Intel processor trace on linux", "context": [{"sec": "sec6", "text": " Recent processor designs, such as Intel Processor Trace, can reduce this overhead to as little as 5% [23], but they require a sophisticated processor, still entail non-zero overhead, and consume considerable storage capacity and throughput.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Intel+processor+trace+on+linux&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "J. C. King, \"Symbolic Execution and Program Testing\", <em>Commun. ACM</em>, vol. 19, no. 7, pp. 385-394, Jul. 1976.", "title": "Symbolic Execution and Program Testing", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/360248.360252", "abstract": "This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may be symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and deb...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+Execution+and+Program+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "C. Cadar, V. Ganesh, P. M. Pawlowski, D. L. Dill, D. R. Engler, \"EXE: Automatically Generating Inputs of Death\", <em>ACM Trans. Inf. Syst. Secur.</em>, vol. 12, no. 2, pp. 10:1-10:38, Dec. 2008.", "title": "EXE: Automatically Generating Inputs of Death", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[32].", "part": "1"}, {"sec": "sec6", "text": " Guided path search heuristics select paths for exploration either randomly [18], [35] or based on the predicted likelihood of reaching a given coverage target [18], [25], [35].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1455518.1455522", "abstract": "This article presents EXE, an effective bug-finding tool that automatically generates inputs that crash real code. Instead of running code on manually or randomly constructed input, EXE runs it on symbolic input initially allowed to be anything. As checked code runs, EXE tracks the constraints on each symbolic (i.e., input-derived) memory location. If a statement uses a symbolic value, EXE does not run it, but instead adds it as an input-constraint; all other statements run as usual. If code con...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=EXE%3A+Automatically+Generating+Inputs+of+Death&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "C. Cadar, D. Engler, \"Execution Generated Test Cases: How to Make Systems Code Crash Itself\" in Model Checking Software ser. Lecture Notes in Computer Science, Berlin, Heidelberg:Springer, pp. 2-23, Aug. 2005.", "title": "Execution Generated Test Cases: How to Make Systems Code Crash Itself", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[26][32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/11537328_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Execution+Generated+Test+Cases%3A+How+to+Make+Systems+Code+Crash+Itself&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "P. Godefroid, N. Klarlund, K. Sen, \"DART: Directed Automated Random Testing\", <em>Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI '05</em>, pp. 213-223, 2005.", "title": "DART: Directed Automated Random Testing", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[27][32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1065010.1065036", "abstract": "We present a new tool, named DART, for automatically testing software that combines three main techniques: (1) automated extraction of the interface of a program with its external environment using static source-code parsing; (2) automatic generation of a test driver for this interface that performs random testing to simulate the most general environment the program can operate in; and (3) dynamic analysis of how the program behaves under random testing and automatic generation of new test input...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DART%3A+Directed+Automated+Random+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "P. Godefroid, M. Y. Levin, D. Molnar, \"SAGE: Whitebox Fuzzing for Security Testing\", <em>Queue</em>, vol. 10, no. 1, pp. 20:20-20:27, Jan. 2012.", "title": "SAGE: Whitebox Fuzzing for Security Testing", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[28][32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2090147.2094081", "abstract": "SAGE has had a remarkable impact at Microsoft.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SAGE%3A+Whitebox+Fuzzing+for+Security+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "K. Sen, D. Marinov, G. Agha, \"CUTE: A Concolic Unit Testing Engine for C\", <em>Proceedings of the 10th European Software Engineering Conference Held Jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. ESEC/FSE-13</em>, pp. 263-272, 2005.", "title": "CUTE: A Concolic Unit Testing Engine for C", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[29][32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=CUTE%3A+A+Concolic+Unit+Testing+Engine+for+C&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "N. Tillmann, J. de Halleux, \"Pex-White Box Test Generation for. NET\" in Tests and Proofs ser. Lecture Notes in Computer Science, Berlin, Heidelberg:Springer, pp. 134-153, Apr. 2008.", "title": "Pex-White Box Test Generation for. NET", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[30][32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-79124-9_10", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pex-White+Box+Test+Generation+for.+NET&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "H. Yoshida, S. Tokumoto, M. R. Prasad, I. Ghosh, T. Uehara, \"FSX: Fine-grained Incremental Unit Test Generation for C/C++ Programs\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis ser. ISSTA 2016</em>, pp. 106-117, 2016.", "title": "FSX: Fine-grained Incremental Unit Test Generation for C/C++ Programs", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[31][32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931055", "abstract": "Automated unit test generation bears the promise of significantly reducing test cost and hence improving software quality. However, the maintenance cost of the automatically generated tests presents a significant barrier to adoption of this technology. To address this challenge, we propose a novel technique for automated and fine-grained incremental generation of unit tests through minimal augmentation of an existing test suite. The technique uses iterative, incremental refinement of test-driver...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=FSX%3A+Fine-grained+Incremental+Unit+Test+Generation+for+C%2FC%2B%2B+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "G. Li, I. Ghosh, S. P. Rajan, \"KLOVER: A Symbolic Execution and Automatic Test Generation Tool for C++ Programs\" in Computer Aided Verification ser. Lecture Notes in Computer Science, Berlin, Heidelberg:Springer, pp. 609-615, Jul. 2011.", "title": "KLOVER: A Symbolic Execution and Automatic Test Generation Tool for C++ Programs", "context": [{"sec": "sec6", "text": "The key concepts of classical symbolic execution, as provided in [24], have been implemented for input generation in many prior tools [9], [18], [25]\u2013\u2013[32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-22110-1_49", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=KLOVER%3A+A+Symbolic+Execution+and+Automatic+Test+Generation+Tool+for+C%2B%2B+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "D. A. Ramos, D. R. Engler, \"Practical Low-Effort Equivalence Verification of Real Code\" in Computer Aided Verification., Berlin Heidelberg:Springer, pp. 669-685, Jul. 2011.", "title": "Practical, Low-Effort Equivalence Verification of Real Code", "context": [{"sec": "sec6", "text": "Our PSE technique is closely related to UC-KLEE [33], which performs under-constrained symbolic execution from an arbitrary function call.", "part": "1"}, {"sec": "sec6", "text": " UC-KLEE [33] uses a version of lazy initialization that models unconstrained pointers as either NULL or pointing to a new memory object.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-22110-1_55", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical%2C+Low-Effort+Equivalence+Verification+of+Real+Code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "D. Trabish, A. Mattavelli, N. Rinetzky, C. Cadar, \"Chopped Symbolic Execution\", <em>Proceedings of the 40th International Conference on Software Engineering ser. ICSE '18</em>, pp. 350-360, 2018.", "title": "Chopped Symbolic Execution", "context": [{"sec": "sec6", "text": "Chopped symbolic execution [34] shares with our work the goal of reaching code buried deep in the call graph, but takes an orthogonal approach; it employs program slicing to exclude uninteresting portions of the code from symbolic execution, while maintaining soundness.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180251", "abstract": "Symbolic execution is a powerful program analysis technique that systematically explores multiple program paths. However, despite important technical advances, symbolic execution often struggles to reach deep parts of the code due to the well-known path explosion problem and constraint solving limitations. In this paper, we propose chopped symbolic execution, a novel form of symbolic execution that allows users to specify uninter-esting parts of the code to exclude during the analysis, thus only...", "pdfSize": "224KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Chopped+Symbolic+Execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "J. Burnim, K. Sen, \"Heuristics for Scalable Dynamic Test Generation\", <em>Proceedings of the 2008 23rd IEEE/ACM International Conference on Automated Software Engineering ser. ASE '08</em>, pp. 443-446, 2008.", "title": "Heuristics for Scalable Dynamic Test Generation", "context": [{"sec": "sec6", "text": " Guided path search heuristics select paths for exploration either randomly [18], [35] or based on the predicted likelihood of reaching a given coverage target [18], [25], [35].", "part": "1"}], "links": {"documentLink": "/document/4639362", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4639362", "abstract": "Recently there has been great success in using symbolic execution to automatically generate test inputs for small software systems. A primary challenge in scaling such approaches to larger programs is the combinatorial explosion of the path space. It is likely that sophisticated strategies for searching this path space are needed to generate inputs that effectively test large programs (by, e.g., achieving significant branch coverage). We present several such heuristic search strategies, includin...", "pdfSize": "199KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Heuristics+for+Scalable+Dynamic+Test+Generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "P. Boonstoppel, C. Cadar, D. Engler, \"RWset: Attacking Path Explosion in Constraint-Based Test Generation\" in Tools and Algorithms for the Construction and Analysis of Systems ser. Lecture Notes in Computer Science, Berlin, Heidelberg:Springer, pp. 351-366, Mar. 2008.", "title": "RWset: Attacking Path Explosion in Constraint-Based Test Generation", "context": [{"sec": "sec6", "text": " Other approaches reduce the number of paths to search by removing equivalent paths [36], removing paths that cannot reach new code [37], or merging state on selected paths [38].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-78800-3_27", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=RWset%3A+Attacking+Path+Explosion+in+Constraint-Based+Test+Generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "S. Bugrara, D. Engler, \"Redundant State Detection for Dynamic Symbolic Execution\", <em>Proceedings of the 2013 USENIX Conference on Annual Technical Conference ser. USENIX ATC'13</em>, pp. 199-212, 2013.", "title": "Redundant State Detection for Dynamic Symbolic Execution", "context": [{"sec": "sec6", "text": " Other approaches reduce the number of paths to search by removing equivalent paths [36], removing paths that cannot reach new code [37], or merging state on selected paths [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Redundant+State+Detection+for+Dynamic+Symbolic+Execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "V. Kuznetsov, J. Kinder, S. Bucur, G. Candea, \"Efficient State Merging in Symbolic Execution\", <em>Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI '12</em>, pp. 193-204, 2012.", "title": "Efficient State Merging in Symbolic Execution", "context": [{"sec": "sec6", "text": " Other approaches reduce the number of paths to search by removing equivalent paths [36], removing paths that cannot reach new code [37], or merging state on selected paths [38].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254088", "abstract": "Symbolic execution has proven to be a practical technique for building automated test case generation and bug finding tools. Nevertheless, due to state explosion, these tools still struggle to achieve scalability. Given a program, one way to reduce the number of states that the tools need to explore is to merge states obtained on different paths. Alas, doing so increases the size of symbolic path conditions (thereby stressing the underlying constraint solver) and interferes with optimizations of...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+State+Merging+in+Symbolic+Execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "S. Anand, C. S. P\u0103s\u0103reanu, W. Visser, \"JPF-SE: A Symbolic Execution Extension to Java PathFinder\" in Tools and Algorithms for the Construction and Analysis of Systems ser. Lecture Notes in Computer Science, Berlin, Heidelberg:Springer, pp. 134-138, Mar. 2007.", "title": "JPF-SE: A Symbolic Execution Extension to Java PathFinder", "context": [{"sec": "sec6", "text": " Various tools have implemented lazy initialization for symbolic execution in Java (e.g., [9], [39], [40]\u2013), C/C++ (via LLVM IR [3]), and object code [41].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-71209-1_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=JPF-SE%3A+A+Symbolic+Execution+Extension+to+Java+PathFinder&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "W. Visser, C. S. P\u0103s\u0103reanu, S. Khurshid, \"Test Input Generation with Java PathFinder\", <em>Proceedings of the 2004 ACM SIGSOFT International Symposium on Software Testing and Analysis ser. ISSTA '04</em>, pp. 97-107, 2004.", "title": "Test Input Generation with Java PathFinder", "context": [{"sec": "sec6", "text": " Various tools have implemented lazy initialization for symbolic execution in Java (e.g., [9], [39], [40]\u2013), C/C++ (via LLVM IR [3]), and object code [41].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1007512.1007526", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+Input+Generation+with+Java+PathFinder&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "P. Godefroid, \"Micro Execution\", <em>Proceedings of the 36th International Conference on Software Engineering ser. ICSE 2014</em>, pp. 539-549, 2014.", "title": "Micro Execution", "context": [{"sec": "sec6", "text": " Various tools have implemented lazy initialization for symbolic execution in Java (e.g., [9], [39], [40]\u2013), C/C++ (via LLVM IR [3]), and object code [41].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568273", "abstract": "Micro execution is the ability to execute any code fragment without a user-provided test driver or input data. The user simply identifies a function or code location in an exe or dll. A runtime Virtual Machine (VM) customized for testing purposes then starts executing the code at that location, catches all memory operations before they occur, allocates memory on-the-fly in order to perform those read/write memory operations, and provides input values according to a customizable memory policy, wh...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Micro+Execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "N. Rosner, J. Geldenhuys, N. M. Aguirre, W. Visser, M. F. Frias, \"BLISS: Improved Symbolic Execution by Bounded Lazy Initialization with SAT Support\", <em>IEEE Transactions on Software Engineering</em>, vol. 41, no. 7, pp. 639-660, Jul. 2015.", "title": "BLISS: Improved Symbolic Execution by Bounded Lazy Initialization with SAT Support", "context": [{"sec": "sec6", "text": " Because this technique can inflict a significant performance penalty, researchers have proposed optimizations for Java-based symbolic execution [42]\u2013[44].", "part": "1"}], "links": {"documentLink": "/document/7004061", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7004061", "abstract": "Lazy Initialization (LI) allows symbolic execution to effectively deal with heap-allocated data structures, thanks to a significant reduction in spurious and redundant symbolic structures. Bounded lazy initialization (BLI) improves on LI by taking advantage of precomputed relational bounds on the interpretation of class fields in order to reduce the number of spurious structures even further. In this paper we present bounded lazy initialization with SAT support (BLISS), a novel technique that re...", "pdfSize": "1577KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=BLISS%3A+Improved+Symbolic+Execution+by+Bounded+Lazy+Initialization+with+SAT+Support&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "P. Braione, G. Denaro, M. Pezz\u00e8, \"Enhancing Symbolic Execution with Built-in Term Rewriting and Constrained Lazy Initialization\", <em>Proceedings of the 2013 9th Joint Meeting on Foundations of Software Engineering ser. ESEC/FSE 2013</em>, pp. 411-421, 2013.", "title": "Enhancing Symbolic Execution with Built-in Term Rewriting and Constrained Lazy Initialization", "context": [{"sec": "sec6", "text": " Because this technique can inflict a significant performance penalty, researchers have proposed optimizations for Java-based symbolic execution [42]\u2013[43][44].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491433", "abstract": "Symbolic execution suffers from problems when analyzing programs that handle complex data structures as their inputs and take decisions over non-linear expressions. For these programs, symbolic execution may incur invalid inputs or unidentified infeasible traces, and may raise large amounts of false alarms. Some symbolic executors tackle these problems by introducing executable preconditions to exclude invalid inputs, and some solvers exploit rewrite rules to address non linear problems. In this...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enhancing+Symbolic+Execution+with+Built-in+Term+Rewriting+and+Constrained+Lazy+Initialization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "X. Deng, J. Lee, Robby, \"Efficient and formal generalized symbolic execution\", <em>Automated Software Engineering</em>, vol. 19, no. 3, pp. 233-301, Sep. 2012.", "title": "Efficient and formal generalized symbolic execution", "context": [{"sec": "sec6", "text": " Because this technique can inflict a significant performance penalty, researchers have proposed optimizations for Java-based symbolic execution [42]\u2013[44].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-011-0089-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+and+formal+generalized+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "J. Balasch, B. Gierlichs, I. Verbauwhede, \"Electromagnetic circuit fingerprints for hardware trojan detection\", <em>2015 IEEE International Symposium on Electromagnetic Compatibility (EMC)</em>, pp. 246-251, Aug 2015.", "title": "Electromagnetic circuit fingerprints for hardware trojan detection", "context": [{"sec": "sec6", "text": " More recently, researchers have leveraged EM side channels for hardware Trojan detection [45], [46], malware detection [47], control flow integrity assessment [48], and software profiling [1], [49].", "part": "1"}], "links": {"documentLink": "/document/7256167", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7256167", "abstract": "Integrated circuit counterfeits, relabeled parts and maliciously modified integrated circuits (so-called Hardware Trojan horses) are a recognized emerging threat for embedded systems in safety or security critical applications. We propose a Hardware Trojan detection technique based on fingerprinting the electromagnetic emanations of integrated circuits. In contrast to most previous work, we do not evaluate our proposal using simulations but we rather conduct experiments with an FPGA. We investig...", "pdfSize": "1818KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Electromagnetic+circuit+fingerprints+for+hardware+trojan+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "O. s\u00f6ll, T. Korak, M. Muehlberghuber, M. Hutter, \"Em-based detection of hardware trojans on fpgas\", <em>2014 IEEE International Symposium on Hardware-Oriented Security and Trust (HOST)</em>, pp. 84-87, May 2014.", "title": "Em-based detection of hardware trojans on fpgas", "context": [{"sec": "sec6", "text": " More recently, researchers have leveraged EM side channels for hardware Trojan detection [45], [46], malware detection [47], control flow integrity assessment [48], and software profiling [1], [49].", "part": "1"}], "links": {"documentLink": "/document/6855574", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6855574", "abstract": "The detectability of malicious circuitry on FPGAs with varying placement properties yet has to be investigated. The authors utilize a Xilinx Virtex-II Pro target platform in order to insert a sequential denial-of-service Trojan into an existing AES design by manipulating a Xilinx-specific, intermediate file format prior to the bitstream generation. Thereby, there is no need for an attacker to acquire access to the hardware description language representation of a potential target architecture. U...", "pdfSize": "2092KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Em-based+detection+of+hardware+trojans+on+fpgas&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "A. Nazari, N. Sehatbakhsh, M. Alam, A. Zajic, M. Prvulovic, \"Eddie: Em-based detection of deviations in program execution\", <em>Proceedings of the 44th Annual International Symposium on Computer Architecture ser. ISCA '17</em>, pp. 333-346, 2017.", "title": "Eddie: Em-based detection of deviations in program execution", "context": [{"sec": "sec6", "text": " More recently, researchers have leveraged EM side channels for hardware Trojan detection [45], [46], malware detection [47], control flow integrity assessment [48], and software profiling [1], [49].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3079856.3080223", "abstract": "This paper describes EM-Based Detection of Deviations in Program Execution (EDDIE), a new method for detecting anomalies in program execution, such as malware and other code injections, without introducing any overheads, adding any hardware support, changing any software, or using any resources on the monitored system itself. Monitoring with EDDIE involves receiving electromagnetic (EM) emanations that are emitted as a side effect of execution on the monitored system, and it relies on spikes in ...", "pdfSize": "824KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eddie%3A+Em-based+detection+of+deviations+in+program+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "Y. Han, S. Etigowni, H. Liu, S. Zonouz, A. Petropulu, \"Watch me but don't touch me! contactless control flow monitoring via electromagnetic emanations\", <em>Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security ser. CCS '17</em>, pp. 1095-1108, 2017.", "title": "Watch me, but don't touch me! contactless control flow monitoring via electromagnetic emanations", "context": [{"sec": "sec6", "text": " More recently, researchers have leveraged EM side channels for hardware Trojan detection [45], [46], malware detection [47], control flow integrity assessment [48], and software profiling [1], [49].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3133956.3134081", "abstract": "Trustworthy operation of industrial control systems depends on secure and real-time code execution on the embedded programmable logic controllers (PLCs). The controllers monitor and control the critical infrastructures, such as electric power grids and healthcare platforms, and continuously report back the system status to human operators. We present Zeus, a contactless embedded controller security monitor to ensure its execution control flow integrity. Zeus leverages the electromagnetic emissio...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Watch+me%2C+but+don%27t+touch+me%21+contactless+control+flow+monitoring+via+electromagnetic+emanations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "N. Sehatbakhsh, A. Nazari, A. Zajic, M. Prvulovic, \"Spectral profiling: Observer-effect-free profiling by monitoring em emanations\", <em>Microarchitecture (MICRO) 2016 49th Annual IEEE/ACM International Symposium on.</em>, pp. 1-11, 2016.", "title": "Spectral profiling: Observer-effect-free profiling by monitoring em emanations", "context": [{"sec": "sec6", "text": " More recently, researchers have leveraged EM side channels for hardware Trojan detection [45], [46], malware detection [47], control flow integrity assessment [48], and software profiling [1], [49].", "part": "1"}], "links": {"documentLink": "/document/7783762", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7783762", "abstract": "This paper presents Spectral Profiling, a new method for profiling program execution without instrumenting or otherwise affecting the profiled system. Spectral Profiling monitors EM emanations unintentionally produced by the profiled system, looking for spectral \u201cspikes\u201d produced by periodic program activity (e.g. loops). This allows Spectral Profiling to determine which parts of the program have executed at what time. By analyzing the frequency and shape of the spectral \u201cspike\u201d, Spectral Profil...", "pdfSize": "1149KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Spectral+profiling%3A+Observer-effect-free+profiling+by+monitoring+em+emanations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812035", "articleId": "8812035", "startPage": "234", "endPage": "245", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 63}}
{"title": "Tool Choice Matters: JavaScript Quality Assurance Tools and Usage Outcomes in GitHub Projects", "authors": [{"name": "David Kavaler", "affiliation": "UC Davis", "firstName": "David", "lastName": "Kavaler", "id": "37086247366"}, {"name": "Asher Trockman", "affiliation": "University of Evansville", "firstName": "Asher", "lastName": "Trockman", "id": "37086461953"}, {"name": "Bogdan Vasilescu", "affiliation": "CMU", "firstName": "Bogdan", "lastName": "Vasilescu", "id": "38229105200"}, {"name": "Vladimir Filkov", "affiliation": "UC Davis", "firstName": "Vladimir", "lastName": "Filkov", "id": "37391520400"}], "abstract": "Quality assurance automation is essential in modern software development. In practice, this automation is supported by a multitude of tools that fit different needs and require developers to make decisions about which tool to choose in a given context. Data and analytics of the pros and cons can inform these decisions. Yet, in most cases, there is a dearth of empirical evidence on the effectiveness of existing practices and tool choices. We propose a general methodology to model the time-dependent effect of automation tool choice on four outcomes of interest: prevalence of issues, code churn, number of pull requests, and number of contributors, all with a multitude of controls. On a large data set of npm JavaScript projects, we extract the adoption events for popular tools in three task classes: linters, dependency managers, and coverage reporters. Using mixed methods approaches, we study the reasons for the adoptions and compare the adoption effects within each class, and sequential tool adoptions across classes. We find that some tools within each group are associated with more beneficial outcomes than others, providing an empirical perspective for the benefits of each. We also find that the order in which some tools are implemented is associated with varying outcomes.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Tools", "Task analysis", "Pipelines", "Quality assurance", "Automation", "Software", "Switches"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["decision making", "Internet", "Java", "program debugging", "program diagnostics", "program testing", "project management", "public domain software", "quality assurance", "software quality"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["adoption effects", "sequential tool adoptions", "beneficial outcomes", "varying outcomes", "tool choice matters", "JavaScript quality assurance tools", "GitHub projects", "quality assurance automation", "empirical evidence", "time-dependent effect", "automation tool choice", "data set", "npm JavaScript projects", "adoption events", "task classes", "dependency managers", "software development"]}, {"type": "Author Keywords ", "kwd": ["quality assurance tools", "empirical study"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00060", "ref": [{"order": "1", "text": "S. W. Richard, \"Organizations: Rational natural and open systems\", <em>Aufl. Englewood Cliffs (NJ)</em>, 1992.", "title": "Organizations: Rational, natural, and open systems", "context": [{"sec": "sec1", "text": "Organizational science, particularly contingency theory [1], predicts that no one solution will fit all [2], [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Organizations%3A+Rational%2C+natural%2C+and+open+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "T. E. Burns, G. M. Stalker, \"The management of innovation\", <em>University of Illinois at Urbana-Champaign\u2018s Academy for Entrepreneurial Leadership Historical Research Reference in Entrepreneurship</em>, 1961.", "title": "The management of innovation", "context": [{"sec": "sec1", "text": "Organizational science, particularly contingency theory [1], predicts that no one solution will fit all [2], [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+management+of+innovation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "J. Woodward, Industrial organization: theory and practice, Oxford University Press, 1965.", "title": "Industrial organization: theory and practice", "context": [{"sec": "sec1", "text": "Organizational science, particularly contingency theory [1], predicts that no one solution will fit all [2], [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Industrial+organization%3A+theory+and+practice&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "Q. Wiki, \"Are there any companies focused on doing devops consulting?\", <em>Are- there- any- companies-focused-on-doing-DevOps-consulting</em>, Jul. 2017,  [online]  Available: https://www.quora.com/.", "title": "Are there any companies focused on doing devops consulting?", "context": [{"sec": "sec1", "text": " Unsurprisingly, general advice on which tools are \u201cbest\u201d is rare and industrial consultants are therefore busy offering DevOps customizations [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+there+any+companies+focused+on+doing+devops+consulting%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "G. Gousios, A. Zaidman, M.-A. Storey, A. Van Deursen, \"Work practices and challenges in pull-based development: the integrator's perspective\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 358-368, 2015.", "title": "Work practices and challenges in pull-based development: the integrator's perspective", "context": [{"sec": "sec2a", "text": "CI is a widely-used practice [5], by which all work is \u201ccontinuously\u201d compiled, built, and tested; multiple CI tools exist [6].", "part": "1"}], "links": {"documentLink": "/document/7675420", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7675420", "abstract": "In the pull-based development model, the integrator has the crucial role of managing and integrating contributions. This work focuses on the role of the integrator and investigates working habits and challenges alike. We set up an exploratory qualitative study involving a large-scale survey of 749 integrators, to which we add quantitative data from the integrator&#39;s project. Our results provide insights into the factors they consider in their decision making process to accept or reject a contribu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Work+practices+and+challenges+in+pull-based+development%3A+the+integrator%27s+perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "M. Meyer, \"Continuous integration and its tools\", <em>IEEE Software</em>, vol. 31, no. 3, pp. 14-16, 2014.", "title": "Continuous integration and its tools", "context": [{"sec": "sec2a", "text": "CI is a widely-used practice [5], by which all work is \u201ccontinuously\u201d compiled, built, and tested; multiple CI tools exist [6].", "part": "1"}], "links": {"documentLink": "/document/6802994", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6802994", "abstract": "Continuous integration has been around for a while now, but the habits it suggests are far from common practice. Automated builds, a thorough test suite, and committing to the mainline branch every day sound simple at first, but they require a responsible team to implement and constant care. What starts with improved tooling can be a catalyst for long-lasting change in your company&#39;s shipping culture. Continuous integration is more than a set of practices, it&#39;s a mindset that has one thing in mi...", "pdfSize": "1664KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+integration+and+its+tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "B. Vasilescu, Y. Yu, H. Wang, P. Devanbu, V. Filkov, \"Quality and productivity outcomes relating to continuous integration in GitHub\", <em>Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 805-816, 2015.", "title": "Quality and productivity outcomes relating to continuous integration in GitHub", "context": [{"sec": "sec2a", "text": " The effect of CI adoption on measures of project success has been studied, with prior work finding beneficial overall effects [7].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786850", "abstract": "Software processes comprise many steps; coding is followed by building, integration testing, system testing, deployment, operations, among others. Software process integration and automation have been areas of key concern in software engineering, ever since the pioneering work of Osterweil; market pressures for Agility, and open, decentralized, software development have provided additional pressures for progress in this area. But do these innovations actually help projects? Given the numerous co...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quality+and+productivity+outcomes+relating+to+continuous+integration+in+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "M. Hilton, N. Nelson, T. Tunnell, D. Marinov, D. Dig, \"Trade-offs in continuous integration: assurance security and flexibility\", <em>Joint Meeting on Foundations of Software Engineering (ESECIFSE)</em>, pp. 197-207, 2017.", "title": "Trade-offs in continuous integration: assurance, security, and flexibility", "context": [{"sec": "sec2a", "text": "Hilton et al. describe multiple issues that developers experience when configuring and using CI [8], including lack of support for a desired workflow and lack of tool integration: developers want powerful and highly configurable systems, yet simple and easy to use.", "part": "1"}, {"sec": "sec3", "text": " However, given the complexity of tool configuration [8], [10], [55] in general and the requirement of keeping configurations up-to-date [12], developers may need to change between tools within a given task class over time.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106270", "abstract": "Continuous integration (CI) systems automate the compilation, building, and testing of software. Despite CI being a widely used activity in software engineering, we do not know what motivates developers to use CI, and what barriers and unmet needs they face. Without such knowledge, developers make easily avoidable errors, tool builders invest in the wrong direction, and researchers miss opportunities for improving the practice of CI. We present a qualitative study of the barriers and needs devel...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Trade-offs+in+continuous+integration%3A+assurance%2C+security%2C+and+flexibility&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "T. Xu, Y. Zhou, \"Systems approaches to tackling configuration errors: A survey\", <em>ACM Computing Surveys (CSUR)</em>, vol. 47, no. 4, pp. 70, 2015.", "title": "Systems approaches to tackling configuration errors: A survey", "context": [{"sec": "sec2a", "text": " However, Xu and Zhou [9] find that over-configurable systems hinder usability.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2791577", "abstract": "In recent years, configuration errors (i.e., misconfigurations) have become one of the dominant causes of system failures, resulting in many severe service outages and downtime. Unfortunately, it is notoriously difficult for system users (e.g., administrators and operators) to prevent, detect, and troubleshoot configuration errors due to the complexity of the configurations as well as the systems under configuration. As a result, the cost of resolving configuration errors is often tremendous fro...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Systems+approaches+to+tackling+configuration+errors%3A+A+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "T. Xu, L. Jin, X. Fan, Y. Zhou, S. Pasupathy, R. Talwadker, \"Hey you have given me too many knobs!: Understanding and dealing with over-designed configuration in system software\", <em>Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 307-319, 2015.", "title": "Hey, you have given me too many knobs!: Understanding and dealing with over-designed configuration in system software", "context": [{"sec": "sec2a", "text": " It has also been shown that developers often don't use the vast majority of configuration options available to them [10].", "part": "1"}, {"sec": "sec3", "text": " However, given the complexity of tool configuration [8], [10], [55] in general and the requirement of keeping configurations up-to-date [12], developers may need to change between tools within a given task class over time.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786852", "abstract": "Configuration problems are not only prevalent, but also severely impair the reliability of today&#39;s system software. One fundamental reason is the ever-increasing complexity of configuration, reflected by the large number of configuration parameters (&#34;knobs&#34;). With hundreds of knobs, configuring system software to ensure high reliability and performance becomes a daunting, error-prone task. This paper makes a first step in understanding a fundamental question of configuration design: &#34;do users re...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hey%2C+you+have+given+me+too+many+knobs%21%3A+Understanding+and+dealing+with+over-designed+configuration+in+system+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "M. Sayagh, N. Kerzazi, B. Adams, \"On cross-stack configuration errors\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 255-265, 2017.", "title": "On cross-stack configuration errors", "context": [{"sec": "sec2a", "text": " Misconfigurations have been called \u201cthe most urgent but thorny problems in software reliability\u201d [11].", "part": "1"}], "links": {"documentLink": "/document/7985667", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985667", "abstract": "Today&#39;s web applications are deployed on powerful software stacks such as MEAN (JavaScript) or LAMP (PHP), which consist of multiple layers such as an operating system, web server, database, execution engine and application framework, each of which provide resources to the layer just above it. These powerful software stacks unfortunately are plagued by so-called cross-stack configuration errors (CsCEs), where a higher layer in the stack suddenly starts to behave incorrectly or even crash due to ...", "pdfSize": "876KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+cross-stack+configuration+errors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "S. Zhang, M. D. Ernst, \"Which configuration option should I change?\", <em>Proc. International Conference on Software Engineering (ICSE)</em>, pp. 152-163, 2014.", "title": "Which configuration option should I change?", "context": [{"sec": "sec2a", "text": " In addition, configuration requirements can change over time as older setups become obsolete, or must be changed due to, e.g., dependency upgrades [12].", "part": "1"}, {"sec": "sec3", "text": " However, given the complexity of tool configuration [8], [10], [55] in general and the requirement of keeping configurations up-to-date [12], developers may need to change between tools within a given task class over time.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568251", "abstract": "Modern software often exposes configuration options that enable users to customize its behavior. During software evolution, developers may change how the configuration options behave. When upgrading to a new software version, users may need to re-configure the software by changing the values of certain configuration options.   This paper addresses the following question during the evolution of a configurable software system: which configuration options should a user change to maintain the softwa...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Which+configuration+option+should+I+change%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "M. Morisio, C. B. Seaman, A. T. Parra, V. R. Basili, S. E. Kraft, S. E. Condon, \"Investigating and improving a COTS-based software development process\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 32-41, 2000.", "title": "Investigating and improving a COTS-based software development process", "context": [{"sec": "sec2a", "text": "The integration cost for off-the-shelf tools has been long-studied in computer science [13]\u2013[17].", "part": "1"}, {"sec": "sec3", "text": " Prior work has shown that there are costs when integrating pre-built tools in general [13]\u2013[17], but the empirical evidence for differential costs within task classes is lacking, especially in the choice-laden GitHub open-source setting.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/337180.337186", "abstract": "The work described in the paper is an investigation of COTS based software development within a particular NASA environment, with an emphasis on the processes used. Fifteen projects using a COTS based approach were studied and their actual process was documented. This process is evaluated to identify essential differences in comparison to traditional software development. The main differences, and the activities for which projects require more guidance, are requirements definition and COTS selec...", "pdfSize": "967KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Investigating+and+improving+a+COTS-based+software+development+process&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "C. Abts, B. W. Boehm, E. B. Clark, \"COCOTS: A COTS software integration lifecycle cost model-model overview and preliminary data collection findings\", <em>ESCOM-SCOPE Conference</em>, pp. 18-20, 2000.", "title": "COCOTS: A COTS software integration lifecycle cost model-model overview and preliminary data collection findings", "context": [{"sec": "sec2a", "text": "The integration cost for off-the-shelf tools has been long-studied in computer science [13]\u2013[14][17].", "part": "1"}, {"sec": "sec3", "text": " Prior work has shown that there are costs when integrating pre-built tools in general [13]\u2013[14][17], but the empirical evidence for differential costs within task classes is lacking, especially in the choice-laden GitHub open-source setting.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=COCOTS%3A+A+COTS+software+integration+lifecycle+cost+model-model+overview+and+preliminary+data+collection+findings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "B. Boehm, B. Clark, E. Horowitz, C. Westland, R. Madachy, R. Selby, \"Cost models for future software life cycle processes: CO-COMO 2.0\", <em>Annals of software engineering</em>, vol. 1, no. 1, pp. 57-94, 1995.", "title": "Cost models for future software life cycle processes: CO-COMO 2.0", "context": [{"sec": "sec2a", "text": "The integration cost for off-the-shelf tools has been long-studied in computer science [13]\u2013[15][17].", "part": "1"}, {"sec": "sec3", "text": " Prior work has shown that there are costs when integrating pre-built tools in general [13]\u2013[15][17], but the empirical evidence for differential costs within task classes is lacking, especially in the choice-laden GitHub open-source setting.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF02249046", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cost+models+for+future+software+life+cycle+processes%3A+CO-COMO+2.0&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "M. Morisio, C. B. Seaman, V. R. Basili, A. T. Parra, S. E. Kraft, S. E. Condon, \"COTS-based software development: Processes and open issues\", <em>Journal of Systems and Software</em>, vol. 61, no. 3, pp. 189-199, 2002.", "title": "COTS-based software development: Processes and open issues", "context": [{"sec": "sec2a", "text": "The integration cost for off-the-shelf tools has been long-studied in computer science [13]\u2013[16][17].", "part": "1"}, {"sec": "sec3", "text": " Prior work has shown that there are costs when integrating pre-built tools in general [13]\u2013[16][17], but the empirical evidence for differential costs within task classes is lacking, especially in the choice-laden GitHub open-source setting.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0164-1212(01)00147-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=COTS-based+software+development%3A+Processes+and+open+issues&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "D. Yakimovich, J. M. Bieman, V. R. Basili, \"Software architecture classification for estimating the cost of COTS integration\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 296-302, 1999.", "title": "Software architecture classification for estimating the cost of COTS integration", "context": [{"sec": "sec2a", "text": "The integration cost for off-the-shelf tools has been long-studied in computer science [13]\u2013[17].", "part": "1"}, {"sec": "sec3", "text": " Prior work has shown that there are costs when integrating pre-built tools in general [13]\u2013[17], but the empirical evidence for differential costs within task classes is lacking, especially in the choice-laden GitHub open-source setting.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/302405.302643", "abstract": "The use of commercial-off-the-shelf (COTS) products creates a software integration problem, whether a single COTS software component is being integrated into a software system, or the whole system is being built primarily from COTS products. This integration may require considerable effort and affect system quality. A good estimate of integration cost can help in the decision of whether or not to use a COTS solution, the selection of the best COTS products, and determine the amount and type of g...", "pdfSize": "722KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+architecture+classification+for+estimating+the+cost+of+COTS+integration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "J. Hartikainen, \"A comparison of javascript linting tools\", Mar. 2015,  [online]  Available: https://www.sitepoint.com/comparison-javascript-linting-tools/.", "title": "A comparison of javascript linting tools", "context": [{"sec": "sec2b", "text": " E.g., a web search for JavaScript linters turns up many blog posts discussing options and pros and cons [18], [19].", "part": "1"}, {"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+comparison+of+javascript+linting+tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "D. Sternlicht, \"Thoughts about JavaScript linters and \u201clint driven development\u201d\", Aug. 2017,  [online]  Available: https://medium.com/@danielsternlicht/thoughts-about-javascript-linters-and-lint-driven-development-7c8f17e7e1a0.", "title": "Thoughts about JavaScript linters and \u201clint driven development\u201d", "context": [{"sec": "sec2b", "text": " E.g., a web search for JavaScript linters turns up many blog posts discussing options and pros and cons [18], [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Thoughts+about+JavaScript+linters+and+%E2%80%9Clint+driven+development%E2%80%9D&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "K. F. T\u00f3masd\u00f3ttir, M. Aniche, A. v. Deursen, \"Why and how JavaScript developers use linters\", <em>International Conference on Automated Software Engineering (ASE)</em>, pp. 578-589, 2017.", "title": "Why and how JavaScript developers use linters", "context": [{"sec": "sec2b", "text": " Specifically, we investigate three task classes commonly-studied in prior work (e.g., [20]\u2013[22])and commonly-used in the JavaScript community: linters, dependency managers, and code coverage tools.", "part": "1"}, {"sec": "sec3", "text": " Prior work has reported that JavaScript developers use linters primarily to prevent errors [20].", "part": "1"}], "links": {"documentLink": "/document/8115668", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115668", "abstract": "Automatic static analysis tools help developers to automatically spot code issues in their software. They can be of extreme value in languages with dynamic characteristics, such as JavaScript, where developers can easily introduce mistakes which can go unnoticed for a long time, e.g. a simple syntactic or spelling mistake. Although research has already shown how developers perceive such tools for strongly-typed languages such as Java, little is known about their perceptions when it comes to dyna...", "pdfSize": "169KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+and+how+JavaScript+developers+use+linters&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "S. Mirhosseini, C. Parnin, \"Can automated pull requests encourage software developers to upgrade out-of-date dependencies?\", <em>International Conference on Automated Software Engineering (ASE)</em>, pp. 84-94, 2017.", "title": "Can automated pull requests encourage software developers to upgrade out-of-date dependencies?", "context": [{"sec": "sec2b", "text": " Specifically, we investigate three task classes commonly-studied in prior work (e.g., [20]\u2013[21][22])and commonly-used in the JavaScript community: linters, dependency managers, and code coverage tools.", "part": "1"}, {"sec": "sec2b", "text": " Dependency management is a popular research topic [47]\u2013[50]. david, gemnasium, and snyk are examples of such tools that require manual intervention; their results are often displayed as badges [21], [51] on a project's README file.", "part": "1"}, {"sec": "sec3", "text": " Prior work [21] found that dependency management is (according to one developer)\u201cone of the most significantly painful problems with development\u201d.", "part": "1"}], "links": {"documentLink": "/document/8115621", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115621", "abstract": "Developers neglect to update legacy software dependencies, resulting in buggy and insecure software. One explanation for this neglect is the difficulty of constantly checking for the availability of new software updates, verifying their safety, and addressing any migration efforts needed when upgrading a dependency. Emerging tools attempt to address this problem by introducing automated pull requests and project badges to inform the developer of stale dependencies. To understand whether these to...", "pdfSize": "416KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Can+automated+pull+requests+encourage+software+developers+to+upgrade+out-of-date+dependencies%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Q. Yang, J. J. Li, D. M. Weiss, \"A survey of coverage-based testing tools\", <em>The Computer Journal</em>, vol. 52, no. 5, pp. 589-597, 2009.", "title": "A survey of coverage-based testing tools", "context": [{"sec": "sec2b", "text": " Specifically, we investigate three task classes commonly-studied in prior work (e.g., [20]\u2013[22])and commonly-used in the JavaScript community: linters, dependency managers, and code coverage tools.", "part": "1"}], "links": {"documentLink": "/document/8130777", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8130777", "abstract": "Test coverage is sometimes used to measure how thoroughly software is tested and developers and vendors sometimes use it to indicate their confidence in the readiness of their software. This survey studies and compares 17 coverage-based testing tools primarily focusing on, but not restricted to, coverage measurement. We also survey features such as program prioritization for testing, assistance in debugging, automatic generation of test cases and customization of test reports. Such features make...", "pdfSize": "110KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+of+coverage-based+testing+tools&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "M. Beller, R. Bholanath, S. McIntosh, A. Zaidman, \"Analyzing the state of static analysis: A large-scale evaluation in open source software\", <em>International Conference on Software Analysis Evolution and Reengineering (SANER)</em>, vol. 1, pp. 470-481, 2016.", "title": "Analyzing the state of static analysis: A large-scale evaluation in open source software", "context": [{"sec": "sec2b", "text": " There has been interest in the application of such static analysis tools in open-source projects [23] and CI pipelines [24].", "part": "1"}], "links": {"documentLink": "/document/7476667", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7476667", "abstract": "The use of automatic static analysis has been a software engineering best practice for decades. However, we still do not know a lot about its use in real-world software projects: How prevalent is the use of Automated Static Analysis Tools (ASATs) such as FindBugs and JSHint? How do developers use these tools, and how does their use evolve over time? We research these questions in two studies on nine different ASATs for Java, JavaScript, Ruby, and Python with a population of 122 and 168,214 open-...", "pdfSize": "762KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analyzing+the+state+of+static+analysis%3A+A+large-scale+evaluation+in+open+source+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "F. Zampetti, S. Scalabrino, R. Oliveto, G. Canfora, M. Di Penta, \"How open source projects use static code analysis tools in continuous integration pipelines\", <em>International Conference on Mining Software Repositories (MSR)</em>, pp. 334-344, 2017.", "title": "How open source projects use static code analysis tools in continuous integration pipelines", "context": [{"sec": "sec2b", "text": " There has been interest in the application of such static analysis tools in open-source projects [23] and CI pipelines [24].", "part": "1"}], "links": {"documentLink": "/document/7962383", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7962383", "abstract": "Static analysis tools are often used by software developers to entail early detection of potential faults, vulnerabilities, code smells, or to assess the source code adherence to coding standards and guidelines. Also, their adoption within Continuous Integration (CI) pipelines has been advocated by researchers and practitioners. This paper studies the usage of static analysis tools in 20 Java open source projects hosted on GitHub and using Travis CI as continuous integration infrastructure. Spec...", "pdfSize": "229KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+open+source+projects+use+static+code+analysis+tools+in+continuous+integration+pipelines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "\"Fixed accidentally global \u2018browserlist var\", <em>papandreou</em>, January 2015,  [online]  Available: https//github.com/browserslist/browserslist/pull/7.", "title": "Fixed accidentally global \u2018browserlist var", "context": [{"sec": "sec2b", "text": " Qualitative analysis of 32 issue threads discussing linters suggests that project maintainers and contributors are concerned with specific features (16 discussions)and ease of installation (15), with some recommending specific linters based on personal preferences or popularity, favoring those that they have used before without much justification (8), e.g., [25]\u2013[27].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fixed+accidentally+global+%E2%80%98browserlist+var&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "\"add a more strict linter\", March 2015,  [online]  Available: https://github.com/janl/mustache.js/issues/433.", "title": "add a more strict linter", "context": [{"sec": "sec2b", "text": " Qualitative analysis of 32 issue threads discussing linters suggests that project maintainers and contributors are concerned with specific features (16 discussions)and ease of installation (15), with some recommending specific linters based on personal preferences or popularity, favoring those that they have used before without much justification (8), e.g., [25]\u2013[26][27].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=add+a+more+strict+linter&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "\"Feature: choose between eslint + airbnb and jshint?\", <em>jack guy</em>, April 2016,  [online]  Available: https://github.com/feathersjs/generator-feathers/issues/112.", "title": "Feature: choose between eslint + airbnb and jshint?", "context": [{"sec": "sec2b", "text": " Qualitative analysis of 32 issue threads discussing linters suggests that project maintainers and contributors are concerned with specific features (16 discussions)and ease of installation (15), with some recommending specific linters based on personal preferences or popularity, favoring those that they have used before without much justification (8), e.g., [25]\u2013[27].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature%3A+choose+between+eslint+%2B+airbnb+and+jshint%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "\"Add mocha to mocha environment\", <em>valorkin</em>, January 2015,  [online]  Available: https://github.com/sindresorhus/globals/issues/34.", "title": "Add mocha to mocha environment", "context": [{"sec": "sec2b", "text": "ESLint's high configurability makes it a common choice (9 discussions [28]\u2013[33]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Add+mocha+to+mocha+environment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "\"added all globals for full jshint compatibility\", January 2015,  [online]  Available: https://github.com/sindresorhus/globals/pull/17.", "title": "added all globals for full jshint compatibility", "context": [{"sec": "sec2b", "text": "ESLint's high configurability makes it a common choice (9 discussions [28]\u2013[29][33]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=added+all+globals+for+full+jshint+compatibility&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "\"Easy require\", <em>jasonkarns</em>, May 2015,  [online]  Available: https://github.com/sindresorhus/jshint-stylish/pull/20.", "title": "Easy require", "context": [{"sec": "sec2b", "text": "ESLint's high configurability makes it a common choice (9 discussions [28]\u2013[30][33]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Easy+require&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "\"Configure hound to lint with jscs\", <em>seanpdoyle</em>, November 2015,  [online]  Available: https://github.com/ember-cli/ember-cli/issues/5106.", "title": "Configure hound to lint with jscs", "context": [{"sec": "sec2b", "text": "ESLint's high configurability makes it a common choice (9 discussions [28]\u2013[31][33]).", "part": "1"}, {"sec": "sec2b", "text": " Ten projects switched to ESLint or JSHint after using older linters which lack this functionality; in fact, four view ESLint as a combination of older linters [31], [34]\u2013[36].", "part": "1"}, {"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Configure+hound+to+lint+with+jscs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "\"Consider switching to coveralls\", <em>jamesplease</em>, September 2016,  [online]  Available: https://github.com/babel/generator-babel-boilerplate/issues/409.", "title": "Consider switching to coveralls", "context": [{"sec": "sec2b", "text": "ESLint's high configurability makes it a common choice (9 discussions [28]\u2013[32][33]).", "part": "1"}, {"sec": "sec2b", "text": "Out of ten issue discussions about coverage tools, in four developers talked about not wanting to spend too much time on configuration [32], [40], [40], [41].", "part": "1"}, {"sec": "sec2b", "text": " One developer states that the sole purpose of such a tool is to get the coverage badge, i.e., to signal that the project cares about test coverage [32].", "part": "1"}, {"sec": "sec2b", "text": " It seems developers want to invest minimal effort in coverage services, but seem unaware that some services require more overhead than others: \u201ca yml config file seems silly when all that you want is coverage,\u201d states a developer [32].", "part": "1"}, {"sec": "sec2b", "text": "coveralls and codecov are considered very focused services, generally providing, as per the issue discussions, only coverage [32], [40], [44], [45], without additional features.", "part": "1"}, {"sec": "sec2b", "text": " Two developers claim that coveralls is unreliable [45], [46], inspiring a switch to codecov, which is said to have a better user experience [45]. codeclimate provides other services besides coverage, e.g., linting, and developers may be confused by its high configurability [32], [45]: \u201cCodeClimate isn't sure if it wants to be a CI or not,\u201d states a developer [32].", "part": "1"}, {"sec": "sec5a", "text": " This may be due to a prevalence of a \u201cset it and forget it\u201d mentality; developers wish to use a tool and not have to deal with the additional configuration work of changing that tool [32], [40].", "part": "1"}, {"sec": "sec5a", "text": " This switch may be due to the stated confusion regarding the wide array of varying features that codeclimate provides [32], [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Consider+switching+to+coveralls&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "\"Lint source code\", <em>cscott</em>, January 2016,  [online]  Available: https://github.com/CSSLintiparser-lib/pull/179.", "title": "Lint source code", "context": [{"sec": "sec2b", "text": "ESLint's high configurability makes it a common choice (9 discussions [28]\u2013[33]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lint+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "\"Stop using jscs\", <em>magawac</em>, April 2016,  [online]  Available: https://github.com/caolan/async/issues/1111.", "title": "Stop using jscs", "context": [{"sec": "sec2b", "text": " Ten projects switched to ESLint or JSHint after using older linters which lack this functionality; in fact, four view ESLint as a combination of older linters [31], [34]\u2013[36].", "part": "1"}, {"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Stop+using+jscs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "\"Csslint + stylelint\", July 2016,  [online]  Available: https://github.com/CSSLint/csslint/issues/668.", "title": "Csslint + stylelint", "context": [{"sec": "sec2b", "text": " Ten projects switched to ESLint or JSHint after using older linters which lack this functionality; in fact, four view ESLint as a combination of older linters [31], [34]\u2013[35][36].", "part": "1"}, {"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[35][36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Csslint+%2B+stylelint&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "\"Update link to. jscrc file\", <em>Herst</em>, June 2016,  [online]  Available: https://github.com/Mottie/tablesorter/issues/1227.", "title": "Update link to. jscrc file", "context": [{"sec": "sec2b", "text": " Ten projects switched to ESLint or JSHint after using older linters which lack this functionality; in fact, four view ESLint as a combination of older linters [31], [34]\u2013[36].", "part": "1"}, {"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Update+link+to.+jscrc+file&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "\"Switch to ESlint (what kind of tooling should we use for linters)\", <em>martijnrusschen</em>, February 2016,  [online]  Available: https://github.com/Hacker0x01/react-datepicker/issues/367.", "title": "Switch to ESlint (what kind of tooling should we use for linters)", "context": [{"sec": "sec2b", "text": " This makes the project harder to maintain and hinders approachability\u201d [37].", "part": "1"}, {"sec": "sec5b1", "text": " It is interesting to note that this potential overhead is referred to by one developer in our qualitative analysis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Switch+to+ESlint+%28what+kind+of+tooling+should+we+use+for+linters%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "\"Add eslint config for standard to project\", <em>rtablada</em>, July 2016,  [online]  Available: https://github.com/poppinss/adonis-fold/pull/4.", "title": "Add eslint config for standard to project", "context": [{"sec": "sec2b", "text": " One developer notes it may be more convenient for contributors, who are more likely to be familiar with the \u201cstandard\u201d style [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Add+eslint+config+for+standard+to+project&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "\"Use standard.js for code formatting\", <em>emmby</em>, June 2016,  [online]  Available: https://github.com/futurice/pepperoni-app-kit/issues/50.", "title": "Use standard.js for code formatting", "context": [{"sec": "sec2b", "text": " However, another developer finds it less appealing as they \u201csimply don't agree with those default settings\u201d [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Use+standard.js+for+code+formatting&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "\"feat(travis): add codeclimate integration\", <em>henrjk</em>, October 2015,  [online]  Available: https://github.com/anvilresearch/connect/pull/275.", "title": "feat(travis): add codeclimate integration", "context": [{"sec": "sec2b", "text": "Out of ten issue discussions about coverage tools, in four developers talked about not wanting to spend too much time on configuration [32], [40], [40], [41].", "part": "1"}, {"sec": "sec2b", "text": "coveralls and codecov are considered very focused services, generally providing, as per the issue discussions, only coverage [32], [40], [44], [45], without additional features.", "part": "1"}, {"sec": "sec5a", "text": " This may be due to a prevalence of a \u201cset it and forget it\u201d mentality; developers wish to use a tool and not have to deal with the additional configuration work of changing that tool [32], [40].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=feat%28travis%29%3A+add+codeclimate+integration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "\"Use standard.js for code formatting\", <em>emmby</em>, June 2016,  [online]  Available: https://github.com/futurice/pepperoni-app-kit/issues/50.", "title": "Use standard.js for code formatting", "context": [{"sec": "sec2b", "text": "Out of ten issue discussions about coverage tools, in four developers talked about not wanting to spend too much time on configuration [32], [40], [40], [41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Use+standard.js+for+code+formatting&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "\"Add code coverage statistics\", <em>KrysKruk</em>, April 2016,  [online]  Available: https://github.com/Neft-io/neft/issues/31.", "title": "Add code coverage statistics", "context": [{"sec": "sec2b", "text": " As expected, two developers state that they use a certain coverage tool simply because they are more familiar with it [42], [43].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Add+code+coverage+statistics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "\"Refactorized websocket api\", <em>yagpo</em>, December 2015,  [online]  Available: https://github.com/bitfinexcom/bitfinex-api-node/pull/6.", "title": "Refactorized websocket api", "context": [{"sec": "sec2b", "text": " As expected, two developers state that they use a certain coverage tool simply because they are more familiar with it [42], [43].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Refactorized+websocket+api&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "\"Breaking change rfc: Remove codecov.io support\", <em>isaacs</em>, June 2016,  [online]  Available: https://github.com/tapjs/node-tap/issues/270.", "title": "Breaking change rfc: Remove codecov.io support", "context": [{"sec": "sec2b", "text": "coveralls and codecov are considered very focused services, generally providing, as per the issue discussions, only coverage [32], [40], [44], [45], without additional features.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Breaking+change+rfc%3A+Remove+codecov.io+support&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "\"code coverage in ci\", <em>boneskull</em>, July 2016,  [online]  Available: https://github.com/mochajs/mocha/issues/2351.", "title": "code coverage in ci", "context": [{"sec": "sec2b", "text": "coveralls and codecov are considered very focused services, generally providing, as per the issue discussions, only coverage [32], [40], [44], [45], without additional features.", "part": "1"}, {"sec": "sec2b", "text": " Two developers claim that coveralls is unreliable [45], [46], inspiring a switch to codecov, which is said to have a better user experience [45]. codeclimate provides other services besides coverage, e.g., linting, and developers may be confused by its high configurability [32], [45]: \u201cCodeClimate isn't sure if it wants to be a CI or not,\u201d states a developer [32].", "part": "1"}, {"sec": "sec5a", "text": " However, some online discussions [81]\u2013[83] and issue discussions [45], [46] suggest that project communities may be starting to favor codecov due to its superset of features and its direct integration with GitHub, BitBucket, and other git-related services, and due to its better support.", "part": "1"}, {"sec": "sec5a", "text": " This switch may be due to the stated confusion regarding the wide array of varying features that codeclimate provides [32], [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=code+coverage+in+ci&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "\"Integrate codecov.io\", <em>ariya</em>, June 2015,  [online]  Available: https://github.com/jquery/esprima/issues/1215.", "title": "Integrate codecov.io", "context": [{"sec": "sec2b", "text": " Two developers claim that coveralls is unreliable [45], [46], inspiring a switch to codecov, which is said to have a better user experience [45]. codeclimate provides other services besides coverage, e.g., linting, and developers may be confused by its high configurability [32], [45]: \u201cCodeClimate isn't sure if it wants to be a CI or not,\u201d states a developer [32].", "part": "1"}, {"sec": "sec5a", "text": " However, some online discussions [81]\u2013[83] and issue discussions [45], [46] suggest that project communities may be starting to favor codecov due to its superset of features and its direct integration with GitHub, BitBucket, and other git-related services, and due to its better support.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Integrate+codecov.io&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "G. Bavota, G. Canfora, M. Di Penta, R. Oliveto, S. Panichella, \"How the apache community upgrades dependencies: an evolutionary study\", <em>Empirical Software Engineering</em>, vol. 20, no. 5, pp. 1275-1317, 2015.", "title": "How the apache community upgrades dependencies: an evolutionary study", "context": [{"sec": "sec2b", "text": " Dependency management is a popular research topic [47]\u2013[50]. david, gemnasium, and snyk are examples of such tools that require manual intervention; their results are often displayed as badges [21], [51] on a project's README file.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-014-9325-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+the+apache+community+upgrades+dependencies%3A+an+evolutionary+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "J. Cox, E. Bouwers, M. van Eekelen, J. Visser, \"Measuring dependency freshness in software systems\", <em>International Conference on Software Engineering (ICSE)</em>, pp. 109-118, 2015.", "title": "Measuring dependency freshness in software systems", "context": [{"sec": "sec2b", "text": " Dependency management is a popular research topic [47]\u2013[48][50]. david, gemnasium, and snyk are examples of such tools that require manual intervention; their results are often displayed as badges [21], [51] on a project's README file.", "part": "1"}], "links": {"documentLink": "/document/7202955", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7202955", "abstract": "Modern software systems often make use of third-party components to speed-up development and reduce maintenance costs. In return, developers need to update to new releases of these dependencies to avoid, for example, security and compatibility risks. In practice, prioritizing these updates is difficult because the use of outdated dependencies is often opaque. In this paper we aim to make this concept more transparent by introducing metrics to quantify the use of recent versions of dependencies, ...", "pdfSize": "733KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Measuring+dependency+freshness+in+software+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "J. Hejderup, In dependencies we trust: How vulnerable are dependencies in software modules?, 2015.", "title": "In dependencies we trust: How vulnerable are dependencies in software modules?", "context": [{"sec": "sec2b", "text": " Dependency management is a popular research topic [47]\u2013[49][50]. david, gemnasium, and snyk are examples of such tools that require manual intervention; their results are often displayed as badges [21], [51] on a project's README file.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=In+dependencies+we+trust%3A+How+vulnerable+are+dependencies+in+software+modules%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "R. G. Kula, D. M. German, A. Ouni, T. Ishio, K. Inoue, \"Do developers update their library dependencies?\", <em>Empirical Software Engineering</em>, vol. 23, no. 1, pp. 384-417, 2018.", "title": "Do developers update their library dependencies?", "context": [{"sec": "sec2b", "text": " Dependency management is a popular research topic [47]\u2013[50]. david, gemnasium, and snyk are examples of such tools that require manual intervention; their results are often displayed as badges [21], [51] on a project's README file.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-017-9521-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+developers+update+their+library+dependencies%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "A. Trockman, S. Zhou, C. Kastner, B. Vasilescu, \"Adding sparkle to social coding: An empirical study of repository badges in the npm ecosystem\", <em>International Conference on Software Engineering (ICSE)</em>, 2018.", "title": "Adding sparkle to social coding: An empirical study of repository badges in the npm ecosystem", "context": [{"sec": "sec2b", "text": " Dependency management is a popular research topic [47]\u2013[50]. david, gemnasium, and snyk are examples of such tools that require manual intervention; their results are often displayed as badges [21], [51] on a project's README file.", "part": "1"}, {"sec": "sec4a", "text": " Instead, we determine their adoption date from the corresponding badge on a project's README [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adding+sparkle+to+social+coding%3A+An+empirical+study+of+repository+badges+in+the+npm+ecosystem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "M.-A. Storey, A. Zagalsky, \"Disrupting developer productivity one bot at a time\", <em>International Symposium on Foundations of Software Engineering (FSE)</em>, pp. 928-931, 2016.", "title": "Disrupting developer productivity one bot at a time", "context": [{"sec": "sec2b", "text": " However, automatic upgrades increase the number of PRs to review, and may cause notification fatigue [52].", "part": "1"}, {"sec": "sec5b4", "text": " However, dependency management tools may cause developers to suffer from notification fatigue [52], when they issue too many automated warnings.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2983989", "abstract": "Bots are used to support different software development activities, from automating repetitive tasks to bridging knowledge and communication gaps in software teams. We anticipate the use of Bots will increase and lead to improvements in software quality and developer and team productivity, but what if the disruptive effect is not what we expect?   Our goal in this paper is to provoke and inspire researchers to study the impact (positive and negative) of Bots on software development. We outline t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Disrupting+developer+productivity+one+bot+at+a+time&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "\"Full refactoring\", <em>ghaiklor</em>, October 2015,  [online]  Available: https://github.com/building5/sails-hook-bunyan/issues/9.", "title": "Full refactoring", "context": [{"sec": "sec2b", "text": " Our analysis suggests that developers value ease of installation, e.g., low configuration overhead, over other concerns: e.g., one developer prefers david since it's a specific, easy-to-install service [53], as opposed to bithound, which, as another developer notes, provides dependency management as well as numerous extra features [54].", "part": "1"}, {"sec": "sec5a", "text": " This may be due to its ease of installation [53], as compared to, e.g., bithound, which provides dependency management and many other features [54].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Full+refactoring&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "\"Update minimatch version\", <em>jhwohlgemuth</em>, September 2016,  [online]  Available: https://github.com/nightwatchjs/nightwatch/pull/1184.", "title": "Update minimatch version", "context": [{"sec": "sec2b", "text": " Our analysis suggests that developers value ease of installation, e.g., low configuration overhead, over other concerns: e.g., one developer prefers david since it's a specific, easy-to-install service [53], as opposed to bithound, which, as another developer notes, provides dependency management as well as numerous extra features [54].", "part": "1"}, {"sec": "sec5a", "text": " This may be due to its ease of installation [53], as compared to, e.g., bithound, which provides dependency management and many other features [54].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Update+minimatch+version&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "M. Sayagh, Z. Dong, A. Andrzejak, B. Adams, \"Does the choice of configuration framework matter for developers? empirical study on 11 Java configuration frameworks\", <em>International Working Conference on Source Code Analysis and Manipulation (SCAM)</em>, pp. 41-50, 2017.", "title": "Does the choice of configuration framework matter for developers? empirical study on 11 Java configuration frameworks", "context": [{"sec": "sec3", "text": " However, given the complexity of tool configuration [8], [10], [55] in general and the requirement of keeping configurations up-to-date [12], developers may need to change between tools within a given task class over time.", "part": "1"}], "links": {"documentLink": "/document/8090137", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8090137", "abstract": "Configuration frameworks are routinely used in software systems to change application behavior without recompilation. Selecting a suitable configuration framework among the vast variety of existing choices is a crucial decision for developers, as it can impact project reliability and its maintenance profile. In this paper, we analyze almost 2,000 Java projects on GitHub to investigate the features and properties of 11 major Java configuration frameworks. We analyze the popularity of the framewor...", "pdfSize": "275KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Does+the+choice+of+configuration+framework+matter+for+developers%3F+empirical+study+on+11+Java+configuration+frameworks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "H. Pham, X. Zhang, \"Nhpp software reliability and cost models with testing coverage\", <em>European Journal of Operational Research</em>, vol. 145, no. 2, pp. 443-454, 2003.", "title": "Nhpp software reliability and cost models with testing coverage", "context": [{"sec": "sec3", "text": " Test coverage has been described as important for software quality [56].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0377-2217(02)00181-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Nhpp+software+reliability+and+cost+models+with+testing+coverage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "G. J. Myers, C. Sandler, T. Badgett, The art of software testing, John Wiley & Sons, 2011.", "title": "The art of software testing", "context": [{"sec": "sec3", "text": " However, achieving full coverage is difficult [57], and relies on an appropriate test suite.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+art+of+software+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "G. Gousios, D. Spinellis, \"GHTorrent: GitHub's data from a fire-hose\", <em>International Conference on Mining Software Repositories (MSR)</em>, pp. 12-21, 2012.", "title": "GHTorrent: GitHub's data from a fire-hose", "context": [{"sec": "sec4a", "text": "For project-level GitHub measures (e.g., number of commits, number of PRs), we use data from the March 2017 dump of GHTorrent [58], aggregated monthly, and join this to our tool adoption data.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=GHTorrent%3A+GitHub%27s+data+from+a+fire-hose&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "M. Beller, G. Gousios, A. Zaidman, \"TravisTorrent: Synthesizing Travis CI and GitHub for full-stack research on continuous integration\", <em>International Conference on Mining Software Repositories (MSR)</em>, pp. 447-450, 2017.", "title": "TravisTorrent: Synthesizing Travis CI and GitHub for full-stack research on continuous integration", "context": [{"sec": "sec4b", "text": " The difficulty of parsing CI job logs has been noted by prior work [59].", "part": "1"}], "links": {"documentLink": "/document/7962393", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7962393", "abstract": "Continuous Integration (CI) has become a best practice of modern software development. Thanks in part to its tight integration with GitHub, Travis CI has emerged as arguably the most widely used CI platform for Open-Source Software (OSS) development. However, despite its prominent role in Software Engineering in practice, the benefits, costs, and implications of doing CI are all but clear from an academic standpoint. Little research has been done, and even less was of quantitative nature. In ord...", "pdfSize": "467KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=TravisTorrent%3A+Synthesizing+Travis+CI+and+GitHub+for+full-stack+research+on+continuous+integration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "R. H. Baayen, D. J. Davidson, D. M. Bates, \"Mixed-effects modeling with crossed random effects for subjects and items\", <em>Journal of Memory and Language</em>, vol. 59, no. 4, pp. 390-412, 2008.", "title": "Mixed-effects modeling with crossed random effects for subjects and items", "context": [{"sec": "sec4d", "text": "We use linear mixed-effects regression [60] (LMER)to measure the relationship between our outcomes (dependent variables)and our explanatory variables of interest, under the effect of various controls.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jml.2007.12.005", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mixed-effects+modeling+with+crossed+random+effects+for+subjects+and+items&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "J. Cohen, Applied multiple regression/correlation analysis for the behavioral sciences, Lawrence Erlbaum, 2003.", "title": "Applied multiple regression/correlation analysis for the behavioral sciences", "context": [{"sec": "sec4d", "text": " In OLS regression, multiple observation can lead to multicollinearity, which can limit inferential ability [61].", "part": "1"}, {"sec": "sec4d", "text": "We account for multicollinearity by considering only fixed-effect control variables with VIF (variance inflation factor)less than 5 [61], as having many fixed effects along with a complex design structure can introduce issues in model estimation.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Applied+multiple+regression%2Fcorrelation+analysis+for+the+behavioral+sciences&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "R. Tibshirani, \"Regression shrinkage and selection via the lasso\", <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, pp. 267-288, 1996.", "title": "Regression shrinkage and selection via the lasso", "context": [{"sec": "sec4d", "text": " Thus, random effects (or, e.g., LASSO regression [62])can be used as a form of shrinkage.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.2517-6161.1996.tb02080.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Regression+shrinkage+and+selection+via+the+lasso&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "P. B\u00fchlmann, S. Van De Geer, Statistics for high-dimensional data: methods theory and applications, Springer, 2011.", "title": "Statistics for high-dimensional data: methods, theory and applications", "context": [{"sec": "sec4d", "text": " Each random effect group level is shrunk towards its corresponding \u201cgrand mean\u201d, analogous to standard regularization strategies [63].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-20192-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Statistics+for+high-dimensional+data%3A+methods%2C+theory+and+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "R. Hyman, \"Quasi-experimentation: Design and analysis issues for field settings (book)\", <em>Journal of Personality Assessment</em>, vol. 46, no. 1, pp. 96-97, 1982.", "title": "Quasi-experimentation: Design and analysis issues for field settings (book)", "context": [{"sec": "sec4d", "text": " To do this, we use a model design analogous to regression discontinuity design (RDD)[64], [65] using mixed-effects regression [66].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1207/s15327752jpa4601_16", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quasi-experimentation%3A+Design+and+analysis+issues+for+field+settings+%28book%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "Y. Zhao, A. Serebrenik, Y. Zhou, V. Filkov, B. Vasilescu, \"The impact of continuous integration on other software development practices: a large-scale empirical study\", <em>International Conference on Automated Software Engineering (ASE)</em>, pp. 60-71, 2017.", "title": "The impact of continuous integration on other software development practices: a large-scale empirical study", "context": [{"sec": "sec4d", "text": " To do this, we use a model design analogous to regression discontinuity design (RDD)[64], [65] using mixed-effects regression [66].", "part": "1"}], "links": {"documentLink": "/document/8115619", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115619", "abstract": "Continuous Integration (CI) has become a disruptive innovation in software development: with proper tool support and adoption, positive effects have been demonstrated for pull request throughput and scaling up of project sizes. As any other innovation, adopting CI implies adapting existing practices in order to take full advantage of its potential, and &#34;best practices&#34; to that end have been proposed. Here we study the adaptation and evolution of code writing and submission, issue and pull reques...", "pdfSize": "1260KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+continuous+integration+on+other+software+development+practices%3A+a+large-scale+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "J. D. Singer, J. B. Willett, Applied longitudinal data analysis: modeling change and event occurrence, Oxford University Press, 2003.", "title": "Applied longitudinal data analysis: modeling change and event occurrence", "context": [{"sec": "sec4d", "text": " To do this, we use a model design analogous to regression discontinuity design (RDD)[64], [65] using mixed-effects regression [66].", "part": "1"}, {"sec": "sec4d", "text": " We perform standard model diagnostic tests to evaluate model fit [66]; our models pass these tests.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1093/acprof:oso/9780195152968.001.0001", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Applied+longitudinal+data+analysis%3A+modeling+change+and+event+occurrence&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "Z. Feng, T. Braun, C. McCulloch, \"Small sample inference for clustered data\", <em>Proceedings of the Second Seattle Symposium in Biostatistics</em>, pp. 71-87, 2004.", "title": "Small sample inference for clustered data", "context": [{"sec": "sec4d", "text": "The idea of variable significance in LMER is greatly debated in statistics, mostly due to the lack of classical asymptotic theory as used for inference in, e.g., OLS regression [67]\u2013[70]. 22Examples of this debate abound; listed references are a small sample.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4419-9076-1_5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Small+sample+inference+for+clustered+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "M. L. Bell, G. K. Grunwald, \"Small sample estimation properties of longitudinal count models\", <em>Journal of Statistical Computation and Simulation</em>, vol. 81, no. 9, pp. 1067-1079, 2011.", "title": "Small sample estimation properties of longitudinal count models", "context": [{"sec": "sec4d", "text": "The idea of variable significance in LMER is greatly debated in statistics, mostly due to the lack of classical asymptotic theory as used for inference in, e.g., OLS regression [67]\u2013[68][70]. 22Examples of this debate abound; listed references are a small sample.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1080/00949651003674144", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Small+sample+estimation+properties+of+longitudinal+count+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "A. Gelman, J. Hill, Data analysis using regression and multi-level/hierarchical models, Cambridge university press, 2006.", "title": "Data analysis using regression and multi-level/hierarchical models", "context": [{"sec": "sec4d", "text": "The idea of variable significance in LMER is greatly debated in statistics, mostly due to the lack of classical asymptotic theory as used for inference in, e.g., OLS regression [67]\u2013[69][70]. 22Examples of this debate abound; listed references are a small sample.", "part": "1"}, {"sec": "sec4d", "text": " This is considered a reasonable approach when sample sizes are large [69].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1017/CBO9780511790942", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+analysis+using+regression+and+multi-level%2Fhierarchical+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "J. C. Pinheiro, D. M. Bates, \"Linear mixed-effects models: basic concepts and examples\", <em>Mixed-effects models in S and S-Plus</em>, pp. 3-56, 2000.", "title": "Linear mixed-effects models: basic concepts and examples", "context": [{"sec": "sec4d", "text": "The idea of variable significance in LMER is greatly debated in statistics, mostly due to the lack of classical asymptotic theory as used for inference in, e.g., OLS regression [67]\u2013[70]. 22Examples of this debate abound; listed references are a small sample.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4419-0318-1_1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Linear+mixed-effects+models%3A+basic+concepts+and+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}, {"order": "71", "text": "A. Kuznetsova, P. B. Brockhoff, R. H. Christensen, \"lmertest package: Tests in linear mixed effects models\", <em>Journal of Statistical Software</em>, vol. 82, no. 13, pp. 1-26, 2017.", "title": "lmertest package: Tests in linear mixed effects models", "context": [{"sec": "sec4d", "text": " We report significance using Satterthwaite approximation for denominator degrees of freedom for regression variable t-tests, implemented using the lmerTest R library [71].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18637/jss.v082.i13", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=lmertest+package%3A+Tests+in+linear+mixed+effects+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref71"}, {"order": "72", "text": "S. Nakagawa, H. Schielzeth, \"A general and simple method for obtaining r2 from generalized linear mixed-effects models\", <em>Methods in Ecology and Evolution</em>, vol. 4, no. 2, pp. 133-142, 2013.", "title": "A general and simple method for obtaining r2 from generalized linear mixed-effects models", "context": [{"sec": "sec4d", "text": "We report psuedo- \\$R^{2}\\$ values as described by Nakagawa and Schielzeth [72], called marginal \\$R^{2}\\$ and conditional \\$R^{2}\\$, The marginal \\$R^{2}\\$ can be interpreted as the variance described by the fixed effects alone; conditional \\$R^{2}\\$ as the variance described by both fixed and random effects.", "part": "1"}, {"sec": "sec4e", "text": " The notion of goodness-of-fit in these models is highly debated [72], with many available metrics for assessment [74]\u2013[77].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.2041-210x.2012.00261.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+general+and+simple+method+for+obtaining+r2+from+generalized+linear+mixed-effects+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref72"}, {"order": "73", "text": "Y. Benjamini, Y. Hochberg, \"Controlling the false discovery rate: a practical and powerful approach to multiple testing\", <em>Journal of the royal statistical society. Series B (Methodological)</em>, pp. 289-300, 1995.", "title": "Controlling the false discovery rate: a practical and powerful approach to multiple testing", "context": [{"sec": "sec4d", "text": " As we build many models, we also perform multiple hypothesis testing (p-value)correction by the Benjamini and Hochberg method [73]; this correction balances false positives and false negatives, unlike the more conservative Bonferroni correction which aims to lower only false positives.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.2517-6161.1995.tb02031.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Controlling+the+false+discovery+rate%3A+a+practical+and+powerful+approach+to+multiple+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref73"}, {"order": "74", "text": "A. Tom, T. A. S. R. J. Bosker, R. J. Bosker, <em>Multilevel analysis: an introduction to basic and advanced multilevel modeling</em>, 1999.", "title": "Multilevel analysis: an introduction to basic and advanced multilevel modeling", "context": [{"sec": "sec4e", "text": " The notion of goodness-of-fit in these models is highly debated [72], with many available metrics for assessment [74]\u2013[77].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multilevel+analysis%3A+an+introduction+to+basic+and+advanced+multilevel+modeling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref74"}, {"order": "75", "text": "R. Xu, \"Measuring explained variation in linear mixed effects models\", <em>Statistics in medicine</em>, vol. 22, no. 22, pp. 3527-3541, 2003.", "title": "Measuring explained variation in linear mixed effects models", "context": [{"sec": "sec4e", "text": " The notion of goodness-of-fit in these models is highly debated [72], with many available metrics for assessment [74]\u2013[75][77].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/sim.1572", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Measuring+explained+variation+in+linear+mixed+effects+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref75"}, {"order": "76", "text": "H. Liu, Y. Zheng, J. Shen, \"Goodness-of-fit measures of r 2 for repeated measures mixed effect models\", <em>Journal of Applied Statistics</em>, vol. 35, no. 10, pp. 1081-1092, 2008.", "title": "Goodness-of-fit measures of r 2 for repeated measures mixed effect models", "context": [{"sec": "sec4e", "text": " The notion of goodness-of-fit in these models is highly debated [72], with many available metrics for assessment [74]\u2013[76][77].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1080/02664760802124422", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Goodness-of-fit+measures+of+r+2+for+repeated+measures+mixed+effect+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref76"}, {"order": "77", "text": "J. G. Orelien, L. J. Edwards, \"Fixed-effect variable selection in linear mixed models using r2 statistics\", <em>Computational Statistics & Data Analysis</em>, vol. 52, no. 4, pp. 1896-1907, 2008.", "title": "Fixed-effect variable selection in linear mixed models using r2 statistics", "context": [{"sec": "sec4e", "text": " The notion of goodness-of-fit in these models is highly debated [72], with many available metrics for assessment [74]\u2013[77].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.csda.2007.06.006", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fixed-effect+variable+selection+in+linear+mixed+models+using+r2+statistics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref77"}, {"order": "78", "text": "\"[suggestion]greenkeeper\", <em>thiagogcm</em>, March 2016,  [online]  Available: https://github.com/jhipster/generator-jhipster/issues/3159.", "title": "[suggestion]greenkeeper", "context": [{"sec": "sec5a", "text": " This is reflected in a statement by one commenter: \u201cthere are too many tools to manage\u201d [78].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=%5Bsuggestion%5Dgreenkeeper&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref78"}, {"order": "79", "text": "L. Hils\u00a2e, \"Linting javascript in 2015\", Jul. 2015,  [online]  Available: http://tech.lauritz.me/linting-javascript-in-2015/.", "title": "Linting javascript in 2015", "context": [{"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Linting+javascript+in+2015&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref79"}, {"order": "80", "text": "\"Jshint vs. eslint\", <em>Slant</em>, 2018,  [online]  Available: https://www.slant.co/versus/8627/8628/~jshint_vs_eslint.", "title": "Jshint vs. eslint", "context": [{"sec": "sec5a", "text": " This could be due to apparent popular opinion that ESLint does a better job than JSHint for the same tasks, is more highly configurable, or provides a superset of features, as evidenced by multiple blog posts [18], [79], [80] and our qualitative analysis [31], [34]\u2013[36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jshint+vs.+eslint&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref80"}, {"order": "81", "text": "G. jazzband/django-model utils, \"Use codecov instead of coveralls\", Jun. 2015,  [online]  Available: https://github.com/jazzband/django-model-utils/pull/175.", "title": "Use codecov instead of coveralls", "context": [{"sec": "sec5a", "text": " However, some online discussions [81]\u2013[83] and issue discussions [45], [46] suggest that project communities may be starting to favor codecov due to its superset of features and its direct integration with GitHub, BitBucket, and other git-related services, and due to its better support.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Use+codecov+instead+of+coveralls&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref81"}, {"order": "82", "text": "G. chaijs/chai, \"Coveralls/coverage badge not working\", Feb. 2017,  [online]  Available: https://github.com/chaijs/chai/issues/927.", "title": "Coveralls/coverage badge not working", "context": [{"sec": "sec5a", "text": " However, some online discussions [81]\u2013[82][83] and issue discussions [45], [46] suggest that project communities may be starting to favor codecov due to its superset of features and its direct integration with GitHub, BitBucket, and other git-related services, and due to its better support.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coveralls%2Fcoverage+badge+not+working&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref82"}, {"order": "83", "text": "G. vavr-io/vavr jackson, \"Move code coverage from coveralls.io to codecov.io\", Nov. 2015,  [online]  Available: https://github.com/vavr-io/vavr-jackson/issues/14.", "title": "Move code coverage from coveralls.io to codecov.io", "context": [{"sec": "sec5a", "text": " However, some online discussions [81]\u2013[83] and issue discussions [45], [46] suggest that project communities may be starting to favor codecov due to its superset of features and its direct integration with GitHub, BitBucket, and other git-related services, and due to its better support.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Move+code+coverage+from+coveralls.io+to+codecov.io&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref83"}, {"order": "84", "text": "M. Burdon, B. Lane, P. von Nessen, \"The mandatory notification of data breaches: Issues arising for australian and eu legal developments\", <em>Computer Law & Security Review</em>, vol. 26, no. 2, pp. 115-129, 2010.", "title": "The mandatory notification of data breaches: Issues arising for australian and eu legal developments", "context": [{"sec": "sec5b4", "text": " Such fatigue due to false alarms is a serious issue across many disciplines [84]\u2013[86].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.clsr.2010.01.006", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+mandatory+notification+of+data+breaches%3A+Issues+arising+for+australian+and+eu+legal+developments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref84"}, {"order": "85", "text": "M. Cvach, \"Monitor alarm fatigue: an integrative review\", <em>Biomedical Instrumentation & Technology</em>, vol. 46, no. 4, pp. 268-277, 2012.", "title": "Monitor alarm fatigue: an integrative review", "context": [{"sec": "sec5b4", "text": " Such fatigue due to false alarms is a serious issue across many disciplines [84]\u2013[85][86].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2345/0899-8205-46.4.268", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Monitor+alarm+fatigue%3A+an+integrative+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref85"}, {"order": "86", "text": "J. Welch, \"An evidence-based approach to reduce nuisance alarms and alarm fatigue\", <em>Biomedical Instrumentation & Technology</em>, vol. 45, no. s1, pp. 46-52, 2011.", "title": "An evidence-based approach to reduce nuisance alarms and alarm fatigue", "context": [{"sec": "sec5b4", "text": " Such fatigue due to false alarms is a serious issue across many disciplines [84]\u2013[86].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2345/0899-8205-45.s1.46", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+evidence-based+approach+to+reduce+nuisance+alarms+and+alarm+fatigue&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref86"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812106", "articleId": "8812106", "startPage": "476", "endPage": "487", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 2, "citationCountPatent": 0, "totalDownloads": 72}}
{"title": "Investigating the Effects of Gender Bias on GitHub", "authors": [{"name": "Nasif Imtiaz", "affiliation": "North Carolina State University", "firstName": "Nasif", "lastName": "Imtiaz", "id": "37086953665"}, {"name": "Justin Middleton", "affiliation": "North Carolina State University", "firstName": "Justin", "lastName": "Middleton", "id": "37086144145"}, {"name": "Joymallya Chakraborty", "affiliation": "North Carolina State University", "firstName": "Joymallya", "lastName": "Chakraborty", "id": "37086951829"}, {"name": "Neill Robson", "affiliation": "North Carolina State University", "firstName": "Neill", "lastName": "Robson", "id": "37086948063"}, {"name": "Gina Bai", "affiliation": "North Carolina State University", "firstName": "Gina", "lastName": "Bai", "id": "37086800548"}, {"name": "Emerson Murphy-Hill", "affiliation": "Google LLC", "firstName": "Emerson", "lastName": "Murphy-Hill", "id": "38330554900"}], "abstract": "Diversity, including gender diversity, is valued by many software development organizations, yet the field remains dominated by men. One reason for this lack of diversity is gender bias. In this paper, we study the effects of that bias by using an existing framework derived from the gender studies literature.We adapt the four main effects proposed in the framework by posing hypotheses about how they might manifest on GitHub,then evaluate those hypotheses quantitatively. While our results how that effects of gender bias are largely invisible on the GitHub platform itself, there are still signals of women concentrating their work in fewer places and being more restrained in communication than men.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software", "Software engineering", "Companies", "Correlation", "Encoding", "Computer science"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["gender issues", "software development management", "software metrics"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["gender bias", "gender diversity", "software development organizations", "gender studies", "GitHub"]}, {"type": "Author Keywords ", "kwd": ["gender bias", "software engineering"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00079", "ref": [{"order": "1", "text": "<em>List of swear words bad words & curse words</em>,  [online]  Available: https://www.noswearing.com/dictionary.", "title": "List of swear words, bad words, & curse words", "context": [{"sec": "sec5b2", "text": " For a list, we used a crowdsourced and curated list of 349 profane words [1] used in prior work [26], [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=List+of+swear+words%2C+bad+words%2C+%26+curse+words&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Mastering issues</em>,  [online]  Available: https://guides.GitHub.com/features/issues.", "title": "Mastering issues", "context": [{"sec": "sec5a", "text": " The GitHub documentation designates issue and pull requests as the appropriate place for project-related discussions among developers [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mastering+issues&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Open source guides - your code of conduct</em>.", "title": "Open source guides - your code of conduct", "context": [{"sec": "sec8", "text": " Interventions like adopting a \u201ccode of conduct\u201d [3], may help mitigate Tightrope effects by helping communities articulate acceptable behaviors for all members.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Open+source+guides+-+your+code+of+conduct&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "Laura Arjona-Reina, Gregorio Robles, S Due\u00f1as, <em>The floss2013 free/libre/open source survey</em>, 2014.", "title": "The floss2013 free/libre/open source survey", "context": [{"sec": "sec1", "text": " In a 2013 survey over 200 open source developers, only 11.2% of the respondents were women [4].", "part": "1"}, {"sec": "sec6b", "text": " However, we decided against comparing the raw proportions of those who had a picture with a child against those whom did not, since a 2013 survey by Arjona-Reina and colleagues suggests that OSS contributors of different genders are parents at different rates [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+floss2013+free%2Flibre%2Fopen+source+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "Felice Batlan, \"if you become his second wife you are a fool\u201d: Shifting paradigms of the roles perceptions and working conditions of legal secretaries in large law firms\" in Special Issue Law Firms Legal Culture and Legal Practice, Emerald Group Publishing Limited, pp. 169-210, 2010.", "title": "if you become his second wife, you are a fool\u201d: Shifting paradigms of the roles, perceptions, and working conditions of legal secretaries in large law firms", "context": [{"sec": "sec7", "text": " As an example, in interviews at law firms, Batlan quotes one legal assistant, who said, \u201cFemales are harder on their female assistants\u201d [5].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1108/S1059-4337(2010)0000052009", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=if+you+become+his+second+wife%2C+you+are+a+fool%E2%80%9D%3A+Shifting+paradigms+of+the+roles%2C+perceptions%2C+and+working+conditions+of+legal+secretaries+in+large+law+firms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "Monica Biernat, Diane Kobrynowicz, \"Gender-and race-based standards of competence: lower minimum standards but higher ability standards for devalued groups\", <em>Journal of personality and social psychology</em>, vol. 72, no. 3, 1997.", "title": "Gender-and race-based standards of competence: lower minimum standards but higher ability standards for devalued groups", "context": [{"sec": "sec4", "text": "The first effect of bias that we investigate is what Williams and Dempsey call Prove-it-Again, where a member of a group that doesn't align with stereotypes is measured at a stricter standard than those who do align with the stereotypes and consequently has to provide more evidence to demonstrate competence [6], [47].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0022-3514.72.3.544", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender-and+race-based+standards+of+competence%3A+lower+minimum+standards+but+higher+ability+standards+for+devalued+groups&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "Hannah Riley Bowles, Linda Babcock, Lei Lai, \"Social incentives for gender differences in the propensity to initiate negotiations: Sometimes it does hurt to ask\", <em>Organizational Behavior and human decision Processes</em>, vol. 103, no. 1, pp. 84-103, 2007.", "title": "Social incentives for gender differences in the propensity to initiate negotiations: Sometimes it does hurt to ask", "context": [{"sec": "sec5", "text": " Bowles and colleagues found that women are penalized when initiating a negotiation [7].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.obhdp.2006.09.001", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Social+incentives+for+gender+differences+in+the+propensity+to+initiate+negotiations%3A+Sometimes+it+does+hurt+to+ask&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "Diana Burgess, Eugene Borgida, \"Who women are who women should be: Descriptive and prescriptive gender stereotyping in sex discrimination\", <em>Psychology public policy and law</em>, vol. 5, no. 3, 1999.", "title": "Who women are, who women should be: Descriptive and prescriptive gender stereotyping in sex discrimination", "context": [{"sec": "sec5", "text": " Burgess and colleagues showed how descriptive (how women are) and prescriptive (how women should be) components of gender stereotypes impose artificial restrictions on women's behavior [8].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/1076-8971.5.3.665", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Who+women+are%2C+who+women+should+be%3A+Descriptive+and+prescriptive+gender+stereotyping+in+sex+discrimination&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "Fabio Calefato, Filippo Lanubile, Federico Maiorano, Nicole Novielli, \"Sentiment polarity detection for software development\", <em>Empirical Software Engineering</em>, pp. 1-31, 2017.", "title": "Sentiment polarity detection for software development", "context": [{"sec": "sec5b3", "text": " We use a tool named Senti4SD [9], which has the most accurate sentiment analysis over GitHub comments, compared to similar tools [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sentiment+polarity+detection+for+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "Shelley J Correll, Stephen Benard, In Paik, \"Getting a job: Is there a motherhood penalty?\", <em>American journal of sociology</em>, vol. 112, no. 5, pp. 1297-1338, 2007.", "title": "Getting a job: Is there a motherhood penalty?", "context": [{"sec": "sec6", "text": " Because of this perception, mothers' work and r\u00e9sum\u00e9s are often held to higher scrutiny, and many working mothers are subtly pushed out of their positions in favor of non-mothers [10].", "part": "1"}, {"sec": "sec6", "text": " Prior work has also shown that mothers make less money than women without children and also less than fathers, whose wages tend to actually increase [10].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1086/511799", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Getting+a+job%3A+Is+there+a+motherhood+penalty%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "Laura Dabbish, Colleen Stuart, Jason Tsay, Jim Herbsleb, \"Social coding in GitHub: transparency and collaboration in an open software repository\", <em>Proceedings of the ACM 2012 conference on Computer Supported Cooperative Work</em>, pp. 1277-1286, 2012.", "title": "Social coding in GitHub: transparency and collaboration in an open software repository", "context": [{"sec": "sec4a3", "text": " Prior research suggests that many developers consciously manage their self-image to promote their work [11] and that GitHub re- viewers explore new contributors' profiles to seek information when evaluating a pull request from an unknown person [28].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2145204.2145396", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Social+coding+in+GitHub%3A+transparency+and+collaboration+in+an+open+software+repository&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "Cristian Danescu-Niculescu-Mizil, Moritz Sudhof, Dan Jurafsky, Jure Leskovec, Christopher Potts, A computational approach to politeness with application to social factors, 2013.", "title": "A computational approach to politeness with application to social factors", "context": [{"sec": "sec5b1", "text": "We used a tool developed by Danescu-Niculescu-Mizil and colleagues [12] to measure politeness in our GitHub comments, which has been used in recent software engineering studies [31], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+computational+approach+to+politeness+with+application+to+social+factors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "Heather K Davison, Michael J Burke, \"Sex discrimination in simulated employment contexts: A meta-analytic investigation\", <em>Journal of Vocational Behavior</em>, vol. 56, no. 2, pp. 225-248, 2000.", "title": "Sex discrimination in simulated employment contexts: A meta-analytic investigation", "context": [{"sec": "sec2", "text": " Davison and colleagues' meta-analysis has shown that sex-typed of a job (e.g., nurse is female sex-typed) affects employees' performance ratings and favors the sex it is typecast to [13].", "part": "1"}, {"sec": "sec4", "text": " This effect is more prominent in roles that are stereotypically typecast to men [13], such as software development.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1006/jvbe.1999.1711", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sex+discrimination+in+simulated+employment+contexts%3A+A+meta-analytic+investigation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "Rafael Xavier de Souza, <em>Complete list of GitHub markdown emoji markup</em>,  [online]  Available: https://gist.GitHub.com/rxaviers/7360908.", "title": "Complete list of GitHub markdown emoji markup", "context": [{"sec": "sec5b4", "text": " For emojis, GitHub offers a continuously expanding list of emojis, but we chose to study the 194 \u201cpeople\u201d GitHub emojis as defined by de Souza [14].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Complete+list+of+GitHub+markdown+emoji+markup&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Krystle A. Hearns, Elizabeth J. Parks-Stamm, Madeline E. Heilman, \"Motivated to penalize: women's strategic rejection of successful women\", <em>Personality and Social Psychology Bulletin</em>, vol. 34, pp. 237-247, 2008.", "title": "Motivated to penalize: women's strategic rejection of successful women", "context": [{"sec": "sec7", "text": "Williams and Dempsey's Tug of War suggests that in heavily competitive environments, women sometimes discourage other women because either they doubt the competency of other women [27] or they think encouraging others may increase the level of competition [15].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Motivated+to+penalize%3A+women%27s+strategic+rejection+of+successful+women&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "Rishab A Ghosh, Ruediger Glott, Bernhard Krieger, Gregorio Robles, <em>Free/libre and open source software: Survey and study</em>, 2002.", "title": "Free/libre and open source software: Survey and study", "context": [{"sec": "sec2", "text": " Nafus' study points out the existence of sexist behavior in open source, which may play a part in women's low participation [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Free%2Flibre+and+open+source+software%3A+Survey+and+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Georgios Gousios, \"The ghtorent dataset and tool suite\", <em>Proceedings of the 10th working conference on mining software repositories</em>, pp. 233-236, 2013.", "title": "The ghtorent dataset and tool suite", "context": [{"sec": "sec3a", "text": "We conducted our research on GitHub, a collaborative software development platform [17].", "part": "1"}, {"sec": "sec3b", "text": "We began with our prior dataset [40], which builds on GHTorrent data [17] mined from public GitHub data from June 7, 2010 to April 1, 2015.", "part": "1"}], "links": {"documentLink": "/document/6624034", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6624034", "abstract": "During the last few years, GitHub has emerged as a popular project hosting, mirroring and collaboration platform. GitHub provides an extensive REST API, which enables researchers to retrieve high-quality, interconnected data. The GHTorent project has been collecting data for all public projects available on Github for more than a year. In this paper, we present the dataset details and construction process and outline the challenges and research opportunities emerging from it.", "pdfSize": "655KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+ghtorent+dataset+and+tool+suite&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Georgios Gousios, Martin Pinzger, Arie van Deursen, \"An exploratory study of the pull-based software development model\", <em>Proceedings of the 36th International Conference on Software Engineering</em>, pp. 345-355, 2014.", "title": "An exploratory study of the pull-based software development model", "context": [{"sec": "sec3a", "text": " GitHub uses a pull-based development model, where any user can contribute changes to any public project [18].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568260", "abstract": "The advent of distributed version control systems has led to the development of a new paradigm for distributed software development; instead of pushing changes to a central repository, developers pull them from other repositories and merge them locally. Various code hosting sites, notably Github, have tapped on the opportunity to facilitate pull-based development by offering workflow support tools, such as code reviewing systems and integrated issue trackers. In this work, we explore how pull-ba...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+exploratory+study+of+the+pull-based+software+development+model&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "Michele Grossman, Wendy Wood, \"Sex differences in intensity of emotional experience: a social role interpretation\", <em>Journal of personality and social psychology</em>, vol. 65, no. 5, 1993.", "title": "Sex differences in intensity of emotional experience: a social role interpretation", "context": [{"sec": "sec8", "text": " A reader might attribute these results to \u201cnatural\u201d expressiveness differences between genders, but prior research suggests that emotional expressiveness is strongly shaped by social expectations [19].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0022-3514.65.5.1010", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sex+differences+in+intensity+of+emotional+experience%3A+a+social+role+interpretation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Madeline E Heilman, \"Gender stereotypes and workplace bias\", <em>Research in organizational Behavior</em>, vol. 32, pp. 113-135, 2012.", "title": "Gender stereotypes and workplace bias", "context": [{"sec": "sec1", "text": " The existence of bias in the profession should be unsurprising; as Heilman finds, gender bias is generally higher in occupations and fields dominated by men [20].", "part": "1"}, {"sec": "sec2", "text": " The issue of women being rarely found at the highest level of organizations in the US and Europe was also addressed by Heilman, who explains how gender stereotypes lead to biased judgments against women and impede their career progress [20].", "part": "1"}, {"sec": "sec5b5", "text": "We used Heilman's definition and traits of stereotypical masculine and feminine behaviors, as a guiding material for this manual analysis [20].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.riob.2012.11.003", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+stereotypes+and+workplace+bias&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Alexander Hogenboom, Daniella Bal, Flavius Frasincar, Malissa Bal, Franciska de Jong, Uzay Kaymak, \"Exploiting emoticons in sentiment analysis\", <em>Proceedings of the 28th annual ACM symposium on applied computing</em>, pp. 703-710, 2013.", "title": "Exploiting emoticons in sentiment analysis", "context": [{"sec": "sec5a", "text": " Hogenboom and colleagues found that, \u201cwhenever emoticons are used, their associated sentiment dominates the sentiment conveyed by textual cues and forms a good proxy for intended sentiment\u201d [21].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2480362.2480498", "abstract": "As people increasingly use emoticons in text in order to express, stress, or disambiguate their sentiment, it is crucial for automated sentiment analysis tools to correctly account for such graphical cues for sentiment. We analyze how emoticons typically convey sentiment and demonstrate how we can exploit this by using a novel, manually created emoticon sentiment lexicon in order to improve a state-of-the-art lexicon-based sentiment classification method. We evaluate our approach on 2,080 Dutch ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploiting+emoticons+in+sentiment+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Sander Hoogendoorn, Hessel Oosterbeek, Mirjam Van Praag, \"The impact of gender diversity on the performance of business teams: Evidence from a field experiment\", <em>Management Science</em>, vol. 59, no. 7, pp. 1514-1528, 2013.", "title": "The impact of gender diversity on the performance of business teams: Evidence from a field experiment", "context": [{"sec": "sec1", "text": " For example, Hoogendoorn and colleagues found that teams with a gender balance performed better in a simulated startup than teams that were dominated by men [22].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/mnsc.1120.1674", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+gender+diversity+on+the+performance+of+business+teams%3A+Evidence+from+a+field+experiment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "Nasif Imtiaz, Justin Middleton, Peter Girouard, Emerson Murphy-Hill, \"Sentiment and politeness analysis tools on developer discussions are unreliable but so are people\", <em>Proceedings of the Third International Workshop on Emotion Awareness in Software Engineering</em>, 2018.", "title": "Sentiment and politeness analysis tools on developer discussions are unreliable, but so are people", "context": [{"sec": "sec5b1", "text": " This tool was found to have a fair agreement with human rating over GitHub comments [23].", "part": "1"}, {"sec": "sec5b1", "text": " Using this tool, we rated each comment as either polite or neutral as per the same approach followed in the prior work [23].", "part": "1"}, {"sec": "sec5b1", "text": " We chose not to use the impoliteness ratings from the tool as prior work has shown them to be relatively unreliable [23].", "part": "1"}, {"sec": "sec5b3", "text": " We use a tool named Senti4SD [9], which has the most accurate sentiment analysis over GitHub comments, compared to similar tools [23].", "part": "1"}, {"sec": "sec9", "text": " Imtiaz and colleagues evaluated the tools we used on a test data set of GitHub comments and measured an agreement rate (Weighted Kohen's Kappa) of. 33 for Senti4SD and. 39 for the politeness tool with the human rating [23].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3194932.3194938", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sentiment+and+politeness+analysis+tools+on+developer+discussions+are+unreliable%2C+but+so+are+people&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "Kalliamvakou Eirini, Gousios Georgios, Blincoe Kelly, Singer Leif, Daniel M German, Daniela Damian, \"The promises and perils of mining GitHub\", <em>Proceedings of the 11 th working conference on mining software repositories</em>, pp. 92-101, 2014.", "title": "The promises and perils of mining GitHub", "context": [{"sec": "sec9", "text": "Kalliamvakou and colleagues' discussion of GitHub mining underscores the threat of data incompleteness that also threatens the internal validity of our results [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+promises+and+perils+of+mining+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "Knobloch-Westerwick Silvia, Carroll J Glynn, Michael Huge, \"The matilda effect in science communication: an experiment on gender bias in publication quality perceptions and collaboration interest\", <em>Science Communication</em>, vol. 35, no. 5, pp. 603-625, 2013.", "title": "The matilda effect in science communication: an experiment on gender bias in publication quality perceptions and collaboration interest", "context": [{"sec": "sec4", "text": " Given a similar quality of work, work by contributors whose perceived gender is male is preferred [25], [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+matilda+effect+in+science+communication%3A+an+experiment+on+gender+bias+in+publication+quality+perceptions+and+collaboration+interest&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "Kontostathis April, Reynolds Kelly, Garron Andy, Edwards Lynne, \"Detecting cyberbullying: query terms and techniques\", <em>Proceedings of the 5th annual acm web science conference</em>, pp. 195-204, 2013.", "title": "Detecting cyberbullying: query terms and techniques", "context": [{"sec": "sec5b2", "text": " For a list, we used a crowdsourced and curated list of 349 profane words [1] used in prior work [26], [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+cyberbullying%3A+query+terms+and+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "Ziva Kunda, Lisa Sinclair, \"Motivated stereotyping of women: she's fine if she praised me but incompetent if she criticized me\", <em>Personality and Social Psychology Bulletin</em>, vol. 26, pp. 1329-1342, 2000.", "title": "Motivated stereotyping of women: she's fine if she praised me but incompetent if she criticized me", "context": [{"sec": "sec7", "text": "Williams and Dempsey's Tug of War suggests that in heavily competitive environments, women sometimes discourage other women because either they doubt the competency of other women [27] or they think encouraging others may increase the level of competition [15].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Motivated+stereotyping+of+women%3A+she%27s+fine+if+she+praised+me+but+incompetent+if+she+criticized+me&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "Jennifer Marlow, Laura Dabbish, Jim Herbsleb, \"Impression formation in online peer production: activity traces and personal profiles in GitHub\", <em>Proceedings of the 2013 conference on Computer supported cooperative work</em>, pp. 117-128, 2013.", "title": "Impression formation in online peer production: activity traces and personal profiles in GitHub", "context": [{"sec": "sec4a3", "text": " Prior research suggests that many developers consciously manage their self-image to promote their work [11] and that GitHub re- viewers explore new contributors' profiles to seek information when evaluating a pull request from an unknown person [28].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2441776.2441792", "abstract": "In this paper we describe a qualitative investigation of impression formation in an online distributed software development community with social media functionality. We find that users in this setting seek out additional information about each other to explore the project space, inform future interactions, and understand the potential future value of a new person. They form impressions around other users&#39; expertise based on history of activity across projects, and successful collaborations with...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Impression+formation+in+online+peer+production%3A+activity+traces+and+personal+profiles+in+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Corinne A Moss-Racusin, John F Dovidio, Victoria L Brescoll, Mark J Graham, Jo Handelsman, \"Science facultys subtle gender biases favor male students\", <em>Proceedings of the National Academy of Sciences</em>, vol. 109, no. 41, pp. 16474-16479, 2012.", "title": "Science facultys subtle gender biases favor male students", "context": [{"sec": "sec4", "text": " Given a similar quality of work, work by contributors whose perceived gender is male is preferred [25], [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Science+facultys+subtle+gender+biases+favor+male+students&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "Dawn Nafus, \"patches don't have gender': What is not open in open source software\", <em>New Media & Society</em>, vol. 14, no. 4, pp. 669-683, 2012.", "title": "patches don't have gender': What is not open in open source software", "context": [{"sec": "sec1", "text": " In Nafus's interviews with open source developers, she found that \u201csexist behavior is\u2026 as constant as it is extreme\u201d [30].", "part": "1"}, {"sec": "sec2", "text": "Nafus, in her qualitative study, finds that despite having a reputation for being open and democratic, the complex construct of \u201copenness\u201d in open source software development leads to a male monopoly [30].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/1461444811422887", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=patches+don%27t+have+gender%27%3A+What+is+not+open+in+open+source+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "Marco Ortu, Bram Adams, Giuseppe Destefanis, Parastou Tourani, Michele Marchesi, Roberto Tonelli, \"Are bullies more productive? empirical study of affectiveness vs. issue fixing time\", <em>Mining Software Repositories (MSR) 2015 IEEE/ACM 12th Working Conference</em>, pp. 303-313, 2015.", "title": "Are bullies more productive? empirical study of affectiveness vs. issue fixing time", "context": [{"sec": "sec5b1", "text": "We used a tool developed by Danescu-Niculescu-Mizil and colleagues [12] to measure politeness in our GitHub comments, which has been used in recent software engineering studies [31], [32].", "part": "1"}], "links": {"documentLink": "/document/7180089", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180089", "abstract": "Human Affectiveness, i.e., The emotional state of a person, plays a crucial role in many domains where it can make or break a team&#39;s ability to produce successful products. Software development is a collaborative activity as well, yet there is little information on how affectiveness impacts software productivity. As a first measure of this impact, this paper analyzes the relation between sentiment, emotions and politeness of developers in more than 560K Jira comments with the time to fix a Jira ...", "pdfSize": "513KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+bullies+more+productive%3F+empirical+study+of+affectiveness+vs.+issue+fixing+time&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "Marco Ortu, Giuseppe Destefanis, Mohamad Kassab, Steve Counsell, Michele Marchesi, Roberto Tonelli, \"Would you mind fixing this issue?\", <em>International Conference on Agile Software Development</em>, pp. 129-140, 2015.", "title": "Would you mind fixing this issue?", "context": [{"sec": "sec5b1", "text": "We used a tool developed by Danescu-Niculescu-Mizil and colleagues [12] to measure politeness in our GitHub comments, which has been used in recent software engineering studies [31], [32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-18612-2_11", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Would+you+mind+fixing+this+issue%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "Bo Pang, Lillian Lee et al., \"Opinion mining and sentiment analysis\", <em>Foundations and Trends\u00ae in Information Retrieval</em>, vol. 2, no. 1\u20132, pp. 1-135, 2008.", "title": "Opinion mining and sentiment analysis", "context": [{"sec": "sec5b3", "text": "To evaluate Hypothesis TR 3, we applied automated sentiment analysis, which focuses on classifying the sentiment of text as to their polarity (positive, negative, or neutral)[33].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1561/1500000011", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Opinion+mining+and+sentiment+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "Jeffrey Lee Rasmussen, Barbara E Moely, \"Impression formation as a function of the sex role appropriateness of linguistic behavior\", <em>Sex Roles</em>, vol. 14, no. 3-4, pp. 149-161, 1986.", "title": "Impression formation as a function of the sex role appropriateness of linguistic behavior", "context": [{"sec": "sec5a", "text": "At the other end, the Tightrope effect would also predict that women are less likely to use strong expletives to avoid impoliteness, as the social norms disapprove the use of profane words by women [34].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF00288246", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Impression+formation+as+a+function+of+the+sex+role+appropriateness+of+linguistic+behavior&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "Jennifer Rindfleish, \"Senior management women in australia: Diverse perspectives\", <em>Women in Management Review</em>, 2000.", "title": "Senior management women in australia: Diverse perspectives", "context": [{"sec": "sec7", "text": " The Tug of War effect is related to the so-called \u201cqueen bee\u201d syndrome, where some successful women believe that more junior women should be able to be successful in a harsh work environment without help, because the senior women were successful in the same environment [35].", "part": "1"}, {"sec": "sec7c", "text": " A possible explanation behind this result could be the aforementioned \u201cqueen bee\u201d syndrome [35].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1108/09649420010335491", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Senior+management+women+in+australia%3A+Diverse+perspectives&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "Philip L Roth, Kristen L Purvis, Philip Bobko, \"A meta-analysis of gender group differences for measures of job performance in field studies\", <em>Journal of Management</em>, vol. 38, no. 2, pp. 719-739, 2012.", "title": "A meta-analysis of gender group differences for measures of job performance in field studies", "context": [{"sec": "sec2", "text": " Roth and colleagues' meta-analysis, however, showed that women generally score higher in job performance ratings, although they still lag behind men in promotions [36].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/0149206310374774", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+meta-analysis+of+gender+group+differences+for+measures+of+job+performance+in+field+studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "Laurie A Rudman, Julie E Phelan, \"Backlash effects for disconfirming gender stereotypes in organizations\", <em>Research in organizational behavior</em>, vol. 28, pp. 61-79, 2008.", "title": "Backlash effects for disconfirming gender stereotypes in organizations", "context": [{"sec": "sec5", "text": " Consequently, women face an impression-management dilemma because there often is a negative reaction to expressing agency [37].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.riob.2008.04.003", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Backlash+effects+for+disconfirming+gender+stereotypes+in+organizations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "Sara Owsley Sood, Judd Antin, Elizabeth F Churchill, \"Using crowd-sourcing to improve profanity detection\", <em>AAAI Spring Symposium: Wisdom of the Crowd</em>, vol. 12, pp. 06, 2012.", "title": "Using crowd-sourcing to improve profanity detection", "context": [{"sec": "sec5b2", "text": " For a list, we used a crowdsourced and curated list of 349 profane words [1] used in prior work [26], [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+crowd-sourcing+to+improve+profanity+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "\"StackOverflow\", <em>Developer survey results. Internet</em>,  [online]  Available: https://insights.stackoverflow.com/survey/2017.", "title": "StackOverflow", "context": [{"sec": "sec1", "text": " In an annual survey on Stack Overflow, a question-answer site for programmers, only 7.6% of the 64,227 developers surveyed were women [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=StackOverflow&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "Josh Terrell, Andrew Kofink, Justin Middleton, Clarissa Rainear, Emerson Murphy-Hill, Chris Parnin, Jon Stallings, \"Gender differences and bias in open source: Pull request acceptance of women versus men\", <em>PeerJ Computer Science</em>, vol. 3, 2017.", "title": "Gender differences and bias in open source: Pull request acceptance of women versus men", "context": [{"sec": "sec1", "text": " In a quantitative retrospective study, Terrell and colleagues showed that when women portray themselves as women in their GitHub profiles, their acceptance rate is lower than men's, yet when their gender is not visible, their acceptance rate is higher than men's [40].", "part": "1"}, {"sec": "sec2", "text": "We recently studied gender differences and bias in open source [40], largely by comparing the acceptance rate of pull requests from men and women on GitHub.", "part": "1"}, {"sec": "sec3b", "text": "We began with our prior dataset [40], which builds on GHTorrent data [17] mined from public GitHub data from June 7, 2010 to April 1, 2015.", "part": "1"}, {"sec": "sec3b", "text": " Therefore, the core part of our dataset remains the same that in our prior paper [40].", "part": "1"}, {"sec": "sec4b", "text": "As Hypotheses PIA 1 and 2 deal with the pull request evaluation process, we restrict our analyses to pull requests coming from outsiders [40] who do not have direct commit permission to the project, because such outsiders are more likely to have to demonstrate competence than people already trusted by the project.", "part": "1"}, {"sec": "sec4b", "text": " The rationale derives from Tsay and colleagues' finding that outsiders are less likely to have their PRs accepted [42] and Terrell and colleagues' finding that gender bias affects outsiders [40].", "part": "1"}, {"sec": "sec4b", "text": "For Hypothesis PIA 2, we restrict our analysis to outsider pull requests from users whose gender is likely visible to other users, using Terrell and colleagues' technique of selecting only users who (a) have chosen their own profile image, and (b) an automated tool can confidently guess their gender based on their display name [40].", "part": "1"}, {"sec": "sec4c", "text": " Moreover, women contribute to fewer organizations and fewer projects than men \\$(p <. 001)\\$, consistent with prior work about project contributions [40].", "part": "1"}, {"sec": "sec7a", "text": " In the context of pull requests, we use a metric used in a prior work to measure bias [40] to hypothesize:.", "part": "1"}, {"sec": "sec7a", "text": "While the measure in Hypothesis TOW 1 is validated in a prior work [40], the measures in Hypothesis TOW 2 are validated in Hypothesis PIA 2.", "part": "1"}, {"sec": "sec8", "text": " Another explanation for our Prove-It-Again result could be that women, although lower in number in GitHub, are more competent than men overall [40] and therefore, their work does not face as much push-back as men.", "part": "1"}, {"sec": "sec9", "text": " In the data that we adopted from Terrell and colleagues [40], developers could have misrepresented their genders on their Google+ accounts, or there could be bot accounts with arbitrarily assigned genders with a Google+ profile.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.7717/peerj-cs.111", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+differences+and+bias+in+open+source%3A+Pull+request+acceptance+of+women+versus+men&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "Mike Thelwall, Kevan Buckley, Georgios Paltoglou, Di Cai, Arvid Kappas, \"Sentiment strength detection in short informal text\", <em>Journal of the Association for Information Science and Technology</em>, vol. 61, no. 12, pp. 2544-2558, 2010.", "title": "Sentiment strength detection in short informal text", "context": [{"sec": "sec9", "text": " Furthermore, we ran another cross-check with a commonly used tool named Sen-tiStrength [41].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/asi.21416", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sentiment+strength+detection+in+short+informal+text&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Jason Tsay, Laura Dabbish, James Herbsleb, \"Influence of social and technical factors for evaluating contribution in GitHub\", <em>Proceedings of the 36th international conference on Software engineering</em>, pp. 356-366, 2014.", "title": "Influence of social and technical factors for evaluating contribution in GitHub", "context": [{"sec": "sec4b", "text": " The rationale derives from Tsay and colleagues' finding that outsiders are less likely to have their PRs accepted [42] and Terrell and colleagues' finding that gender bias affects outsiders [40].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568315", "abstract": "Open source software is commonly portrayed as a meritocracy, where decisions are based solely on their technical merit. However, literature on open source suggests a complex social structure underlying the meritocracy. Social work environments such as GitHub make the relationships between users and between users and work artifacts transparent. This transparency enables developers to better use information such as technical value and social connections when making work decisions. We present a stu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Influence+of+social+and+technical+factors+for+evaluating+contribution+in+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "Bogdan Vasilescu, Andrea Capiluppi, Alexander Serebrenik, \"Gender representation and online participation: A quantitative study\", <em>Interacting with Computers</em>, vol. 26, no. 5, pp. 488-511, 2013.", "title": "Gender, representation and online participation: A quantitative study", "context": [{"sec": "sec2", "text": " Vasilescu and colleagues' study of Stack Overflow, a question-answer site for programmers, found that women disengage from the platform sooner than men, even though they have similar activity levels [43].", "part": "1"}], "links": {"documentLink": "/document/8154879", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8154879", "abstract": "Online communities are flourishing as social meeting web spaces for users and peer community members. Different online communities require different levels of competence for participants to join, and scattered evidence suggests that females and minorities as participants can be under-represented. Additional anecdotal evidence suggests that women withdraw from unfriendly online communities. Owing to the limited amount of empirical evidence on the matter, this paper provides a quantitative study o...", "pdfSize": "1076KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender%2C+representation+and+online+participation%3A+A+quantitative+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "Vasilescu Bogdan, Posnett Daryl, Ray Baishakhi, Mark GJ van den Brand, Serebrenik Alexander, Devanbu Premkumar, Filkov Vladimir, \"Gender and tenure diversity in GitHub teams\", <em>Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems</em>, pp. 3789-3798, 2015.", "title": "Gender and tenure diversity in GitHub teams", "context": [{"sec": "sec1", "text": " In a software engineering context, Vasilescu and colleagues study of GitHub found that gender diversity is a significant and positive predictor of software development productivity [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gender+and+tenure+diversity+in+GitHub+teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "Wang Hao, Jorge A Castanon, \"Sentiment expression via emoticons on social media\", <em>Big Data (Big Data) 2015 IEEE International Conference</em>, pp. 2404-2408, 2015.", "title": "Sentiment expression via emoticons on social media", "context": [{"sec": "sec5b4", "text": " For emoticons, we use Wang and colleagues' list of the 34 most frequently used emoticons [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sentiment+expression+via+emoticons+on+social+media&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "Joan C Williams, Stephanie Bornstein, \"Evolution of fred: Family responsibilities discrimination and developments in the law of stereotyping and implicit bias\", <em>Hastings LJ</em>, vol. 59, 2007.", "title": "Evolution of fred: Family responsibilities discrimination and developments in the law of stereotyping and implicit bias", "context": [{"sec": "sec6", "text": "Williams and Dempsey define the Maternal Wall effect as the bias against mothers wherein their coworkers perceive a choice without compromise: either the mothers continue to work and neglect their family, making the mother less likable, or the mother prioritize family over work, making them less reliable in the workplace [46].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evolution+of+fred%3A+Family+responsibilities+discrimination+and+developments+in+the+law+of+stereotyping+and+implicit+bias&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "Joan C Williams, Rachel Dempsey, <em>What works for women at work</em>, 2014.", "title": "What works for women at work", "context": [{"sec": "sec1", "text": " To focus our investigation, we examined the four effects of gender bias described in Williams and Dempsey's work [47].", "part": "1"}, {"sec": "sec4", "text": "The first effect of bias that we investigate is what Williams and Dempsey call Prove-it-Again, where a member of a group that doesn't align with stereotypes is measured at a stricter standard than those who do align with the stereotypes and consequently has to provide more evidence to demonstrate competence [6], [47].", "part": "1"}, {"sec": "sec4a4", "text": " When the Prove-It-Again effect is present, one strategy that women might take, consciously or subconsciously, is to focus their efforts on known environments so that they do not have to go through proving themselves repeatedly in new environments [47].", "part": "1"}, {"sec": "sec5", "text": " To quote one woman interviewed by Williams and Dempsey [47],.", "part": "1"}, {"sec": "sec6a", "text": " We instead measure a second-order effect of Maternal Wall, wherein we hypothesize mothers are more likely to react to the knowledge of this effect by not revealing the fact that they had children, in fear that their coworkers and employers would view them and their priorities differently [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+works+for+women+at+work&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "Yenchun Wu, Wei-Hung Chang, Chih-Hung Yuan, <em>Do facebook profile pictures reflect user's personality?</em>, vol. 51, pp. 880-889, 2015.", "title": "Do facebook profile pictures reflect user's personality?", "context": [{"sec": "sec6a", "text": " However, GitHub still supports other ways of personal expression, such as a user's choice of profile picture, as is common on other social media [48].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+facebook+profile+pictures+reflect+user%27s+personality%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "Yue Yu, Huaimin Wang, Vladimir Filkov, Premkumar Devanbu, Bogdan Vasilescu, \"Wait for it: Determinants of pull request evaluation latency on GitHub\", <em>Mining software repositories (MSR) 2015 IEEE/ACM 12th working conference</em>, pp. 367-371, 2015.", "title": "Wait for it: Determinants of pull request evaluation latency on GitHub", "context": [{"sec": "sec4a1", "text": " When submitting a PR, developers can provide a description that justifies the PR [49].", "part": "1"}], "links": {"documentLink": "/document/7180096", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180096", "abstract": "The pull-based development model, enabled by git and popularised by collaborative coding platforms like Bit Bucket, Gitorius, and GitHub, is widely used in distributed software teams. While this model lowers the barrier to entry for potential contributors (since anyone can submit pull requests to any repository), it also increases the burden on integrators (i.e., Members of a project&#39;s core team, responsible for evaluating the proposed changes and integrating them into the main development line)...", "pdfSize": "142KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Wait+for+it%3A+Determinants+of+pull+request+evaluation+latency+on+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "Stuart Zweben, Betsy Bizot, \"2017 taulbee survey\", <em>Computing</em>, vol. 29, no. 5, 2017.", "title": "2017 taulbee survey", "context": [{"sec": "sec1", "text": " According to the most recent Taulbee survey by the Computing Research Association, only about 18.1% of bachelor's degrees are awarded to women [50].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=2017+taulbee+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812110", "articleId": "8812110", "startPage": "700", "endPage": "711", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 105}}
{"title": "Training Binary Classifiers as Data Structure Invariants", "authors": [{"name": "Facundo Molina", "affiliation": "CONICET and University of Rio Cuarto, Argentina", "firstName": "Facundo", "lastName": "Molina", "id": "37086463329"}, {"name": "Renzo Degiovanni", "affiliation": "SnT, University of Luxembourg, Luxembourg", "firstName": "Renzo", "lastName": "Degiovanni", "id": "37085359439"}, {"name": "Pablo Ponzio", "affiliation": "CONICET and University of Rio Cuarto, Argentina", "firstName": "Pablo", "lastName": "Ponzio", "id": "37086461492"}, {"name": "Germ\u00e1n Regis", "affiliation": "University of Rio Cuarto, Argentina", "firstName": "Germ\u00e1n", "lastName": "Regis", "id": "37086159178"}, {"name": "Nazareno Aguirre", "affiliation": "CONICET and University of Rio Cuarto, Argentina", "firstName": "Nazareno", "lastName": "Aguirre", "id": "37550110300"}, {"name": "Marcelo Frias", "affiliation": "CONICET and Buenos Aires Institute of Technology, Argentina", "firstName": "Marcelo", "lastName": "Frias", "id": "38181048800"}], "abstract": "We present a technique to distinguish valid from invalid data structure objects. The technique is based on building an artificial neural network, more precisely a binary classifier, and training it to identify valid and invalid instances of a data structure. The obtained classifier can then be used in place of the data structure's invariant, in order to attempt to identify (in)correct behaviors in programs manipulating the structure. In order to produce the valid objects to train the network, an assumed-correct set of object building routines is randomly executed. Invalid instances are produced by generating values for object fields that \"break\" the collected valid values, i.e., that assign values to object fields that have not been observed as feasible in the assumed-correct executions that led to the collected valid instances. We experimentally assess this approach, over a benchmark of data structures. We show that this learning technique produces classifiers that achieve significantly better accuracy in classifying valid/invalid objects compared to a technique for dynamic invariant detection, and leads to improved bug finding.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Data structures", "Tools", "Java", "Computer bugs", "Software", "Neural networks", "Test pattern generators"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["data structures", "learning (artificial intelligence)", "neural nets", "pattern classification", "program debugging", "program testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["data structure invariants", "invalid data structure objects", "artificial neural network", "invalid instances", "object building routines", "assign values", "learning technique", "dynamic invariant detection", "valid instances", "binary classifiers training", "bug finding", "valid data structure objects"]}, {"type": "Author Keywords ", "kwd": ["Specification inference", "Machine learning", "Bug finding"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00084", "ref": [{"order": "1", "text": "<em>Fibonacci heap implementation from the graphmaker library.</em>,  [online]  Available: https://github.com/nlfiedler/graphmaker.", "title": "Fibonacci heap implementation from the graphmaker library.", "context": [{"sec": "sec1", "text": " Finally, we also compare our object classifiers with invariants produced by Daikon, in bug finding through test generation, for a number of case studies involving data structures, taken from the literature: schedule from the SIR repository [12], an implementation of n-ary trees in the ANTLR parser generator, a red-black tree implementation of integer sets introduced in [42], binary search trees and binomial heaps from the evaluation performed in [14], and fibonacci heaps from the graphmaker library [1].", "part": "1"}, {"sec": "sec5", "text": " To evaluate it, we took buggy implementations of data structures from the literature: the scheduler implementation from the SIR repository [12], an implementation of \\$n\\$ -ary trees that is part of the ANTLR parser generator, implementations of routines of a set of integers, over red black trees, with seeded bugs, presented in [42], binary search trees and binomial heaps used in the empirical evaluation in [14] containing one real bug each, and a fibonacci heap implementation taken from [1], containing a real bug.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fibonacci+heap+implementation+from+the+graphmaker+library.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Home page of the korat test generation tool.</em>,  [online]  Available: http://korat.sourceforge.net.", "title": "Home page of the korat test generation tool.", "context": [{"sec": "sec5", "text": " We took all case studies accompanying the Korat distribution [8] (available in [2]), that involve various data structures of varying complexities for which class invariants are provided (notice that Korat requires class invariants expressed as Java predicates for test input generation [8]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Home+page+of+the+korat+test+generation+tool.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Replication package of the object (in) validity learning approach</em>,  [online]  Available: https://sites.google.com/site/learninginvariants.", "title": "Replication package of the object (in) validity learning approach", "context": [{"sec": "sec5", "text": " Further details can be found in the experiments site [3].", "part": "1"}, {"sec": "sec5", "text": " Again, a sample of the structures and scopes is shown; more information can be found in the experiments site [3].", "part": "1"}, {"sec": "sec5", "text": "All the experiments presented in this section can be reproduced following the instructions found in the site of the replication package of our approach [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Replication+package+of+the+object+%28in%29+validity+learning+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "Abad Pablo, Aguirre Nazareno, Valeria S. Bengolea, Daniel Ciolek, Marcelo F. Frias, Juan P. Galeotti, Tom Maibaum, Mariano M. Moscato, Nicol\u00e1s Rosner, Ignacio Vissani, \"Improving test generation under rich contracts by tight bounds and incremental SAT solving\", <em>Sixth IEEE International Conference on Software Testing Verification and Validation ICST 2013</em>, pp. 21-30, March 18-22, 2013.", "title": "Improving test generation under rich contracts by tight bounds and incremental SAT solving", "context": [{"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+test+generation+under+rich+contracts+by+tight+bounds+and+incremental+SAT+solving&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "Mike Barnett, Howard Barringer, Yli\u00e8s Falcone, Bernd Finkbeiner, Klaus Havelund, Insup Lee, Gordon J. Pace, Grigore Rosu, Oleg Sokolsky, Nikolai Tillmann, \"Code contracts for. net: Runtime verification and so much more\", <em>Runtime Verification - First International Conference RV 2010</em>, vol. 6418, pp. 16-17, November 1-4, 2010.", "title": "Code contracts for. net: Runtime verification and so much more", "context": [{"sec": "sec2a", "text": " Other languages support design-by-contract [25] and assertions, invariants among them, via special languages and libraries, such as JML [9] for Java and Code Contracts [5] for.", "part": "1"}, {"sec": "sec7", "text": " NET [5], among others.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-16612-9_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+contracts+for.+net%3A+Runtime+verification+and+so+much+more&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "Earl T. Barr, Mark Harman, Phil McMinn, Muzammil Shahbaz, Shin Yoo, \"The oracle problem in software testing: A survey\", <em>IEEE Trans. Software Eng.</em>, vol. 41, no. 5, pp. 507-525, 2015.", "title": "The oracle problem in software testing: A survey", "context": [{"sec": "sec1", "text": "Given the current advances in automated program analysis, it is now possible to efficiently produce large sets of program inputs, as well as examining very large sets of program executions [8], [14], [29], [30], but effectively deciding whether the behavior of software is correct or not remains a problem in this context, that mainly depends on the provision of software specifications (i.e., specified oracles in the terminology of [6]).", "part": "1"}, {"sec": "sec7", "text": "The oracle problem has been studied by many researchers, and techniques to tackling it in different ways, have been proposed [6].", "part": "1"}, {"sec": "sec7", "text": " Our approach is more closely related to techniques for oracle derivation [6], more precisely, for specification inference.", "part": "1"}], "links": {"documentLink": "/document/6963470", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6963470", "abstract": "Testing involves examining the behaviour of a system in order to discover potential faults. Given an input for a system, the challenge of distinguishing the corresponding desired, correct behaviour from potentially incorrect behavior is called the \u201ctest oracle problem\u201d. Test oracle automation is important to remove a current bottleneck that inhibits greater overall test automation. Without test oracle automation, the human has to determine whether observed behaviour is correct. The literature on...", "pdfSize": "1052KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+oracle+problem+in+software+testing%3A+A+survey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "James Bergstra, Yoshua Bengio, \"Random search for hyper-parameter optimization\", <em>J. Mach. Learn. Res.</em>, vol. 13, pp. 281-305, February 2012.", "title": "Random search for hyper-parameter optimization", "context": [{"sec": "sec4c", "text": " Known algorithms to automatically select hyperparameters are grid search and random search; we use random search due to its ability to reduce the validation set error faster than grid search [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Random+search+for+hyper-parameter+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "Chandrasekhar Boyapati, Sarfraz Khurshid, Darko Marinov, Phyllis G. Frankl, \"Korat: automated testing based on java predicates\", <em>Proceedings of the International Symposium on Software Testing and Analysis ISSTA 2002</em>, pp. 123-133, July 22\u201324, 2002.", "title": "Korat: automated testing based on java predicates", "context": [{"sec": "sec1", "text": "Given the current advances in automated program analysis, it is now possible to efficiently produce large sets of program inputs, as well as examining very large sets of program executions [8], [14], [29], [30], but effectively deciding whether the behavior of software is correct or not remains a problem in this context, that mainly depends on the provision of software specifications (i.e., specified oracles in the terminology of [6]).", "part": "1"}, {"sec": "sec2a", "text": " Finally, various programming methodologies (e.g., [22]) and analysis tools (e.g., [29], [8]) can exploit class invariants expressed as Java predicates, i.e., via boolean methods that check internal object consistency.", "part": "1"}, {"sec": "sec2b", "text": " Adopting this notion of object identifier allows us to have a canonical (isomorphism-free [18]) representation for each structure shape (a similar symmetry breaking approach is also present in other approaches, e.g., [8]).", "part": "1"}, {"sec": "sec4b", "text": " In order to encode object states as vectors, we adopt the candidate vector format of Korat [8].", "part": "1"}, {"sec": "sec5", "text": " We took all case studies accompanying the Korat distribution [8] (available in [2]), that involve various data structures of varying complexities for which class invariants are provided (notice that Korat requires class invariants expressed as Java predicates for test input generation [8]).", "part": "1"}, {"sec": "sec5", "text": " We then used for each class \\$C\\$ its Korat invariant \\$I\\$ to generate all valid objects within a given scope \\$k\\$ (i.e., all valid objects of size at most \\$k)\\$, using the Korat tool [8].", "part": "1"}, {"sec": "sec7", "text": " However, tools like Korat and Symbolic PathFinder, that require class invariants in the form of repOK routines to be provided, cannot be used with our learned classifiers, since they exploit the program structure of the invariant to drive the search for valid inputs [8], [30].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/566189.566191", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Korat%3A+automated+testing+based+on+java+predicates&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "Chalin Patrice, Joseph R. Kiniry, Gary T. Leavens, Erik Poll, S. Frank, Boer de, Marcello M. Bonsangue, Susanne Graf, Willem P. de Roever, \"Beyond assertions: Advanced specification and verification with JML and esc/java2\", <em>Formal Methods for Components and Objects 4th International Symposium FMCO 2005</em>, vol. 4111, pp. 342-363, November 1\u20134, 2005.", "title": "Beyond assertions: Advanced specification and verification with JML and esc/java2", "context": [{"sec": "sec2a", "text": " Other languages support design-by-contract [25] and assertions, invariants among them, via special languages and libraries, such as JML [9] for Java and Code Contracts [5] for.", "part": "1"}, {"sec": "sec3", "text": " If we had this invariant formally specified, we may check that it is indeed preserved with the aid of some automated analysis tools, e.g., some run-time assertion checker as that accompanying the JML toolset [9], or a test generation tool like Randoop [29].", "part": "1"}, {"sec": "sec7", "text": " Some tools use invariants for run time checking, notably the Eiffel programming language, that incorporates contracts as part of the programming language [26], the runtime assertion checker and static verifiers that use JML [9], Code Contracts for.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Beyond+assertions%3A+Advanced+specification+and+verification+with+JML+and+esc%2Fjava2&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "Christoph Csallner, Nikolai Tillmann, Yannis Smaragdakis, Wilhelm Sch\u00e4fer, Matthew B. Dwyer, Volker Gruhn, \"Dysy: dynamic symbolic execution for invariant inference\", <em>30th International Conference on Software Engineering (ICSE 2008)</em>, pp. 281-290, May 10\u201318, 2008.", "title": "Dysy: dynamic symbolic execution for invariant inference", "context": [{"sec": "sec1", "text": " Examples of techniques that derive specifications implicit in code are Daikon [13], JWalk [38], and related tools [10], [37].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368127", "abstract": "Dynamically discovering likely program invariants from concrete test executions has emerged as a highly promising software engineering technique. Dynamic invariant inference has the advantage of succinctly summarizing both &#34;expected&#34; program inputs and the subset of program behaviors that is normal under those inputs. In this paper, we introduce a technique that can drastically increase the relevance of inferred invariants, or reduce the size of the test suite required to obtain good invariants....", "pdfSize": "174KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dysy%3A+dynamic+symbolic+execution+for+invariant+inference&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "Greg Dennis, Felix Sheng-Ho Chang, Daniel Jackson, Lori L. Pollock, Mauro Pezz\u00e8, \"Modular verification of code with SAT\", <em>Proceedings of the ACM/SIGSOFT International Symposium on Software Testing and Analysis ISSTA 2006</em>, pp. 109-120, July 17\u201320, 2006.", "title": "Modular verification of code with SAT", "context": [{"sec": "sec2b", "text": "Various tools for program analysis that employ SAT solving as underlying technology adopt a relational program state semantics (e.g., [11], [14]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1146238.1146251", "abstract": "An approach is described for checking the methods of a class against a full specification. It shares with traditional model checking the idea of exhausting the entire space of executions within some finite bounds, and with traditional verification the idea of modular analysis, in which a method is analyzed, in isolation, for all possible calling contexts.The analysis involves an automatic two-phase reduction: first, to an intermediate form in relational logic (using a new encoding described here...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modular+verification+of+code+with+SAT&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "Do Hyunsook, Sebastian G. Elbaum, Gregg Rothermel, \"Supporting controlled experimentation with testing techniques: An infrastructure and its potential impact\", <em>Empirical Software Engineering</em>, vol. 10, no. 4, pp. 405-435, 2005.", "title": "Supporting controlled experimentation with testing techniques: An infrastructure and its potential impact", "context": [{"sec": "sec1", "text": " Finally, we also compare our object classifiers with invariants produced by Daikon, in bug finding through test generation, for a number of case studies involving data structures, taken from the literature: schedule from the SIR repository [12], an implementation of n-ary trees in the ANTLR parser generator, a red-black tree implementation of integer sets introduced in [42], binary search trees and binomial heaps from the evaluation performed in [14], and fibonacci heaps from the graphmaker library [1].", "part": "1"}, {"sec": "sec5", "text": " To evaluate it, we took buggy implementations of data structures from the literature: the scheduler implementation from the SIR repository [12], an implementation of \\$n\\$ -ary trees that is part of the ANTLR parser generator, implementations of routines of a set of integers, over red black trees, with seeded bugs, presented in [42], binary search trees and binomial heaps used in the empirical evaluation in [14] containing one real bug each, and a fibonacci heap implementation taken from [1], containing a real bug.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Supporting+controlled+experimentation+with+testing+techniques%3A+An+infrastructure+and+its+potential+impact&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "Michael D. Ernst, Jeff H. Perkins, Philip J. Guo, Stephen McCamant, Carlos Pacheco, Matthew S. Tschantz, Chen Xiao, \"The daikon system for dynamic detection of likely invariants\", <em>Sci. Comput. Program.</em>, vol. 69, no. 1-3, pp. 35-45, 2007.", "title": "The daikon system for dynamic detection of likely invariants", "context": [{"sec": "sec1", "text": " Examples of techniques that derive specifications implicit in code are Daikon [13], JWalk [38], and related tools [10], [37].", "part": "1"}, {"sec": "sec1", "text": " Daikon produces a set of candidate properties from a program definition, and infers likely invariants by observing program executions, and checking which of the candidate properties were not \u201cfalsified\u201d (violated) by any execution [13].", "part": "1"}, {"sec": "sec1", "text": " Daikon is limited to relatively simple program properties, and complex structural constraints such as acyclicity are beyond the scope of the technique [13].", "part": "1"}, {"sec": "sec1", "text": " In this context, we compare our technique with Daikon [13], a tool for dynamic invariant discovery.", "part": "1"}, {"sec": "sec5", "text": "In order to have a reference of the accuracy of our approach, we compare our learned object classifiers with invariants generated using Daikon [13].", "part": "1"}, {"sec": "sec7", "text": " Within this category, tools that perform specification inference from executions, like ours, include Daikon [13] and JWalk [38].", "part": "1"}, {"sec": "sec8", "text": " The technique is related to other, similarly motivated, approaches [13], [38], in the sense that it explores dynamic software behaviours for the inference, but it also incorporates a technique for producing invalid objects, enabling the training of a neural network.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.scico.2007.01.015", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+daikon+system+for+dynamic+detection+of+likely+invariants&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "Juan P. Galeotti, Nicol\u00e1s Rosner, Carlos L\u00f3pez Pombo, Marcelo F. Frias, Paolo Tonella, Alessandro Orso, \"Analysis of invariants for efficient bounded verification\", <em>Proceedings of the Nineteenth International Symposium on Software Testing and Analysis ISSTA 2010</em>, pp. 25-36, July 12\u201316, 2010.", "title": "Analysis of invariants for efficient bounded verification", "context": [{"sec": "sec1", "text": "Given the current advances in automated program analysis, it is now possible to efficiently produce large sets of program inputs, as well as examining very large sets of program executions [8], [14], [29], [30], but effectively deciding whether the behavior of software is correct or not remains a problem in this context, that mainly depends on the provision of software specifications (i.e., specified oracles in the terminology of [6]).", "part": "1"}, {"sec": "sec1", "text": " Finally, we also compare our object classifiers with invariants produced by Daikon, in bug finding through test generation, for a number of case studies involving data structures, taken from the literature: schedule from the SIR repository [12], an implementation of n-ary trees in the ANTLR parser generator, a red-black tree implementation of integer sets introduced in [42], binary search trees and binomial heaps from the evaluation performed in [14], and fibonacci heaps from the graphmaker library [1].", "part": "1"}, {"sec": "sec2b", "text": "Various tools for program analysis that employ SAT solving as underlying technology adopt a relational program state semantics (e.g., [11], [14]).", "part": "1"}, {"sec": "sec5", "text": " To evaluate it, we took buggy implementations of data structures from the literature: the scheduler implementation from the SIR repository [12], an implementation of \\$n\\$ -ary trees that is part of the ANTLR parser generator, implementations of routines of a set of integers, over red black trees, with seeded bugs, presented in [42], binary search trees and binomial heaps used in the empirical evaluation in [14] containing one real bug each, and a fibonacci heap implementation taken from [1], containing a real bug.", "part": "1"}, {"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1831708.1831712", "abstract": "SAT-based bounded verification of annotated code consists of translating the code together with the annotations to a propositional formula, and analyzing the formula for specification violations using a SAT-solver. If a violation is found, an execution trace exposing the error is exhibited. Code involving linked data structures with intricate invariants is particularly hard to analyze using these techniques. In this article we present TACO, a prototype tool which implements a novel, general and ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analysis+of+invariants+for+efficient+bounded+verification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Milos Gligoric, Tihomir Gvero, Vilas Jagannath, Sarfraz Khurshid, Viktor Kuncak, Darko Marinov, Jeff Kramer, Bishop Judith, Premkumar T. Devanbu, Sebasti\u00e1n Uchitel, \"Test generation through programming in UDIT A\", <em>Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1 ICSE 2010</em>, pp. 225-234, 1\u20138 May 2010.", "title": "Test generation through programming in UDIT A", "context": [{"sec": "sec4a", "text": "In order to build valid instances, any input generation technique that can produce objects from a class interface, is suitable, including model checking based ones [20], [15], and random generation [29], [27], for instance (in our experiments we will use random generation).", "part": "1"}, {"sec": "sec4a", "text": " Some techniques require the scope \\$a\\$ priori for generation (e.g., [15]), while in others the scope can be derived from the generated instances, e.g., looking at the largest produced object, or the range of produced values.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806835", "abstract": "We present an approach for describing tests using non-deterministic test generation programs. To write such programs, we introduce UDITA, a Java-based language with non-deterministic choice operators and an interface for generating linked structures. We also describe new algorithms that generate concrete tests by efficiently exploring the space of all executions of non-deterministic UDITA programs. We implemented our approach and incorporated it into the official, publicly available repository o...", "pdfSize": "249KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Test+generation+through+programming+in+UDIT+A&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "Isabelle Guyon, Andr\u00e9 Elisseeff, \"An introduction to variable and feature selection\", <em>Journal of Machine Learning Research</em>, vol. 3, no. 1157-1182, 2003.", "title": "An introduction to variable and feature selection", "context": [{"sec": "sec8", "text": " The performance of artificial neural networks can also be improved by feature engineering [16], a mechanism we have not yet explored.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+introduction+to+variable+and+feature+selection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Daniel Jackson, Software Abstractions - Logic Language and Analysis., MIT Press, 2006.", "title": "Software Abstractions - Logic, Language, and Analysis.", "context": [{"sec": "sec2a", "text": " Languages such as Alloy [17] have also been employed to express class invariants, as done, e.g., in [19].", "part": "1"}, {"sec": "sec2b", "text": " This is typically achieved in the context of bounded analysis by a notion of scope, in the sense of [17].", "part": "1"}, {"sec": "sec7", "text": "The notion of field extension as a compact representation of a collection of generated structures was put forward in [33], and originates in the relational semantics of signature fields in Alloy [17], and in the notions of upper and lower bounds introduced with the KodKod engine [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+Abstractions+-+Logic%2C+Language%2C+and+Analysis.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "Daniel Jackson, Somesh Jha, Craig Damon, \"Isomorph-free model enumeration: A new method for checking relational specifications\", <em>ACM Trans. Program. Lang. Syst.</em>, vol. 20, no. 2, pp. 302-343, 1998.", "title": "Isomorph-free model enumeration: A new method for checking relational specifications", "context": [{"sec": "sec2b", "text": " Adopting this notion of object identifier allows us to have a canonical (isomorphism-free [18]) representation for each structure shape (a similar symmetry breaking approach is also present in other approaches, e.g., [8]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/276393.276396", "abstract": "Software specifications often involve data structures with huge numbers of value, and consequently they cannot be checked using standard state exploration or model-checking techniques. Data structures can be expressed with binary relations, and operations over such structures can be expressed as formulae involving relational variables. Checking properties such as preservation of an invariant thus reduces to determining the validity of a formula or, equivalently, finding a model (of the formula&#39;s...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Isomorph-free+model+enumeration%3A+A+new+method+for+checking+relational+specifications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "Shadi Abdul Khalek, Guowei Yang, Lingming Zhang, Darko Marinov, Sarfraz Khurshid, Perry Alexander, Corina S. Pasareanu, John G. Hosking, \"Testera: A tool for testing java programs using alloy specifications\", <em>26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011)</em>, pp. 608-611, November 6\u201310, 2011.", "title": "Testera: A tool for testing java programs using alloy specifications", "context": [{"sec": "sec2a", "text": " Languages such as Alloy [17] have also been employed to express class invariants, as done, e.g., in [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Testera%3A+A+tool+for+testing+java+programs+using+alloy+specifications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Khurshid Sarfraz, Corina S. Pasareanu, Willem Visser, Hubert Garavel, John Hatcliff, \"Generalized symbolic execution for model checking and testing\", <em>Tools and Algorithms for the Construction and Analysis of Systems 9th International Conference TACAS 2003 Held as Part of the Joint European Conferences on Theory and Practice of Software ETAPS 2003</em>, vol. 2619, pp. 553-568, April 7\u201311, 2003.", "title": "Generalized symbolic execution for model checking and testing", "context": [{"sec": "sec1", "text": " This is a standard approach in various contexts, in particular in some program verification and test generation techniques [28], [24], [20] (Daikon and JWalk in essence also work under this assumption).", "part": "1"}, {"sec": "sec4a", "text": " This assumption is in fact rather common in verification and test generation environments, that produce instances from a class's public interface (see, e.g., [20], [28], [24]).", "part": "1"}, {"sec": "sec4a", "text": "In order to build valid instances, any input generation technique that can produce objects from a class interface, is suitable, including model checking based ones [20], [15], and random generation [29], [27], for instance (in our experiments we will use random generation).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generalized+symbolic+execution+for+model+checking+and+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Claire Le Goues, ThanhVu Nguyen, Stephanie Forrest, Westley Weimer, \"Genprog: A generic method for automatic software repair\", <em>IEEE Trans. Software Eng.</em>, vol. 38, no. 1, pp. 54-72, 2012.", "title": "Genprog: A generic method for automatic software repair", "context": [{"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "links": {"documentLink": "/document/6035728", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6035728", "abstract": "This paper describes GenProg, an automated method for repairing defects in off-the-shelf, legacy programs without formal specifications, program annotations, or special coding practices. GenProg uses an extended form of genetic programming to evolve a program variant that retains required functionality but is not susceptible to a given defect, using existing test suites to encode both the defect and required functionality. Structural differencing algorithms and delta debugging reduce the differe...", "pdfSize": "3123KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Genprog%3A+A+generic+method+for+automatic+software+repair&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Barbara Liskov, John V. Guttag, Program Development in Java - Abstraction Specification and Object-Oriented Design., Addison-Wesley, 2001.", "title": "Program Development in Java - Abstraction, Specification, and Object-Oriented Design.", "context": [{"sec": "sec1", "text": "In this paper, we deal with the specification inference problem, in a way similar in motivation to techniques like Daikon and JWalk, but targeting object validity classifiers for complex objects, like class invariants [25], [22] for data structures.", "part": "1"}, {"sec": "sec2a", "text": "One of the keys of object orientation is the emphasis that this programming paradigm puts into data abstraction [22].", "part": "1"}, {"sec": "sec2a", "text": " These assumptions are often implicit, since they are not a necessary part of the definition of the data representation, in most programming languages [22].", "part": "1"}, {"sec": "sec2a", "text": "A class invariant [25], or representation invariant [22], is a predicate inv that, given an object \\$o\\$ of class \\$C\\$, states whether \\$o\\$ is a valid representation of the concept that \\$C\\$ captures or not.", "part": "1"}, {"sec": "sec2a", "text": " Finally, various programming methodologies (e.g., [22]) and analysis tools (e.g., [29], [8]) can exploit class invariants expressed as Java predicates, i.e., via boolean methods that check internal object consistency.", "part": "1"}, {"sec": "sec3", "text": " This includes guaranteeing that all public constructors in SinglyLinkedList build objects that satisfy the previously stated class invariant [22], and public methods in the class (that may include various methods for element insertion, deletion and retrieval) preserve this invariant.", "part": "1"}, {"sec": "sec8", "text": " Invariants are becoming more common in program development, with methodologies that incorporate these [25], [22], and tools that can significantly exploit them when available for useful analyses.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program+Development+in+Java+-+Abstraction%2C+Specification%2C+and+Object-Oriented+Design.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "Kurt Mehlhorn, Peter Sanders, Algorithms and Data Structures: The Basic Toolbox., Springer, 2008.", "title": "Algorithms and Data Structures: The Basic Toolbox.", "context": [{"sec": "sec2a", "text": " For instance, assume that the programmer's intention with singly linked lists is to represent sequences of integers using acyclic linked lists, with a dummy (sentinel) node [23], where size must hold the number of elements in the sequence, i.e., it must coincide with the number of non-dummy nodes in the list.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Algorithms+and+Data+Structures%3A+The+Basic+Toolbox.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "Florian Merz, Stephan Falke, Carsten Sinz, Rajeev Joshi, Peter M\u00fcller, Andreas Printelski, \"LLBMC: bounded model checking of C and C++ programs using a compiler IR\", <em>Verified Software: Theories Tools Experiments-4th International Conference VSTTE 2012</em>, vol. 7152, pp. 146-161, January 28\u201329, 2012.", "title": "LLBMC: bounded model checking of C and C++ programs using a compiler IR", "context": [{"sec": "sec1", "text": " This is a standard approach in various contexts, in particular in some program verification and test generation techniques [28], [24], [20] (Daikon and JWalk in essence also work under this assumption).", "part": "1"}, {"sec": "sec4a", "text": " This assumption is in fact rather common in verification and test generation environments, that produce instances from a class's public interface (see, e.g., [20], [28], [24]).", "part": "1"}, {"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-27705-4_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=LLBMC%3A+bounded+model+checking+of+C+and+C%2B%2B+programs+using+a+compiler+IR&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "Bertrand Meyer, Object-Oriented Software Construction, Prentice-Hall, 1997.", "title": "Object-Oriented Software Construction", "context": [{"sec": "sec1", "text": "In this paper, we deal with the specification inference problem, in a way similar in motivation to techniques like Daikon and JWalk, but targeting object validity classifiers for complex objects, like class invariants [25], [22] for data structures.", "part": "1"}, {"sec": "sec2a", "text": "A class invariant [25], or representation invariant [22], is a predicate inv that, given an object \\$o\\$ of class \\$C\\$, states whether \\$o\\$ is a valid representation of the concept that \\$C\\$ captures or not.", "part": "1"}, {"sec": "sec2a", "text": " Other languages support design-by-contract [25] and assertions, invariants among them, via special languages and libraries, such as JML [9] for Java and Code Contracts [5] for.", "part": "1"}, {"sec": "sec8", "text": " Invariants are becoming more common in program development, with methodologies that incorporate these [25], [22], and tools that can significantly exploit them when available for useful analyses.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Object-Oriented+Software+Construction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "Bertrand Meyer, \"Design by contract: The eiffel method\", <em>TOOLS 1998: 26th International Conference on Technology of Object-Oriented Languages and Systems</em>, pp. 446, 3\u20137 August 1998.", "title": "Design by contract: The eiffel method", "context": [{"sec": "sec2a", "text": " The Eiffel programming language [26], in particular, includes built-in support for expressing class invariants as assertions under a specific invariant clause.", "part": "1"}, {"sec": "sec7", "text": " Some tools use invariants for run time checking, notably the Eiffel programming language, that incorporates contracts as part of the programming language [26], the runtime assertion checker and static verifiers that use JML [9], Code Contracts for.", "part": "1"}], "links": {"documentLink": "/document/711043", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=711043", "pdfSize": "12KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Design+by+contract%3A+The+eiffel+method&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "Bertrand Meyer, Ilinca Ciupa, Andreas Leitner, Lisa Ling Liu, Jan van Leeuwen, Giuseppe F. Italiano, Wiebe van der Hoek, Christoph Meinel, Harald Sack, Frantisek Plasil, \"Automatic testing of object-oriented software\", <em>SOFSEM 2007: Theory and Practice of Computer Science 33rd Conference on Current Trends in Theory and Practice of Computer Science</em>, vol. 4362, pp. 114-129, January 20\u201326, 2007.", "title": "Automatic testing of object-oriented software", "context": [{"sec": "sec4a", "text": "In order to build valid instances, any input generation technique that can produce objects from a class interface, is suitable, including model checking based ones [20], [15], and random generation [29], [27], for instance (in our experiments we will use random generation).", "part": "1"}, {"sec": "sec7", "text": " Some examples are Randoop [29] and AutoTest [27].", "part": "1"}, {"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-69507-3_9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+testing+of+object-oriented+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "Aditya V. Nori, Sriram K. Rajamani, SaiDeep Tetali, Aditya V. Thakur, Stefan Kowalewski, Anna Philippou, \"The yogiproject: Software property checking via static analysis and testing\", <em>Tools and Algorithms for the Construction and Analysis of Systems 15th International Conference TACAS 2009 Held as Part of the Joint European Conferences on Theory and Practice of Software ETAPS 2009</em>, vol. 5505, pp. 178-181, March 22\u201329, 2009.", "title": "The yogiproject: Software property checking via static analysis and testing", "context": [{"sec": "sec1", "text": " This is a standard approach in various contexts, in particular in some program verification and test generation techniques [28], [24], [20] (Daikon and JWalk in essence also work under this assumption).", "part": "1"}, {"sec": "sec4a", "text": " This assumption is in fact rather common in verification and test generation environments, that produce instances from a class's public interface (see, e.g., [20], [28], [24]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+yogiproject%3A+Software+property+checking+via+static+analysis+and+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "Pacheco Carlos, Shuvendu K. Lahiri, Michael D. Ernst, Thomas Ball, \"Feedback-directed random test generation\", <em>29th International Conference on Software Engineering (ICSE 2007)</em>, pp. 75-84, May 20\u201326, 2007.", "title": "Feedback-directed random test generation", "context": [{"sec": "sec1", "text": "Given the current advances in automated program analysis, it is now possible to efficiently produce large sets of program inputs, as well as examining very large sets of program executions [8], [14], [29], [30], but effectively deciding whether the behavior of software is correct or not remains a problem in this context, that mainly depends on the provision of software specifications (i.e., specified oracles in the terminology of [6]).", "part": "1"}, {"sec": "sec2a", "text": " Finally, various programming methodologies (e.g., [22]) and analysis tools (e.g., [29], [8]) can exploit class invariants expressed as Java predicates, i.e., via boolean methods that check internal object consistency.", "part": "1"}, {"sec": "sec3", "text": " If we had this invariant formally specified, we may check that it is indeed preserved with the aid of some automated analysis tools, e.g., some run-time assertion checker as that accompanying the JML toolset [9], or a test generation tool like Randoop [29].", "part": "1"}, {"sec": "sec4a", "text": "In order to build valid instances, any input generation technique that can produce objects from a class interface, is suitable, including model checking based ones [20], [15], and random generation [29], [27], for instance (in our experiments we will use random generation).", "part": "1"}, {"sec": "sec7", "text": " Some examples are Randoop [29] and AutoTest [27].", "part": "1"}, {"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feedback-directed+random+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "Corina S. Pasareanu, Willem Visser, David H. Bushnell, Jaco Gelden-Huys, Peter C. Mehlitz, Neha Rungta, \"Symbolic pathfinder: integrating symbolic execution with model checking for java bytecode analysis\", <em>Autom. Softw. Eng.</em>, vol. 20, no. 3, pp. 391-425, 2013.", "title": "Symbolic pathfinder: integrating symbolic execution with model checking for java bytecode analysis", "context": [{"sec": "sec1", "text": "Given the current advances in automated program analysis, it is now possible to efficiently produce large sets of program inputs, as well as examining very large sets of program executions [8], [14], [29], [30], but effectively deciding whether the behavior of software is correct or not remains a problem in this context, that mainly depends on the provision of software specifications (i.e., specified oracles in the terminology of [6]).", "part": "1"}, {"sec": "sec7", "text": " However, tools like Korat and Symbolic PathFinder, that require class invariants in the form of repOK routines to be provided, cannot be used with our learned classifiers, since they exploit the program structure of the invariant to drive the search for valid inputs [8], [30].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-013-0122-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+pathfinder%3A+integrating+symbolic+execution+with+model+checking+for+java+bytecode+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "F. Pedregosa, G. Varoquaux, A. Gramfort, V. Michel, B. Thirion, O. Grisel, M. Blondel, P. Prettenhofer, R. Weiss, V. Dubourg, J. Vander-Plas, A. Passos, D. Cournapeau, M. Brucher, M. Perrot, E. Duch-Esnay, \"Scikit-learn: Machine learning in Python\", <em>Journal of Machine Learning Research</em>, vol. 12, pp. 2825-2830, 2011.", "title": "Scikit-learn: Machine learning in Python", "context": [{"sec": "sec4c", "text": "We use the Multi-layer Perceptron neural network implementation of the python scikit-learn package [31].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scikit-learn%3A+Machine+learning+in+Python&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "Pei Yu, Carlo A. Furia, Martin Nordio, Yi Wei, Bertrand Meyer, Andreas Zeller, \"Automated fixing of programs with contracts\", <em>IEEE Trans. Software Eng.</em>, vol. 40, no. 5, pp. 427-449, 2014.", "title": "Automated fixing of programs with contracts", "context": [{"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+fixing+of+programs+with+contracts&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "Ponzio Pablo, Aguirre Nazareno, Marcelo F. Frias, Willem Visser, Thomas Zimmermann, Jane Cleland-Huang, Zhendong Su, \"Field-exhaustive testing\", <em>Proceedings of the 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering FSE 2016</em>, pp. 908-919, November 13\u201318, 2016.", "title": "Field-exhaustive testing", "context": [{"sec": "sec7", "text": "The notion of field extension as a compact representation of a collection of generated structures was put forward in [33], and originates in the relational semantics of signature fields in Alloy [17], and in the notions of upper and lower bounds introduced with the KodKod engine [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Field-exhaustive+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "Stuart J. Russell, Peter Norvig, Artificial Intelligence - A Modern Approach (3. internat. ed.)., Pearson Education, 2010.", "title": "Artificial Intelligence - A Modern Approach (3. internat. ed.).", "context": [{"sec": "sec1", "text": " Firstly, it is based on the use of neural networks [34] for learning classifiers from valid and invalid objects, obtained from program executions.", "part": "1"}, {"sec": "sec1", "text": " Second, we take a benchmark of data structures for which class invariants and object builders (constructors and insertion routines) are provided; we generate object classifiers using the provided builders, and evaluate their precision and recall against the corresponding invariants on valid and invalid inputs, as is customary in the context of automated learning [34].", "part": "1"}, {"sec": "sec2c", "text": " Often, neural networks will have one hidden layer, since one layer is enough to approximate many continuous functions [34].", "part": "1"}, {"sec": "sec2c", "text": " Provided that one has a set of inputs for which the desired output is known (i.e., a set of known input-output pairs for \\$f)\\$, one can train an artificial neural network to approximate function \\$f\\$ by analyzing the difference between the expected output and the output obtained from the network for a known input, and producing (slight) changes to the weights so that, if the network would be fed with the same input again, its output would be \u201ccloser\u201d to the expected output [34] (a mechanism that is often employed for this task is backpropagation).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Artificial+Intelligence+-+A+Modern+Approach+%283.+internat.+ed.%29.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "Seyed Reza Shahamiri, Wan M. N. Wan-Kadir, Suhaimi Ibrahim, Siti Zaiton Mohd Hashim, \"Artificial neural networks as multi-networks automated test oracle\", <em>Autom. Softw. Eng.</em>, vol. 19, no. 3, pp. 303-334, 2012.", "title": "Artificial neural networks as multi-networks automated test oracle", "context": [{"sec": "sec7", "text": " The use of artificial neural networks for inferring specifications has been proposed before [36], [35]; these works, however, attempt to learn postcondition relations (I/O relations) from \u201cgolden versions\u201d of programs, i.e., assumed correct programs.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-011-0094-z", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Artificial+neural+networks+as+multi-networks+automated+test+oracle&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "Seyed Reza Shahamiri, Wan Mohd Nasir Wan-Kadir, Suhaimi Ibrahim, Siti Zaiton Mohd Hashim, \"An automated framework for software test oracle\", <em>Information & Software Technology</em>, vol. 53, no. 7, pp. 774-788, 2011.", "title": "An automated framework for software test oracle", "context": [{"sec": "sec7", "text": " The use of artificial neural networks for inferring specifications has been proposed before [36], [35]; these works, however, attempt to learn postcondition relations (I/O relations) from \u201cgolden versions\u201d of programs, i.e., assumed correct programs.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2011.02.006", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+automated+framework+for+software+test+oracle&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "Rahul Sharma, Alex Aiken, \"From invariant checking to invariant inference using randomized search\", <em>Formal Methods in System Design</em>, vol. 48, no. 3, pp. 235-256, 2016.", "title": "From invariant checking to invariant inference using randomized search", "context": [{"sec": "sec1", "text": " Examples of techniques that derive specifications implicit in code are Daikon [13], JWalk [38], and related tools [10], [37].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10703-016-0248-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=From+invariant+checking+to+invariant+inference+using+randomized+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "Anthony J. H. Simons, \"Jwalk: a tool for lazy systematic testing of java classes by design introspection and user interaction\", <em>Autom. Softw. Eng.</em>, vol. 14, no. 4, pp. 369-418, 2007.", "title": "Jwalk: a tool for lazy, systematic testing of java classes by design introspection and user interaction", "context": [{"sec": "sec1", "text": " Examples of techniques that derive specifications implicit in code are Daikon [13], JWalk [38], and related tools [10], [37].", "part": "1"}, {"sec": "sec1", "text": " JWalk also shares this limitation, and the learned oracles are more \u201cscenario-specific\u201d, i.e., closer to test assertions, than those produced by Daikon [38].", "part": "1"}, {"sec": "sec7", "text": " Within this category, tools that perform specification inference from executions, like ours, include Daikon [13] and JWalk [38].", "part": "1"}, {"sec": "sec8", "text": " The technique is related to other, similarly motivated, approaches [13], [38], in the sense that it explores dynamic software behaviours for the inference, but it also incorporates a technique for producing invalid objects, enabling the training of a neural network.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-007-0015-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jwalk%3A+a+tool+for+lazy%2C+systematic+testing+of+java+classes+by+design+introspection+and+user+interaction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "Emina Torlak, Daniel Jackson, \"Kodkod: A relational model finder\", <em>Orna Grumberg and Michael Huth editors Tools and Algorithms for the Construction and Analysis of Systems 13th International Conference TACAS 2007 Held as Part of the Joint European Conferences on Theory and Practice of Software ETAPS 2007</em>, vol. 4424, pp. 632-647, March 24 - April 1, 2007.", "title": "Kodkod: A relational model finder", "context": [{"sec": "sec2b", "text": "This notion of field extension is related to the concept of (upper) bound in KodKod [39], used with the purpose of optimizing the relational representation of fields in Alloy analyses.", "part": "1"}, {"sec": "sec7", "text": "The notion of field extension as a compact representation of a collection of generated structures was put forward in [33], and originates in the relational semantics of signature fields in Alloy [17], and in the notions of upper and lower bounds introduced with the KodKod engine [39].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-71209-1_49", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Kodkod%3A+A+relational+model+finder&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "Westley Weimer, ThanhVu Nguyen, Claire Le Goues, Stephanie Forrest, \"Automatically finding patches using genetic programming\", <em>31st International Conference on Software Engineering ICSE 2009</em>, pp. 364-374, May 16\u201324, 2009.", "title": "Automatically finding patches using genetic programming", "context": [{"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "links": {"documentLink": "/document/5070536", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070536", "abstract": "Automatic program repair has been a longstanding goal in software engineering, yet debugging remains a largely manual process. We introduce a fully automated method for locating and repairing bugs in software. The approach works on off-the-shelf legacy applications and does not require formal specifications, program annotations or special coding practices. Once a program fault is discovered, an extended form of genetic programming is used to evolve program variants until one is found that both r...", "pdfSize": "264KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+finding+patches+using+genetic+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "W. Eric, Wong Ruizhi, Gao Yihao, Li Rui Abreu, Franz Wotawa, \"A survey on software fault localization\", <em>IEEE Trans. Software Eng.</em>, vol. 42, no. 8, pp. 707-740, 2016.", "title": "A survey on software fault localization", "context": [{"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+on+software+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Razieh Nokhbeh Zaeem, Divya Gopinath, Sarfraz Khurshid, Kathryn S. McKinley, \"History-aware data structure repair using SAT\", <em>Cormac Flanagan and Barbara K\u00f6nig editors Tools and Algorithms for the Construction and Analysis of Systems-18th International Conference TACAS 2012 Held as Part of the European Joint Conferences on Theory and Practice of Software ETAPS 2012</em>, vol. 7214, pp. 2-17, March 24 - April 1, 2012.", "title": "History-aware data structure repair using SAT", "context": [{"sec": "sec1", "text": " Finally, we also compare our object classifiers with invariants produced by Daikon, in bug finding through test generation, for a number of case studies involving data structures, taken from the literature: schedule from the SIR repository [12], an implementation of n-ary trees in the ANTLR parser generator, a red-black tree implementation of integer sets introduced in [42], binary search trees and binomial heaps from the evaluation performed in [14], and fibonacci heaps from the graphmaker library [1].", "part": "1"}, {"sec": "sec5", "text": " To evaluate it, we took buggy implementations of data structures from the literature: the scheduler implementation from the SIR repository [12], an implementation of \\$n\\$ -ary trees that is part of the ANTLR parser generator, implementations of routines of a set of integers, over red black trees, with seeded bugs, presented in [42], binary search trees and binomial heaps used in the empirical evaluation in [14] containing one real bug each, and a fibonacci heap implementation taken from [1], containing a real bug.", "part": "1"}, {"sec": "sec5a", "text": " The bugs seeded in the red-black tree implementation from [42] all correspond to the insert method.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-28756-5_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=History-aware+data+structure+repair+using+SAT&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "Xiangyu Zhang, Neelam Gupta, Rajiv Gupta, Leon J. Osterweil, H. Dieter Rombach, Mary Lou Soffa, \"Locating faults through automated predicate switching\", <em>28th International Conference on Software Engineering (ICSE 2006)</em>, pp. 272-281, May 20\u201328, 2006.", "title": "Locating faults through automated predicate switching", "context": [{"sec": "sec8", "text": " In the context of program analysis, there is an increasing availability of powerful techniques, including test generation [29], [27], [4], bug finding [14], [24], fault localization [43], [41] and program fixing [40], [21], [32], for which the need for program specifications becomes crucial.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134324", "abstract": "Typically debugging begins when during a program execution a point is reached at which an obviously incorrect value is observed. A general and powerful approach to automated debugging can be based upon identifying modifications to the program state that will bring the execution to a successful conclusion. However, searching for arbitrary changes to the program state is difficult due to the extremely large search space. In this paper we demonstrate that by forcibly switching a predicate&#39;s outcome...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Locating+faults+through+automated+predicate+switching&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811951", "articleId": "8811951", "startPage": "759", "endPage": "770", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 86}}
{"title": "Symbolic Model Extraction for Web Application Verification", "authors": [{"name": "Ivan Bocic", "affiliation": "Dept. of Comput. Sci., Univ. of California, Santa Barbara, Santa Barbara, CA, USA", "firstName": "Ivan", "lastName": "Bocic", "id": "37074929500"}, {"name": "Tevfik Bultan", "affiliation": "Dept. of Comput. Sci., Univ. of California, Santa Barbara, Santa Barbara, CA, USA", "firstName": "Tevfik", "lastName": "Bultan", "id": "37283128300"}], "abstract": "Modern web applications use complex data models and access control rules which lead to data integrity and access control errors. One approach to find such errors is to use formal verification techniques. However, as a first step, most formal verification techniques require extraction of a formal model which is a difficult problem in itself due to dynamic features of modern languages, and it is typically done either manually, or using ad hoc techniques. In this paper, we present a technique called symbolic model extraction for extracting formal data models from web applications. The key ideas of symbolic model extraction are 1) to use the source language interpreter for model extraction, which enables us to handle dynamic features of the language, 2) to use code instrumentation so that execution of each instrumented piece of code returns the formal model that corresponds to that piece of code, 3) to instrument the code dynamically so that the models of methods that are created at runtime can also be extracted, and 4) to execute both sides of branches during instrumented execution so that all program behaviors can be covered in a single instrumented execution. We implemented the symbolic model extraction technique for the Rails framework and used it to extract data and access control models from web applications. Our experiments demonstrate that symbolic model extraction is scalable and extracts formal models that are precise enough to find bugs in real-world applications without reporting too many false positives.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Instruments", "Feature extraction", "Data models", "Data mining", "Rails", "Runtime", "Load modeling"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["authorisation", "data integrity", "formal verification"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["symbolic model extraction technique", "program behaviors", "source language interpreter", "formal verification techniques", "access control rules", "complex data models", "Web application verification"]}, {"type": "Author Keywords ", "kwd": ["Formal Verification", "Model Extraction", "Web Applications"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.72", "ref": [{"order": "1", "text": "<em>ekremkaraca/awesome-rails: A collection / list of awesome projects sites made with Rails</em>.", "title": "ekremkaraca/awesome-rails: A collection / list of awesome projects, sites made with Rails", "context": [{"sec": "sec5", "text": " We looked at the 25 most starred open-source Rails applications on Github according to the OpenSourceRails.com website [25], a compilation of open source Rails applications categorized by domain [1], and applications investigated by related work.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ekremkaraca%2Fawesome-rails%3A+A+collection+%2F+list+of+awesome+projects%2C+sites+made+with+Rails&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>activeadmin/activeadmin: The administration framework for Ruby on Rails applications.</em>, Aug. 2016,  [online]  Available: https://github.com/activeadmin/activeadmin.", "title": "activeadmin/activeadmin: The administration framework for Ruby on Rails applications.", "context": [{"sec": "sec2", "text": " Some of these libraries, such as ActiveAdmin [2], can even generate entire actions that are not present statically.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=activeadmin%2Factiveadmin%3A+The+administration+framework+for+Ruby+on+Rails+applications.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "I. Bocic, T. Bultan, \"Inductive verification of data model invariants for web applications\", <em>Proceedings of the 36th International Conference on Software Engineering (ICSE 2014)</em>, May 2014.", "title": "Inductive verification of data model invariants for web applications", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}, {"sec": "sec1", "text": "Some of this research specifically targets applications written in dynamically typed languages [17], [18], [3], [4].", "part": "1"}, {"sec": "sec2", "text": " As the target modeling language, we focus on Abstract Data Store Language (ADSL) which has been defined in our earlier work [3].", "part": "1"}, {"sec": "sec4", "text": " We used these models for two purposes: to verify data integrity [3] and access control [6] properties.", "part": "1"}, {"sec": "sec4b", "text": "For data integrity verification, we make an additional step to extract invariants [3].", "part": "1"}, {"sec": "sec5", "text": "We used symbolic model extraction to extract models from Rails applications in order to verify their data integrity [3]\u2013[5] and access control [6] properties.", "part": "1"}, {"sec": "sec6", "text": "This work relies on previous work for data model integrity verification [3]\u2013[5] and access control verification [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568281", "abstract": "Modern software applications store their data in remote cloud servers. Users interact with these applications using web browsers or thin clients running on mobile devices. A key issue in dependability of these applications is the correctness of the actions that update the data store, which are triggered by user requests. In this paper, we present techniques for au- tomatically checking if the actions of an application preserve the data model invariants. Our approach first automatically extracts ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inductive+verification+of+data+model+invariants+for+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "I. Bocic, T. Bultan, \"Coexecutability for efficient verification of data model updates\", <em>37th IEEE/ACM International Conference on Software Engineering ICSE 2015</em>, vol. 1, pp. 744-754, May 16\u201324, 2015.", "title": "Coexecutability for efficient verification of data model updates", "context": [{"sec": "sec1", "text": "Some of this research specifically targets applications written in dynamically typed languages [17], [18], [3], [4].", "part": "1"}, {"sec": "sec5", "text": "We used symbolic model extraction to extract models from Rails applications in order to verify their data integrity [3]\u2013[4][5] and access control [6] properties.", "part": "1"}, {"sec": "sec6", "text": "This work relies on previous work for data model integrity verification [3]\u2013[4][5] and access control verification [6].", "part": "1"}], "links": {"abstract": "Modern applications use back-end data stores for persistent data. Automated verification of the code that updates the data store would prevent bugs that can cause loss or corruption of data. In this paper, we focus on the most challenging part of this problem: automated verification of code that updates the data store and contains loops. Due to dependencies between loop iterations, verification of code that contains loops is a hard problem, and typically requires manual assistance in the form of...", "pdfSize": "732KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coexecutability+for+efficient+verification+of+data+model+updates&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "I. Bocic, T. Bultan, \"Efficient data model verification with many-sorted logic\", <em>30th IEEE/ACM International Conference on Automated Software Engineering ASE 2015</em>, November 9\u201313, 2015.", "title": "Efficient data model verification with many-sorted logic", "context": [{"sec": "sec5", "text": "We used symbolic model extraction to extract models from Rails applications in order to verify their data integrity [3]\u2013[5] and access control [6] properties.", "part": "1"}, {"sec": "sec6", "text": "This work relies on previous work for data model integrity verification [3]\u2013[5] and access control verification [6].", "part": "1"}], "links": {"documentLink": "/document/7371994", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7371994", "abstract": "Misuse or loss of web application data can have catastrophic consequences in today&#39;s Internet oriented world. Hence, verification of web application data models is of paramount importance. We have developed a framework for verification of web application data models via translation to First Order Logic (FOL), followed by automated theorem proving. Due to the undecidability of FOL, this automated approach does not always produce a conclusive answer. In this paper, we investigate the use of many-s...", "pdfSize": "336KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+data+model+verification+with+many-sorted+logic&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "I. Bocic, T. Bultan, \"Finding access control bugs in web applications with CanCheck\", <em>31st IEEE/ACM International Conference on Automated Software Engineering ASE 2016</em>, 2016.", "title": "Finding access control bugs in web applications with CanCheck", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}, {"sec": "sec4", "text": " We used these models for two purposes: to verify data integrity [3] and access control [6] properties.", "part": "1"}, {"sec": "sec4a2", "text": " The formal definition of these models is discussed in prior work [6].", "part": "1"}, {"sec": "sec4b", "text": " We extract access control information from CanCan configuration [6].", "part": "1"}, {"sec": "sec5", "text": "We used symbolic model extraction to extract models from Rails applications in order to verify their data integrity [3]\u2013[5] and access control [6] properties.", "part": "1"}, {"sec": "sec5a", "text": " This verification technique is detailed in prior work [6].", "part": "1"}, {"sec": "sec6", "text": "This work relies on previous work for data model integrity verification [3]\u2013[5] and access control verification [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970350", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+access+control+bugs+in+web+applications+with+CanCheck&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>ryanb/cancan \u2022 GitHub</em>, Nov. 2015,  [online]  Available: https://github.com/ryanb/cancan.", "title": "ryanb/cancan \u2022 GitHub", "context": [{"sec": "sec2", "text": " In line 5 of Figure 1 we see the load_resource declaration, defined by the CanCan gem [7].", "part": "1"}, {"sec": "sec5", "text": "Column Access Control shows whether the application employs access control through CanCan [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ryanb%2Fcancan+%E2%80%A2+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "A. Chaudhuri, J.S. Foster, \"Symbolic security analysis of ruby-on-rails web applications\", <em>Proceedings of the 17th ACM Conference on Computerand Communications Security CCS 2010</em>, pp. 585-594, October 4\u20138, 2010.", "title": "Symbolic security analysis of ruby-on-rails web applications", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}, {"sec": "sec6", "text": "RubyX [8] is a tool for symbolic execution in Rails that can be used to find access control bugs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1866307.1866373", "abstract": "Many of today&#39;s web applications are built on frameworks that include sophisticated defenses against malicious adversaries. However, mistakes in the way developers deploy those defenses could leave applications open to attack. To address this issue, we introduce Rubyx, a symbolic executor that we use to analyze Ruby-on-Rails web applications for security vulnerabilities. Rubyx specifications can easily be adapted to variety of properties, since they are built from general assertions, assumptions...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+security+analysis+of+ruby-on-rails+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "A. Cimatti, E.M. Clarke, F. Giunchiglia, M. Roveri, \"NUSMV: A new symbolic model checker\", <em>STTT</em>, vol. 2, no. 4, pp. 410-425, 2000.", "title": "NUSMV: A new symbolic model checker", "context": [{"sec": "sec1", "text": " These models are then verified using model checkers or theorem provers [12], [9], [10], [31], [30], [14].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s100090050046", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=NUSMV%3A+A+new+symbolic+model+checker&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "L.M. de Moura, N. Bj\u00f8mer, \"Z3: an efficient SMT solver\", <em>Tools and Algorithms for the Construction and Analysis of Systems 14th International Conference TACAS 2008 Held as Part of the Joint European Conferences on Theory and Practice of Software ETAPS 2008 Budapest Hungary March 29-April 6 2008. Proceedings</em>, pp. 337-340, 2008.", "title": "Z3: an efficient SMT solver", "context": [{"sec": "sec1", "text": " These models are then verified using model checkers or theorem provers [12], [9], [10], [31], [30], [14].", "part": "1"}, {"sec": "sec5b", "text": " In addition to installing ruby and dependencies of our library, theorem provers Spass [31] and Z3 [10] need to be installed and added to the system path variable.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Z3%3A+an+efficient+SMT+solver&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "S. Hall\u00e9, T. Ettema, C. Bunch, T. Bultan, \"Eliminating navigation errors in web applications via model checking and runtime enforcement of navigation state machines\", <em>Proceedings of the 25th IEEE/ACM Int. Conf. Automated Software Engineering (ASE 2010)</em>, pp. 235-244, 2010.", "title": "Eliminating navigation errors in web applications via model checking and runtime enforcement of navigation state machines", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1858996.1859044", "abstract": "The enforcement of navigation constraints in web applications is challenging and error prone due to the unrestricted use of navigation functions in web browsers. This often leads to navigation errors, producing cryptic messages and exposing information that can be exploited by malicious users. We propose a runtime enforcement mechanism that restricts the control flow of a web application to a state machine model specified by the developer, and use model checking to verify temporal properties on ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eliminating+navigation+errors+in+web+applications+via+model+checking+and+runtime+enforcement+of+navigation+state+machines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "G.J. Holzmann, \"The model checker SPIN\", <em>IEEE Trans. Software Eng.</em>, vol. 23, no. 5, pp. 279-295, 1997.", "title": "The model checker SPIN", "context": [{"sec": "sec1", "text": " These models are then verified using model checkers or theorem provers [12], [9], [10], [31], [30], [14].", "part": "1"}], "links": {"documentLink": "/document/588521", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=588521", "abstract": "SPIN is an efficient verification system for models of distributed software systems. It has been used to detect design errors in applications ranging from high-level descriptions of distributed algorithms to detailed code for controlling telephone exchanges. The paper gives an overview of the design and structure of the verifier, reviews its theoretical foundation, and gives an overview of significant practical applications.", "pdfSize": "256KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+model+checker+SPIN&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. hoon (David) An, A. Chaudhuri, J.S. Foster, \"Static typing for Ruby on Rails\", <em>Proceedings of the 24th IEEE/ACM International Conference on Automated Software Engineering (ASE 2009)</em>, pp. 590-594, 2009.", "title": "Static typing for Ruby on Rails", "context": [{"sec": "sec1", "text": " To statically verify such applications, verification tools require either that the applications do not use these features [21], [22], or they pre-process applications to make declarative constructs explicit [13].", "part": "1"}, {"sec": "sec6", "text": " Furthermore, they use DRails [13] to make specific usages of Rails code explicit, whereas we capture metaprogramming natively.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+typing+for+Ruby+on+Rails&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "D. Jackson, \"Alloy: A lightweight object modelling notation\", <em>ACM Transactions on Software Enginnering and Methodology (TOSEM 2002)</em>, vol. 11, no. 2, pp. 256-290, 2002.", "title": "Alloy: A lightweight object modelling notation", "context": [{"sec": "sec1", "text": " These models are then verified using model checkers or theorem provers [12], [9], [10], [31], [30], [14].", "part": "1"}, {"sec": "sec6", "text": "Near et al. [17] developed Rubicon, a web application verification tool that adds quantification to unit tests, for verification using Alloy [14].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/505145.505149", "abstract": "Alloy is a little language for describing structural properties. It offers a declaration syntax compatible with graphical object models, and a set-based formula syntax powerful enough to express complex constraints and yet amenable to a fully automatic semantic analysis. Its meaning is given by translation to an even smaller (formally defined) kernel. This paper presents the language in its entirety, and explains its motivation, contributions and deficiencies.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Alloy%3A+A+lightweight+object+modelling+notation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "J.C. King, \"Symbolic execution and program testing\", <em>Commun. ACM</em>, vol. 19, no. 7, pp. 385-394, 1976.", "title": "Symbolic execution and program testing", "context": [{"sec": "sec6", "text": "Symbolic execution [15] is a well known technique for program analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/360248.360252", "abstract": "This paper describes the symbolic execution of programs. Instead of supplying the normal inputs to a program (e.g. numbers) one supplies symbols representing arbitrary values. The execution proceeds as in a normal execution except that values may be symbolic formulas over the input symbols. The difficult, yet interesting issues arise during the symbolic execution of conditional branch type statements. A particular system called EFFIGY which provides symbolic execution for program testing and deb...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+execution+and+program+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "S. Munetoh, N. Yoshioka, \"Model-assisted access control implementation for code-centric Ruby-on-Rails web application development\", <em>2013 International Conference on Availability Reliability and Security ARES 2013</em>, pp. 350-359, September 2\u20136, 2013.", "title": "Model-assisted access control implementation for code-centric Ruby-on-Rails web application development", "context": [{"sec": "sec6", "text": "RailroadMap [16] is an automated tool for verification of access control in Rails using CanCan and Pundit.", "part": "1"}], "links": {"abstract": "In a Web application framework suitable for a code-centric development approach, maintaining the faultlessness of the security features is an issue because the security features are dispersed throughout the code during the implementation. In this paper, we propose a method and develop a static verification tool for Web applications that checks the completeness of the security features implementation. The tool generates a navigation model from an application code while retaining the security prop...", "pdfSize": "328KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Model-assisted+access+control+implementation+for+code-centric+Ruby-on-Rails+web+application+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "J.P. Near, D. Jackson, \"Rubicon: bounded verification of web applications\", <em>Proceedings of the ACM SIGSOFT 20th Int. Symp. Foundations of Software Engineering (FSE 2012)</em>, pp. 60:1-60:11, 2012.", "title": "Rubicon: bounded verification of web applications", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}, {"sec": "sec1", "text": "Some of this research specifically targets applications written in dynamically typed languages [17], [18], [3], [4].", "part": "1"}, {"sec": "sec1", "text": " Even with these limitations that are due to challenges in model extraction, model based verification techniques were able to find various previously unknown security and data integrity bugs in open source web applications[17], [20], [21].", "part": "1"}, {"sec": "sec6", "text": " [17] developed Rubicon, a web application verification tool that adds quantification to unit tests, for verification using Alloy [14].", "part": "1"}, {"sec": "sec6", "text": "Access control bugs are sometimes found with techniques not specifically tailored for finding access control bugs [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2393596.2393667", "abstract": "Rubicon is a verifier for web applications. Specifications are written in an embedded domain-specific language and are checked fully automatically. Rubicon is designed to fit with current practices: its language is based on RSpec, a popular testing framework, and its analysis leverages the standard Ruby interpreter to perform symbolic execution (generating verification conditions that are checked by the Alloy Analyzer). Rubicon has been evaluated on five open-source applications; in one, a widel...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rubicon%3A+bounded+verification+of+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "J.P. Near, D. Jackson, I. Crnkovic, M. Chechik, P. Gr\u00fcnbacher, \"Derailer: interactive security analysis for web applications\", <em>ACM/IEEE International Conference on Automated Software Engineering ASE '14</em>, pp. 587-598, September 15\u201319, 2014.", "title": "Derailer: interactive security analysis for web applications", "context": [{"sec": "sec1", "text": "Some of this research specifically targets applications written in dynamically typed languages [17], [18], [3], [4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2642937.2643012", "abstract": "Derailer is an interactive tool for finding security bugs in web applications. Using symbolic execution, it enumerates the ways in which application data might be exposed. The user is asked to examine these exposures and classify the conditions under which they occur as security-related or not; in so doing, the user effectively constructs a specification of the application&#39;s security policy. The tool then highlights exposures missing security checks, which tend to be security bugs. We have teste...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Derailer%3A+interactive+security+analysis+for+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J.P. Near, D. Jackson, \"Symbolic execution for (almost) free: Hijacking an existing implementation to perform symbolic execution\", <em>Technical Report MIT-CSAIL-TR-2014-007</em>, April 2014.", "title": "Symbolic execution for (almost) free: Hijacking an existing implementation to perform symbolic execution", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}, {"sec": "sec6", "text": " Their symbolic execution is fully explained in a technical report [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+execution+for+%28almost%29+free%3A+Hijacking+an+existing+implementation+to+perform+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J.P. Near, D. Jackson, \"Finding security bugs in web applications using a catalog of access control patterns\", <em>Proceedings of the 38th International Conference on Software Engineering ICSE 2016</em>, pp. 947-958, May 14\u201322, 2016.", "title": "Finding security bugs in web applications using a catalog of access control patterns", "context": [{"sec": "sec1", "text": " Even with these limitations that are due to challenges in model extraction, model based verification techniques were able to find various previously unknown security and data integrity bugs in open source web applications[17], [20], [21].", "part": "1"}, {"sec": "sec6", "text": " Recently, they used their symbolic execution technique to extract access control signatures from Rails programs [20].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884836", "abstract": "We propose a specification-free technique for finding missing security checks in web applications using a catalog of access control patterns in which each pattern models a common access control use case. Our implementation, SPACE, checks that every data exposure allowed by an application&#39;s code matches an allowed exposure from a security pattern in our catalog. The only user-provided input is a mapping from application types to the types of the catalog; the rest of the process is entirely automa...", "pdfSize": "1276KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+security+bugs+in+web+applications+using+a+catalog+of+access+control+patterns&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "J. Nijjar, <em>Analysis and Verification of Web Application Data Models</em>, Jan. 2014.", "title": "Analysis and Verification of Web Application Data Models", "context": [{"sec": "sec1", "text": " To statically verify such applications, verification tools require either that the applications do not use these features [21], [22], or they pre-process applications to make declarative constructs explicit [13].", "part": "1"}, {"sec": "sec1", "text": " Even with these limitations that are due to challenges in model extraction, model based verification techniques were able to find various previously unknown security and data integrity bugs in open source web applications[17], [20], [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analysis+and+Verification+of+Web+Application+Data+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "J. Nijjar, I. Boci\u0107, T. Bultan, \"An integrated data model verifier with property templates\", <em>Proceedings of the ICSE Workshop on Formal Methods in Software Engineering (FormaliSE 2013)</em>, 2013.", "title": "An integrated data model verifier with property templates", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}, {"sec": "sec1", "text": " To statically verify such applications, verification tools require either that the applications do not use these features [21], [22], or they pre-process applications to make declarative constructs explicit [13].", "part": "1"}], "links": {"documentLink": "/document/6612274", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6612274", "abstract": "Most modern web applications are built using development frameworks based on the Model-View-Controller (MVC) pattern. In MVC-based web applications the data model specifies the types of objects used by the application and the relations among them. Since the data model forms the foundation of such applications, its correctness is crucial. In this paper we present a tool, IDAVER, that 1) automatically extracts a formal data model specification from applications implemented using the Ruby on Rails ...", "pdfSize": "360KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+integrated+data+model+verifier+with+property+templates&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "J. Nijjar, T. Bultan, \"Bounded verification of Ruby on Rails data models\", <em>Proceedings of the 20th Int. Symp. on Software Testing and Analysis (ISSTA 2011)</em>, pp. 67-77, 2011.", "title": "Bounded verification of Ruby on Rails data models", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2001420.2001429", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bounded+verification+of+Ruby+on+Rails+data+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "J. Nijjar, T. Bultan, \"Unbounded data model verification using SMT solvers\", <em>Proceedings of the 27th IEEE/ACM Int. Conf. Automated Software Engineering (ASE 2012)</em>, pp. 210-219, 2012.", "title": "Unbounded data model verification using SMT solvers", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2351676.2351706", "abstract": "The growing influence of web applications in every aspect of society makes their dependability an immense concern. A fundamental building block of web applications that use the Model-View-Controller (MVC) pattern is the data model, which specifies the object classes and the relations among them. We present an approach for unbounded, automated verification of data models that 1) extracts a formal data model from an Object Relational Mapping, 2) converts verification queries about the data model t...", "pdfSize": "748KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Unbounded+data+model+verification+using+SMT+solvers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "<em>Open Source Rails</em>, Jan. 2016,  [online]  Available: http://www.opensourcerails.com.", "title": "Open Source Rails", "context": [{"sec": "sec5", "text": " We looked at the 25 most starred open-source Rails applications on Github according to the OpenSourceRails.com website [25], a compilation of open source Rails applications categorized by domain [1], and applications investigated by related work.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Open+Source+Rails&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "<em>ActsAsParanoid/acts_as_paranoid: ActiveRecord plugin allowing you to hide and restore records without actually deleting them</em>, Aug. 2016,  [online]  Available: https://github.com/ActsAsParanoid/acts_as_paranoid.", "title": "ActsAsParanoid/acts_as_paranoid: ActiveRecord plugin allowing you to hide and restore records without actually deleting them", "context": [{"sec": "sec2", "text": " However, in line 2, the acts_as_paranoid declaration (provided by the ActsAsParanoid gem [26]), overrides the destroy! method for the Article class.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ActsAsParanoid%2Facts_as_paranoid%3A+ActiveRecord+plugin+allowing+you+to+hide+and+restore+records+without+actually+deleting+them&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "E.D. Sciascio, F.M. Donini, M. Mongiello, R. Totaro, D. Castelluccia, \"Design verification of web applications using symbolic model checking\", <em>Proceedings of the 5th Int. Conf. Web Engineering (ICWE 2005)</em>, pp. 69-74, 2005.", "title": "Design verification of web applications using symbolic model checking", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/11531371_12", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Design+verification+of+web+applications+using+symbolic+model+checking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "K. Sen, D. Marinov, G. Agha, \"CUTE: a concolic unit testing engine for C\", <em>Proceedings of the 10th European Software Engineering Conference held jointly with 13th ACM SIGSOFT International Symposium on Foundations of Software Engineering (ESEC/FSE 05)</em>, pp. 263-272, 2005.", "title": "CUTE: a concolic unit testing engine for C", "context": [{"sec": "sec6", "text": "Concolic execution [28] extends on symbolic execution by keeping track of concrete values as well as symbolic.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=CUTE%3A+a+concolic+unit+testing+engine+for+C&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "P.D. Stotts, R. Furuta, C.R. Cabarrus, \"Hyperdocuments as automata: Verification of trace-based browsing properties by model checking\", <em>ACM Transactions on Information Systems (TOIS 1998)</em>, vol. 16, no. 1, pp. 1-30, 1998.", "title": "Hyperdocuments as automata: Verification of trace-based browsing properties by model checking", "context": [{"sec": "sec1", "text": "There exists a significant body of work on model based verification of web applications [29], [11], [27], [3], [6], [8], [17], [19], [23], [24], [22].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/267954.267955", "abstract": "We present a view of hyperdocuments in which each document encodes its own browsing semantics in its links. This requires a mental shift in how a hyperdocument is thought of abstractly. Instead of treating the links of a document as defining a static directed graph, they are thought of as defining an abstract program, termed the links-automaton of the document. A branching temporal logic notation, termed HTL*, is introduced for specifying properties a document should exhibit during browsing. An ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hyperdocuments+as+automata%3A+Verification+of+trace-based+browsing+properties+by+model+checking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "W. Visser, K. Havelund, G.P. Brat, S. Park, F. Lerda, \"Model checking programs\", <em>Autom. Softw. Eng.</em>, vol. 10, no. 2, pp. 203-232, 2003.", "title": "Model checking programs", "context": [{"sec": "sec1", "text": " These models are then verified using model checkers or theorem provers [12], [9], [10], [31], [30], [14].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/A:1022920129859", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Model+checking+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "C. Weidenbach, D. Dimova, A. Fietzke, R. Kumar, M. Suda, P. Wischnewski, \"SPASS version 3.5\", <em>Proceedings of the 22nd Int. Conf. Automated Deduction (CADE 2009)</em>, pp. 140-145, 2009.", "title": "SPASS version 3.5", "context": [{"sec": "sec1", "text": " These models are then verified using model checkers or theorem provers [12], [9], [10], [31], [30], [14].", "part": "1"}, {"sec": "sec5b", "text": " In addition to installing ruby and dependencies of our library, theorem provers Spass [31] and Z3 [10] need to be installed and added to the system path variable.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SPASS+version+3.5&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985708", "articleId": "7985708", "startPage": "724", "endPage": "734", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 296}}
{"title": "The Evolution of Continuous Experimentation in Software Product Development: From Data to a Data-Driven Organization at Scale", "authors": [{"name": "Aleksander Fabijan", "affiliation": "Fac. of Technol. & Soc., Malmo Univ., Malmo, Sweden", "firstName": "Aleksander", "lastName": "Fabijan", "id": "37085889209"}, {"name": "Pavel Dmitriev", "affiliation": "Microsoft Anal. & Experimentation, Microsoft, Redmond, WA, USA", "firstName": "Pavel", "lastName": "Dmitriev", "id": "38180198300"}, {"name": "Helena Holmstr\u00f6m Olsson", "affiliation": "Fac. of Technol. & Soc., Malmo Univ., Malmo, Sweden", "firstName": "Helena Holmstr\u00f6m", "lastName": "Olsson", "id": "37072408100"}, {"name": "Jan Bosch", "affiliation": "Dept. of Comput. Sci. & Eng., Chalmers Univ. of Technol., Goteborg, Sweden", "firstName": "Jan", "lastName": "Bosch", "id": "37267646700"}], "abstract": "Software development companies are increasingly aiming to become data-driven by trying to continuously experiment with the products used by their customers. Although familiar with the competitive edge that the A/B testing technology delivers, they seldom succeed in evolving and adopting the methodology. In this paper, and based on an exhaustive and collaborative case study research in a large software-intense company with highly developed experimentation culture, we present the evolution process of moving from ad-hoc customer data analysis towards continuous controlled experimentation at scale. Our main contribution is the \"Experimentation Evolution Model\" in which we detail three phases of evolution: technical, organizational and business evolution. With our contribution, we aim to provide guidance to practitioners on how to develop and scale continuous experimentation in software organizations with the purpose of becoming data-driven at scale.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software engineering"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["organisational aspects", "product development", "software engineering"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["continuous experimentation", "software product development", "data-driven organization", "A/B testing technology", "software-intense company", "ad-hoc customer data analysis", "experimentation evolution model", "business evolution", "organizational evolution", "technical evolution", "software organizations"]}, {"type": "Author Keywords ", "kwd": ["A/B testing", "continuous experimentation", "data science", "customer feedback", "continuous product innovation", "Experimentation Evolution Model", "product value", "Experiment Owner"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.76", "ref": [{"order": "1", "text": "D.J. Patil, \"Building Data Science Teams\", <em>Oreilly Radar</em>, pp. 1-25, 2011.", "title": "Building Data Science Teams", "context": [{"sec": "sec1", "text": "Software development organizations and their product development teams are increasingly using customer and product data to support decisions throughout the product lifecycle [1], [2].", "part": "1"}, {"sec": "sec1", "text": " Data-driven companies acquire, process, and leverage data in order to create efficiencies, iterate on and develop new products, and navigate the competitive landscape [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Building+Data+Science+Teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "A. Fabijan, H.H. Olsson, J. Bosch, \"Customer Feedback and Data Collection Techniques in Software R&D: A Literature Review\", <em>Software Business ICSOB 2015</em>, vol. 210, pp. 139-153, 2015.", "title": "Customer Feedback and Data Collection Techniques in Software R&D: A Literature Review", "context": [{"sec": "sec1", "text": "Software development organizations and their product development teams are increasingly using customer and product data to support decisions throughout the product lifecycle [1], [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Customer+Feedback+and+Data+Collection+Techniques+in+Software+R%26D%3A+A+Literature+Review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "G. Westerman, M. Tannou, D. Bonnet, P. Ferraris, A. McAfee, \"The Digital Advantage: How Digital Leaders Outperform their Peers in Every Industry\", <em>MIT Sloan Manag. Rev.</em>, pp. 1-24, 2012.", "title": "The Digital Advantage: How Digital Leaders Outperform their Peers in Every Industry", "context": [{"sec": "sec1", "text": " Digitally adept and technology driven companies are as much as 26 percent more profitable than their competitors [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Digital+Advantage%3A+How+Digital+Leaders+Outperform+their+Peers+in+Every+Industry&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "R. Kohavi, R. Longbotham, \"Online Controlled Experiments and A/B Tests\", <em>Encyclopedia of Machine Learning and Data Mining no. Ries 2011</em>, pp. 1-11, 2015.", "title": "Online Controlled Experiments and A/B Tests", "context": [{"sec": "sec1", "text": " Recent software engineering research reflects this situation with a number of publications on how to change and efficiently conduct controlled experiments to become data-driven [4]\u2013[8], [27].", "part": "1"}, {"sec": "sec2", "text": " Controlled experimentation is becoming the norm in advanced software companies for reliably evaluating ideas with customers in order to correctly prioritize product development activities [4]\u2013[8].", "part": "1"}, {"sec": "sec2a", "text": " Users' interactions with the product are instrumented and key metrics are computed [4], [23].", "part": "1"}, {"sec": "sec2a", "text": " [4], [26], [27] in their papers present common pitfalls in the process of establishing a controlled experimentation system and guidance on how to reliably define an OEC.", "part": "1"}, {"sec": "sec6", "text": "Controlled Experimentation is becoming the norm in the software industry for reliably evaluating ideas with customers and correctly prioritizing product development activities [4]\u2013[8], [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Online+Controlled+Experiments+and+A%2FB+Tests&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "H.H. Olsson, J. Bosch, <em>The HYPEX model: From opinions to data-driven software development</em>, 2014.", "title": "The HYPEX model: From opinions to data-driven software development", "context": [{"sec": "sec1", "text": " Recent software engineering research reflects this situation with a number of publications on how to change and efficiently conduct controlled experiments to become data-driven [4]\u2013[5][8], [27].", "part": "1"}, {"sec": "sec2", "text": " Controlled experimentation is becoming the norm in advanced software companies for reliably evaluating ideas with customers in order to correctly prioritize product development activities [4]\u2013[5][8].", "part": "1"}, {"sec": "sec6", "text": "Controlled Experimentation is becoming the norm in the software industry for reliably evaluating ideas with customers and correctly prioritizing product development activities [4]\u2013[5][8], [21].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+HYPEX+model%3A+From+opinions+to+data-driven+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "H.H. Olsson, J. Bosch, \"Towards continuous customer validation: A conceptual model for combining qualitative customer feedback with quantitative customer observation\", <em>Lecture Notes in Business Information Processing</em>, vol. 210, pp. 154-166, 2015.", "title": "Towards continuous customer validation: A conceptual model for combining qualitative customer feedback with quantitative customer observation", "context": [{"sec": "sec1", "text": " Recent software engineering research reflects this situation with a number of publications on how to change and efficiently conduct controlled experiments to become data-driven [4]\u2013[6][8], [27].", "part": "1"}, {"sec": "sec2", "text": " Controlled experimentation is becoming the norm in advanced software companies for reliably evaluating ideas with customers in order to correctly prioritize product development activities [4]\u2013[6][8].", "part": "1"}, {"sec": "sec6", "text": "Controlled Experimentation is becoming the norm in the software industry for reliably evaluating ideas with customers and correctly prioritizing product development activities [4]\u2013[6][8], [21].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[6][8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+continuous+customer+validation%3A+A+conceptual+model+for+combining+qualitative+customer+feedback+with+quantitative+customer+observation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "F. Fagerholm, A.S. Guinea, H. M\u00e4enp\u00e4\u00e4, J. M\u00fcnch, \"Building Blocks for Continuous Experimentation\", <em>Proc. 1st Int. Work. Rapid Contin. Softw. Eng.</em>, pp. 26-35, 2014.", "title": "Building Blocks for Continuous Experimentation", "context": [{"sec": "sec1", "text": " Recent software engineering research reflects this situation with a number of publications on how to change and efficiently conduct controlled experiments to become data-driven [4]\u2013[7][8], [27].", "part": "1"}, {"sec": "sec2", "text": " Controlled experimentation is becoming the norm in advanced software companies for reliably evaluating ideas with customers in order to correctly prioritize product development activities [4]\u2013[7][8].", "part": "1"}, {"sec": "sec6", "text": "Controlled Experimentation is becoming the norm in the software industry for reliably evaluating ideas with customers and correctly prioritizing product development activities [4]\u2013[7][8], [21].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[7][8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2593812.2593816", "abstract": "Development of software-intensive products and services increasingly occurs by continuously deploying product or service increments, such as new features and enhancements, to customers. Product and service developers need to continuously find out what customers want by direct customer feedback and observation of usage behaviour, rather than indirectly through up-front business analyses. This paper examines the preconditions for setting up an experimentation system for continuous customer experim...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Building+Blocks+for+Continuous+Experimentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "F. Fagerholm, A.S. Guinea, H. M\u00e4enp\u00e4\u00e4, J. M\u00fcnch, \"The RIGHT model for Continuous Experimentation\", <em>J. Syst. Softw.</em>, pp. 1-14, 2015.", "title": "The RIGHT model for Continuous Experimentation", "context": [{"sec": "sec1", "text": " Recent software engineering research reflects this situation with a number of publications on how to change and efficiently conduct controlled experiments to become data-driven [4]\u2013[8], [27].", "part": "1"}, {"sec": "sec2", "text": "Rapid delivery of value to customers is one of the core priorities of software companies [8].", "part": "1"}, {"sec": "sec2", "text": " Controlled experimentation is becoming the norm in advanced software companies for reliably evaluating ideas with customers in order to correctly prioritize product development activities [4]\u2013[8].", "part": "1"}, {"sec": "sec6", "text": "Controlled Experimentation is becoming the norm in the software industry for reliably evaluating ideas with customers and correctly prioritizing product development activities [4]\u2013[8], [21].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+RIGHT+model+for+Continuous+Experimentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "M. Kim, T. Zimmermann, R. DeLine, A. Begel, \"The emerging role of data scientists on software development teams\", <em>Proceedings of the 38th International Conference on Software Engineering \u2014 ICSE '16</em>, pp. 96-107, 2016.", "title": "The emerging role of data scientists on software development teams", "context": [{"sec": "sec1", "text": " The role of data scientists is increasingly gaining momentum in large software companies [9].", "part": "1"}, {"sec": "sec5a", "text": " To evaluate the product statistics, skills that are typically possessed by data scientists [9] are required within the company.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884783", "abstract": "Creating and running software produces large amounts of raw data about the development process and the customer usage, which can be turned into actionable insight with the help of skilled data scientists. Unfortunately, data scientists with the analytical and software engineering skills to analyze these large data sets have been hard to come by; only recently have software companies started to develop competencies in software-oriented data analytics. To understand this emerging role, we intervie...", "pdfSize": "934KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+emerging+role+of+data+scientists+on+software+development+teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "P. Rodr\u00edguez et al., \"Continuous Deployment of Software Intensive Products and Services: A Systematic Mapping Study\", <em>J. Syst. Softw.</em>, 2015.", "title": "Continuous Deployment of Software Intensive Products and Services: A Systematic Mapping Study", "context": [{"sec": "sec1", "text": " However, despite having data, the number of companies that efficiently use it and that successfully transform into data-driven organizations stays low and how this transformation is done in practice is little studied [10], [11].", "part": "1"}, {"sec": "sec2", "text": " Next, companies focus on various lean concepts such as eliminating waste [14], removing constraints in the development pipeline [15] and advancing towards continuous integration [16] and continuous deployment of software functionality [10].", "part": "1"}, {"sec": "sec2a", "text": " However, the count of companies that successfully developed an experimentation culture and became data-driven remains low and limited to other web service companies such as Facebook, Google, Booking, Amazon, LinkedIn, Etsy, Skyscanner [10], [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+Deployment+of+Software+Intensive+Products+and+Services%3A+A+Systematic+Mapping+Study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "A. Fabijan, H.H. Olsson, J. Bosch, \"The Lack of Sharing of Customer Data in Large Software Organizations: Challenges and Implications\", <em>17th International Conference on Agile Software Development XP2016</em>, pp. 39-52, 2016.", "title": "The Lack of Sharing of Customer Data in Large Software Organizations: Challenges and Implications", "context": [{"sec": "sec1", "text": " However, despite having data, the number of companies that efficiently use it and that successfully transform into data-driven organizations stays low and how this transformation is done in practice is little studied [10], [11].", "part": "1"}, {"sec": "sec2a", "text": " Companies have the necessary instrumentation in place [30], are able to gather and analyze product data, but they fail to efficiently utilize it and learn from it [11].", "part": "1"}, {"sec": "sec3c2", "text": " The embedded systems domain is one example area where companies are aiming to become data-driven and that we previously studied [34], [11], [35].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-33515-5_4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Lack+of+Sharing+of+Customer+Data+in+Large+Software+Organizations%3A+Challenges+and+Implications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "R.C. Martin, <em>Agile Software Development Principles Patterns and Practices</em>, 2002.", "title": "Agile Software Development, Principles, Patterns, and Practices", "context": [{"sec": "sec2", "text": " At first, they inherit the Agile principles within the development part of the organization [12] and expand them to other departments [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Agile+Software+Development%2C+Principles%2C+Patterns%2C+and+Practices&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "H.H. Olsson, H. Alahyari, J. Bosch, \"Climbing the \u2018Stairway to heaven\u2019 \u2014 A mulitiple-case study exploring barriers in the transition from agile development towards continuous deployment of software\", <em>Proceedings \u2014 38th EUROMICRO Conference on Software Engineering and Advanced Applications SEAA 2012</em>, pp. 392-399, 2012.", "title": "Climbing the \u2018Stairway to heaven\u2019 \u2014 A mulitiple-case study exploring barriers in the transition from agile development towards continuous deployment of software", "context": [{"sec": "sec2", "text": " At first, they inherit the Agile principles within the development part of the organization [12] and expand them to other departments [13].", "part": "1"}], "links": {"documentLink": "/document/6328180", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6328180", "abstract": "Agile software development is well-known for its focus on close customer collaboration and customer feedback. In emphasizing flexibility, efficiency and speed, agile practices have lead to a paradigm shift in how software is developed. However, while agile practices have succeeded in involving the customer in the development cycle, there is an urgent need to learn from customer usage of software also after delivering and deployment of the software product. The concept of continuous deployment, i...", "pdfSize": "220KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Climbing+the+%E2%80%98Stairway+to+heaven%E2%80%99+%E2%80%94+A+mulitiple-case+study+exploring+barriers+in+the+transition+from+agile+development+towards+continuous+deployment+of+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "S. Mujtaba, R. Feldt, K. Petersen, \"Waste and lead time reduction in a software product customization process with value stream maps\", <em>Proceedings of the Australian Software Engineering Conference ASWEC</em>, pp. 139-148, 2010.", "title": "Waste and lead time reduction in a software product customization process with value stream maps", "context": [{"sec": "sec2", "text": " Next, companies focus on various lean concepts such as eliminating waste [14], removing constraints in the development pipeline [15] and advancing towards continuous integration [16] and continuous deployment of software functionality [10].", "part": "1"}], "links": {"abstract": "Custom-developed adaptations of software products are increasingly important to meet different and changing customer needs and heterogeneous system environments. Efficient software customization processes with short lead times are thus a priority for companies to stay competitive. The purpose of this case study is to identify waste-related problems in a software product customization process by using value stream maps (VSM). The study was conducted at the telecom company Ericsson AB; the empiric...", "pdfSize": "311KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Waste+and+lead+time+reduction+in+a+software+product+customization+process+with+value+stream+maps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "E.M. Goldratt, J. Cox, <em>The Goal: A Process of Ongoing Improvement</em>, vol. 2nd, no. 337, pp. 2004.", "title": "The Goal: A Process of Ongoing Improvement", "context": [{"sec": "sec2", "text": " Next, companies focus on various lean concepts such as eliminating waste [14], removing constraints in the development pipeline [15] and advancing towards continuous integration [16] and continuous deployment of software functionality [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Goal%3A+A+Process+of+Ongoing+Improvement&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "D. St\u00e5hl, J. Bosch, \"Continuous integration flows\", <em>Continuous software engineering</em>, vol. 9783319112, pp. 107-115, 2014.", "title": "Continuous integration flows", "context": [{"sec": "sec2", "text": " Next, companies focus on various lean concepts such as eliminating waste [14], removing constraints in the development pipeline [15] and advancing towards continuous integration [16] and continuous deployment of software functionality [10].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-11283-1_9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+integration+flows&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "E. Ries, <em>The Lean Startup: How Today's Entrepreneurs Use Continuous Innovation to Create Radically Successful Businesses</em>, 2011.", "title": "The Lean Startup: How Today's Entrepreneurs Use Continuous Innovation to Create Radically Successful Businesses", "context": [{"sec": "sec2", "text": " Continuous deployment, however, is characterized by a bidirectional channel that enables companies not only to send data to their customers to rapidly prototype with them [17], but also to receive feedback data from products in the field.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Lean+Startup%3A+How+Today%27s+Entrepreneurs+Use+Continuous+Innovation+to+Create+Radically+Successful+Businesses&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "G. Castellion, \"Do It Wrong Quickly: How the Web Changes the Old Marketing Rules by Mike Moran\", <em>J. Prod. Innov. Manag.</em>, vol. 25, no. 6, pp. 633-635, 2008.", "title": "Do It Wrong Quickly: How the Web Changes the Old Marketing Rules by Mike Moran", "context": [{"sec": "sec2", "text": " The intuition of software development companies on customer preferences can be wrong as much as 90% of the time [18]\u2013[20].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.1540-5885.2008.00327_1.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+It+Wrong+Quickly%3A+How+the+Web+Changes+the+Old+Marketing+Rules+by+Mike+Moran&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "\"The standish group report\", <em>Chaos</em>, vol. 49, pp. 1-8, 1995.", "title": "The standish group report", "context": [{"sec": "sec2", "text": " The intuition of software development companies on customer preferences can be wrong as much as 90% of the time [18]\u2013[19][20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+standish+group+report&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J. Manzi, Uncontrolled: the surprising payoff of trial-and-error for business politics and society, Basic Books, 2012.", "title": "Uncontrolled: the surprising payoff of trial-and-error for business, politics, and society", "context": [{"sec": "sec2", "text": " The intuition of software development companies on customer preferences can be wrong as much as 90% of the time [18]\u2013[20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Uncontrolled%3A+the+surprising+payoff+of+trial-and-error+for+business%2C+politics%2C+and+society&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "P. Bosch-Sijtsema, J. Bosch, \"User Involvement throughout the Innovation Process in High-Tech Industries\", <em>J. Prod. Innov. Manag.</em>, vol. 32, no. 5, pp. 1-36, 2014.", "title": "User Involvement throughout the Innovation Process in High-Tech Industries", "context": [{"sec": "sec2", "text": " The actual product usage data has the potential to make the prioritization process in product development more accurate as it focuses on what customers do rather than what they say [21], [22].", "part": "1"}, {"sec": "sec6", "text": "Controlled Experimentation is becoming the norm in the software industry for reliably evaluating ideas with customers and correctly prioritizing product development activities [4]\u2013[8], [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=User+Involvement+throughout+the+Innovation+Process+in+High-Tech+Industries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "H.H.H.H. Olsson, J. Bosch, \"From opinions to data-driven software R&D: A multi-case study on how to close the \u2018open loop\u2019 problem\", <em>Proceedings \u2014 40th Euromicro Conference Series on Software Engineering and Advanced Applications SEAA 2014</em>, pp. 9-16, 2014.", "title": "From opinions to data-driven software R&D: A multi-case study on how to close the \u2018open loop\u2019 problem", "context": [{"sec": "sec2", "text": " The actual product usage data has the potential to make the prioritization process in product development more accurate as it focuses on what customers do rather than what they say [21], [22].", "part": "1"}], "links": {"documentLink": "/document/6928783", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6928783", "abstract": "In most software development companies the road mapping and requirements prioritization process is a complex process in which product management experiences difficulties in getting timely and accurate customer feedback. The feedback loop from customers is slow and often there is a lack of mechanisms that allow for efficient customer data collection and analysis. As a result, there is the risk that requirements prioritization becomes opinion-based rather than data-driven, and that R&D investments...", "pdfSize": "315KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=From+opinions+to+data-driven+software+R%26D%3A+A+multi-case+study+on+how+to+close+the+%E2%80%98open+loop%E2%80%99+problem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "M.L.T. Cossio et al., <em>AlB Testing \u2014 The most powerful way to turn clicks into customers</em>, vol. XXXIII, no. 2, 2012.", "title": "AlB Testing \u2014 The most powerful way to turn clicks into customers", "context": [{"sec": "sec2a", "text": " Users' interactions with the product are instrumented and key metrics are computed [4], [23].", "part": "1"}, {"sec": "sec2a", "text": " The Return on Investment (ROI) of controlled experimentation has been discussed a number of times in the literature [23], [27].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=AlB+Testing+%E2%80%94+The+most+powerful+way+to+turn+clicks+into+customers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "R.C. Van Nostrand, \"Design of Experiments Using the Taguchi Approach: 16 Steps to Product and Process Improvement\", <em>Technometrics</em>, vol. 44, no. 3, pp. 289-289, Aug. 2002.", "title": "Design of Experiments Using the Taguchi Approach: 16 Steps to Product and Process Improvement", "context": [{"sec": "sec2a", "text": " An OEC is a quantitative measure of a controlled experiment's objective [24] and steers the direction of the business development.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1198/004017002320256440", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Design+of+Experiments+Using+the+Taguchi+Approach%3A+16+Steps+to+Product+and+Process+Improvement&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "H. Hohnhold, D. O'Brien, D. Tang, \"Focusing on the Long-term\", <em>Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining \u2014 KDD '15</em>, pp. 1849-1858, 2015.", "title": "Focusing on the Long-term", "context": [{"sec": "sec2a", "text": " In controlled experimentation, it is intuitive to measure the short-term effect, i.e., the impact observed during the experiment [25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2783258.2788583", "abstract": "Over the past 10+ years, online companies large and small have adopted widespread A/B testing as a robust data-based method for evaluating potential product improvements. In online experimentation, it is straightforward to measure the short-term effect, i.e., the impact observed during the experiment. However, the short-term effect is not always predictive of the long-term effect, i.e., the final impact once the product has fully launched and users have changed their behavior in response. Thus, ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Focusing+on+the+Long-term&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "R. Kohavi, A. Deng, R. Longbotham, \"Seven Rules of Thumb for Web Site Experimenters\", <em>Kdd</em>, pp. 1-11, 2014.", "title": "Seven Rules of Thumb for Web Site Experimenters", "context": [{"sec": "sec2a", "text": " However, the short-term effect is not always predictive of the long-term effect and consequently should not be the sole component of an OEC [26].", "part": "1"}, {"sec": "sec2a", "text": " Kohavi et al. [4], [26], [27] in their papers present common pitfalls in the process of establishing a controlled experimentation system and guidance on how to reliably define an OEC.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2623330.2623341", "abstract": "Web site owners, from small web sites to the largest properties that include Amazon, Facebook, Google, LinkedIn, Microsoft, and Yahoo, attempt to improve their web sites, optimizing for criteria ranging from repeat usage, time on site, to revenue. Having been involved in running thousands of controlled experiments at Amazon, Booking.com, LinkedIn, and multiple Microsoft properties, we share seven rules of thumb for experimenters, which we have generalized from these experiments and their results...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Seven+Rules+of+Thumb+for+Web+Site+Experimenters&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "R. Kohavi, R. Longbotham, D. Sommerfield, R.M. Henne, \"Controlled experiments on the web: Survey and practical guide\", <em>Data Min. Knowl. Discov.</em>, vol. 18, pp. 140-181, 2009.", "title": "Controlled experiments on the web: Survey and practical guide", "context": [{"sec": "sec1", "text": " Recent software engineering research reflects this situation with a number of publications on how to change and efficiently conduct controlled experiments to become data-driven [4]\u2013[8], [27].", "part": "1"}, {"sec": "sec2a", "text": " Kohavi et al. [4], [26], [27] in their papers present common pitfalls in the process of establishing a controlled experimentation system and guidance on how to reliably define an OEC.", "part": "1"}, {"sec": "sec2a", "text": "Research contributions with practical guides on how to develop an experimentation system have previously been published both by Microsoft [27], [28] and Google [29].", "part": "1"}, {"sec": "sec2a", "text": " The Return on Investment (ROI) of controlled experimentation has been discussed a number of times in the literature [23], [27].", "part": "1"}, {"sec": "sec5b1b", "text": " Practitioners can use the guidance on how to calculate the statistics behind a controlled experiment in [27].", "part": "1"}, {"sec": "sec5e1b", "text": " A statistical interaction between two treatments A and B exists if their combined effect is not the same as the sum of two individual treatment effects [27].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10618-008-0114-1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Controlled+experiments+on+the+web%3A+Survey+and+practical+guide&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "R. Kohavi, A. Deng, B. Frasca, T. Walker, Y. Xu, N. Pohlmann, \"Online controlled experiments at large scale\", <em>Proceedings of the 19th ACM SIGKDD international conference on Knowledge discovery and data mining</em>, pp. 1168-1176, 2013.", "title": "Online controlled experiments at large scale", "context": [{"sec": "sec2a", "text": "Research contributions with practical guides on how to develop an experimentation system have previously been published both by Microsoft [27], [28] and Google [29].", "part": "1"}, {"sec": "sec2a", "text": " However, the count of companies that successfully developed an experimentation culture and became data-driven remains low and limited to other web service companies such as Facebook, Google, Booking, Amazon, LinkedIn, Etsy, Skyscanner [10], [28].", "part": "1"}, {"sec": "sec5d1a", "text": " Knowingly hurting users slightly in the short-term (e.g., in a 2- week experiment) enables teams at Microsoft to understand fundamental issues and thereby improve the experience in the long-term [28].", "part": "1"}, {"sec": "sec5d1b", "text": " Detailed guidance on how to avoid this situation and develop alerting that works is available in [28].", "part": "1"}, {"sec": "sec5e1b", "text": " Detailed guidance on how to implement this feature is available in [28].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2487575.2488217", "abstract": "Web-facing companies, including Amazon, eBay, Etsy, Facebook, Google, Groupon, Intuit, LinkedIn, Microsoft, Netflix, Shop Direct, StumbleUpon, Yahoo, and Zynga use online controlled experiments to guide product development and accelerate innovation. At Microsoft&#39;s Bing, the use of controlled experiments has grown exponentially over time, with over 200 concurrent experiments now running on any given day. Running experiments at large scale requires addressing multiple challenges in three areas: cu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Online+controlled+experiments+at+large+scale&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "D. Tang, A. Agarwal, D. O'Brien, M. Meyer, \"Overlapping experiment infrastructure\", <em>Proceedings of the 16th ACM SIGKDD international conference on Knowledge discovery and data mining \u2014 KDD '10</em>, pp. 17, 2010.", "title": "Overlapping experiment infrastructure", "context": [{"sec": "sec2a", "text": "Research contributions with practical guides on how to develop an experimentation system have previously been published both by Microsoft [27], [28] and Google [29].", "part": "1"}, {"sec": "sec6", "text": " Previous research publications by Microsoft [27], [28], Google [29] and academia [5]\u2013[8] reveal the essential building blocks for an experimentation platform; however, they leave out the details on how to incrementally scale (e.g. which technical and organizational activities to focus on at what phase).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1835804.1835810", "abstract": "At Google, experimentation is practically a mantra; we evaluate almost every change that potentially affects what our users experience. Such changes include not only obvious user-visible changes such as modifications to a user interface, but also more subtle changes such as different machine learning algorithms that might affect ranking or content selection. Our insatiable appetite for experimentation has led us to tackle the problems of how to run more experiments, how to run experiments that p...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Overlapping+experiment+infrastructure&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "T. Barik, R. Deline, S. Drucker, D. Fisher, <em>The Bones of the System: A Case Study of Logging and Telemetry at Microsoft</em>, 2016.", "title": "The Bones of the System: A Case Study of Logging and Telemetry at Microsoft", "context": [{"sec": "sec2a", "text": " Companies have the necessary instrumentation in place [30], are able to gather and analyze product data, but they fail to efficiently utilize it and learn from it [11].", "part": "1"}, {"sec": "sec5b1a", "text": " In non-data driven companies, logging exists for the purpose of debugging product features [30], [37], [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Bones+of+the+System%3A+A+Case+Study+of+Logging+and+Telemetry+at+Microsoft&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "P. Runeson, M. H\u00f6st, \"Guidelines for conducting and reporting case study research in software engineering\", <em>Empir. Softw. Eng.</em>, vol. 14, no. 2, pp. 131-164, 2008.", "title": "Guidelines for conducting and reporting case study research in software engineering", "context": [{"sec": "sec3", "text": " In principle, it is an in-depth and single case study [31], however, our participants are from different organizational units and product teams with fundamentally different product and service offerings.", "part": "1"}, {"sec": "sec3c2", "text": " However, and since this approach differs from a traditional case study [31], the contributions of this paper risk being biased from this extensive inside view.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-008-9102-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guidelines+for+conducting+and+reporting+case+study+research+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "P. Mayring, \"Qualitative content analysis \u2014 research instrument or mode of interpretation\", <em>The Role of the Researcher in Qualitative Psychology</em>, pp. 139-148, 2002.", "title": "Qualitative content analysis \u2014 research instrument or mode of interpretation", "context": [{"sec": "sec3b", "text": " Second, and with the goal to model the evolution of continuous experimentation, we performed inductive category development [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Qualitative+content+analysis+%E2%80%94+research+instrument+or+mode+of+interpretation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "K.M. Eisenhardt, \"Building Theories from Case Study Research\", <em>Acad. Manag. Rev.</em>, vol. 14, no. 4, pp. 532-550, 1989.", "title": "Building Theories from Case Study Research", "context": [{"sec": "sec3b", "text": " This approach is similar to the Grounded Theory approach as we didn't have preconceptions on which categories to form beforehand [33].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2307/258557", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Building+Theories+from+Case+Study+Research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "J. Bosch, U. Eklund, \"Eternal embedded software: Towards innovation experiment systems\", <em>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</em>, vol. 7609, pp. 19-31, 2012.", "title": "Eternal embedded software: Towards innovation experiment systems", "context": [{"sec": "sec3c2", "text": " The embedded systems domain is one example area where companies are aiming to become data-driven and that we previously studied [34], [11], [35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eternal+embedded+software%3A+Towards+innovation+experiment+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "A. Fabijan, H.H. Olsson, J. Bosch, \"Time to Say \u2018Good Bye\u2019: Feature Lifecycle\", <em>42th Euromicro Conference on Software Engineering and Advanced Applications (SEAA)</em>, pp. 9-16, 31 Aug.\u20132 Sept. 2016.", "title": "Time to Say \u2018Good Bye\u2019: Feature Lifecycle", "context": [{"sec": "sec3c2", "text": " The embedded systems domain is one example area where companies are aiming to become data-driven and that we previously studied [34], [11], [35].", "part": "1"}], "links": {"abstract": "With continuous deployment of software functionality, a constant flow of new features to products is enabled. Although new functionality has potential to deliver improvements and possibilities that were previously not available, it does not necessary generate business value. On the contrary, with fast and increasing system complexity that is associated with high operational costs, more waste than value risks to be created. Validating how much value a feature actually delivers, project how this v...", "pdfSize": "260KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Time+to+Say+%E2%80%98Good+Bye%E2%80%99%3A+Feature+Lifecycle&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "<em>Hypothesis Kit for A/B testing</em>,  [online]  Available: http://www.experimentationhub.com/hypothesis-kit.html.", "title": "Hypothesis Kit for A/B testing", "context": [{"sec": "sec5a", "text": " For companies that lack these skills and wish to train their engineers on these topics, online resources and kits are available [36].", "part": "1"}, {"sec": "sec5c1b", "text": " See [36] for details.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hypothesis+Kit+for+A%2FB+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "D. Yuan, S. Park, Y. Zhou, \"Characterizing logging practices in open-source software\", <em>Proceedings \u2014 International Conference on Software Engineering</em>, pp. 102-112, 2012.", "title": "Characterizing logging practices in open-source software", "context": [{"sec": "sec5b1a", "text": " In non-data driven companies, logging exists for the purpose of debugging product features [30], [37], [38].", "part": "1"}], "links": {"documentLink": "/document/6227202", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227202", "abstract": "Software logging is a conventional programming practice. While its efficacy is often important for users and developers to understand what have happened in the production run, yet software logging is often done in an arbitrary manner. So far, there have been little study for understanding logging practices in real world software. This paper makes the first attempt (to the best of our knowledge) to provide a quantitative characteristic study of the current log messages within four pieces of large...", "pdfSize": "952KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+logging+practices+in+open-source+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "Q. Fu et al., \"Where do developers log? an empirical study on logging practices in industry\", <em>Companion Proc. 36th Int. Conf. Softw. Eng. \u2014 ICSE Companion 2014</em>, pp. 24-33, 2014.", "title": "Where do developers log? an empirical study on logging practices in industry", "context": [{"sec": "sec5b1a", "text": " In non-data driven companies, logging exists for the purpose of debugging product features [30], [37], [38].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2591062.2591175", "abstract": "System logs are widely used in various tasks of software system management. It is crucial to avoid logging too little or too much. To achieve so, developers need to make informed decisions on where to log and what to log in their logging practices during development. However, there exists no work on studying such logging practices in industry or helping developers make informed decisions. To fill this significant gap, in this paper, we systematically study the logging practices of developers in ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Where+do+developers+log%3F+an+empirical+study+on+logging+practices+in+industry&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "K. Rodden, H. Hutchinson, X. Fu, \"Measuring the User Experience on a Large Scale: User-Centered Metrics for Web Applications\", <em>Proc. SIGCHI Conf. Hum. Factors Comput. Syst.</em>, pp. 2395-2398, 2010.", "title": "Measuring the User Experience on a Large Scale: User-Centered Metrics for Web Applications", "context": [{"sec": "sec5c1a", "text": " A popular research contribution from Google provides practical guidance on the creation of these metrics for measuring user experience on a large scale [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1753326.1753687", "abstract": "More and more products and services are being deployed on the web, and this presents new challenges and opportunities for measurement of user experience on a large scale. There is a strong need for user-centered metrics for web applications, which can be used to measure progress towards key goals, and drive product decisions. In this note, we describe the HEART framework for user-centered metrics, as well as a process for mapping product goals to metrics. We include practical examples of how HEA...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Measuring+the+User+Experience+on+a+Large+Scale%3A+User-Centered+Metrics+for+Web+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "<em>Optimizely</em>,  [online]  Available: https://www.optimizely.com/.", "title": "Optimizely", "context": [{"sec": "sec5c1b", "text": " Several third party experimentation platforms are available to software companies out of the box [40]\u2013[42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Optimizely&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "<em>Mixpanel</em>,  [online]  Available: https://mixpanel.com/.", "title": "Mixpanel", "context": [{"sec": "sec5c1b", "text": " Several third party experimentation platforms are available to software companies out of the box [40]\u2013[41][42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mixpanel&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "<em>Oracle Maxymiser</em>,  [online]  Available: https://www.oracle.com/marketingcloud/products/testing-and-optimization/index.html.", "title": "Oracle Maxymiser", "context": [{"sec": "sec5c1b", "text": " Several third party experimentation platforms are available to software companies out of the box [40]\u2013[42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Oracle+Maxymiser&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "W. Wood, M.G. Witt, L. Tam, \"Changing circumstances disrupting habits\", <em>J. Pers. Soc. Psychol.</em>, vol. 88, no. 6, pp. 918-33, 2005.", "title": "Changing circumstances, disrupting habits", "context": [{"sec": "sec5d1a", "text": " Metrics should evolve from counting signals to capturing more abstract concepts such as \u201cloyalty\u201d and \u201csuccess\u201d, closely related to long-term company goals [43].", "part": "1"}, {"sec": "sec5e1a", "text": " At the same time, and since customers' preferences change over time [43], a product team should invest in standardizing metric design and evaluation practices and scheduling the activities for updating the existing OEC.", "part": "1"}, {"sec": "sec5e1a", "text": " See [43] for details.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0022-3514.88.6.918", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Changing+circumstances%2C+disrupting+habits&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985712", "articleId": "7985712", "startPage": "770", "endPage": "780", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 13, "citationCountPatent": 0, "totalDownloads": 692}}
{"title": "Adaptive Unpacking of Android Apps", "authors": [{"name": "Lei Xue", "affiliation": "Dept. of Comput., Hong Kong Polytech. Univ., Hong Kong, China", "firstName": "Lei", "lastName": "Xue", "id": "37085422436"}, {"name": "Xiapu Luo", "affiliation": "Dept. of Comput., Hong Kong Polytech. Univ., Hong Kong, China", "firstName": "Xiapu", "lastName": "Luo", "id": "37417418500"}, {"name": "Le Yu", "affiliation": "Dept. of Comput., Hong Kong Polytech. Univ., Hong Kong, China", "firstName": "Le", "lastName": "Yu", "id": "37085775655"}, {"name": "Shuai Wang", "affiliation": "Dept. of Comput., Hong Kong Polytech. Univ., Hong Kong, China", "firstName": "Shuai", "lastName": "Wang", "id": "37085775723"}, {"name": "Dinghao Wu", "affiliation": "Coll. of Inf. Sci. & Technol, Pennsylvania State Univ., University Park, PA, USA", "firstName": "Dinghao", "lastName": "Wu", "id": "37896552600"}], "abstract": "More and more app developers use the packing services (or packers) to prevent attackers from reverse engineering and modifying the executable (or Dex files) of their apps. At the same time, malware authors also use the packers to hide the malicious component and evade the signature-based detection. Although there are a few recent studies on unpacking Android apps, it has been shown that the evolving packers can easily circumvent them because they are not adaptive to the changes of packers. In this paper, we propose a novel adaptive approach and develop a new system, named PackerGrind, to unpack Android apps. We also evaluate PackerGrind with real packed apps, and the results show that PackerGrind can successfully reveal the packers' protection mechanisms and recover the Dex files with low overhead, showing that our approach can effectively handle the evolution of packers.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Androids", "Humanoid robots", "Monitoring", "Subspace constraints", "Data collection", "Runtime", "Loading"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "invasive software", "reverse engineering"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["adaptive unpacking", "Android apps", "signature-based detection", "reverse engineering", "PackerGrind", "malware authors"]}, {"type": "Author Keywords ", "kwd": ["Dynamic Analysis", "App Unpacking"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.40", "ref": [{"order": "1", "text": "<em>Statistics and facts about Android</em>, 2016,  [online]  Available: https://www.statista.com/topics/876/android/.", "title": "Statistics and facts about Android", "context": [{"sec": "sec1", "text": "With more than 2 million apps on the Google Play, Android has accounted for around 85% of all smartphone sales to end users [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Statistics+and+facts+about+Android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "G. Kelly, <em>97% of mobile malware is on Android. this is the easy way you stay safe</em>, 2014,  [online]  Available: http://arcy24.blogspot.hk!2014/09/report-97-of-mobile-malware-is-on.html.", "title": "97% of mobile malware is on Android. this is the easy way you stay safe", "context": [{"sec": "sec1", "text": " At the same time, recent reports revealed that 97-99% of mobile malware runs on Android [2], [3], most of which are repackaged apps [4]\u2013[7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=97%25+of+mobile+malware+is+on+Android.+this+is+the+easy+way+you+stay+safe&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Cisco 2014 annual security report</em>, 2014,  [online]  Available: https://www.cisco.comlweb/offers/lp/2014-annual-security-report/index.html.", "title": "Cisco 2014 annual security report", "context": [{"sec": "sec1", "text": " At the same time, recent reports revealed that 97-99% of mobile malware runs on Android [2], [3], most of which are repackaged apps [4]\u2013[7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cisco+2014+annual+security+report&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "Y. Zhou, X. Jiang, \"Dissecting Android malware: Characterization and evolution\", <em>Proceedings of the IEEE Symposium on Security and Privacy (IEEE S&P)</em>, 2012.", "title": "Dissecting Android malware: Characterization and evolution", "context": [{"sec": "sec1", "text": " At the same time, recent reports revealed that 97-99% of mobile malware runs on Android [2], [3], most of which are repackaged apps [4]\u2013[7].", "part": "1"}], "links": {"documentLink": "/document/6234407", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6234407", "abstract": "The popularity and adoption of smart phones has greatly stimulated the spread of mobile malware, especially on the popular platforms such as Android. In light of their rapid growth, there is a pressing need to develop effective solutions. However, our defense capability is largely constrained by the limited understanding of these emerging mobile malware and the lack of timely access to related samples. In this paper, we focus on the Android platform and aim to systematize or characterize existin...", "pdfSize": "454KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dissecting+Android+malware%3A+Characterization+and+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "K. Chen, P. Wang, Y. Lee, X. Wang, N. Zhang, H. Huang, W. Zou, P. Liu, \"Finding unknown malice in 10 seconds: Mass vetting for new threats at the Google-Play scale\", <em>Proceedings of the USENIX Security Symposium</em>, 2015.", "title": "Finding unknown malice in 10 seconds: Mass vetting for new threats at the Google-Play scale", "context": [{"sec": "sec1", "text": " At the same time, recent reports revealed that 97-99% of mobile malware runs on Android [2], [3], most of which are repackaged apps [4]\u2013[5][7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+unknown+malice+in+10+seconds%3A+Mass+vetting+for+new+threats+at+the+Google-Play+scale&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "Y. Shao, X. Luo, C. Qian, P. Zhu, L. Zhang, \"Towards a scalable resource-driven approach for detecting repackaged android applications\", <em>Proceedings of the Annual ComputerSecurity Applications Conference (ACSAC)</em>, 2014.", "title": "Towards a scalable resource-driven approach for detecting repackaged android applications", "context": [{"sec": "sec1", "text": " At the same time, recent reports revealed that 97-99% of mobile malware runs on Android [2], [3], most of which are repackaged apps [4]\u2013[6][7].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2664243.2664275", "abstract": "Repackaged Android applications (or simply apps) are one of the major sources of mobile malware and also an important cause of severe revenue loss to app developers. Although a number of solutions have been proposed to detect repackaged apps, the majority of them heavily rely on code analysis, thus suffering from two limitations: (1) poor scalability due to the billion opcode problem; (2) unreliability to code obfuscation/app hardening techniques. In this paper, we explore an alternative approac...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+a+scalable+resource-driven+approach+for+detecting+repackaged+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "M. Fan, J. Liu, X. Luo, K. Chen, T. Chen, Z. Tian, X. Zhang, Q. Zheng, T. Liu, \"Frequent subgraph based familial classification of android malware\", <em>Proceedings of the International Symposium on Software Reliability Engineering (ISSRE)</em>, 2016.", "title": "Frequent subgraph based familial classification of android malware", "context": [{"sec": "sec1", "text": " At the same time, recent reports revealed that 97-99% of mobile malware runs on Android [2], [3], most of which are repackaged apps [4]\u2013[7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Frequent+subgraph+based+familial+classification+of+android+malware&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>OWASP mobile top 10 risks</em>, 2014,  [online]  Available: https://www.owasp.org/index.php/OWASP_Mobile_Security_Project#tab=Top_10_Mobile_Risks.", "title": "OWASP mobile top 10 risks", "context": [{"sec": "sec1", "text": " One root cause is the lack of binary protections, which is one of the OWASP mobile top ten risks [8], so that attackers can easily reverse engineer the apps and tamper their code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=OWASP+mobile+top+10+risks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "<em>Debunking six myths of app wrapping</em>, 2015,  [online]  Available: https://www.gartner.com/doc/3008117/debunking-myths-app-wrapping.", "title": "Debunking six myths of app wrapping", "context": [{"sec": "sec1", "text": "To protect apps from being tampered and reverse engineered, a number of app packing services (or packers) emerge [9], which conceal and obfuscate the real code (i.e., Dex files) and prevent others from obtaining them [10], [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Debunking+six+myths+of+app+wrapping&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "Y. Zhang, X. Luo, H. Yin, \"DexHunter: toward extracting hidden code from packed Android applications\", <em>Proceedings of the European Symposium on Research in ComputerSecurity (ESORICS)</em>, 2015.", "title": "DexHunter: toward extracting hidden code from packed Android applications", "context": [{"sec": "sec1", "text": "To protect apps from being tampered and reverse engineered, a number of app packing services (or packers) emerge [9], which conceal and obfuscate the real code (i.e., Dex files) and prevent others from obtaining them [10], [11].", "part": "1"}, {"sec": "sec1", "text": " Therefore, researchers proposed a few unpacking approaches recently to recover the Dex files from packed apps in order to facilitate the analysis of mobile malware [10], [11].", "part": "1"}, {"sec": "sec1", "text": " The results show that PackerGrind can unpack all these apps with low overhead whereas DexHunter [10] recovered a few and Android-unpacker [21] unpacked none.", "part": "1"}, {"sec": "sec2c", "text": "The state-of-the-art unpackers (i.e, DexHunter [10] and AppSpear [11]) cannot obtain the instructions in \\$onCreate001()\\$ effectively.", "part": "1"}, {"sec": "sec4e3", "text": " Note that other unpackers (e.g., [10], [11]) cannot profile such behavior.", "part": "1"}, {"sec": "sec7", "text": " The unpacking techniques for x86 binaries cannot be applied to packed Android apps because Android and the OSes running on x86 CPU have different architectures and execution models [10], [11], let alone the different formats of their executables.", "part": "1"}, {"sec": "sec7", "text": "Since mobile malware adopts packers to evade the detection, a few studies on unpacking apps were proposed recently from both academia [10], [11], [58] and industry [21], [39].", "part": "1"}, {"sec": "sec7", "text": " DexHunter [10] and AppSpear [11] are proposed to be general unpacker by customizing Android runtime.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-24177-7_15", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DexHunter%3A+toward+extracting+hidden+code+from+packed+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "W. Yang, Y. Zhang, J. Li, J. Shu, B. Li, W. Hu, D. Gu, \"AppSpear: Bytecode decrypting and DEX reassembling for packed Android malware\", <em>Proceedings of the InternationalSymposium on Research in Attacks Intrusions and Defenses (RAID)</em>, 2015.", "title": "AppSpear: Bytecode decrypting and DEX reassembling for packed Android malware", "context": [{"sec": "sec1", "text": "To protect apps from being tampered and reverse engineered, a number of app packing services (or packers) emerge [9], which conceal and obfuscate the real code (i.e., Dex files) and prevent others from obtaining them [10], [11].", "part": "1"}, {"sec": "sec1", "text": " Therefore, researchers proposed a few unpacking approaches recently to recover the Dex files from packed apps in order to facilitate the analysis of mobile malware [10], [11].", "part": "1"}, {"sec": "sec2c", "text": "The state-of-the-art unpackers (i.e, DexHunter [10] and AppSpear [11]) cannot obtain the instructions in \\$onCreate001()\\$ effectively.", "part": "1"}, {"sec": "sec4e3", "text": " Note that other unpackers (e.g., [10], [11]) cannot profile such behavior.", "part": "1"}, {"sec": "sec7", "text": " The unpacking techniques for x86 binaries cannot be applied to packed Android apps because Android and the OSes running on x86 CPU have different architectures and execution models [10], [11], let alone the different formats of their executables.", "part": "1"}, {"sec": "sec7", "text": "Since mobile malware adopts packers to evade the detection, a few studies on unpacking apps were proposed recently from both academia [10], [11], [58] and industry [21], [39].", "part": "1"}, {"sec": "sec7", "text": " DexHunter [10] and AppSpear [11] are proposed to be general unpacker by customizing Android runtime.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-26362-5_17", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AppSpear%3A+Bytecode+decrypting+and+DEX+reassembling+for+packed+Android+malware&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "A. Apvrille, R. Nigam, Obfuscation in Android malware and how to fight back, Virus Bulletin, July 2014.", "title": "Obfuscation in Android malware, and how to fight back", "context": [{"sec": "sec1", "text": " Unfortunately, attackers also utilize packers to hide malware for evading the signature-based detection and impeding the investigation of their malicious behaviors [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Obfuscation+in+Android+malware%2C+and+how+to+fight+back&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "S. Aimoto, <em>Five ways Android malware is becoming more resilient</em>, 2016,  [online]  Available: https://www.symantec.com/connect/blogs/five-ways-android-malware-becoming-more-resilient.", "title": "Five ways Android malware is becoming more resilient", "context": [{"sec": "sec1", "text": " A recent report from Symantec reveals that the number of packed Android malware has increased from 10% to 25% [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Five+ways+Android+malware+is+becoming+more+resilient&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "T. Vidas, N. Christin, \"Evading Android runtime analysis via sandbox detection\", <em>Proceedings of the ACM Asia Conference on Computerand Communications Security (ASIA CCS)</em>, 2014.", "title": "Evading Android runtime analysis via sandbox detection", "context": [{"sec": "sec1", "text": " Packed apps usually exploit the features of the Java language, Android framework, and native libs/instructions to hide the real code, detect emulator, and prohibit debugging [14].", "part": "1"}, {"sec": "sec2b2", "text": " Since many dynamic analysis systems rely on Android emulator, packers employ advanced techniques [14] to determine whether a packed app is running in an emulator.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2590296.2590325", "abstract": "The large amounts of malware, and its diversity, have made it necessary for the security community to use automated dynamic analysis systems. These systems often rely on virtualization or emulation, and have recently started to be available to process mobile malware. Conversely, malware authors seek to detect such systems and evade analysis. In this paper, we present techniques for detecting Android runtime analysis systems. Our techniques are classified into four broad classes showing the abili...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evading+Android+runtime+analysis+via+sandbox+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "L.-K. Yan, H. Yin, \"DroidScope: Seamlessly reconstructing OS and Dalvik semantic views for dynamic Android malware analysis\", <em>Proceedings of the USENIX Security Symposium</em>, 2012.", "title": "DroidScope: Seamlessly reconstructing OS and Dalvik semantic views for dynamic Android malware analysis", "context": [{"sec": "sec1", "text": " Existing dynamic analysis systems for monitoring apps cannot address RQ1, because they either rely on emulator (e.g., QEMU) [15], [16] and debugging techniques [17], [18] or lack of the support of cross-layer profiling [16], [19].", "part": "1"}, {"sec": "sec5f", "text": " Compared with the dynamic analysis systems based on emulator that may introduce 11\u201334 times slowdown [15], PackerGrind has acceptable efficiency.", "part": "1"}, {"sec": "sec7", "text": "Existing cross-layer monitoring tools [15], [19], [59], [60] for Android cannot collect all necessary information and fulfill the requirement for handling packed apps.", "part": "1"}, {"sec": "sec7", "text": " DroidScope [15] and NDroid [60] rely on QEMU, which can be detected by packers [61].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidScope%3A+Seamlessly+reconstructing+OS+and+Dalvik+semantic+views+for+dynamic+Android+malware+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "K. Tam, S.J. Khan, A. Fattori, L. Cavallaro, \"CopperDroid: Automatic reconstruction of Android malware behaviors\", <em>Proceedings of the Network and Distributed System Security Symposium (NDSS)</em>, 2015.", "title": "CopperDroid: Automatic reconstruction of Android malware behaviors", "context": [{"sec": "sec1", "text": " Existing dynamic analysis systems for monitoring apps cannot address RQ1, because they either rely on emulator (e.g., QEMU) [15], [16] and debugging techniques [17], [18] or lack of the support of cross-layer profiling [16], [19].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2015.23145", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CopperDroid%3A+Automatic+reconstruction+of+Android+malware+behaviors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Zheng, M. Sun, J.C. Lui, \"DroidTrace: a ptrace based Android dynamic analysis system with forward execution capability\", <em>Proceedings of the International Wireless Communicationsand Mobile Computing Conference (IWCMC)</em>, 2014.", "title": "DroidTrace: a ptrace based Android dynamic analysis system with forward execution capability", "context": [{"sec": "sec1", "text": " Existing dynamic analysis systems for monitoring apps cannot address RQ1, because they either rely on emulator (e.g., QEMU) [15], [16] and debugging techniques [17], [18] or lack of the support of cross-layer profiling [16], [19].", "part": "1"}], "links": {"abstract": "Android, being an open source smartphone operating system, enjoys a large community of developers who create new mobile services and applications. However, it also attracts malware writers to exploit Android devices in order to distribute malicious apps in the wild. In fact, Android malware are becoming more sophisticated and they use advanced \u201cdynamic loading\u201d techniques like Java reflection or native code execution to bypass security detection. To detect dynamic loading, one has to use dynamic...", "pdfSize": "841KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DroidTrace%3A+a+ptrace+based+Android+dynamic+analysis+system+with+forward+execution+capability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "C. Yang, G. Yang, A. Gehani, V. Yegneswaran, D. Tariq, G. Gu, \"Using provenance patterns to vet sensitive behaviors in Android apps\", <em>Proceedings of the EAI International Conference on Security and Privacy in Communication Networks (SecureComm)</em>, 2015.", "title": "Using provenance patterns to vet sensitive behaviors in Android apps", "context": [{"sec": "sec1", "text": " Existing dynamic analysis systems for monitoring apps cannot address RQ1, because they either rely on emulator (e.g., QEMU) [15], [16] and debugging techniques [17], [18] or lack of the support of cross-layer profiling [16], [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+provenance+patterns+to+vet+sensitive+behaviors+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "W. Enck, P. Gilbert, S. Han, V. Tendulkar, B.-G. Chun, L.P. Cox, J. Jung, P. McDaniel, A.N. Sheth, \"TaintDroid: an information-flow tracking system for realtime privacy monitoring on smartphones\", <em>ACM Transactions on ComputerSystems</em>, vol. 32, no. 2, 2014.", "title": "TaintDroid: an information-flow tracking system for realtime privacy monitoring on smartphones", "context": [{"sec": "sec1", "text": " Existing dynamic analysis systems for monitoring apps cannot address RQ1, because they either rely on emulator (e.g., QEMU) [15], [16] and debugging techniques [17], [18] or lack of the support of cross-layer profiling [16], [19].", "part": "1"}, {"sec": "sec7", "text": "Existing cross-layer monitoring tools [15], [19], [59], [60] for Android cannot collect all necessary information and fulfill the requirement for handling packed apps.", "part": "1"}, {"sec": "sec7", "text": " TaintDroid [19] neither supports ART nor collects information at the runtime, system, and instruction layers.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2619091", "abstract": "Today\u2019s smartphone operating systems frequently fail to provide users with visibility into how third-party applications collect and share their private data. We address these shortcomings with TaintDroid, an efficient, system-wide dynamic taint tracking and analysis system capable of simultaneously tracking multiple sources of sensitive data. TaintDroid enables realtime analysis by leveraging Android\u2019s virtualized execution environment. TaintDroid incurs only 32% performance overhead on a CPU-bo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=TaintDroid%3A+an+information-flow+tracking+system+for+realtime+privacy+monitoring+on+smartphones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "N. Nethercote, J. Seward, \"Valgrind: a framework for heavyweight dynamic binary instrumentation\", <em>Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, 2007.", "title": "Valgrind: a framework for heavyweight dynamic binary instrumentation", "context": [{"sec": "sec1", "text": " By exploiting dynamic binary translation [20], it collects information from the runtime, the system, and the instruction layers and runs in smartphones.", "part": "1"}, {"sec": "sec2b2", "text": " Instead, it exploits dynamic binary translation [20] to perform cross-layer monitoring and recovers Dex files. (2) Anti-debug.", "part": "1"}, {"sec": "sec4a", "text": " We develop PackerGrind based on Valgrind [20] and therefore it runs in real smartphone instead of emulator.", "part": "1"}, {"sec": "sec4b1", "text": "To locate the structure DexFile, which represents a Dex file in runtime, and collect Dex data from the four basic data collection points (Section III), PackerGrind monitors the arguments and the returns of the selected functions in Table I using the function wrapping technique [20].", "part": "1"}, {"sec": "sec4b3", "text": "To monitor memory modifications, PackerGrind inserts an intermediate representation (IR) of function invocation statement before Ist_StoreG and Ist_Store statements that are translated from packed apps' native code by Valgrind [20].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1250734.1250746", "abstract": "Dynamic binary instrumentation (DBI) frameworks make it easy to build dynamic binary analysis (DBA) tools such as checkers and profilers. Much of the focus on DBI frameworks has been on performance; little attention has been paid to their capabilities. As a result, we believe the potential of DBI has not been fully exploited. In this paper we describe Valgrind, a DBI framework designed for building heavyweight DBA tools. We focus on its unique support for shadow values-a powerful but previously ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Valgrind%3A+a+framework+for+heavyweight+dynamic+binary+instrumentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>Android-unpacker</em>,  [online]  Available: https://github.com/strazzere/android-unpacker.", "title": "Android-unpacker", "context": [{"sec": "sec1", "text": " The results show that PackerGrind can unpack all these apps with low overhead whereas DexHunter [10] recovered a few and Android-unpacker [21] unpacked none.", "part": "1"}, {"sec": "sec5d", "text": " Hence, we only compare PackerGrind, DexHunter and Android-unpacker [21] using 30 randomly selected samples from six packers (i.e., 5 samples from each packer).", "part": "1"}, {"sec": "sec7", "text": "Since mobile malware adopts packers to evade the detection, a few studies on unpacking apps were proposed recently from both academia [10], [11], [58] and industry [21], [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android-unpacker&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>Dalvik executable format</em>, 2016,  [online]  Available: https://source.android.com/devices/tech/dalvik/dex-format.html.", "title": "Dalvik executable format", "context": [{"sec": "sec2a", "text": "The bytecode of an Android app is contained in the Dex file which is a highly structured data file consisting of different Dex data items [22](e.g., proto_id_item, code_data_item).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dalvik+executable+format&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "C. Collberg, J. Nagra, Surreptitious Software: Obfuscation Watermarking and Tamperproojing for Software Protection, Addison-Wesley, 2009.", "title": "Surreptitious Software: Obfuscation, Watermarking, and Tamperproojing for Software Protection", "context": [{"sec": "sec2b3", "text": "Packers commonly employ various techniques (e.g., obfuscation [23], etc.) to raise the bar for understanding the intemal logics through static code analysis.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Surreptitious+Software%3A+Obfuscation%2C+Watermarking%2C+and+Tamperproojing+for+Software+Protection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "<em>Baidu Inc.</em>,  [online]  Available: http://app.baidu.com.", "title": "Baidu Inc.", "context": [{"sec": "sec2c", "text": "We use an app packed by Baidu packer (in DB-15) [24] as a motivating example.", "part": "1"}, {"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}, {"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Baidu+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "M.Y. Wong, D. Lie, \"IntelliDroid: A targeted input generator for the dynamic analysis of Android malware\", <em>Proceedings of the Network and Distributed System Security Symposium (NDSS)</em>, 2016.", "title": "IntelliDroid: A targeted input generator for the dynamic analysis of Android malware", "context": [{"sec": "sec4e1", "text": "We employ IntelliDroid [25] to determine how to trigger the JNI methods in the dumped Dex files through statical analysis.", "part": "1"}, {"sec": "sec6", "text": " We also use IntelliDroid [25] to trigger the execution of such methods.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2016.23118", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=IntelliDroid%3A+A+targeted+input+generator+for+the+dynamic+analysis+of+Android+malware&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "<em>F-Droid</em>, 2015,  [online]  Available: https://f-droid.org/.", "title": "F-Droid", "context": [{"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=F-Droid&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>Qihoo360 Inc.</em>,  [online]  Available: http://dev.360.cn/.", "title": "Qihoo360 Inc.", "context": [{"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}, {"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Qihoo360+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "<em>Alibaba Inc.</em>,  [online]  Available: http://jaq.alibaba.com/.", "title": "Alibaba Inc.", "context": [{"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}, {"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Alibaba+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "<em>Bangcle Inc.</em>,  [online]  Available: http://www.bangcle.com/.", "title": "Bangcle Inc.", "context": [{"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}, {"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bangcle+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "<em>Tencent Inc.</em>,  [online]  Available: https://www.qcloud.com/product/cr.", "title": "Tencent Inc.", "context": [{"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}, {"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tencent+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "<em>Ijiami Inc.</em>,  [online]  Available: http://www.ijiami.cn/.", "title": "Ijiami Inc.", "context": [{"sec": "sec5a", "text": " More precisely, we download 40 randomly selected open-source apps from F-Droid [26] and then upload them to 6 online commercial packing services (Qihoo [27], Ali [28], Bangcle [29], Tencent [30], Baidu [24], Ijiami [31]) in Mar. 2015 (denoted as DB-15) and Mar. 2016 (denoted as DB-16) to construct 480 packed apps.", "part": "1"}, {"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ijiami+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "\"Palo Alto Networks\", <em>Wildfire [tm] lcloud-based threat analysis service</em>,  [online]  Available: https://www.paloaltonetworks.com/products/secure-the-network/subscriptions/wildfire.", "title": "Palo Alto Networks", "context": [{"sec": "sec5a", "text": " The second set consist of 200 packed malware samples from Palo Alto Networks [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Palo+Alto+Networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "<em>Apk protect</em>,  [online]  Available: https://sourceforge.net/projects/apkprotect.", "title": "Apk protect", "context": [{"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apk+protect&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "<em>NAGA IN Inc.</em>,  [online]  Available: http://www.nagain.com/.", "title": "NAGA IN Inc.", "context": [{"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=NAGA+IN+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "T. Strazzere, J. Sawyer, \"Android hacker protection level 0\", <em>DEFCON</em>, 2014.", "title": "Android hacker protection level 0", "context": [{"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+hacker+protection+level+0&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "<em>Netqin Inc.</em>,  [online]  Available: https://www.netqin.com.", "title": "Netqin Inc.", "context": [{"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Netqin+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "<em>PayEgis Inc.</em>,  [online]  Available: http://www.payegis.com/.", "title": "PayEgis Inc.", "context": [{"sec": "sec5a", "text": " These samples were packed by eleven packers including Ali [28], APKProtect [33], Baidu [24], Bangcle [29], Ijiami [31], Naga [34], Qihoo [27], Tencent [30], LIAPP [35], Netqin [36], and Payegis [37].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=PayEgis+Inc.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "<em>LG Nexus 5</em>,  [online]  Available: http://www.gsmarena.comllg_nexus_5-5705.php.", "title": "LG Nexus 5", "context": [{"sec": "sec5a", "text": "We conduct the experiments in both Android 4.4 with DVM and Android 6.0 with ART on a Nexus 5 smartphone [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=LG+Nexus+5&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "<em>ZjDroid</em>, 2016,  [online]  Available: https://github.comlhalfkiss/ZjDroid.", "title": "ZjDroid", "context": [{"sec": "sec5b", "text": " Bangcle packers uses \\$ptrace ()\\$ to protect the app process from being attached by debugging tools while Ijiami packer of DB-16 periodically searches for the string \u201c@com.android.reverse-\u201d to detect ZjDroid [39].", "part": "1"}, {"sec": "sec7", "text": "Since mobile malware adopts packers to evade the detection, a few studies on unpacking apps were proposed recently from both academia [10], [11], [58] and industry [21], [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ZjDroid&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "<em>Baksmali</em>, 2016,  [online]  Available: https://github.com/JesusFreke/smali.", "title": "Baksmali", "context": [{"sec": "sec5c2", "text": " These tools include Baksmali [40], Dexdump [41], Dex2jar [42], Jadx [43] and IDA Pro [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Baksmali&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "<em>Dexdump</em>, 2016,  [online]  Available: https://developer.android.com/studio/command-line/index.html.", "title": "Dexdump", "context": [{"sec": "sec5c2", "text": " These tools include Baksmali [40], Dexdump [41], Dex2jar [42], Jadx [43] and IDA Pro [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dexdump&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "<em>Dex2jar</em>, 2016,  [online]  Available: https://github.com/pxb1988/dex2jar.", "title": "Dex2jar", "context": [{"sec": "sec5c2", "text": " These tools include Baksmali [40], Dexdump [41], Dex2jar [42], Jadx [43] and IDA Pro [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dex2jar&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "<em>Jadx</em>, 2016,  [online]  Available: https://github.com/skylot/jadx.", "title": "Jadx", "context": [{"sec": "sec5c2", "text": " These tools include Baksmali [40], Dexdump [41], Dex2jar [42], Jadx [43] and IDA Pro [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jadx&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "<em>IDA Pro</em>, 2016,  [online]  Available: https://www.hex-rays.com/products/ida/.", "title": "IDA Pro", "context": [{"sec": "sec5c2", "text": " These tools include Baksmali [40], Dexdump [41], Dex2jar [42], Jadx [43] and IDA Pro [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=IDA+Pro&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "K. Au, Y.F. Zhou, Z. Huang, D. Lie, \"PScout: Analyzing the Android permission specification\", <em>Proceedings of the ACM Conference on Computerand Communications Security (CCS)</em>, 2012.", "title": "PScout: Analyzing the Android permission specification", "context": [{"sec": "sec5e", "text": " Given a Dex file, we scan all sensitive APIs in it, and count how many permissions are required according to the mapping between permissions and APIs from PScout [45].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2382196.2382222", "abstract": "Modern smartphone operating systems (OSs) have been developed with a greater emphasis on security and protecting privacy. One of the mechanisms these systems use to protect users is a permission system, which requires developers to declare what sensitive resources their applications will use, has users agree with this request when they install the application and constrains the application to the requested resources during runtime. As these permission systems become more common, questions have r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=PScout%3A+Analyzing+the+Android+permission+specification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "M. Zhang, Y. Duan, H. Yin, Z. Zhao, \"Semantics-aware android malware classification using weighted contextual api dependency graphs\", <em>Proceedings of the ACM Conference on Computerand Communications Security (CCS)</em>, 2014.", "title": "Semantics-aware android malware classification using weighted contextual api dependency graphs", "context": [{"sec": "sec5e", "text": " It is worth noting that many detection systems leverage sensitive APIs and permissions to discover mobile malware [46]\u2013[50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660359", "abstract": "The drastic increase of Android malware has led to a strong interest in developing methods to automate the malware analysis process. Existing automated Android malware detection and classification methods fall into two general categories: 1) signature-based and 2) machine learning-based. Signature-based approaches can be easily evaded by bytecode-level transformation attacks. Prior learning-based works extract features from application syntax, rather than program semantics, and are also subject ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semantics-aware+android+malware+classification+using+weighted+contextual+api+dependency+graphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "V. Avdiienko, K. Kuznetsov, A. Gorla, A. Zeller, S. Arzt, S. Rasthofer, E. Bodden, \"Mining apps for abnormal usage of sensitive data\", <em>Proceedings of the ACM/IEEE International Conference on Software Engineering (ICSE)</em>, 2015.", "title": "Mining apps for abnormal usage of sensitive data", "context": [{"sec": "sec5e", "text": " It is worth noting that many detection systems leverage sensitive APIs and permissions to discover mobile malware [46]\u2013[47][50].", "part": "1"}], "links": {"abstract": "What is it that makes an app malicious? One important factor is that malicious apps treat sensitive data differently from benign apps. To capture such differences, we mined 2,866 benign Android applications for their data flow from sensitive sources, and compare these flows against those found in malicious apps. We find that (a) for every sensitive source, the data ends up in a small number of typical sinks; (b) these sinks differ considerably between benign and malicious apps; (c) these differe...", "pdfSize": "984KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+apps+for+abnormal+usage+of+sensitive+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "L. Yu, X. Luo, X. Liu, T. Zhang, \"Can we trust the privacy policies of android apps?\", <em>Proceedings of the IEEE/IFIP InternationalConference on Dependable Systems and Networks (DSN)</em>, 2016.", "title": "Can we trust the privacy policies of android apps?", "context": [{"sec": "sec5e", "text": " It is worth noting that many detection systems leverage sensitive APIs and permissions to discover mobile malware [46]\u2013[48][50].", "part": "1"}], "links": {"documentLink": "/document/7579770", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7579770", "abstract": "Recent years have witnessed the sharp increase of malicious apps that steal users&#39; personal information. To address users&#39; concerns about privacy risks, more and more apps are accompanied with privacy policies written in natural language because it is difficult for users to infer an app&#39;s behaviors according to the required permissions. However, little is known whether these privacy policies are trustworthy or not. It is worth noting that a questionable privacy policy may result from careless pr...", "pdfSize": "428KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Can+we+trust+the+privacy+policies+of+android+apps%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "M. Xu, C. Song, Y. Ji, M.-W. Shih, K. Lu, C. Zheng, R. Duan, Y. Jang, B. Lee, C. Qian, S. Lee, T. Kim, \"Toward engineering a secure android ecosystem: A survey of existing techniques\", <em>ACM Computing Surveys (CSUR)</em>, vol. 49, no. 2, 2016.", "title": "Toward engineering a secure android ecosystem: A survey of existing techniques", "context": [{"sec": "sec5e", "text": " It is worth noting that many detection systems leverage sensitive APIs and permissions to discover mobile malware [46]\u2013[49][50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2963145", "abstract": "The openness and extensibility of Android have made it a popular platform for mobile devices and a strong candidate to drive the Internet-of-Things. Unfortunately, these properties also leave Android vulnerable, attracting attacks for profit or fun. To mitigate these threats, numerous issue-specific solutions have been proposed. With the increasing number and complexity of security problems and solutions, we believe this is the right moment to step back and systematically re-evaluate the Android...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Toward+engineering+a+secure+android+ecosystem%3A+A+survey+of+existing+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "K. Tam, A. Feizollah, N.B. Anuar, R. Salleh, L. Cavallaro, \"The evolution of android malware and android analysis techniques\", <em>ACM Computing Surveys (CSUR)</em>, vol. 49, no. 4, 2017.", "title": "The evolution of android malware and android analysis techniques", "context": [{"sec": "sec5e", "text": " It is worth noting that many detection systems leverage sensitive APIs and permissions to discover mobile malware [46]\u2013[50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3017427", "abstract": "With the integration of mobile devices into daily life, smartphones are privy to increasing amounts of sensitive information. Sophisticated mobile malware, particularly Android malware, acquire or utilize such data without user consent. It is therefore essential to devise effective techniques to analyze and detect these threats. This article presents a comprehensive survey on leading Android malware analysis and detection techniques, and their effectiveness against evolving malware. This article...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+evolution+of+android+malware+and+android+analysis+techniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "<em>CF-Bench</em>, 2016,  [online]  Available: http://bench.chainfire.eu/.", "title": "CF-Bench", "context": [{"sec": "sec5f", "text": "To evaluate the overhead introduced by PackerGrind, we run CF-Benchmark [51] 30 times on Nexus 5 without Valgrind, with Valgrind, and with PackerGrind, respectively.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=CF-Bench&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "S.R. Choudhary, A. Gorla, A. Orso, \"Automated test input generation for android: Are we there yet?\", <em>Proceedings of the IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, 2015.", "title": "Automated test input generation for android: Are we there yet?", "context": [{"sec": "sec6", "text": " Since packers may delay the execution of such methods after knowing the mechanism of PackerGrind we will leverage advanced input generator for Android [52], [53] to enhance PackerGrind in future work.", "part": "1"}], "links": {"documentLink": "/document/7372031", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372031", "abstract": "Like all software, mobile applications (&#34;apps&#34;) must be adequately tested to gain confidence that they behave correctly. Therefore, in recent years, researchers and practitioners alike have begun to investigate ways to automate apps testing. In particular, because of Android&#39;s open source nature and its large share of the market, a great deal of research has been performed on input generation techniques for apps that run on the Android operating systems. At this point in time, there are in fact ...", "pdfSize": "289KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+test+input+generation+for+android%3A+Are+we+there+yet%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "N. Mirzaei, J. Garcia, H. Bagheri, A. Sadeghi, S. Malek, \"Reducing combinatorics in gui testing of Android applications\", <em>Proceedings of the ACM/IEEE InternationalConference on Software Engineering (ICSE)</em>, 2016.", "title": "Reducing combinatorics in gui testing of Android applications", "context": [{"sec": "sec6", "text": " Since packers may delay the execution of such methods after knowing the mechanism of PackerGrind we will leverage advanced input generator for Android [52], [53] to enhance PackerGrind in future work.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884853", "abstract": "The rising popularity of Android and the GUI-driven nature of its apps have motivated the need for applicable automated GUI testing techniques. Although exhaustive testing of all possible combinations is the ideal upper bound in combinatorial testing, it is often infeasible, due to the combinatorial explosion of test cases. This paper presents TrimDroid, a framework for GUI testing of Android apps that uses a novel strategy to generate tests in a combinatorial, yet scalable, fashion. It is backe...", "pdfSize": "967KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reducing+combinatorics+in+gui+testing+of+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "F. Guo, P. Ferrie, T.-C. Chiueh, \"A study of the packer problem and its solutions\", <em>Proceedings of the International Symposium on Recent Advances in Intrusion Detection (RAID)</em>, 2008.", "title": "A study of the packer problem and its solutions", "context": [{"sec": "sec7", "text": "Although there are already many studies on code packing/unpacking, almost all of them focus on x86 native codes [54]\u2013[57].", "part": "1"}, {"sec": "sec7", "text": " For example, Android packers need to protect both the Dex code and the native code if any, whereas traditional packers only hide native code [54]\u2013[57].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+study+of+the+packer+problem+and+its+solutions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "G. Bonfante, J. Fernandez, J.-Y. Marion, B. Rouxel, F. Sabatier, A. Thierry, \"CoDisasm: Medium scale concatic disassembly of self-modifying binaries with overlapping instructions\", <em>Proceedings of the ACM Conference on Computerand Communications Security (CCS)</em>, 2015.", "title": "CoDisasm: Medium scale concatic disassembly of self-modifying binaries with overlapping instructions", "context": [{"sec": "sec7", "text": "Although there are already many studies on code packing/unpacking, almost all of them focus on x86 native codes [54]\u2013[55][57].", "part": "1"}, {"sec": "sec7", "text": " For example, Android packers need to protect both the Dex code and the native code if any, whereas traditional packers only hide native code [54]\u2013[55][57].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2810103.2813627", "abstract": "Fighting malware involves analyzing large numbers of suspicious binary files. In this context, disassembly is a crucial task in malware analysis and reverse engineering. It involves the recovery of assembly instructions from binary machine code. Correct disassembly of binaries is necessary to produce a higher level representation of the code and thus allow the analysis to develop high-level understanding of its behavior and purpose. Nonetheless, it can be problematic in the case of malicious cod...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CoDisasm%3A+Medium+scale+concatic+disassembly+of+self-modifying+binaries+with+overlapping+instructions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "X. Ugarte-Pedrero, D. Balzarotti, I. Santos, P.G. Bringas, \"SoK: Deep packer inspection: A longitudinal study of the complexity of runtime packers\", <em>Proceedings of the IEEE Symposium on Security and Privacy (IEEE S&P)</em>, 2015.", "title": "SoK: Deep packer inspection: A longitudinal study of the complexity of runtime packers", "context": [{"sec": "sec7", "text": "Although there are already many studies on code packing/unpacking, almost all of them focus on x86 native codes [54]\u2013[56][57].", "part": "1"}, {"sec": "sec7", "text": " For example, Android packers need to protect both the Dex code and the native code if any, whereas traditional packers only hide native code [54]\u2013[56][57].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SoK%3A+Deep+packer+inspection%3A+A+longitudinal+study+of+the+complexity+of+runtime+packers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "S. Schrittwieser, S. Katzenbeisser, J. Kinder, G. Merzdovnik, E. Weippl, \"Protecting software through obfuscation: Can it keep pace with progress in code analysis?\", <em>ACM Computing Surveys (CSUR)</em>, 2016.", "title": "Protecting software through obfuscation: Can it keep pace with progress in code analysis?", "context": [{"sec": "sec7", "text": "Although there are already many studies on code packing/unpacking, almost all of them focus on x86 native codes [54]\u2013[57].", "part": "1"}, {"sec": "sec7", "text": " For example, Android packers need to protect both the Dex code and the native code if any, whereas traditional packers only hide native code [54]\u2013[57].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2886012", "abstract": "Software obfuscation has always been a controversially discussed research area. While theoretical results indicate that provably secure obfuscation in general is impossible, its widespread application in malware and commercial software shows that it is nevertheless popular in practice. Still, it remains largely unexplored to what extent today\u2019s software obfuscations keep up with state-of-the-art code analysis and where we stand in the arms race between software developers and code analysts. The ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Protecting+software+through+obfuscation%3A+Can+it+keep+pace+with+progress+in+code+analysis%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "D. Kim, J. Kwak, J. Ryou, \"DWroidDump: Executable code extraction from Android applications for malware analysis\", <em>International Journal of Distributed Sensor Networks</em>, 2015.", "title": "DWroidDump: Executable code extraction from Android applications for malware analysis", "context": [{"sec": "sec7", "text": "Since mobile malware adopts packers to evade the detection, a few studies on unpacking apps were proposed recently from both academia [10], [11], [58] and industry [21], [39].", "part": "1"}, {"sec": "sec7", "text": " For example, DWroidDump [58] only collects the Dex data in \\$dvmDexFileOpenFromFd()\\$ when a Dex file is mapped to memory by the runtime.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1155/2015/379682", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=DWroidDump%3A+Executable+code+extraction+from+Android+applications+for+malware+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "X. Wei, L. Gomez, I. Neamtiu, M. Faloutsos, \"Profiledroid: multilayer profiling of android applications\", <em>Proceedings of the 18th annual international conference on Mobile computing and networking (Mobicom)</em>, 2012.", "title": "Profiledroid: multilayer profiling of android applications", "context": [{"sec": "sec7", "text": "Existing cross-layer monitoring tools [15], [19], [59], [60] for Android cannot collect all necessary information and fulfill the requirement for handling packed apps.", "part": "1"}, {"sec": "sec7", "text": " For example, ProfileDroid [59] cannot handle packed apps because it relies on apktool to conduct static analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2348543.2348563", "abstract": "The Android platform lacks tools for assessing and monitoring apps in a systematic way. This lack of tools is particularly problematic when combined with the open nature of Google Play, the main app distribution channel. As our key contribution, we design and implement ProfileDroid, a comprehensive, multi-layer system for monitoring and profiling apps. Our approach is arguably the first to profile apps at four layers: (a) static, or app specification, (b) user interaction, (c) operating system, ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Profiledroid%3A+multilayer+profiling+of+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "C. Qian, X. Luo, Y. Shao, A.T. Chan, \"On tracking information flows through jni in android applications\", <em>Proceedings of the IEEE/IFIP International Conference on Dependable Systems and Networks (DSN)</em>, 2014.", "title": "On tracking information flows through jni in android applications", "context": [{"sec": "sec7", "text": "Existing cross-layer monitoring tools [15], [19], [59], [60] for Android cannot collect all necessary information and fulfill the requirement for handling packed apps.", "part": "1"}, {"sec": "sec7", "text": " DroidScope [15] and NDroid [60] rely on QEMU, which can be detected by packers [61].", "part": "1"}], "links": {"documentLink": "/document/6903578", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6903578", "abstract": "Android provides native development kit through JNI for developing high-performance applications (or simply apps). Although recent years have witnessed a considerable increase in the number of apps employing native libraries, only a few systems can examine them. However, none of them scrutinizes the interactions through JNI in them. In this paper, we conduct a systematic study on tracking information flows through JNI in apps. More precisely, we first perform a large-scale examination on apps us...", "pdfSize": "1704KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+tracking+information+flows+through+jni+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "Y. Jing, Z. Zhao, G.-J. Ahn, H. Hu, \"Morpheus: automatically generating heuristics to detect Android emulators\", <em>Proceedings of the Annual Computer Security Applications Conference (ACSAC)</em>, 2014.", "title": "Morpheus: automatically generating heuristics to detect Android emulators", "context": [{"sec": "sec7", "text": " DroidScope [15] and NDroid [60] rely on QEMU, which can be detected by packers [61].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2664243.2664250", "abstract": "Emulator-based dynamic analysis has been widely deployed in Android application stores. While it has been proven effective in vetting applications on a large scale, it can be detected and evaded by recent Android malware strains that carry detection heuristics. Using such heuristics, an application can check the presence or contents of certain artifacts and infer the presence of emulators. However, there exists little work that systematically discovers those heuristics that would be eventually h...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Morpheus%3A+automatically+generating+heuristics+to+detect+Android+emulators&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985676", "articleId": "7985676", "startPage": "358", "endPage": "369", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 14, "citationCountPatent": 0, "totalDownloads": 590}}
{"title": "Latent Patterns in Activities: A Field Study of How Developers Manage Context", "authors": [{"name": "Souti Chattopadhyay", "affiliation": "Oregon State University", "firstName": "Souti", "lastName": "Chattopadhyay", "id": "37086224207"}, {"name": "Nicholas Nelson", "affiliation": "Oregon State University", "firstName": "Nicholas", "lastName": "Nelson", "id": "37086217636"}, {"name": "Yenifer Ramirez Gonzalez", "affiliation": "Oregon State University", "firstName": "Yenifer", "lastName": "Ramirez Gonzalez", "id": "37086947407"}, {"name": "Annel Amelia Leon", "affiliation": "Oregon State University", "firstName": "Annel", "lastName": "Amelia Leon", "id": "37086949639"}, {"name": "Rahul Pandita", "affiliation": "Phase Change Software", "firstName": "Rahul", "lastName": "Pandita", "id": "37591306900"}, {"name": "Anita Sarma", "affiliation": "Oregon State University", "firstName": "Anita", "lastName": "Sarma", "id": "37085824683"}], "abstract": "In order to build efficient tools that support complex programming tasks, it is imperative that we understand how developers program. We know that developers create a context around their programming task by gathering relevant information. We also know that developers decompose their tasks recursively into smaller units. However, important gaps exist in our knowledge about: (1) the role that context plays in supporting smaller units of tasks, (2) the relationship that exists among these smaller units, and (3) how context flows across them. The goal of this research is to gain a better understanding of how developers structure their tasks and manage context through a field study of ten professional developers in an industrial setting. Our analysis reveals that developers decompose their tasks into smaller units with distinct goals, that specific patterns exist in how they sequence these smaller units, and that developers may maintain context between those smaller units with related goals.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Task analysis", "Software", "Encoding", "Tools", "Java", "Programming profession"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["formal specification", "software development management", "software quality"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["programming task", "professional developers", "complex programming tasks", "latent patterns"]}, {"type": "Author Keywords ", "kwd": ["context, task decomposition, field study"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00051", "ref": [{"order": "1", "text": "A. J. Ko, B. A. Myers, M. J. Coblenz, H. H. Aung, \"An exploratory study of how developers seek relate and collect relevant information during software maintenance tasks\", <em>IEEE Transactions on software engineering</em>, vol. 32, no. 12, pp. 971-987, 2006.", "title": "An exploratory study of how developers seek, relate, and collect relevant information during software maintenance tasks", "context": [{"sec": "sec1", "text": " They explore different solutions [1], review past versions [2], and backtrack [3].", "part": "1"}], "links": {"documentLink": "/document/4016573", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4016573", "abstract": "Much of software developers&#39; time is spent understanding unfamiliar code. To better understand how developers gain this understanding and how software development environments might be involved, a study was performed in which developers were given an unfamiliar program and asked to work on two debugging tasks and three enhancement tasks for 70 minutes. The study found that developers interleaved three activities. They began by searching for relevant code both manually and using search tools; how...", "pdfSize": "3888KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+exploratory+study+of+how+developers+seek%2C+relate%2C+and+collect+relevant+information+during+software+maintenance+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "S. Srinivasa Ragavan, S. K. Kuttal, C. Hill, A. Sarma, D. Piorkowski, M. Burnett, \"Foraging among an overabundance of similar variants\", <em>Proceedings of the 2016 CHI Conference on Human Factors in Computing Systems</em>, pp. 3509-3521, 2016.", "title": "Foraging among an overabundance of similar variants", "context": [{"sec": "sec1", "text": " They explore different solutions [1], review past versions [2], and backtrack [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2858036.2858469", "abstract": "Foraging among too many variants of the same artifact can be problematic when many of these variants are similar. This situation, which is largely overlooked in the literature, is commonplace in several types of creative tasks, one of which is exploratory programming. In this paper, we investigate how novice programmers forage through similar variants. Based on our results, we propose a refinement to Information Foraging Theory (IFT) to include constructs about variation foraging behavior, and p...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Foraging+among+an+overabundance+of+similar+variants&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "Y. Yoon, B. A. Myers, \"An exploratory study of backtracking strategies used by developers\", <em>Proceedings of the 5th International Workshop on Co-operative and Human Aspects of Software Engineering</em>, pp. 138-144, 2012.", "title": "An exploratory study of backtracking strategies used by developers", "context": [{"sec": "sec1", "text": " They explore different solutions [1], review past versions [2], and backtrack [3].", "part": "1"}], "links": {"documentLink": "/document/6223012", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6223012", "abstract": "Developers frequently backtrack while coding. They go back to an earlier state by removing inserted code or by restoring removed code for various reasons. However, little is known about when and how the developers backtrack, and modern IDEs do not provide much assistance for backtracking. As a first step towards gathering baseline knowledge about backtracking and designing more robust backtracking assistance tools in modern IDEs, we conducted an exploratory study with 12 professional developers ...", "pdfSize": "565KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+exploratory+study+of+backtracking+strategies+used+by+developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "J. Vosburgh, B. Curtis, R. Wolverton, B. Albert, H. Malec, S. Hoben, Y. Liu, \"Productivity factors and programming environments\", <em>Proceedings of the 7th international conference on Software engineering</em>, pp. 143-152, 1984.", "title": "Productivity factors and programming environments", "context": [{"sec": "sec1", "text": " As early as 1984 Vorburgh et al. studied programming environments, identifying 14 factors influencing team productivity [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Productivity+factors+and+programming+environments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "A. J. Ko, R. DeLine, G. Venolia, \"Information needs in collocated software development teams\", <em>Proceedings of the 29th international conference on Software Engineering</em>, pp. 344-353, 2007.", "title": "Information needs in collocated software development teams", "context": [{"sec": "sec1", "text": " More recently Ko et al. studied the information needs of developers [5] and Meyer et al. studied how developers' work habits correspond with their perceptions of productivity [6].", "part": "1"}, {"sec": "sec5b", "text": "Many researchers [5], [26], [27] found that developers perceive questions about the rationale and intent of code was difficult to answer.", "part": "1"}], "links": {"documentLink": "/document/4222596", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4222596", "abstract": "Previous research has documented the fragmented nature of software development work. To explain this in more detail, we analyzed software developers&#39; day-to-day information needs. We observed seventeen developers at a large software company and transcribed their activities in go-minute sessions. We analyzed these logs for the information that developers sought, the sources that they used, and the situations th at prevented inform action from being acquired. We identified twenty-one information t...", "pdfSize": "1270KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Information+needs+in+collocated+software+development+teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "A. N. Meyer, T. Fritz, G. C. Murphy, T. Zimmermann, \"Software developers' perceptions of productivity\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 19-29, 2014.", "title": "Software developers' perceptions of productivity", "context": [{"sec": "sec1", "text": " More recently Ko et al. studied the information needs of developers [5] and Meyer et al. studied how developers' work habits correspond with their perceptions of productivity [6].", "part": "1"}, {"sec": "sec1", "text": " [6] found that developers organized their development tasks into smaller, basic units of work.", "part": "1"}, {"sec": "sec1", "text": " Additionally, researchers have investigated how developers' working style across subtasks correspond with their perception of productivity [6], and how productive developers' differentiate themselves based on how they decompose their testing tasks [13].", "part": "1"}, {"sec": "sec4b3", "text": "Past work has shown that developers pursue two subgoals concurrently to increase productivity [6].", "part": "1"}, {"sec": "sec5a", "text": " [6], [23] conducted two separate studies to investigate developers' daily activities and observed that developers spend their time on a wide variety of activities, switching regularly between them, and that they perceive context switches to be generally harmful to productivity.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635892", "abstract": "The better the software development community becomes at creating software, the more software the world seems to demand. Although there is a large body of research about measuring and investigating productivity from an organizational point of view, there is a paucity of research about how software developers, those at the front-line of software construction, think about, assess and try to improve their productivity. To investigate software developers&#39; perceptions of software development producti...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+developers%27+perceptions+of+productivity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "V. M. Gonz\u00e1lez, G. Mark, \"Constant constant multi-tasking craziness: managing multiple working spheres\", <em>Proceedings of the SIGCHI conference on Human factors in computing systems</em>, pp. 113-120, 2004.", "title": "Constant, constant, multi-tasking craziness: managing multiple working spheres", "context": [{"sec": "sec1", "text": " Gonzalez and Mark [7] and Meyer et. al. [6] found that developers organized their development tasks into smaller, basic units of work.", "part": "1"}, {"sec": "sec4a", "text": " [7] found that people spend about 3 minutes on average per task (which is synonymous with a subgoal in our study).", "part": "1"}, {"sec": "sec5a", "text": " Gonzalez and Mark [7] found work fragmentation is a common phenomena.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/985692.985707", "abstract": "Most current designs of information technology are based on the notion of supporting distinct tasks such as document production, email usage, and voice communication. In this paper we present empirical results that suggest that people organize their work in terms of much larger and thematically connected units of work. We present results of fieldwork observation of information workers in three different roles: analysts, software developers, and managers. We discovered that all of these types of ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Constant%2C+constant%2C+multi-tasking+craziness%3A+managing+multiple+working+spheres&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "M. Gasparic, G. C. Murphy, F. Ricci, \"A context model for ide-based recommendation systems\", <em>Journal of Systems and Software</em>, vol. 128, pp. 200-219, 2017.", "title": "A context model for ide-based recommendation systems", "context": [{"sec": "sec1", "text": " This context encompasses relevant information needed to complete the development task [8].", "part": "1"}, {"sec": "sec5c", "text": " [8] present a context model that includes thirteen contextual factors (in four main categories: who, what, where, and when), captured in various situations to enhance interactions within an IDE.", "part": "1"}, {"sec": "sec6", "text": " Furthermore, work thus far typically addresses how and when developers perform context switches when working across tasks, and their associated cognitive loads [8].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2016.09.012", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+context+model+for+ide-based+recommendation+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "D. \u010cubrani\u0107, G. C. Murphy, \"Hipikat: Recommending pertinent software development artifacts\", <em>Proceedings of the 25th International Conference on Software Engineering</em>, pp. 408-418, 2003.", "title": "Hipikat: Recommending pertinent software development artifacts", "context": [{"sec": "sec1", "text": " Researchers have built tools to recommend the project artifacts that are relevant to a developer's task [9]\u2013[11].", "part": "1"}, {"sec": "sec6b", "text": "Modern recommendation tools [9]\u2013[11] typically leverage the relationships between artifacts to recommend other relevant artifacts.", "part": "1"}], "links": {"documentLink": "/document/1201219", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1201219", "abstract": "A newcomer to a software project must typically come up-to-speed on a large, varied amount of information about the project before becoming productive. Assimilating this information in the open-source context is difficult because a newcomer cannot rely on the mentoring approach that is commonly used in traditional software developments. To help a newcomer to an open-source project become productive faster, we propose Hipikat, a tool that forms an implicit group memory from the information stored...", "pdfSize": "436KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hipikat%3A+Recommending+pertinent+software+development+artifacts&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "M. Kersten, G. C. Murphy, \"Using task context to improve programmer productivity\", <em>Proceedings of the 14th ACM SIGSOFT international symposium on Foundations of software engineering</em>, pp. 1-11, 2006.", "title": "Using task context to improve programmer productivity", "context": [{"sec": "sec1", "text": " Researchers have built tools to recommend the project artifacts that are relevant to a developer's task [9]\u2013[10][11].", "part": "1"}, {"sec": "sec6b", "text": "Modern recommendation tools [9]\u2013[10][11] typically leverage the relationships between artifacts to recommend other relevant artifacts.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1181775.1181777", "abstract": "When working on a large software system, a programmer typically spends an inordinate amount of time sifting through thousands of artifacts to find just the subset of information needed to complete an assigned task. All too often, before completing the task the programmer must switch to working on a different task. These task switches waste time as the programmer must repeatedly find and identify the information relevant to the task-at-hand. In this paper, we present a mechanism that captures, mo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+task+context+to+improve+programmer+productivity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "M. Kersten, G. Murphy, \"Mylar: a degree-of-interest model for IDEs\", <em>Proceedings of the 4th international conference on Aspect-oriented software development</em>, pp. 159-168, 2005.", "title": "Mylar: a degree-of-interest model for IDEs", "context": [{"sec": "sec1", "text": " Researchers have built tools to recommend the project artifacts that are relevant to a developer's task [9]\u2013[11].", "part": "1"}, {"sec": "sec5c", "text": "Kersten and Murphy [11] introduce Mylar, a tool which captures the task context of program elements by monitoring the programmer's activity.", "part": "1"}, {"sec": "sec6b", "text": "Modern recommendation tools [9]\u2013[11] typically leverage the relationships between artifacts to recommend other relevant artifacts.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1052898.1052912", "abstract": "Even when working on a well-modularized software system, programmers tend to spend more time navigating the code than working with it. This phenomenon arises because it is impossible to modularize the code for all tasks that occur over the lifetime of a system. We describe the use of a degree-of-interest (DOI) model to capture the task context of program elements scattered across a code base. The Mylar tool that we built encodes the DOI of program elements by monitoring the programmer&#39;s activity...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mylar%3A+a+degree-of-interest+model+for+IDEs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "N. Souchon, Q. Limbourg, J. Vanderdonckt, \"Task modelling in multiple contexts of use\", <em>International Workshop on Design Specification and Verification of Interactive Systems</em>, pp. 59-73, 2002.", "title": "Task modelling in multiple contexts of use", "context": [{"sec": "sec1", "text": " Other work has looked further into how developers \u201crecursively decompose a development task into a hierarchy of subtasks\u201d [12].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-36235-5_5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Task+modelling+in+multiple+contexts+of+use&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "D. Kamma, P. Jalote, \"High productivity programmers use effective task processes in unit-testing\", <em>APSEC</em>, pp. 32-39, 2015.", "title": "High productivity programmers use effective task processes in unit-testing", "context": [{"sec": "sec1", "text": " Additionally, researchers have investigated how developers' working style across subtasks correspond with their perception of productivity [6], and how productive developers' differentiate themselves based on how they decompose their testing tasks [13].", "part": "1"}], "links": {"documentLink": "/document/7467280", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7467280", "abstract": "Software productivity is influenced by how efficiently programmers execute tasks assigned to them. For executing a task, programmers execute several steps. How the execution of these steps is organized by a programmer is referred to as task process. While overall software process has been well studied, the impact of task processes has not been studied much. In this work, we study the impact of task processes on the productivity of programmers. We first model a task process as a Markov chain with...", "pdfSize": "188KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=High+productivity+programmers+use+effective+task+processes+in+unit-testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "J. Preissle, L. Grant, \"Fieldwork traditions: Ethnography and participant observation\", <em>Foundations for research: Methods of inquiry in education and the social sciences</em>, pp. 161-180, 2004.", "title": "Fieldwork traditions: Ethnography and participant observation", "context": [{"sec": "sec3", "text": " We unobtrusively observed the workspace, computer-screens, and interactions of each developer following the \u201cfly on the wall\u201d technique described by Preissle and Grant [14].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fieldwork+traditions%3A+Ethnography+and+participant+observation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "S. Easterbrook, J. Singer, M.-A. Storey, D. Damian, \"Selecting empirical methods for software engineering research\" in Guide to advanced empirical software engineering, Springer, pp. 285-311, 2008.", "title": "Selecting empirical methods for software engineering research", "context": [{"sec": "sec3", "text": " [15].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-84800-044-5_11", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Selecting+empirical+methods+for+software+engineering+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "P. Runeson, M. H\u00f6st, \"Guidelines for conducting and reporting case study research in software engineering\", <em>Empirical software engineering</em>, vol. 14, no. 2, pp. 131, 2009.", "title": "Guidelines for conducting and reporting case study research in software engineering", "context": [{"sec": "sec3a", "text": " We demonstrated the think-aloud protocol [16] and requested participants to verbalize their thoughts and interactions during the session, which we recorded using two separate microphones for redundancy.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-008-9102-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guidelines+for+conducting+and+reporting+case+study+research+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "D. R. Garrison, M. Cleveland-Innes, M. Koole, J. Kappelman, \"Revisiting methodological issues in transcript analysis: Negotiated coding and reliability\", <em>The Internet and Higher Education</em>, vol. 9, no. 1, pp. 1-8, 2006.", "title": "Revisiting methodological issues in transcript analysis: Negotiated coding and reliability", "context": [{"sec": "sec3b", "text": " Negotiated agreement was used to create a standardized coding scheme and improve it to an acceptable point where there was no ambiguity in any of the data points [17].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.iheduc.2005.11.001", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Revisiting+methodological+issues+in+transcript+analysis%3A+Negotiated+coding+and+reliability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "A. S. Lee, R. L. Baskerville, \"Generalizing generalizability in information systems research\", <em>Info. Sys. Research</em>, vol. 14, no. 3, pp. 221-243, Sep. 2003.", "title": "Generalizing generalizability in information systems research", "context": [{"sec": "sec3d", "text": " Instead we aim to present findings that can be transferred to various environments, providing contextual support to programmers [18].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/isre.14.3.221.16560", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generalizing+generalizability+in+information+systems+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "S. Xu, V. Rajlich, \"Dialog-based protocol: an empirical research method for cognitive activities in software engineering\", <em>2005 International Symposium on Empirical Software Engineering 2005</em>, Nov 2005.", "title": "Dialog-based protocol: an empirical research method for cognitive activities in software engineering", "context": [{"sec": "sec3d", "text": " The inherent nature of an observational think-aloud study might cause the data to be affected by the Hawthorne effect, response bias or create additional cognitive load in participants needing to think aloud [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dialog-based+protocol%3A+an+empirical+research+method+for+cognitive+activities+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "S. J. Tracy, \"Qualitative quality: Eight \u201cbig-tent\u201d criteria for excellent qualitative research\", <em>Qualitative Inquiry</em>, vol. 16, no. 10, pp. 837-851, 2010.", "title": "Qualitative quality: Eight \u201cbig-tent\u201d criteria for excellent qualitative research", "context": [{"sec": "sec3d", "text": " We mitigated this threat through rigor in our analysis process by using four raters, maintaining inter-rater reliability and using a well defined coding scheme [20].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/1077800410383121", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Qualitative+quality%3A+Eight+%E2%80%9Cbig-tent%E2%80%9D+criteria+for+excellent+qualitative+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "D. E. Perry, N. A. Staudenmayer, L. G. Votta, \"People organizations and process improvement\", <em>IEEE Software</em>, vol. 11, no. 4, pp. 36-45, 1994.", "title": "People, organizations, and process improvement", "context": [{"sec": "sec5a", "text": " [21] conducted two empirical studies on the social and organizational processes of developers and found that developers work in two hour chunks, spending most of their time on writing code and having unplanned interactions with colleagues.", "part": "1"}], "links": {"documentLink": "/document/300082", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=300082", "abstract": "In their efforts to determine how technology affects the software development process, researchers often overlook organizational and social issues. The authors report on two experiments to discover how developers spend their time. They describe how noncoding activities can use up development time and how even a reluctance to use e-mail can influence the development process. The first experiment was to see how programmers thought they spent their time by having them fill out a modified time card ...", "pdfSize": "1253KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=People%2C+organizations%2C+and+process+improvement&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "L. A. Perlow, \"The time famine: Toward a sociology of work time\", <em>Administrative science quarterly</em>, vol. 44, no. 1, pp. 57-81, 1999.", "title": "The time famine: Toward a sociology of work time", "context": [{"sec": "sec5a", "text": " Perlow [22] conducted a qualitative study of how software engineers optimally use their time at work.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2307/2667031", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+time+famine%3A+Toward+a+sociology+of+work+time&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "A. N. Meyer, L. E. Barton, G. C. Murphy, T. Zimmermann, T. Fritz, \"The work life of developers: Activities switches and perceived productivity\", <em>IEEE Transactions on Software Engineering</em>, vol. 43, no. 12, pp. 1178-1193, 2017.", "title": "The work life of developers: Activities, switches and perceived productivity", "context": [{"sec": "sec5a", "text": "Meyer et al. [6], [23] conducted two separate studies to investigate developers' daily activities and observed that developers spend their time on a wide variety of activities, switching regularly between them, and that they perceive context switches to be generally harmful to productivity.", "part": "1"}], "links": {"documentLink": "/document/7829407", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7829407", "abstract": "Many software development organizations strive to enhance the productivity of their developers. All too often, efforts aimed at improving developer productivity are undertaken without knowledge about how developers spend their time at work and how it influences their own perception of productivity. To fill in this gap, we deployed a monitoring application at 20 computers of professional software developers from four companies for an average of 11 full work day in situ. Corroborating earlier find...", "pdfSize": "1089KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+work+life+of+developers%3A+Activities%2C+switches+and+perceived+productivity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "B. O'Conaill, D. Frohlich, \"Timespace in the workplace: Dealing with interruptions\", <em>Conference companion on Human factors in computing systems</em>, pp. 262-263, 1995.", "title": "Timespace in the workplace: Dealing with interruptions", "context": [{"sec": "sec5a", "text": " However, O'Conaill and Frohlich [24] and Hudson et al. [25] report that in many cases interruptions can be beneficial and bring relevant information.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/223355.223665", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Timespace+in+the+workplace%3A+Dealing+with+interruptions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "J. M. Hudson, J. Christensen, W. A. Kellogg, T. Erickson, \"I'd be overwhelmed but it's just one more thing to do: Availability and interruption in research management\", <em>Proceedings of the SIGCHI Conference on Human factors in computing systems</em>, pp. 97-104, 2002.", "title": "I'd be overwhelmed, but it's just one more thing to do: Availability and interruption in research management", "context": [{"sec": "sec5a", "text": " [25] report that in many cases interruptions can be beneficial and bring relevant information.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/503376.503394", "abstract": "Many CSCW projects dealing with individual availability and interruption filtering achieve only limited success. Perhaps this is because designers of such systems have limited evidence to draw upon; most data on interruption management is at least a decade old. This study uses an empirical sampling method and qualitative interviews to examine attitudes toward availability and interruption. Specifically, we analyze how corporate research managers spend their time and look at how their attitudes t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=I%27d+be+overwhelmed%2C+but+it%27s+just+one+more+thing+to+do%3A+Availability+and+interruption+in+research+management&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "T. D. LaToza, B. A. Myers, \"Hard-to-answer questions about code\", <em>Evaluation and Usability of Programming Languages and Tools</em>, pp. 8, 2010.", "title": "Hard-to-answer questions about code", "context": [{"sec": "sec5b", "text": "Many researchers [5], [26], [27] found that developers perceive questions about the rationale and intent of code was difficult to answer.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1937117.1937125", "abstract": "To build new tools and programming languages that make it easier for professional software developers to create, debug, and understand code, it is helpful to better understand the questions that developers ask during coding activities. We surveyed professional software developers and asked them to list hard-to-answer questions that they had recently asked about code. 179 respondents reported 371 questions. We then clustered these questions into 21 categories and 94 distinct questions. The most f...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hard-to-answer+questions+about+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "T. Fritz, G. Murphy, \"Using information fragments to answer the questions developers ask\", <em>Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering</em>, vol. 1, pp. 175-184, 2010.", "title": "Using information fragments to answer the questions developers ask", "context": [{"sec": "sec5b", "text": "Many researchers [5], [26], [27] found that developers perceive questions about the rationale and intent of code was difficult to answer.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806828", "abstract": "Each day, a software developer needs to answer a variety of questions that require the integration of different kinds of project information. Currently, answering these questions, such as &#34;What have my co-workers been doing?&#34;, is tedious, and sometimes impossible, because the only support available requires the developer to manually link and traverse the information step-by-step. Through interviews with eleven professional developers, we identified 78 questions developers want to ask, but for wh...", "pdfSize": "477KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+information+fragments+to+answer+the+questions+developers+ask&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "J. Sillito, G. Murphy, K. De Volder, \"Questions programmers ask during software evolution tasks\", <em>Proceedings of the 14th ACM SIG-SOFT international symposium on Foundations of software engineering</em>, pp. 23-34, 2006.", "title": "Questions programmers ask during software evolution tasks", "context": [{"sec": "sec5b", "text": " [28], [29] conducted two qualitative studies of programmers' information needs when performing change tasks.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1181775.1181779", "abstract": "Though many tools are available to help programmers working on change tasks, and several studies have been conducted to understand how programmers comprehend systems, little is known about the specific kinds of questions programmers ask when evolving a code base. To fill this gap we conducted two qualitative studies of programmers performing change tasks to medium to large sized programs. One study involved newcomers working on assigned change tasks to a medium-sized code base. The other study i...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Questions+programmers+ask+during+software+evolution+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "J. Sillito, G. C. Murphy, K. De Volder, \"Asking and answering questions during a programming change task\", <em>IEEE Transactions on Software Engineering</em>, vol. 34, no. 4, pp. 434-451, 2008.", "title": "Asking and answering questions during a programming change task", "context": [{"sec": "sec5b", "text": "Sillito et al. [28], [29] conducted two qualitative studies of programmers' information needs when performing change tasks.", "part": "1"}], "links": {"documentLink": "/document/4497212", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4497212", "abstract": "Little is known about the specific kinds of questions programmers ask when evolving a code base and how well existing tools support those questions. To better support the activity of programming, answers are needed to three broad research questions: 1) What does a programmer need to know about a code base when evolving a software system? 2) How does a programmer go about finding that information? 3) How well do existing tools support programmers in answering those questions? We undertook two qua...", "pdfSize": "4163KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Asking+and+answering+questions+during+a+programming+change+task&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "T. Fritz, J. Ou, G. C. Murphy, E. Murphy-Hill, \"A degree-of-knowledge model to capture source code familiarity\", <em>Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering</em>, vol. 1, pp. 385-394, 2010.", "title": "A degree-of-knowledge model to capture source code familiarity", "context": [{"sec": "sec5c", "text": " [30] introduce a model that capture context through developers' authorship and interaction information.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806856", "abstract": "The size and high rate of change of source code comprising a software system make it difficult for software developers to keep up with who on the team knows about particular parts of the code. Existing approaches to this problem are based solely on authorship of code. In this paper, we present data from two professional software development teams to show that both authorship and interaction information about how a developer interacts with the code are important in characterizing a developer&#39;s kn...", "pdfSize": "398KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+degree-of-knowledge+model+to+capture+source+code+familiarity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "P. Viriyakattiyaporn, G. C. Murphy, \"Improving program navigation with an active help system\", <em>Proceedings of the 2010 Conference of the Center for Advanced Studies on Collaborative Research</em>, pp. 27-41, 2010.", "title": "Improving program navigation with an active help system", "context": [{"sec": "sec5c", "text": " Petcharat and Murphy [31] introduce Spyglass, which suggests tools to aid program navigation based on the context of their work.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1923947.1923951", "abstract": "When performing software change tasks, software developers spend a substantial amount of their time navigating dependencies in the code. Despite the availability of numerous tools to aid such navigation, there is evidence to suggest that developers are not using these tools. In this paper, we introduce an active help system, called Spyglass, that suggests tools to aid program navigation as a developer works. We report on the results of a laboratory study that investigated two questions: will dev...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+program+navigation+with+an+active+help+system&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "S. Zolaktaf, G. C. Murphy, \"What to learn next: Recommending commands in a feature-rich environment\", <em>Machine Learning and Applications (ICMLA) 2015 IEEE 14th International Conference</em>, pp. 1038-1044, 2015.", "title": "What to learn next: Recommending commands in a feature-rich environment", "context": [{"sec": "sec5c", "text": " Sedigheh and Murphy [32] captures context through three factors-discovery patterns, recent command usage, and elapsed time since last activity.", "part": "1"}], "links": {"documentLink": "/document/7424457", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7424457", "abstract": "Despite an abundance of commands to make tasks easier to perform, the users of feature-rich applications, such as development environments, use only a fraction of the commands available. Earlier work has shown that command recommendation -- in which, given the command usage history of a set of users, the objective is to predict a command that is likely useful for the user to learn -- can improve the usage of a range of commands available within such applications. In this paper, we present a new ...", "pdfSize": "303KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+to+learn+next%3A+Recommending+commands+in+a+feature-rich+environment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "M. Burnett, S. Stumpf, J. Macbeth, S. Makri, L. Beckwith, I. Kwan, A. Peters, W. Jernigan, \"Gendermag: A method for evaluating software's gender inclusiveness\", <em>Interacting with Computers</em>, vol. 28, no. 6, pp. 760-787.", "title": "Gendermag: A method for evaluating software's gender inclusiveness", "context": [{"sec": "sec6a", "text": "Task decomposition may also depend on individual differences in problem solving styles [33].", "part": "1"}], "links": {"documentLink": "/document/8154509", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8154509", "abstract": "In recent years, research into gender differences has established that individual differences in how people problem-solve often cluster by gender. Research also shows that these differences have direct implications for software that aims to support users&#39; problem-solving activities, and that much of this software is more supportive of problem-solving processes favored (statistically) more by males than by females. However, there is almost no work considering how software practitioners\u2014such as Us...", "pdfSize": "8299KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gendermag%3A+A+method+for+evaluating+software%27s+gender+inclusiveness&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "M. Z\u00fcger, C. Corley, A. N. Meyer, B. Li, T. Fritz, D. Shepherd, V. Augustine, P. Francis, N. Kraft, W. Snipes, \"Reducing interruptions at work: A large-scale field study of flowlight\", <em>Proceedings of the 2017 CHI Conference on Human Factors in Computing Systems</em>, pp. 61-72, 2017.", "title": "Reducing interruptions at work: A large-scale field study of flowlight", "context": [{"sec": "sec6b", "text": " Development of tools like FlowLight [34] operationalizes the notion of interruptibility of a developer by using a physical indicator to signal when they are busy.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3025453.3025662", "abstract": "Due to the high number and cost of interruptions at work, several approaches have been suggested to reduce this cost for knowledge workers. These approaches predominantly focus either on a manual and physical indicator, such as headphones or a closed office door, or on the automatic measure of a worker&#39;s interruptibilty in combination with a computer-based indicator. Little is known about the combination of a physical indicator with an automatic interruptibility measure and its long-term impact ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reducing+interruptions+at+work%3A+A+large-scale+field+study+of+flowlight&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811986", "articleId": "8811986", "startPage": "373", "endPage": "383", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 82}}
{"title": "Learning Syntactic Program Transformations from Examples", "authors": [{"name": "Reudismam Rolim", "affiliation": "UFCG, Brazil", "firstName": "Reudismam", "lastName": "Rolim", "id": "37086088173"}, {"name": "Gustavo Soares", "affiliation": "UFCG, Brazil", "firstName": "Gustavo", "lastName": "Soares", "id": "37391827700"}, {"name": "Loris D'Antoni", "affiliation": "Univ. of Wisconsin - Madison, Madison, WI, USA", "firstName": "Loris", "lastName": "D'Antoni", "id": "37086089889"}, {"name": "Oleksandr Polozov", "affiliation": "Univ. of Washington, Seattle, WA, USA", "firstName": "Oleksandr", "lastName": "Polozov", "id": "37086092565"}, {"name": "Sumit Gulwani", "affiliation": "Microsoft, Redmond, WA, USA", "firstName": "Sumit", "lastName": "Gulwani", "id": "38015022400"}, {"name": "Rohit Gheyi", "affiliation": "UFCG, Brazil", "firstName": "Rohit", "lastName": "Gheyi", "id": "37391828700"}, {"name": "Ryo Suzuki", "affiliation": "Univ. of Colorado Boulder, Boulder, CO, USA", "firstName": "Ryo", "lastName": "Suzuki", "id": "37086092004"}, {"name": "Bj\u00f6rn Hartmann", "affiliation": "UC Berkeley, Berkeley, CA, USA", "firstName": "Bj\u00f6rn", "lastName": "Hartmann", "id": "37077868400"}], "abstract": "Automatic program transformation tools can be valuable for programmers to help them with refactoring tasks, and for Computer Science students in the form of tutoring systems that suggest repairs to programming assignments. However, manually creating catalogs of transformations is complex and time-consuming. In this paper, we present REFAZER, a technique for automatically learning program transformations. REFAZER builds on the observation that code edits performed by developers can be used as input-output examples for learning program transformations. Example edits may share the same structure but involve different variables and subexpressions, which must be generalized in a transformation at the right level of abstraction. To learn transformations, REFAZER leverages state-of-the-art programming-by-example methodology using the following key components: (a) a novel domain-specific language (DSL) for describing program transformations, (b) domain-specific deductive algorithms for efficiently synthesizing transformations in the DSL, and (c) functions for ranking the synthesized transformations. We instantiate and evaluate REFAZER in two domains. First, given examples of code edits used by students to fix incorrect programming assignment submissions, we learn program transformations that can fix other students' submissions with similar faults. In our evaluation conducted on 4 programming tasks performed by 720 students, our technique helped to fix incorrect submissions for 87% of the students. In the second domain, we use repetitive code edits applied by developers to the same project to synthesize a program transformation that applies these edits to other locations in the code. In our evaluation conducted on 56 scenarios of repetitive edits taken from three large C# open-source projects, REFAZER learns the intended program transformation in 84% of the cases using only 2.9 examples on average.", "keywords": [{"type": "IEEE Keywords", "kwd": ["DSL", "Programming profession", "Tools", "C# languages", "Pattern matching", "Open source software"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["automatic programming", "program processors"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["syntactic program transformations learning", "REFAZER", "programming-by-example methodology", "domain-specific language", "domain-specific deductive algorithms", "DSL", "code edits", "C# open-source projects"]}, {"type": "Author Keywords ", "kwd": ["Program transformation", "program synthesis", "tutoring systems", "refactoring"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.44", "ref": [{"order": "1", "text": "N. Meng, M. Kim, K.S. McKinley, \"LASE: Locating and applying systematic edits by learning from examples\", <em>Proceedings of the 35th International Conference on Software Engineering</em>, pp. 502-511, 2013.", "title": "LASE: Locating and applying systematic edits by learning from examples", "context": [{"sec": "sec1", "text": " For instance, to apply an API update, a developer needs to locate all references to the old API and consistently replace them with the new API [1], [2].", "part": "1"}, {"sec": "sec2a", "text": " Existing tools for such automatic learning [1], [20] cannot generate a transformation that is general enough to represent both the edits shown in Fig. 1c due to their limited forms of abstraction.", "part": "1"}, {"sec": "sec5a", "text": " [1], [20], [26] propose Lase, a technique for performing repetitive edits using examples.", "part": "1"}], "links": {"abstract": "Adding features and fixing bugs often require sys- tematic edits that make similar, but not identical, changes to many code locations. Finding all the relevant locations and making the correct edits is a tedious and error-prone process for developers. This paper addresses both problems using edit scripts learned from multiple examples. We design and implement a tool called LASE that (1) creates a context-aware edit script from two or more examples, and uses the script to (2) automatically identi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=LASE%3A+Locating+and+applying+systematic+edits+by+learning+from+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "L. Wasserman, \"Scalable example-based refactorings with refaster\", <em>Proceedings of the 2013 ACM Workshop on Workshop on Refactoring Tools</em>, pp. 25-28, 2013.", "title": "Scalable, example-based refactorings with refaster", "context": [{"sec": "sec1", "text": " For instance, to apply an API update, a developer needs to locate all references to the old API and consistently replace them with the new API [1], [2].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2541348.2541355", "abstract": "We discuss Refaster, a tool that uses normal, compilable before-and-after examples of Java code to specify a Java refactoring. Refaster has been used successfully by the Java Core Libraries Team at Google to perform a wide variety of refactorings across Google's massive Java codebase. Our main contribution is that a large class of useful refactorings can be expressed in pure Java, without a specialized DSL, while keeping the tool easily accessible to average Java developers.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable%2C+example-based+refactorings+with+refaster&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Visual Studio</em>, 2016,  [online]  Available: https://www.visualstudio.com.", "title": "Visual Studio", "context": [{"sec": "sec1", "text": " IDEs, such as Visual Studio [3] or Eclipse [4], include features that automate some code transformations, such as adding boilerplate code (e.g., equality comparisons) and code refactoring (e.g., Rename, Extract Method).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Visual+Studio&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Eclipse</em>, 2016,  [online]  Available: https://eclipse.org/.", "title": "Eclipse", "context": [{"sec": "sec1", "text": " IDEs, such as Visual Studio [3] or Eclipse [4], include features that automate some code transformations, such as adding boilerplate code (e.g., equality comparisons) and code refactoring (e.g., Rename, Extract Method).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eclipse&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>ReSharper</em>, 2016,  [online]  Available: https://www.jetbrains.com/resharper/.", "title": "ReSharper", "context": [{"sec": "sec1", "text": " Static analyzers, such as ReSharper [5], Coverity [6], ErrorProne [7], and Clang-tidy [8] automate removal of suspicious code patterns, potential bugs, and verbose code fragments.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=ReSharper&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Coverity</em>, 2016,  [online]  Available: http://www.coverity.com/.", "title": "Coverity", "context": [{"sec": "sec1", "text": " Static analyzers, such as ReSharper [5], Coverity [6], ErrorProne [7], and Clang-tidy [8] automate removal of suspicious code patterns, potential bugs, and verbose code fragments.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coverity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>Error-prone</em>, 2016,  [online]  Available: http://errorprone.info/.", "title": "Error-prone", "context": [{"sec": "sec1", "text": " Static analyzers, such as ReSharper [5], Coverity [6], ErrorProne [7], and Clang-tidy [8] automate removal of suspicious code patterns, potential bugs, and verbose code fragments.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Error-prone&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Clang-tidy</em>, 2016,  [online]  Available: http://clang.llvm.org/extra/clang-tidy/.", "title": "Clang-tidy", "context": [{"sec": "sec1", "text": " Static analyzers, such as ReSharper [5], Coverity [6], ErrorProne [7], and Clang-tidy [8] automate removal of suspicious code patterns, potential bugs, and verbose code fragments.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Clang-tidy&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "R. Singh, S. Gulwani, A. Solar-Lezama, \"Automated feedback generation for introductory programming assignments\", <em>Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 15-26, 2013.", "title": "Automated feedback generation for introductory programming assignments", "context": [{"sec": "sec1", "text": " In an education context, AutoGrader [9] uses a set of transformations provided by an instructor to fix common faults in introductory programming assignments.", "part": "1"}, {"sec": "sec4a4", "text": " This finding also suggests that other automatic grading tools that use a fixed or user-provided fault rubric (e.g., AutoGrader[9]) are not likely to work on arbitrary types of assignments.", "part": "1"}, {"sec": "sec5c", "text": " [9] propose AutoGrader, a program synthesis technique for fixing incorrect student submissions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491956.2462195", "abstract": "We present a new method for automatically providing feedback for introductory programming problems. In order to use this method, we need a reference implementation of the assignment, and an error model consisting of potential corrections to errors that students might make. Using this information, the system automatically derives minimal corrections to student&#39;s incorrect solutions, providing them with a measure of exactly how incorrect a given solution was, as well as feedback about what they di...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+feedback+generation+for+introductory+programming+assignments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S. Gulwani, J. Hern\u00e1ndez-Orallo, E. Kitzelmann, S.H. Muggleton, U. Schmid, B. Zorn, \"Inductive programming meets the real world\", <em>Communications of the ACM</em>, vol. 58, no. 11, pp. 90-99, 2015.", "title": "Inductive programming meets the real world", "context": [{"sec": "sec1", "text": " To resolve these challenges, we leverage state-of-the-art software engineering research to learn such transformations automatically using Inductive Programming (IP), or Programming-by-Example (PBE) [10], which has been successfully applied to many domains, such as text transformation [11], data cleaning [12], and layout transformation [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2736282", "abstract": "Inductive programming can liberate users from performing tedious and repetitive tasks.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inductive+programming+meets+the+real+world&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "S. Gulwani, \"Automating string processing in spreadsheets using input-output examples\", <em>Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, pp. 317-330, 2011.", "title": "Automating string processing in spreadsheets using input-output examples", "context": [{"sec": "sec1", "text": " To resolve these challenges, we leverage state-of-the-art software engineering research to learn such transformations automatically using Inductive Programming (IP), or Programming-by-Example (PBE) [10], which has been successfully applied to many domains, such as text transformation [11], data cleaning [12], and layout transformation [13].", "part": "1"}, {"sec": "sec5b", "text": " Recently, it has been successfully used in industry by FlashFill and FlashExtract [11], [12], [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1926385.1926423", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automating+string+processing+in+spreadsheets+using+input-output+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "V. Le, S. Gulwani, \"FlashExtract: A framework for data extraction by examples\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 542-553, 2014.", "title": "FlashExtract: A framework for data extraction by examples", "context": [{"sec": "sec1", "text": " To resolve these challenges, we leverage state-of-the-art software engineering research to learn such transformations automatically using Inductive Programming (IP), or Programming-by-Example (PBE) [10], which has been successfully applied to many domains, such as text transformation [11], data cleaning [12], and layout transformation [13].", "part": "1"}, {"sec": "sec5b", "text": " Recently, it has been successfully used in industry by FlashFill and FlashExtract [11], [12], [43].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=FlashExtract%3A+A+framework+for+data+extraction+by+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "D. Edge, S. Gulwani, N. Milic-Frayling, M. Raza, R. Adhitya Saputra, C. Wang, K. Yatani, \"Mixed-initiative approaches to global editing in slideware\", <em>Proceedings of the 33rd Annual ACM Conference on Human Factors in Computing Systems</em>, pp. 3503-3512, 2015.", "title": "Mixed-initiative approaches to global editing in slideware", "context": [{"sec": "sec1", "text": " To resolve these challenges, we leverage state-of-the-art software engineering research to learn such transformations automatically using Inductive Programming (IP), or Programming-by-Example (PBE) [10], which has been successfully applied to many domains, such as text transformation [11], data cleaning [12], and layout transformation [13].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2702123.2702551", "abstract": "Good alignment and repetition of objects across presentation slides can facilitate visual processing and contribute to audience understanding. However, creating and maintaining such consistency during slide design is difficult. To solve this problem, we present two complementary tools: (1) StyleSnap, which increases the alignment and repetition of objects by adaptively clustering object edge positions and allowing parallel editing of all objects snapped to the same spatial extent; and (2) FlashF...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mixed-initiative+approaches+to+global+editing+in+slideware&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "O. Polozov, S. Gulwani, \"FlashMeta: A framework for inductive program synthesis\", <em>Proceedings of the ACM International Conference on Object-oriented Programming Systems Languages and Applications</em>, pp. 542-553, 2015.", "title": "FlashMeta: A framework for inductive program synthesis", "context": [{"sec": "sec1a", "text": " Refazer is based on the PROSE [14] Inductive Programming framework.", "part": "1"}, {"sec": "sec3", "text": " Refazer builds on PROSE [14], a framework for program synthesis from examples and under-specifications.", "part": "1"}, {"sec": "sec3", "text": " Because examples are highly ambiguous, this set may contain up to 1020 programs [14], and quickly eliminating undesirable candidates is paramount for a user-friendly experience.", "part": "1"}, {"sec": "sec5b", "text": " FlashFill and FlashExtract motivated research on PROSE [14].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=FlashMeta%3A+A+framework+for+inductive+program+synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "A. Hindle, E.T. Barr, Z. Su, M. Gabel, P. Devanbu, \"On the naturalness of software\", <em>Proceedings of the 34th International Conference on Software Engineering</em>, pp. 837-847, 2012.", "title": "On the naturalness of software", "context": [{"sec": "sec1b", "text": "Our second experiment is motivated by the fact that certain repetitive tasks occurring during software evolution, such as complex forms of code refactoring, are beyond the capabilities of current IDEs and have to be performed manually [15], [16].", "part": "1"}], "links": {"documentLink": "/document/6227135", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227135", "abstract": "Natural languages like English are rich, complex, and powerful. The highly creative and graceful use of languages like English and Tamil, by masters like Shakespeare and Avvaiyar, can certainly delight and inspire. But in practice, given cognitive constraints and the exigencies of daily life, most human utterances are far simpler and much more repetitive and predictable. In fact, these utterances can be very usefully modeled using modern statistical methods. This fact has led to the phenomenal s...", "pdfSize": "383KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+naturalness+of+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "G. Kniesel, H. Koch, \"Static composition of refactorings\", <em>Science of Computer Programming</em>, vol. 52, no. 1\u20133, pp. 9-51, 2004.", "title": "Static composition of refactorings", "context": [{"sec": "sec1b", "text": "Our second experiment is motivated by the fact that certain repetitive tasks occurring during software evolution, such as complex forms of code refactoring, are beyond the capabilities of current IDEs and have to be performed manually [15], [16].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.scico.2004.03.002", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+composition+of+refactorings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "<em>Project Roslyn</em>, 2011,  [online]  Available: https://github.com/dotnet/roslyn.", "title": "Project Roslyn", "context": [{"sec": "sec1b", "text": " We performed a study on three popular open-source C# projects (Roslyn [17], Entity Framework [18], and NuGet [19]) to identify and characterize repetitive code transformations.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Project+Roslyn&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>Entity Framework 6</em>,  [online]  Available: http://www.asp.net/entity-framework.", "title": "Entity Framework 6", "context": [{"sec": "sec1b", "text": " We performed a study on three popular open-source C# projects (Roslyn [17], Entity Framework [18], and NuGet [19]) to identify and characterize repetitive code transformations.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Entity+Framework+6&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>NuGet 2</em>,  [online]  Available: https://github.com/nuget/nuget2.", "title": "NuGet 2", "context": [{"sec": "sec1b", "text": " We performed a study on three popular open-source C# projects (Roslyn [17], Entity Framework [18], and NuGet [19]) to identify and characterize repetitive code transformations.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=NuGet+2&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "N. Meng, M. Kim, K.S. McKinley, \"Systematic editing: Generating program transformations from an example\", <em>Proceedings of the 32Nd ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 329-342, 2011.", "title": "Systematic editing: Generating program transformations from an example", "context": [{"sec": "sec2a", "text": " Existing tools for such automatic learning [1], [20] cannot generate a transformation that is general enough to represent both the edits shown in Fig. 1c due to their limited forms of abstraction.", "part": "1"}, {"sec": "sec5a", "text": "Meng et al. [1], [20], [26] propose Lase, a technique for performing repetitive edits using examples.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1993498.1993537", "abstract": "Software modifications are often systematic ---they consist of similar, but not identical, program changes to multiple contexts. Existing tools for systematic program transformation are limited because they require programmers to manually prescribe edits or only suggest a location to edit with a related example. This paper presents the design and implementation of a program transformation tool called SYDIT. Given an example edit, SYDIT generates a context-aware, abstract edit script, and then ap...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Systematic+editing%3A+Generating+program+transformations+from+an+example&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "R. Alur, R. Bodik, G. Juniwal, M.M.K. Martin, M. Raghothaman, S.A. Seshia, R. Singh, A. Solar-Lezama, E. Torlak, A. Udupa, \"Syntax-guided synthesis\", <em>Proceedings of the 2013 Formal Methods in Computer-Aided Design</em>, pp. 1-8, 2013.", "title": "Syntax-guided synthesis", "context": [{"sec": "sec3", "text": "Search is an enumerative algorithm, which iteratively constructs candidate subexpressions in the grammar and verifies them for compliance with the spec \\$\\varphi\\$ [21].", "part": "1"}], "links": {"abstract": "The classical formulation of the program-synthesis problem is to find a program that meets a correctness specification given as a logical formula. Recent work on program synthesis and program optimization illustrates many potential benefits of allowing the user to supplement the logical specification with a syntactic template that constrains the space of allowed implementations. Our goal is to identify the core computational problem common to these proposals in a logical framework. The input to ...", "pdfSize": "317KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Syntax-guided+synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>XPath</em>, 1999,  [online]  Available: https://www.w3.org/TR/xpath/.", "title": "XPath", "context": [{"sec": "sec3a1", "text": " In addition, a path expression specifies the expected position of \\$x\\$ in the context that is described by pattern, using a notation similar to XPath [22].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=XPath&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "M. Pawlik, N. Augsten, \"RTED: A robust algorithm for the tree edit distance\", <em>Proceedings of the VLDB Endowment</em>, vol. 5, no. 4, pp. 334-345, Dec. 2011.", "title": "RTED: A robust algorithm for the tree edit distance", "context": [{"sec": "sec3a2", "text": " An operation \\$O\\$ takes as input an AST \\$x\\$ and performs one of the standard tree edit procedures [23], [24] on it:\n\n\u2022Insert some fresh AST as the \\$k^{\\text{th}}\\$ child of \\$x\\$;\n\u2022Delete some sub-node from \\$x\\$;\n\u2022Update \\$x\\$ with some fresh AST;\n\u2022Prepend some fresh AST as the preceding sibling of \\$x\\$.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14778/2095686.2095692", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=RTED%3A+A+robust+algorithm+for+the+tree+edit+distance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "K. Zhang, D. Shasha, \"Simple fast algorithms for the editing distance between trees and related problems\", <em>SIAM Journal on Computing</em>, vol. 18, no. 6, pp. 1245-1262, 1989.", "title": "Simple fast algorithms for the editing distance between trees and related problems", "context": [{"sec": "sec3a2", "text": " An operation \\$O\\$ takes as input an AST \\$x\\$ and performs one of the standard tree edit procedures [23], [24] on it:\n\n\u2022Insert some fresh AST as the \\$k^{\\text{th}}\\$ child of \\$x\\$;\n\u2022Delete some sub-node from \\$x\\$;\n\u2022Update \\$x\\$ with some fresh AST;\n\u2022Prepend some fresh AST as the preceding sibling of \\$x\\$.", "part": "1"}, {"sec": "sec3b1", "text": " Note that the state-of-the-art Zhang-Shasha tree edit distance algorithm [24] manipulates single nodes, whereas our operations (and, consequently, examples of their behavior) manipulate whole subtrees.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1137/0218082", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Simple+fast+algorithms+for+the+editing+distance+between+trees+and+related+problems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "M. Ester, H.-P. Kriegel, J. Sander, X. Xu, \"A density-based algorithm for discovering clusters in large spatial databases with noise\", <em>Proceedings of the Second International Conference on Knowledge Discovery and Data Mining</em>, pp. 226-231, 1996.", "title": "A density-based algorithm for discovering clusters in large spatial databases with noise", "context": [{"sec": "sec3b2", "text": "To identify subtree edits that were performed by the same rewrite rule, we use the DBSCAN [25] clustering algorithm to partition edits by similarity.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+density-based+algorithm+for+discovering+clusters+in+large+spatial+databases+with+noise&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "N. Meng, L. Hua, M. Kim, K.S. McKinley, \"Does automated refactoring obviate systematic editing?\", <em>Proceedings of the 37th International Conference on Software Engineering</em>, vol. 1, pp. 392-402, 2015.", "title": "Does automated refactoring obviate systematic editing?", "context": [{"sec": "sec5a", "text": "Meng et al. [1], [20], [26] propose Lase, a technique for performing repetitive edits using examples.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Does+automated+refactoring+obviate+systematic+editing%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "R. Robbes, M. Lanza, \"Example-based program transformation\", <em>Model Driven Engineering Languages and Systems</em>, vol. 5301, pp. 174-188, 2008.", "title": "Example-based program transformation", "context": [{"sec": "sec5a", "text": "Other approaches are semi-automatic using examples in combination with transformation templates [27], [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-87875-9_13", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Example-based+program+transformation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "M. Boshernitsan, S.L. Graham, M.A. Hearst, \"Aligning development tools with the way programmers think about code changes\", <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em>, pp. 567-576, 2007.", "title": "Aligning development tools with the way programmers think about code changes", "context": [{"sec": "sec5a", "text": "Other approaches are semi-automatic using examples in combination with transformation templates [27], [28].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1240624.1240715", "abstract": "Software developers must modify their programs to keepup with changing requirements and designs. Often, aconceptually simple change can require numerous editsthat are similar but not identical, leading to errors andomissions. Researchers have designed programming environmentsto address this problem, but most of thesesystems are counter-intuitive and difficult to use.By applying a task-centered design process, we developeda visual tool that allows programmers to makecomplex code transformations i...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Aligning+development+tools+with+the+way+programmers+think+about+code+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "J.K. Feser, S. Chaudhuri, I. Dillig, \"Synthesizing data structure transformations from input-output examples\", <em>Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, 2015.", "title": "Synthesizing data structure transformations from input-output examples", "context": [{"sec": "sec5a", "text": " [29] propose a technique for synthesizing data structure transformations from examples in functional programming languages.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2737977", "abstract": "We present a method for example-guided synthesis of functional programs over recursive data structures. Given a set of input-output examples, our method synthesizes a program in a functional language with higher-order combinators like map and fold. The synthesized program is guaranteed to be the simplest program in the language to fit the examples. Our approach combines three technical ideas: inductive generalization, deduction, and enumerative search. First, we generalize the input-output examp...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Synthesizing+data+structure+transformations+from+input-output+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "H.A. Nguyen, T.T. Nguyen, G. Wilson, A.T. Nguyen, M. Kim, T.N. Nguyen, \"A graph-based approach to API usage adaptation\", <em>Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications</em>, pp. 302-321, 2010.", "title": "A graph-based approach to API usage adaptation", "context": [{"sec": "sec5a", "text": " [30] present LibSync, a technique that migrates APIs based on migrated clients.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1869459.1869486", "abstract": "Reusing existing library components is essential for reducing the cost of software development and maintenance. When library components evolve to accommodate new feature requests, to fix bugs, or to meet new standards, the clients of software libraries often need to make corresponding changes to correctly use the updated libraries. Existing API usage adaptation techniques support simple adaptation such as replacing the target of calls to a deprecated API, however, cannot handle complex adaptatio...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+graph-based+approach+to+API+usage+adaptation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "W. Tansey, E. Tilevich, \"Annotation refactoring: Inferring upgrade transformations for legacy applications\", <em>Proceedings of the 23rd ACM SIGPLAN Conference. on Object-oriented Programming Systems Languages and Applications</em>, pp. 295-312, 2008.", "title": "Annotation refactoring: Inferring upgrade transformations for legacy applications", "context": [{"sec": "sec5a", "text": " Tansey and Tilevich [31] present an example-based technique to migrate APIs that are based on annotations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1449764.1449788", "abstract": "Since annotations were added to the Java language, many frameworks have moved to using annotated Plain Old Java Objects (POJOs) in their newest releases. Legacy applications are thus forced to undergo extensive restructuring in order to migrate from old framework versions to new versions based on annotations (Version Lock-in). Additionally, because annotations are embedded in the application code, changing between framework vendors may also entail largescale manual changes (Vendor Lock-in). This...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Annotation+refactoring%3A+Inferring+upgrade+transformations+for+legacy+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "B. Hartmann, D. MacDougall, J. Brandt, S.R. Klemmer, \"What would other programmers do: Suggesting solutions to error messages\", <em>Proceedings of the SIGCHI Conference on Human Factors in Computing Systems</em>, pp. 1019-1028, 2010.", "title": "What would other programmers do: Suggesting solutions to error messages", "context": [{"sec": "sec5a", "text": " HelpMeOut [32] learns transformations to fix compilation and run-time errors from examples.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1753326.1753478", "abstract": "Interpreting compiler errors and exception messages is challenging for novice programmers. Presenting examples of how other programmers have corrected similar errors may help novices understand and correct such errors. This paper introduces HelpMeOut, a social recommender system that aids the debugging of error messages by suggesting solutions that peers have applied in the past. HelpMeOut comprises IDE instrumentation to collect examples of code changes that fix errors; a central database that ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+would+other+programmers+do%3A+Suggesting+solutions+to+error+messages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "M. Asaduzzaman, C.K. Roy, S. Monir, K.A. Schneider, \"Exploring API method parameter recommendations\", <em>Proceedings of the 31st IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 271-280, 2015.", "title": "Exploring API method parameter recommendations", "context": [{"sec": "sec5a", "text": " [33] present Parc, a technique to recommend argument (parameter) for method calls based on parameter usage history and static type analyses.", "part": "1"}], "links": {"abstract": "A number of techniques have been developed that support method call completion. However, there has been little research on the problem of method parameter completion. In this paper, we first present a study that helps us to understand how developers complete method parameters. Based on our observations, we developed a recommendation technique, called Parc, that collects parameter usage context using a source code localness property that suggests that developers tend to collocate related code fra...", "pdfSize": "1118KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+API+method+parameter+recommendations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "V. Raychev, M. Sch\u00e4fer, M. Sridharan, M. Vechev, \"Refactoring with synthesis\", <em>Proceedings of the 2013 ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages & Applications</em>, pp. 339-354, 2013.", "title": "Refactoring with synthesis", "context": [{"sec": "sec5a", "text": " [34] use data from large code repositories to learn likely code completions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2509136.2509544", "abstract": "Refactoring has become an integral part of modern software development, with wide support in popular integrated development environments (IDEs). Modern IDEs provide a fixed set of supported refactorings, listed in a refactoring menu. But with IDEs supporting more and more refactorings, it is becoming increasingly difficult for programmers to discover and memorize all their names and meanings. Also, since the set of refactorings is hard-coded, if a programmer wants to achieve a slightly different...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Refactoring+with+synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "S.R. Foster, W.G. Griswold, S. Lerner, \"WitchDoctor: IDE support for real-time auto-completion of refactorings\", <em>Proceedings of the 34th International Conference on Software Engineering</em>, pp. 222-232, 2012.", "title": "WitchDoctor: IDE support for real-time auto-completion of refactorings", "context": [{"sec": "sec5a", "text": " [35] use a large dataset of common code completions and recommend them based on the code context.", "part": "1"}], "links": {"documentLink": "/document/6227191", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227191", "abstract": "Integrated Development Environments (IDEs) have come to perform a wide variety of tasks on behalf of the programmer, refactoring being a classic example. These operations have undeniable benefits, yet their large (and growing) number poses a cognitive scalability problem. Our main contribution is WitchDoctor - a system that can detect, on the fly, when a programmer is hand-coding a refactoring. The system can then complete the refactoring in the background and propose it to the user long before ...", "pdfSize": "846KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=WitchDoctor%3A+IDE+support+for+real-time+auto-completion+of+refactorings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "X. Ge, Q.L. DuBose, E. Murphy-Hill, \"Reconciling manual and automatic refactoring\", <em>Proceedings of the 34th International Conference on Software Engineering</em>, pp. 211-221, 2012.", "title": "Reconciling manual and automatic refactoring", "context": [{"sec": "sec5a", "text": " [36] propose a similar technique for auto-completing a refactoring started manually.", "part": "1"}], "links": {"documentLink": "/document/6227192", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227192", "abstract": "Although useful and widely available, refactoring tools are underused. One cause of this underuse is that a developer sometimes fails to recognize that she is going to refactor before she begins manually refactoring. To address this issue, we conducted a formative study of developers&#39; manual refactoring process, suggesting that developers&#39; reliance on \u201cchasing error messages\u201d when manually refactoring is an error-prone manual refactoring strategy. Additionally, our study distilled a set of manua...", "pdfSize": "375KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reconciling+manual+and+automatic+refactoring&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "A.T. Nguyen, M. Hilton, M. Codoban, H.A. Nguyen, L. Mast, E. Rademacher, T.N. Nguyen, D. Dig, \"API code recommendation using statistical learning from fine-grained changes\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 511-522, 2016.", "title": "API code recommendation using statistical learning from fine-grained changes", "context": [{"sec": "sec5a", "text": " [37] present APIRec, a technique that leverages repetitive edit properties to recommend API usage.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950333", "abstract": "Learning and remembering how to use APIs is difficult. While code-completion tools can recommend API methods, browsing a long list of API method names and their documentation is tedious. Moreover, users can easily be overwhelmed with too much information. We present a novel API recommendation approach that taps into the predictive power of repetitive code changes to provide relevant API recommendations for developers. Our approach and tool, APIREC, is based on statistical learning from fine-grai...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=API+code+recommendation+using+statistical+learning+from+fine-grained+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "V. Raychev, M. Vechev, E. Yahav, \"Code completion with statistical language models\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 419-428, 2014.", "title": "Code completion with statistical language models", "context": [{"sec": "sec5a", "text": " Slang [38] is a technique that computes a statistical model based on code fragments from GitHub repositories.", "part": "1"}, {"sec": "sec5d", "text": " Data-driven approaches leverage large code repositories to synthesize likely changes to the input program [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+completion+with+statistical+language+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "H. Lieberman, Your wish is my command: Programming by example, Morgan Kaufmann, 2001.", "title": "Your wish is my command: Programming by example", "context": [{"sec": "sec5b", "text": "IP has been an active research area in the AI and HCI communities for over a decade [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Your+wish+is+my+command%3A+Programming+by+example&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "A. Leung, J. Sarracino, S. Lerner, \"Interactive parser synthesis by example\", <em>Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 565-574, June 15\u201317, 2015.", "title": "Interactive parser synthesis by example", "context": [{"sec": "sec5b", "text": " IP techniques have recently been developed for various domains including interactive synthesis of parsers [40], imperative data structure manipulations [41], and network policies [42].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2738002", "abstract": "Despite decades of research on parsing, the construction of parsers remains a painstaking, manual process prone to subtle bugs and pitfalls. We present a programming-by-example framework called Parsify that is able to synthesize a parser from input/output examples. The user does not write a single line of code. To achieve this, Parsify provides: (a) an iterative algorithm for synthesizing and refining a grammar one example at a time, (b) an interface that provides immediate visual feedback in re...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Interactive+parser+synthesis+by+example&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "J.K. Feser, S. Chaudhuri, I. Dillig, \"Synthesizing data structure transformations from input-output examples\", <em>Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, 2015.", "title": "Synthesizing data structure transformations from input-output examples", "context": [{"sec": "sec5b", "text": " IP techniques have recently been developed for various domains including interactive synthesis of parsers [40], imperative data structure manipulations [41], and network policies [42].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2737977", "abstract": "We present a method for example-guided synthesis of functional programs over recursive data structures. Given a set of input-output examples, our method synthesizes a program in a functional language with higher-order combinators like map and fold. The synthesized program is guaranteed to be the simplest program in the language to fit the examples. Our approach combines three technical ideas: inductive generalization, deduction, and enumerative search. First, we generalize the input-output examp...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Synthesizing+data+structure+transformations+from+input-output+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Y. Yuan, R. Alur, B.T. Loo, \"NetEgg: Programming network policies by examples\", <em>Proceedings of the 13th ACM Workshop on Hot Topics in Networks</em>, pp. 20:1-20:7, 2014.", "title": "NetEgg: Programming network policies by examples", "context": [{"sec": "sec5b", "text": " IP techniques have recently been developed for various domains including interactive synthesis of parsers [40], imperative data structure manipulations [41], and network policies [42].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2670518.2673879", "abstract": "The emergence of programmable interfaces to network controllers offers network operators the flexibility to implement a variety of policies. We propose NetEgg, a programming framework that allows a network operator to specify the desired functionality using example behaviors. Our synthesis algorithm automatically infers the state that needs to be maintained to exhibit the desired behaviors along with the rules for processing network packets and updating the state. We report on an initial prototy...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=NetEgg%3A+Programming+network+policies+by+examples&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "M. Mayer, G. Soares, M. Grechkin, V. Le, M. Marron, O. Polozov, R. Singh, B. Zorn, S. Gulwani, \"User interaction models for disambiguation in programming by example\", <em>Proceedings of the 28th Annual ACM Symposium on User Interface Software & Technology</em>, pp. 291-301, 2015.", "title": "User interaction models for disambiguation in programming by example", "context": [{"sec": "sec5b", "text": " Recently, it has been successfully used in industry by FlashFill and FlashExtract [11], [12], [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2807442.2807459", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=User+interaction+models+for+disambiguation+in+programming+by+example&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "K. Rivers, K.R. Koedinger, \"Data-driven hint generation in vast solution spaces: a self-improving Python programming tutor\", <em>International Journal of Artificial Intelligence in Education</em>, pp. 1-28, 2015.", "title": "Data-driven hint generation in vast solution spaces: a self-improving Python programming tutor", "context": [{"sec": "sec5c", "text": " Rivers and Koedinger [44] propose a data-driven technique for hint generation.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data-driven+hint+generation+in+vast+solution+spaces%3A+a+self-improving+Python+programming+tutor&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "S. Kaleeswaran, A. Santhiar, A. Kanade, S. Gulwani, \"Semi-supervised verified feedback generation\", <em>Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 739-750, 2016.", "title": "Semi-supervised verified feedback generation", "context": [{"sec": "sec5c", "text": " [45] propose a semi-supervised technique for feedback generation.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950363", "abstract": "Students have enthusiastically taken to online programming lessons and contests. Unfortunately, they tend to struggle due to lack of personalized feedback. There is an urgent need of program analysis and repair techniques capable of handling both the scale and variations in student submissions, while ensuring quality of feedback. Towards this goal, we present a novel methodology called semi-supervised verified feedback generation. We cluster submissions by solution strategy and ask the instructo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semi-supervised+verified+feedback+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "C. Goues, S. Forrest, W. Weimer, \"Current challenges in automatic software repair\", <em>Software Quality Journal</em>, vol. 21, no. 3, pp. 421-443, 2013.", "title": "Current challenges in automatic software repair", "context": [{"sec": "sec5d", "text": "Automated program repair is the task of automatically changing incorrect programs to make them meet a desired specification [46].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s11219-013-9208-0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Current+challenges+in+automatic+software+repair&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "C. Le Goues, M. Dewey-Vogt, S. Forrest, W. Weimer, \"A systematic study of automated program repair: Fixing 55 out of 105 bugs for \\$8 each\", <em>Proceedings of the 34th International Conference on Software Engineering</em>, pp. 3-13, 2012.", "title": "A systematic study of automated program repair: Fixing 55 out of 105 bugs for $8 each", "context": [{"sec": "sec5d", "text": " GenProg uses genetic programming to repeatedly alter the incorrect program aiming to correct it [47].", "part": "1"}], "links": {"documentLink": "/document/6227211", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227211", "abstract": "There are more bugs in real-world programs than human programmers can realistically address. This paper evaluates two research questions: \u201cWhat fraction of bugs can be repaired automatically?\u201d and \u201cHow much does it cost to repair a bug automatically?\u201d In previous work, we presented GenProg, which uses genetic programming to repair defects in off-the-shelf C programs. To answer these questions, we: (1) propose novel algorithmic improvements to GenProg that allow it to scale to large programs and ...", "pdfSize": "337KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+study+of+automated+program+repair%3A+Fixing+55+out+of+105+bugs+for+%248+each&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "F. Long, M. Rinard, \"Automatic patch generation by learning correct code\", <em>Proceedings of the 43rd Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</em>, vol. 51, no. 1, pp. 298-312, 2016.", "title": "Automatic patch generation by learning correct code", "context": [{"sec": "sec5d", "text": " Prophet [48] is a patch generation system that learns a probabilistic application-independent model of correct code from a set of successful human patches.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2837614.2837617", "abstract": "We present Prophet, a novel patch generation system that works with a set of successful human patches obtained from open- source software repositories to learn a probabilistic, application-independent model of correct code. It generates a space of candidate patches, uses the model to rank the candidate patches in order of likely correctness, and validates the ranked patches against a suite of test cases to find correct patches. Experimental results show that, on a benchmark set of 69 real-world ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+patch+generation+by+learning+correct+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "L. D'Antoni, R. Samanta, R. Singh, Qlose: Program repair with quantitative objectives, Springer International Publishing, pp. 383-401, 2016.", "title": "Qlose: Program repair with quantitative objectives", "context": [{"sec": "sec5d", "text": " Qlose provides ways to rank possible repairs based on a cost metric [49].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Qlose%3A+Program+repair+with+quantitative+objectives&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "A. Head, E. Glassman, G. Soares, R. Suzuki, L. D'Antoni, B. Hartmann, \"Writing Reusable Code Feedback at Scale with Mixed-Initiative Program Synthesis\", <em>L@S'17: 4th ACM Conference on Learning at Scale</em>, 2017.", "title": "Writing Reusable Code Feedback at Scale with Mixed-Initiative Program Synthesis", "context": [{"sec": "sec6", "text": " To address this limitation, we have recently built a mixed-initiative approach that uses teacher expertise to better leverage the fixes produced by Refazer [50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3051457.3051467", "abstract": "In large introductory programming classes, teacher feedback on individual incorrect student submissions is often infeasible. Program synthesis techniques are capable of fixing student bugs and generating hints automatically, but they lack the deep domain knowledge of a teacher and can generate functionally correct but stylistically poor fixes. We introduce a mixed-initiative approach which combines teacher expertise with data-driven program synthesis techniques. We demonstrate our novel approach...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Writing+Reusable+Code+Feedback+at+Scale+with+Mixed-Initiative+Program+Synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985680", "articleId": "7985680", "startPage": "404", "endPage": "415", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 11, "citationCountPatent": 0, "totalDownloads": 489}}
{"title": "Why Does Code Review Work for Open Source Software Communities?", "authors": [{"name": "Adam Alami", "affiliation": "IT University of Copenhagen", "firstName": "Adam", "lastName": "Alami", "id": "37086450841"}, {"name": "Marisa Leavitt Cohn", "affiliation": "IT University of Copenhagen, Denmark", "firstName": "Marisa", "lastName": "Leavitt Cohn", "id": "37086952644"}, {"name": "Andrzej W\u0105sowski", "affiliation": "IT University of Copenhagen, Denmark", "firstName": "Andrzej", "lastName": "W\u0105sowski", "id": "37704240300"}], "abstract": "Open source software communities have demonstrated that they can produce high quality results. The overall success of peer code review, commonly used in open source projects, has likely contributed strongly to this success. Code review is an emotionally loaded practice, with public exposure of reputation and ample opportunities for conflict. We set off to ask why code review works for open source communities, despite this inherent challenge. We interviewed 21 open source contributors from four communities and participated in meetings of ROS community devoted to implementation of the code review process. It appears that the hacker ethic is a key reason behind the success of code review in FOSS communities. It is built around the ethic of passion and the ethic of caring. Furthermore, we observed that tasks of code review are performed with strong intrinsic motivation, supported by many non-material extrinsic motivation mechanisms, such as desire to learn, to grow reputation, or to improve one's positioning on the job market. In the paper, we describe the study design, analyze the collected data and formulate 20 proposals for how what we know about hacker ethics and human and social aspects of code review, could be exploited to improve the effectiveness of the practice in software projects.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Interviews", "Software", "Standards", "Ethics", "Guidelines", "Robot kinematics"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["human factors", "public domain software", "software engineering"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["open source projects", "code review process", "code review work", "open source software communities", "peer code review", "open source contributors", "ROS community", "FOSS communities", "nonmaterial extrinsic motivation mechanisms"]}, {"type": "Author Keywords ", "kwd": ["Open Source, Code Review, Motivation"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00111", "ref": [{"order": "1", "text": "P. Rigby, B. Cleary, F. Painchaud, M.-A. Storey, D. German, \"Con-temporary peer review in action: Lessons from open source development\", <em>IEEE software</em>, vol. 29, no. 6, pp. 56-61, 2012.", "title": "Con-temporary peer review in action: Lessons from open source development", "context": [{"sec": "sec1", "text": "Code review is an established software engineering practice, that ensures good quality of source code, lowers bug frequency, and enforces coding standards [1].", "part": "1"}, {"sec": "sec1", "text": "Code review is particularly successful and cherished in free and open source software (FOSS) communities [1]\u2013[4].", "part": "1"}, {"sec": "sec6", "text": "Asynchronous reviews support team discussions and find the same number of defects as collocated meetings [1].", "part": "1"}, {"sec": "sec6", "text": " Rigby et al. point out that communities allow expert developers to self-select submissions to review [1].", "part": "1"}], "links": {"documentLink": "/document/6148202", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6148202", "abstract": "Do you use software peer reviews? Are you happy with your current code review practices? Even though formal inspection is recognized as one of the most effective ways to improve software quality, many software organizations struggle to effectively implement a formal inspection regime. Open source projects use an agile peer review process-based on asynchronous, frequent, incremental reviews that are carried out by invested codevelopers-that contrasts with heavyweight inspection processes. The aut...", "pdfSize": "844KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Con-temporary+peer+review+in+action%3A+Lessons+from+open+source+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "P. C. Rigby, D. M. German, M.-A. Storey, \"Open source software peer review practices: a case study of the apache server\", <em>Proceedings of the 30th international conference on Software engineering ACM</em>, pp. 541-550, 2008.", "title": "Open source software peer review practices: a case study of the apache server", "context": [{"sec": "sec1", "text": "Code review is particularly successful and cherished in free and open source software (FOSS) communities [1]\u2013[2][4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368162", "abstract": "Peer review is seen as an important quality assurance mechanism in both industrial development and the open source software (OSS) community. The techniques for performing inspections have been well studied in industry; in OSS development, peer reviews are less well understood. We examine the two peer review techniques used by the successful, mature Apache server project: review-then-commit and commit-then-review. Using archival records of email discussion and version control repositories, we con...", "pdfSize": "257KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Open+source+software+peer+review+practices%3A+a+case+study+of+the+apache+server&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "M. Beller, A. Bacchelli, A. Zaidman, E. Juergens, \"Modern code reviews in open-source projects: Which problems do they fix?\", <em>Proceedings of the 11th working conference on mining software repositories. ACM</em>, pp. 202-211, 2014.", "title": "Modern code reviews in open-source projects: Which problems do they fix?", "context": [{"sec": "sec1", "text": "Code review is particularly successful and cherished in free and open source software (FOSS) communities [1]\u2013[3][4].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2597073.2597082", "abstract": "Code review is the manual assessment of source code by humans, mainly intended to identify defects and quality problems. Modern Code Review (MCR), a lightweight variant of the code inspections investigated since the 1970s, prevails today both in industry and open-source software (OSS) systems. The objective of this paper is to increase our understanding of the practical benefits that the MCR process produces on reviewed source code. To that end, we empirically explore the problems fixed through ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Modern+code+reviews+in+open-source+projects%3A+Which+problems+do+they+fix%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "A. Aurum, H. Petersson, C. Wohlin, \"State-of-the-art: software inspections after 25 years\", <em>Software Testing Verification and Reliability</em>, vol. 12, no. 3, pp. 133-154, 2002.", "title": "State-of-the-art: software inspections after 25 years", "context": [{"sec": "sec1", "text": "Code review is particularly successful and cherished in free and open source software (FOSS) communities [1]\u2013[4].", "part": "1"}, {"sec": "sec1", "text": " Now, that code review is also widely used in the industry [4], [5], it is particularly relevant to understand why and how it works.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/stvr.243", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=State-of-the-art%3A+software+inspections+after+25+years&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "B. Boehm, V. R. Basili, \"Software defect reduction top 10 list\", <em>Foundations of empirical software engineering: the legacy of Victor R. Basili</em>, vol. 426, no. 37, 2005.", "title": "Software defect reduction top 10 list", "context": [{"sec": "sec1", "text": " Now, that code review is also widely used in the industry [4], [5], it is particularly relevant to understand why and how it works.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-27662-9_26", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+defect+reduction+top+10+list&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "R. J. Vallerand, C. Blanchard, G. A. Mageau, R. Koestner, C. Ratelle, M. Leonard, M. Gagne, J. Marsolais, \"Les passions de l'ame: on obsessive and harmonious passion\", <em>Journal of personality and social psychology</em>, vol. 85, no. 4, 2003.", "title": "Les passions de l'ame: on obsessive and harmonious passion", "context": [], "links": {"crossRefLink": "https://doi.org/10.1037/0022-3514.85.4.756", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Les+passions+de+l%27ame%3A+on+obsessive+and+harmonious+passion&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "N. Noddings, Caring: A relational approach to ethics and moral education, 2013.", "title": "Caring: A relational approach to ethics and moral education", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Caring%3A+A+relational+approach+to+ethics+and+moral+education&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "R. M. Ryan, E. L. Deci, \"Intrinsic and extrinsic motivations: Classic definitions and new directions\", <em>Contemporary educational psychology</em>, vol. 25, no. 1, pp. 54-67, 2000.", "title": "Intrinsic and extrinsic motivations: Classic definitions and new directions", "context": [], "links": {"crossRefLink": "https://doi.org/10.1006/ceps.1999.1020", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Intrinsic+and+extrinsic+motivations%3A+Classic+definitions+and+new+directions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "C. Robson, K. McCartan, Real world research, John Wiley & Sons, 2016.", "title": "Real world research", "context": [{"sec": "sec3e", "text": "We analyzed the material from interviews and meetings following the guidelines of Robson and McCartan [9] and of Miles and coauthors [10].", "part": "1"}, {"sec": "sec3e", "text": " A theme is a concept, an implied topic that organizes a group of repeating ideas that help to answer the study question [9].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Real+world+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "M. B. Miles, A. M. Huberman, J. Saldana, Qualitative data analysis: A method sourcebook, CA, US:Sage Publications, 2014.", "title": "Qualitative data analysis: A method sourcebook", "context": [{"sec": "sec3e", "text": "We analyzed the material from interviews and meetings following the guidelines of Robson and McCartan [9] and of Miles and coauthors [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Qualitative+data+analysis%3A+A+method+sourcebook&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "P. Himanen, The hacker ethic, Random House, 2010.", "title": "The hacker ethic", "context": [{"sec": "sec4", "text": " Himanen [11] argues that the hacker ethics are more about moral virtues, in contrast to the protestant work ethic, which stresses diligent hard effort.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+hacker+ethic&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "R. A. Ghosh, R. Glott, B. Krieger, G. Robles, <em>Free/libre and open source software: Survey and study</em>, 2002.", "title": "Free/libre and open source software: Survey and study", "context": [{"sec": "sec4b", "text": "How learning affects code review? Ghosh and coauthors observe that knowledge is a salient motive for participation in FOSS [12], [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Free%2Flibre+and+open+source+software%3A+Survey+and+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "R. A. Ghosh, \"Understanding free software developers: Findings from the FLOSS study\", <em>Perspectives on free and open source software</em>, pp. 23-46, 2005.", "title": "Understanding free software developers: Findings from the FLOSS study", "context": [{"sec": "sec4b", "text": "How learning affects code review? Ghosh and coauthors observe that knowledge is a salient motive for participation in FOSS [12], [13].", "part": "1"}, {"sec": "sec4b", "text": " FOSS creates a positive environment for learning [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+free+software+developers%3A+Findings+from+the+FLOSS+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "K. R. Lakhani, R. G. Wolf, \"Why hackers do what they do: Understanding motivation and effort in free/open source software projects\", <em>Perspectives on free and open source software</em>, vol. 1, pp. 3-22, 2005.", "title": "Why hackers do what they do: Understanding motivation and effort in free/open source software projects", "context": [{"sec": "sec4b", "text": " Lakhani and Wolf report that 45% of the survey's participants join a FOSS community to improve their skills [14].", "part": "1"}, {"sec": "sec4e", "text": " The FOSS motivation literature suggest that enjoyment is a key motivator for contributors [14], [18], [19].", "part": "1"}, {"sec": "sec4f", "text": " This is in line with the rich literature about desire for reputation as a motivation to participate in FOSS communities overall [14], [24]\u2013[26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+hackers+do+what+they+do%3A+Understanding+motivation+and+effort+in+free%2Fopen+source+software+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "R. J. Vallerand, S.-J. Salvy, G. A. Mageau, A. J. Elliot, P. L. Denis, F. M. E. Grouzet, C. Blanchard, \"On the role of passion in performance\", <em>Journal of personality</em>, vol. 75, no. 3, pp. 505-534, 2007.", "title": "On the role of passion in performance", "context": [{"sec": "sec4c", "text": "Passion is a strong inclination or desire toward an activity that one likes or even loves, that one finds important, and one invests time and energy in [15].", "part": "1"}, {"sec": "sec4c", "text": " Passion is a necessary component in reaching the highest level of achievement, and contributes to creativity [15].", "part": "1"}, {"sec": "sec4c", "text": "How does passion shape the execution of code review? Vallerand et al. propose a dualistic model of passion, distinguishing obsessive and harmonious passion [15].", "part": "1"}, {"sec": "sec4c", "text": " Harmonious passion results from an autonomous internalization of acceptance of the activity [15].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.1467-6494.2007.00447.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+role+of+passion+in+performance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "A. Bonneville-Roussy, G. L. Lavigne, R. J. Vallerand, \"When passion leads to excellence: The case of musicians\", <em>Psychology of Music</em>, vol. 39, no. 1, pp. 123-138, 2011.", "title": "When passion leads to excellence: The case of musicians", "context": [{"sec": "sec4c", "text": " [16] analyze the types of goals that people subject to harmonious and obsessive passion set.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/0305735609352441", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+passion+leads+to+excellence%3A+The+case+of+musicians&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "A. L. Toombs, S. Bardzell, J. Bardzell, \"The proper care and feeding of hackerspaces: Care ethics and cultures of making\", <em>Proceedings of the 33rd annual ACM conference on human factors in computing systems. ACM</em>, pp. 629-638, 2015.", "title": "The proper care and feeding of hackerspaces: Care ethics and cultures of making", "context": [{"sec": "sec4d", "text": " [17] argue that hacker communities demonstrate a nonliberal ethos, prizing self-determination, technological expertise, independence, freedom from government, and suspicion of authorities.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2702123.2702522", "abstract": "Communities of making have been at the center of attention in popular, business, political, and academic research circles in recent years. In HCI, they seem to carry the promise of new forms of computer use, education, innovation, and even ways of life. In the West in particular, the maker manifestos of these communities have shown strong elements of a neoliberal ethos, one that prizes self-determination, tech-savvy, independence, freedom from government, suspicion of authority, and so forth. Ye...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+proper+care+and+feeding+of+hackerspaces%3A+Care+ethics+and+cultures+of+making&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "K. R. Lakhani, E. Von Hippel, \"How open source software works: \u201cfree\u201d user-to-user assistance\", <em>Research policy</em>, vol. 32, no. 6, pp. 923-943, 2003.", "title": "How open source software works: \u201cfree\u201d user-to-user assistance", "context": [{"sec": "sec4e", "text": " The FOSS motivation literature suggest that enjoyment is a key motivator for contributors [14], [18], [19].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0048-7333(02)00095-1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+open+source+software+works%3A+%E2%80%9Cfree%E2%80%9D+user-to-user+assistance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "B. Luthiger, C. Jungwirth, \"The Chase for OSS Quality: The Meaning of Member Roles Motivations and Business Models\", <em>Emerging Free and Open Source Software Practices. IGI Global</em>, pp. 147-168, 2007.", "title": "The Chase for OSS Quality: The Meaning of Member Roles, Motivations, and Business Models", "context": [{"sec": "sec4e", "text": " The FOSS motivation literature suggest that enjoyment is a key motivator for contributors [14], [18], [19].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.4018/978-1-59904-210-7.ch007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Chase+for+OSS+Quality%3A+The+Meaning+of+Member+Roles%2C+Motivations%2C+and+Business+Models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "R. Q. Danish, M. K. Khan, A. U. Shahid, I. Raza, A. A. Humayon, \"Effect of intrinsic rewards on task performance of employees: Mediating role of motivation\", <em>International Journal of Organizational Leadership</em>, vol. 4, no. 1, 2015.", "title": "Effect of intrinsic rewards on task performance of employees: Mediating role of motivation", "context": [{"sec": "sec4e", "text": " How does intrinsic motivation influence the execution of code review? Intrinsically motivated employees perform well, behave effectively, and remain loyal to the organization [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effect+of+intrinsic+rewards+on+task+performance+of+employees%3A+Mediating+role+of+motivation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "J. Rogstadius, V. Kostakos, A. Kittur, B. Smus, J. Laredo, M. Vukovic, \"An assessment of intrinsic and extrinsic motivation on task performance in crowdsourcing markets\", <em>ICWSM</em>, vol. 11, pp. 17-21, 2011.", "title": "An assessment of intrinsic and extrinsic motivation on task performance in crowdsourcing markets", "context": [{"sec": "sec4e", "text": " Rogstadius and coauthors determined that increased pay does increase worker's willingness to accept a task and faster completion, but pay does not affect the quality of the work [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+assessment+of+intrinsic+and+extrinsic+motivation+on+task+performance+in+crowdsourcing+markets&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "E. S. Raymond, The Cathedral and the Bazaar, 1998.", "title": "The Cathedral and the Bazaar", "context": [{"sec": "sec4f", "text": " When giving, the contributor is owed [22].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.5210/fm.v3i2.578", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Cathedral+and+the+Bazaar&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "D. Zeitlyn, \"Gift economies in the development of open source software: anthropological reflections\", <em>Research policy</em>, vol. 32, no. 7, pp. 1287-1291, 2003.", "title": "Gift economies in the development of open source software: anthropological reflections", "context": [{"sec": "sec4f", "text": " There is an implicit moral obligation to reciprocate the gesture of giving [23], but more subtle than just give-and-take.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0048-7333(03)00053-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Gift+economies+in+the+development+of+open+source+software%3A+anthropological+reflections&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "J. Hahn, J. Y. Moon, C. Zhang, \"Emergence of new project teams from open source software developer networks: Impact of prior collaboration ties\", <em>Information Systems Research</em>, vol. 19, no. 3, pp. 369-391, 2008.", "title": "Emergence of new project teams from open source software developer networks: Impact of prior collaboration ties", "context": [{"sec": "sec4f", "text": " This is in line with the rich literature about desire for reputation as a motivation to participate in FOSS communities overall [14], [24]\u2013[26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/isre.1080.0192", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Emergence+of+new+project+teams+from+open+source+software+developer+networks%3A+Impact+of+prior+collaboration+ties&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "G. Hertel, S. Niedner, S. Herrmann, \"Motivation of software developers in Open Source projects: an Internet-based survey of contributors to the Linux kernel\", <em>Research policy</em>, vol. 32, no. 7, pp. 1159-1177, 2003.", "title": "Motivation of software developers in Open Source projects: an Internet-based survey of contributors to the Linux kernel", "context": [{"sec": "sec4f", "text": " This is in line with the rich literature about desire for reputation as a motivation to participate in FOSS communities overall [14], [24]\u2013[25][26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0048-7333(03)00047-7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Motivation+of+software+developers+in+Open+Source+projects%3A+an+Internet-based+survey+of+contributors+to+the+Linux+kernel&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "J. Lerner, J. Tirole, \"Some simple economics of open source\", <em>The journal of industrial economics</em>, vol. 50, no. 2, pp. 197-234, 2002.", "title": "Some simple economics of open source", "context": [{"sec": "sec4f", "text": " This is in line with the rich literature about desire for reputation as a motivation to participate in FOSS communities overall [14], [24]\u2013[26].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/1467-6451.00174", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Some+simple+economics+of+open+source&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "A. K. Shenton, \"Strategies for ensuring trustworthiness in qualitative research projects\", <em>Education for information</em>, vol. 22, no. 2, pp. 63-75, 2004.", "title": "Strategies for ensuring trustworthiness in qualitative research projects", "context": [{"sec": "sec4g", "text": "The validity of qualitative research is achieved through trustworthiness [27], [28].", "part": "1"}, {"sec": "sec4g", "text": "Credibility establishes internal validity, which rivals hypotheses exclusion [27], [29], [30].", "part": "1"}, {"sec": "sec4g", "text": " Participant checks have been used for narrative accuracy and interpretive validity [27], [29], [32].", "part": "1"}, {"sec": "sec4g", "text": "Transferability refers to the extent to which the findings of qualitative research, either partially or completely, can be generalized or applied to similar settings [27].", "part": "1"}, {"sec": "sec4g", "text": " It is concerned with the ability of the research to reach the same conclusions if replicated in the same setting and conditions [27].", "part": "1"}, {"sec": "sec4g", "text": " Shenton [27] suggests that the research report should include discussions on dependability and that researchers should comprehensively explain the research design and the data gathering methods.", "part": "1"}, {"sec": "sec4g", "text": " It is improved by triangulation of the study data and findings [27].", "part": "1"}, {"sec": "sec4g", "text": " An audit trail should also be discussed in the study report as another tool to improve confirmability in the study [27], [29].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3233/EFI-2004-22201", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Strategies+for+ensuring+trustworthiness+in+qualitative+research+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "D. Sikolia, D. Biros, M. Mason, M. Weiser, <em>Trustworthiness of grounded theory methodology research in information systems</em>, 2013.", "title": "Trustworthiness of grounded theory methodology research in information systems", "context": [{"sec": "sec4g", "text": "The validity of qualitative research is achieved through trustworthiness [27], [28].", "part": "1"}, {"sec": "sec4g", "text": " [28] suggest that researchers can ensure transferability by describing the research clearly, explaining the diverse experiences of the participants, implementing methodology, interpreting the results, and adding contributions from debriefing.", "part": "1"}, {"sec": "sec4g", "text": " This audit establishes confirmability [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Trustworthiness+of+grounded+theory+methodology+research+in+information+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "S. C. Brown, R. A. Stevens, P. F. Troiano, M. K. Schneider, \"Exploring complex phenomena: Grounded theory in student affairs research\", <em>Journal of college student development</em>, vol. 43, no. 2, pp. 173-183, 2002.", "title": "Exploring complex phenomena: Grounded theory in student affairs research", "context": [{"sec": "sec4g", "text": "Credibility establishes internal validity, which rivals hypotheses exclusion [27], [29], [30].", "part": "1"}, {"sec": "sec4g", "text": " Participant checks have been used for narrative accuracy and interpretive validity [27], [29], [32].", "part": "1"}, {"sec": "sec4g", "text": " An audit trail should also be discussed in the study report as another tool to improve confirmability in the study [27], [29].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+complex+phenomena%3A+Grounded+theory+in+student+affairs+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "G. Rolfe, \"Validity trustworthiness and rigour: quality and the idea of qualitative research\", <em>Journal of advanced nursing</em>, vol. 53, no. 3, pp. 304-110, 2006.", "title": "Validity, trustworthiness and rigour: quality and the idea of qualitative research", "context": [{"sec": "sec4g", "text": "Credibility establishes internal validity, which rivals hypotheses exclusion [27], [29], [30].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.1365-2648.2006.03727.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Validity%2C+trustworthiness+and+rigour%3A+quality+and+the+idea+of+qualitative+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "D. Straub, M.-C. Boudreau, D. Gefen, \"Validation guidelines for IS positivist research\", <em>The Communications of the Association for Information Systems</em>, vol. 13, no. 1, 2004.", "title": "Validation guidelines for IS positivist research", "context": [{"sec": "sec4g", "text": " It ensures the proposed theory is reliable and representative of the raw data [31].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.17705/1CAIS.01324", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Validation+guidelines+for+IS+positivist+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "M. Carcary, \"The Research Audit Trial: Enhancing Trustworthiness in Qualitative Inquiry\", <em>Electronic Journal of Business Research Methods</em>, vol. 7, no. 1, 2009.", "title": "The Research Audit Trial: Enhancing Trustworthiness in Qualitative Inquiry", "context": [{"sec": "sec4g", "text": " Participant checks have been used for narrative accuracy and interpretive validity [27], [29], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Research+Audit+Trial%3A+Enhancing+Trustworthiness+in+Qualitative+Inquiry&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "A. Cooney, \"Rigour and grounded theory\", <em>Nurse researcher</em>, vol. 18, no. 4, pp. 17-22, 2011.", "title": "Rigour and grounded theory", "context": [{"sec": "sec4g", "text": " An audit trail is available and detailed enough to allow other researchers to replicate a similar inquiry in similar communities [33].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.7748/nr2011.07.18.4.17.c8631", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rigour+and+grounded+theory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "R. J. Burke, L. Fiksenbaum, \"Work motivations satisfactions and health among managers: Passion versus addiction\", <em>Cross-Cultural Research</em>, vol. 43, no. 4, pp. 349-365, 2009.", "title": "Work motivations, satisfactions, and health among managers: Passion versus addiction", "context": [{"sec": "sec5", "text": "According to Burke and Fiksenbaum passion enhances mental and psychological well-being of the employees [34].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/1069397109336990", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Work+motivations%2C+satisfactions%2C+and+health+among+managers%3A+Passion+versus+addiction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "R. M. Ryan, E. L. Deci, \"Self-determination theory and the facilitation of intrinsic motivation social development and well-being\", <em>American psvchologist</em>, vol. 55, no. 1, pp. 68, 2000.", "title": "Self-determination theory and the facilitation of intrinsic motivation, social development, and well-being", "context": [{"sec": "sec5", "text": " Self-determination theory attempts to differentiate factors that facilitate and that undermine intrinsic motivation [35].", "part": "1"}, {"sec": "sec5", "text": " A sub-theory, the cognitive evaluation theory, maintains that interpersonal events that lead to feelings of competence enhance intrinsic motivation when they are accompanied by a sense of autonomy [35], [36].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0003-066X.55.1.68", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Self-determination+theory+and+the+facilitation+of+intrinsic+motivation%2C+social+development%2C+and+well-being&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "F. P. Morgeson, K. Delaney-Klinger, M. A. Hemingway, \"The importance of job autonomy cognitive ability and job-related skill for predicting role breadth and job performance\", <em>Journal of applied psychologv</em>, vol. 90, no. 2, pp. 399, 2005.", "title": "The importance of job autonomy, cognitive ability, and job-related skill for predicting role breadth and job performance", "context": [{"sec": "sec5", "text": " A sub-theory, the cognitive evaluation theory, maintains that interpersonal events that lead to feelings of competence enhance intrinsic motivation when they are accompanied by a sense of autonomy [35], [36].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0021-9010.90.2.399", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+importance+of+job+autonomy%2C+cognitive+ability%2C+and+job-related+skill+for+predicting+role+breadth+and+job+performance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "C. J. Fornaciari, K. L. Dean, \"Experiencing organizational work design: Beyond hackman and oldham\", <em>Journal of Management Education</em>, vol. 29, no. 4, pp. 631-653, 2005.", "title": "Experiencing organizational work design: Beyond hackman and oldham", "context": [{"sec": "sec5", "text": " Autonomy is described as the leeway that is given to the employee to complete their job tasks [37].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/1052562904273378", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Experiencing+organizational+work+design%3A+Beyond+hackman+and+oldham&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "K. Kraiger, R. S. Billings, A. M. Isen, \"The influence of positive affective states on task perceptions and satisfaction\", <em>Organizational Behavior and Human Decision Processes</em>, vol. 44, no. 1, pp. 12-25, 1989.", "title": "The influence of positive affective states on task perceptions and satisfaction", "context": [{"sec": "sec5", "text": " [38] argue that a positive effect increases people's enjoyment and interest.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0749-5978(89)90032-0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+influence+of+positive+affective+states+on+task+perceptions+and+satisfaction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "A. Erez, A. M. Isen, \"The influence of positive affect on the components of expectancy motivation\", <em>Journal of Applied psychology</em>, vol. 87, no. 6, pp. 1055, 2002.", "title": "The influence of positive affect on the components of expectancy motivation", "context": [{"sec": "sec5", "text": " [39] found that a positive effect increases the intrinsic attractiveness (i.e. goodness) of moderately desirable rewards.", "part": "1"}, {"sec": "sec5", "text": " It also affects satisfaction and performance during the activity [39], [40].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0021-9010.87.6.1055", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+influence+of+positive+affect+on+the+components+of+expectancy+motivation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "B. M. Staw, S. G. Barsade, \"Affect and managerial performance: A test of the sadder-but-wiser vs. happier-and-smarter hypotheses\", <em>Administrative Science Quarterlv</em>, pp. 304-331, 1993.", "title": "Affect and managerial performance: A test of the sadder-but-wiser vs. happier-and-smarter hypotheses", "context": [{"sec": "sec5", "text": " It also affects satisfaction and performance during the activity [39], [40].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2307/2393415", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Affect+and+managerial+performance%3A+A+test+of+the+sadder-but-wiser+vs.+happier-and-smarter+hypotheses&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "J. Boiche, P. G. Sarrazin, F. M. Grouzet, L. G. Pelletier, J. P. Chanal, \"Students' motivational profiles and achievement outcomes in physical education: A self-determination perspective\", <em>Journal of Educational Psychology</em>, vol. 100, no. 3, pp. 688, 2008.", "title": "Students' motivational profiles and achievement outcomes in physical education: A self-determination perspective", "context": [{"sec": "sec5", "text": " There are known results that extrinsic motivators do correlate with performance and that they synergize with intrinsic motivations [41], [42].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/0022-0663.100.3.688", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Students%27+motivational+profiles+and+achievement+outcomes+in+physical+education%3A+A+self-determination+perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "L. G. Pelletier, P. Sarrazin, <em>Measurement issues in self-determination theory and sport.</em>, 2007.", "title": "Measurement issues in self-determination theory and sport.", "context": [{"sec": "sec5", "text": " There are known results that extrinsic motivators do correlate with performance and that they synergize with intrinsic motivations [41], [42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Measurement+issues+in+self-determination+theory+and+sport.&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "A. Bacchelli, C. Bird, \"Expectations outcomes and challenges of modern code review\", <em>Proceedings of the 2013 international conference on software engineering IEEE Press</em>, pp. 712-721, 2013.", "title": "Expectations, outcomes, and challenges of modern code review", "context": [{"sec": "sec6", "text": " Bachelli and Bird [43] found that the top motivation for code reviewers is finding defects, but in fact, defect-related communication is proportionally small.", "part": "1"}], "links": {"documentLink": "/document/7190109", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7190109", "abstract": "Code review is a common software engineering practice employed both in open source and industrial contexts. Review today is less formal and more lightweight than the code inspections performed and studied in the 70s and 80s. We empirically explore the motivations, challenges, and outcomes of tool-based code reviews. We observed, interviewed, and surveyed developers and managers and manually classified hundreds of review comments across diverse teams at Microsoft. Our study reveals that while fin...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Expectations%2C+outcomes%2C+and+challenges+of+modern+code+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "S. Lussier, \"New tricks: How open source changed the way my team works\", <em>IEEE software</em>, vol. 21, no. 1, pp. 68-72, 2004.", "title": "New tricks: How open source changed the way my team works", "context": [{"sec": "sec6", "text": "Lussier [44] describes the experience of first rejection of a contribution to the Wine project, an open source implementation of the Windows API.", "part": "1"}], "links": {"documentLink": "/document/1259222", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1259222", "abstract": "A commercial software team contributed to an open source implementation of the Windows API on X-Windows and Unix. Wine is an open source implementation of the Windows API, a compatibility layer that lets native windows programs run on X-Windows and Unix. With our contribution filling in some gaps, our client planned to include Wine with a slightly modified product. Expecting chaos in the organization and code, the team instead found a structured community with procedures all its own. The version...", "pdfSize": "403KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=New+tricks%3A+How+open+source+changed+the+way+my+team+works&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "L. Votta, \"Does the Modern Code Inspection Have Value\", <em>Presentation at the NRC Seminar on Measuring Success: Empirical Studies of Software Engineering</em>, 1999.", "title": "Does the Modern Code Inspection Have Value", "context": [{"sec": "sec6", "text": "Votta [45] suggests that face-to-face code review meetings of the whole team should be replaced with depositions.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Does+the+Modern+Code+Inspection+Have+Value&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "D. M. German, G. Robles, G. Poo-Caamano, X. Yang, H. Iida, K. Inoue, \"Was my contribution fairly reviewed?: a framework to study the perception of fairness in modern code reviews\", <em>Proceedings of the 40th International Conference on Software Engineering. ACM</em>, pp. 523-534, 2018.", "title": "Was my contribution fairly reviewed?: a framework to study the perception of fairness in modern code reviews", "context": [{"sec": "sec6", "text": "German and colleagues [46] studied OpenStack.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180217", "abstract": "Modern code reviews improve the quality of software products. Although modern code reviews rely heavily on human interactions, little is known regarding whether they are performed fairly. Fairness plays a role in any process where decisions that affect others are made. When a system is perceived to be unfair, it affects negatively the productivity and motivation of its participants. In this paper, using fairness theory we create a framework that describes how fairness affects modern code reviews...", "pdfSize": "173KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Was+my+contribution+fairly+reviewed%3F%3A+a+framework+to+study+the+perception+of+fairness+in+modern+code+reviews&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812037", "articleId": "8812037", "startPage": "1073", "endPage": "1083", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 121}}
{"title": "The Seven Sins: Security Smells in Infrastructure as Code Scripts", "authors": [{"name": "Akond Rahman", "affiliation": "North Carolina State University, USA", "firstName": "Akond", "lastName": "Rahman", "id": "37533217200"}, {"name": "Chris Parnin", "affiliation": "North Carolina State University, USA", "firstName": "Chris", "lastName": "Parnin", "id": "37312438600"}, {"name": "Laurie Williams", "affiliation": "North Carolina State University, USA", "firstName": "Laurie", "lastName": "Williams", "id": "37275745700"}], "abstract": "Practitioners use infrastructure as code (IaC) scripts to provision servers and development environments. While developing IaC scripts, practitioners may inadvertently introduce security smells. Security smells are recurring coding patterns that are indicative of security weakness and can potentially lead to security breaches. The goal of this paper is to help practitioners avoid insecure coding practices while developing infrastructure as code (IaC) scripts through an empirical study of security smells in IaC scripts. We apply qualitative analysis on 1,726 IaC scripts to identify seven security smells. Next, we implement and validate a static analysis tool called Security Linter for Infrastructure as Code scripts (SLIC) to identify the occurrence of each smell in 15,232 IaC scripts collected from 293 open source repositories. We identify 21,201 occurrences of security smells that include 1,326 occurrences of hard-coded passwords. We submitted bug reports for 1,000 randomly-selected security smell occurrences. We obtain 212 responses to these bug reports, of which 148 occurrences were accepted by the development teams to be fixed. We observe security smells can have a long lifetime, e.g., a hard-coded secret can persist for as long as 98 months, with a median lifetime of 20 months.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Password", "Encoding", "Tools", "Software", "Servers", "Static analysis"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["program debugging", "program diagnostics", "security of data"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["hard-coded passwords", "security smells", "hard-coded secret", "security weakness", "security breaches", "IaC scripts", "security linter tool", "security linter for infrastructure as code scripts"]}, {"type": "Author Keywords ", "kwd": ["devops, devsecops, empirical study, infrastructure as code, puppet, security, smell, static analysis"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00033", "ref": [{"order": "1", "text": "J. Humble, D. Farley, Continuous Delivery: Reliable Software Releases Through Build Test and Deployment Automation, Addison-Wesley Professional, 2010.", "title": "Continuous Delivery: Reliable Software Releases Through Build, Test, and Deployment Automation", "context": [{"sec": "sec1", "text": "Infrastructure as code (IaC) scripts help practitioners to provision and configure their development environment and servers at scale [1].", "part": "1"}, {"sec": "sec1", "text": " IaC scripts are also known as configuration scripts [2] [1] or configuration as code scripts [1] [3].", "part": "1"}, {"sec": "sec2a", "text": "IaC is the practice of automatically defining and managing network and system configurations and infrastructure through source code [1].", "part": "1"}, {"sec": "sec2a", "text": " Companies widely use commercial tools such as Puppet, to implement the practice of IaC [1] [8] [9].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+Delivery%3A+Reliable+Software+Releases+Through+Build%2C+Test%2C+and+Deployment+Automation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "T. Sharma, M. Fragkoulis, D. Spinellis, \"Does your configuration code smell?\", <em>Proceedings of the 13th International Conference on Mining Software Repositories ser. MSR'16</em>, pp. 189-200, 2016.", "title": "Does your configuration code smell?", "context": [{"sec": "sec1", "text": " IaC scripts are also known as configuration scripts [2] [1] or configuration as code scripts [1] [3].", "part": "1"}, {"sec": "sec2b", "text": " [2], Schwarz [12], and Bent et al. [13], in separate studies investigated code maintainability aspects of Chef and Puppet scripts.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2901739.2901761", "abstract": "Infrastructure as Code (IaC) is the practice of specifying computing system configurations through code, and managing them through traditional software engineering methods. The wide adoption of configuration management and increasing size and complexity of the associated code, prompt for assessing, maintaining, and improving the configuration code&#39;s quality. In this context, traditional software engineering knowledge and best practices associated with code quality management can be leveraged to ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Does+your+configuration+code+smell%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "A. Rahman, A. Partho, P. Morrison, L. Williams, \"What questions do programmers ask about configuration as code?\", <em>Proceedings of the 4th International Workshop on Rapid Continuous Software Engineering ser. RCoSE'18</em>, pp. 16-22, 2018.", "title": "What questions do programmers ask about configuration as code?", "context": [{"sec": "sec1", "text": " IaC scripts are also known as configuration scripts [2] [1] or configuration as code scripts [1] [3].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3194760.3194769", "abstract": "Configuration as code (CaC) tools, such as Ansible and Puppet, help software teams to implement continuous deployment and deploy software changes rapidly. CaC tools are growing in popularity, yet what challenges programmers encounter about CaC tools, have not been characterized. A systematic investigation on what questions are asked by programmers, can help us identify potential technical challenges about CaC, and can aid in successful use of CaC tools. The goal of this paper is to help current ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+questions+do+programmers+ask+about+configuration+as+code%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "P. Labs, <em>Puppet Documentation</em>, 2018,  [online]  Available: https://docs.puppet.com/.", "title": "Puppet Documentation", "context": [{"sec": "sec1", "text": " Commercial IaC tool vendors, such as Chef 11https://www.chef.io/chef/ and Puppet [4], provide programming syntax and libraries so that programmers can specify configuration and dependency information as scripts.", "part": "1"}, {"sec": "sec2a", "text": "Typical entities of Puppet include manifests [4].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Puppet+Documentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "\"Nyse and ice: Compliance devops and efficient growth with puppet enterprise\", <em>Puppet Tech. Rep.</em>, April 2018,  [online]  Available: https://puppet.com/resources/case-study/nyse-and-ice.", "title": "Nyse and ice: Compliance, devops and efficient growth with puppet enterprise", "context": [{"sec": "sec1", "text": " For example, ICE, which runs millions of financial transactions daily44https://www.theice.com/publicdocs/ICE_at_a_glance.pdf, maintains 75% of its 20,000 servers using IaC scripts [5].", "part": "1"}, {"sec": "sec1", "text": " The use of IaC scripts has helped ICE decrease the time needed to provision development environments from 1~2 days to 21 minutes [5].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Nyse+and+ice%3A+Compliance%2C+devops+and+efficient+growth+with+puppet+enterprise&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>CWE-Common Weakness Enumeration</em>, 2018,  [online]  Available: https://cwe.mitre.org/index.html.", "title": "CWE-Common Weakness Enumeration", "context": [{"sec": "sec1", "text": " Hard-coded passwords in software artifacts is considered as a software security weakness (\u2018CWE-798: Use of Hard-coded Credentials\u2019) by Common Weakness Enumerator (CWE) [6].", "part": "1"}, {"sec": "sec1", "text": " According to CWE [6], \u201cIf hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question\u201d.", "part": "1"}, {"sec": "sec3a", "text": " Next, we map each identified smell to a possible security weakness defined by CWE [6].", "part": "1"}, {"sec": "sec3a", "text": " We select the CWE to map each smell to a security weakness because CWE is a list of common software security weaknesses developed by the security community [6].", "part": "1"}, {"sec": "sec3a", "text": " Upon derivation we observe \u2018Hard-coded secret\u2019 to be related to \u2018CWE-798: Use of Hard-coded Credentials\u2019 and \u2018CWE-259: Use of Hard-coded Password\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " The smell is related with \u2018CWE-250: Execution with Unnecessary Privileges\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " The smell is similar to the weakness \u2018CWE-258: Empty Password in Configuration File\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " Relevant weaknesses to the smell are \u2018CWE-798: Use of Hard-coded Credentials\u2019 and \u2018CWE-259: Use of Hard-coded Password\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " This smell is related to improper access control as stated in the weakness \u2018CWE-284: Improper Access Control\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " The smell is related to \u2018CWE-546: Suspicious Comment\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " This security smell is related to \u2018CWE-319: Cleartext Transmission of Sensitive Information\u2019 [6].", "part": "1"}, {"sec": "sec3b", "text": " This smell is related to \u2018CWE-327: Use of a Broken or Risky Cryptographic Algorithm\u2019 and \u2018CWE-326: Inadequate Encryption Strength\u2019 [6].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=CWE-Common+Weakness+Enumeration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C. Wohlin, P. Runeson, M. Hst, M. C. Ohlsson, B. Regnell, A. Wessln, Experimentation in Software Engineering, Springer Publishing Company, 2012.", "title": "Experimentation in Software Engineering", "context": [{"sec": "sec1", "text": " We apply qualitative analysis [7] on 1,726 scripts to determine security smells.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-29044-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Experimentation+in+Software+Engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "Y. Jiang, B. Adams, \"Co-evolution of infrastructure and source code: An empirical study\", <em>Proceedings of the 12th Working Conference on Mining Software Repositories ser. MSR'15</em>, pp. 45-55, 2015.", "title": "Co-evolution of infrastructure and source code: An empirical study", "context": [{"sec": "sec2a", "text": " Companies widely use commercial tools such as Puppet, to implement the practice of IaC [1] [8] [9].", "part": "1"}, {"sec": "sec3a", "text": " We use Puppet scripts to construct our dataset because Puppet is considered as one of the most popular tools for configuration management [8] [9], and has been used by companies since 2005 [19].", "part": "1"}, {"sec": "sec5b", "text": " Jiang and Adams [8] reported for OSS repositories, which are used in production, IaC scripts co-exist with other types of files, such as Makefiles.", "part": "1"}], "links": {"documentLink": "/document/7180066", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180066", "abstract": "Infrastructure-as-code automates the process of configuring and setting up the environment (e.g., servers, VMs and databases) in which a software system will be tested and/or deployed, through textual specification files in a language like Puppet or Chef. Since the environment is instantiated automatically by the infrastructure languages&#39; tools, no manual intervention is necessary apart from maintaining the infrastructure specification files. The amount of work involved with such maintenance, as...", "pdfSize": "1454KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Co-evolution+of+infrastructure+and+source+code%3A+An+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "R. Shambaugh, A. Weiss, A. Guha, \"Rehearsal: A configuration verification tool for puppet\", <em>SIGPLAN Not.</em>, vol. 51, no. 6, pp. 416-430, Jun. 2016.", "title": "Rehearsal: A configuration verification tool for puppet", "context": [{"sec": "sec2a", "text": " Companies widely use commercial tools such as Puppet, to implement the practice of IaC [1] [8] [9].", "part": "1"}, {"sec": "sec3a", "text": " We use Puppet scripts to construct our dataset because Puppet is considered as one of the most popular tools for configuration management [8] [9], and has been used by companies since 2005 [19].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2980983.2908083", "abstract": "Large-scale data centers and cloud computing have turned system configuration into a challenging problem. Several widely-publicized outages have been blamed not on software bugs, but on configuration bugs. To cope, thousands of organizations use system configuration languages to manage their computing infrastructure. Of these, Puppet is the most widely used with thousands of paying customers and many more open-source users. The heart of Puppet is a domain-specific language that describes the sta...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rehearsal%3A+A+configuration+verification+tool+for+puppet&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "P. Labs, \"Borsa istanbul: Improving efficiency and reducing costs to manage a growing infrastructure\", <em>Puppet Tech. Rep.</em>, July 2018,  [online]  Available: https://puppet.com/resources/case-studyiborsa-istanbul.", "title": "Borsa istanbul: Improving efficiency and reducing costs to manage a growing infrastructure", "context": [{"sec": "sec2a", "text": " For example, using IaC scripts application deployment time for Borsa Istanbul, Turkey's stock exchange, reduced from ~10 days to an hour [10].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Borsa+istanbul%3A+Improving+efficiency+and+reducing+costs+to+manage+a+growing+infrastructure&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "\"Ambit energy's competitive advantage? it's really a devops software company\", <em>Puppet Tech. Rep.</em>, April 2018,  [online]  Available: https://puppet.com/resources/case-study/ambit-energy.", "title": "Ambit energy's competitive advantage? it's really a devops software company", "context": [{"sec": "sec2a", "text": " With IaC scripts Ambit Energy increased their deployment frequency by a factor of 1,200 [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ambit+energy%27s+competitive+advantage%3F+it%27s+really+a+devops+software+company&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "J. Schwarz, <em>Code Smell Detection in Infrastructure as Code</em>, 2017,  [online]  Available: https://www.swc.rwth-aachen.de/thesis/code-smell-detection-infrastructure-code/.", "title": "Code Smell Detection in Infrastructure as Code", "context": [{"sec": "sec2b", "text": " For example, Sharma et al. [2], Schwarz [12], and Bent et al. [13], in separate studies investigated code maintainability aspects of Chef and Puppet scripts.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+Smell+Detection+in+Infrastructure+as+Code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "E. van der Bent, J. Hage, J. Visser, G. Gousios, \"How good is your puppet? an empirically defined and validated quality model for puppet\", <em>2018 IEEE 25th International Conference on Software Analysis Evolution and Reengineering (SANER)</em>, pp. 164-174, March 2018.", "title": "How good is your puppet? an empirically defined and validated quality model for puppet", "context": [{"sec": "sec2b", "text": " [13], in separate studies investigated code maintainability aspects of Chef and Puppet scripts.", "part": "1"}], "links": {"documentLink": "/document/8330206", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8330206", "abstract": "Puppet is a declarative language for configuration management that has rapidly gained popularity in recent years. Numerous organizations now rely on Puppet code for deploying their software systems onto cloud infrastructures. In this paper we provide a definition of code quality for Puppet code and an automated technique for measuring and rating Puppet code quality. To this end, we first explore the notion of code quality as it applies to Puppet code by performing a survey among Puppet developer...", "pdfSize": "520KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+good+is+your+puppet%3F+an+empirically+defined+and+validated+quality+model+for+puppet&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "A. Rahman, L. Williams, \"Characterizing defective configuration scripts used for continuous deployment\", <em>2018 IEEE 11th International Conference on Software Testing Verification and Validation (ICST)</em>, pp. 34-45, April 2018.", "title": "Characterizing defective configuration scripts used for continuous deployment", "context": [{"sec": "sec2b", "text": " Rahman and Williams [14] characterized defective IaC scripts using text mining and created prediction models using text feature metrics.", "part": "1"}, {"sec": "sec5c1", "text": "Proportion of Scripts (Script%): Similar to prior work in defect analysis [14] [47], we use the metric \u2018Proportion of Scripts\u2019 to quantify how many scripts have at least one security smell.", "part": "1"}], "links": {"documentLink": "/document/8367034", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8367034", "abstract": "In software engineering, validation and verification (V&V) resources are limited and characterization of defective software source files can help in efficiently allocating V&V resources. Similar to software source files, defects occur in the scripts used to automatically manage configurations and software deployment infrastructure, often known as infrastructure as code (IaC) scripts. Defects in IaC scripts can have dire consequences, for example, creating large-scale system outages. Identifying ...", "pdfSize": "372KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+defective+configuration+scripts+used+for+continuous+deployment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "A. Rahman, A. Partho, D. Meder, L. Williams, \"Which factors influence practitioners' usage of build automation tools?\", <em>Proceedings of the 3rd International Workshop on Rapid Continuous Software Engineering ser. RCoSE'17</em>, pp. 20-26, 2017.", "title": "Which factors influence practitioners' usage of build automation tools?", "context": [{"sec": "sec2b", "text": " [15] surveyed practitioners to investigate which factors influence usage of IaC tools.", "part": "1"}], "links": {"documentLink": "/document/7958397", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7958397", "abstract": "Even though build automation tools help to reduce errors and rapid releases of software changes, use of build automation tools is not widespread amongst software practitioners. Software practitioners perceive build automation tools as complex, which can hinder the adoption of these tools. How well founded such perception is, can be determined by systematic exploration of adoption factors that influence usage of build automation tools. The goal of this paper is to aid software practitioners in in...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Which+factors+influence+practitioners%27+usage+of+build+automation+tools%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "A. Rahman, R. Mahdavi-Hezaveh, L. Williams, \"A systematic mapping study of infrastructure as code research\", <em>Information and Software Technology</em>, 2018,  [online]  Available: http://www.sciencedirect.com/science/article/pii/S0950584918302507.", "title": "A systematic mapping study of infrastructure as code research", "context": [{"sec": "sec2b", "text": " [16] conducted a systematic mapping study with 32 IaC-related publications and observed lack in security-related research in the domain of IaC.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+mapping+study+of+infrastructure+as+code+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Fowler, K. Beck, Refactoring: improving the design of existing code, Addison-Wesley Professional, 1999.", "title": "Refactoring: improving the design of existing code", "context": [{"sec": "sec3", "text": "A code smell is a recurrent coding pattern that is indicative of potential maintenance problems [17].", "part": "1"}, {"sec": "sec3", "text": " A code smell may not always have bad consequences, but still deserves attention, as a code smell may be an indicator of a problem [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Refactoring%3A+improving+the+design+of+existing+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>Csrc-glossary-vulnerability</em>, 2018,  [online]  Available: https://csrc.nist.gov/Glossary/?term=2436.", "title": "Csrc-glossary-vulnerability", "context": [{"sec": "sec3", "text": " Security smells are different from vulnerabilities, because a vulnerability is a weakness in software, which upon exploitation results in a negative impact [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Csrc-glossary-vulnerability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J. T. McCune, Jeffrey, Pro Puppet, Apress, 2011,  [online]  Available: https://www.springer.com/gpibook/9781430230571.", "title": "Pro Puppet", "context": [{"sec": "sec3a", "text": " We use Puppet scripts to construct our dataset because Puppet is considered as one of the most popular tools for configuration management [8] [9], and has been used by companies since 2005 [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pro+Puppet&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J. Saldana, The coding manual for qualitative researchers, Sage, 2015.", "title": "The coding manual for qualitative researchers", "context": [{"sec": "sec3a", "text": "We first apply a qualitative analysis technique called descriptive coding [20] on 1,726 Puppet scripts to identify security smells.", "part": "1"}, {"sec": "sec4b", "text": "We construct the oracle dataset by applying closed coding [20], where a rater identifies a pre-determined pattern.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+coding+manual+for+qualitative+researchers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>Security and privacy controls for federal information systems and organizations</em>, 2014,  [online]  Available: https://www.nist.gov/publications/security-and-privacy-controls-federal-information-systems-and-organizations-including-0.", "title": "Security and privacy controls for federal information systems and organizations", "context": [{"sec": "sec3b", "text": " The smell can violate the \u2018principle of least privilege\u2019 property [21], which recommends practitioners to design and implement a system in a manner so that by default the least amount of access necessary is provided to any entity.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Security+and+privacy+controls+for+federal+information+systems+and+organizations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "T. Ylonen, C. Lonvick, The secure shell (ssh) protocol architecture, 2006.", "title": "The secure shell (ssh) protocol architecture", "context": [{"sec": "sec3b", "text": " In SSH key-based authentication, instead of passwords, public and private keys can be used [22].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.17487/rfc4251", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+secure+shell+%28ssh%29+protocol+architecture&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "P. Mutaf, \"Defending against a denial-of-service attack on tcp\", <em>Recent Advances in Intrusion Detection</em>, 1999.", "title": "Defending against a denial-of-service attack on tcp", "context": [{"sec": "sec3b", "text": " Binding to the address 0.0.0.0 may cause security concerns as this address can allow connections from every possible network [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Defending+against+a+denial-of-service+attack+on+tcp&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "M.-A. Storey, J. Ryall, R. I. Bull, D. Myers, J. Singer, \"Todo or to bug: Exploring how task annotations play a role in the work practices of software developers\", <em>Proceedings of the 30th International Conference on Software Engineering ser. ICSE'08</em>, pp. 251-260, 2008.", "title": "Todo or to bug: Exploring how task annotations play a role in the work practices of software developers", "context": [{"sec": "sec3b", "text": " Keywords such as \u2018TODO\u2019 and \u2018FIXME\u2019 in comments are used to specify an edge case or a problem [24].", "part": "1"}, {"sec": "sec7a", "text": "We acknowledge that in OSS development, programmers may be introducing suspicious comments to facilitate collaborative development and to provide clues on why the corresponding code changes are made [24].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368123", "abstract": "Software development is a highly collaborative activity that requires teams of developers to continually manage and coordinate their programming tasks. In this paper, we describe an empirical study that explored how task annotations embedded within the source code play a role in how software developers manage personal and team tasks. We present findings gathered by combining results from a survey of professional software developers, an analysis of code from open source projects, and interviews w...", "pdfSize": "263KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Todo+or+to+bug%3A+Exploring+how+task+annotations+play+a+role+in+the+work+practices+of+software+developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "E. Rescorla, Http over tls, 2000.", "title": "Http over tls", "context": [{"sec": "sec3b", "text": " Such use makes the communication between two entities less secure, as without TLS, use of HTTP is susceptible to man-in-the-middle attacks [25].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.17487/rfc2818", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Http+over+tls&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "\"skywiper (a.k.a. flame a.k.a. flamer): A complex malware for targeted attacks\", <em>Laboratory of Cryptography and System Security Budapest Hungary Tech. Rep.</em>, May 2012,  [online]  Available: http://www.crysys.hu/skywiper/skywiper.pdf.", "title": "skywiper (a.k.a. flame a.k.a. flamer): A complex malware for targeted attacks", "context": [{"sec": "sec3b", "text": " MD5 suffers from security problems, as demonstrated by the Flame malware in 2012 [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=skywiper+%28a.k.a.+flame+a.k.a.+flamer%29%3A+A+complex+malware+for+targeted+attacks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "B. den Boer, A. Bosselaers, \"Collisions for the compression function of md5\", <em>Workshop on the Theory and Application of Cryptographic Techniques on Advances in Cryptology ser. EUROCRYPT'93</em>, pp. 293-304, 1994.", "title": "Collisions for the compression function of md5", "context": [{"sec": "sec3b", "text": " MD5 is susceptible to collision attacks [27] and modular differential attacks [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-48285-7_26", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Collisions+for+the+compression+function+of+md5&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "X. Wang, H. Yu, \"How to break md5 and other hash functions\", <em>Proceedings of the 24th Annual International Conference on Theory and Applications of Cryptographic Techniques ser. EUROCRYPT'05</em>, pp. 19-35, 2005.", "title": "How to break md5 and other hash functions", "context": [{"sec": "sec3b", "text": " MD5 is susceptible to collision attacks [27] and modular differential attacks [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/11426639_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+break+md5+and+other+hash+functions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "M. Ghafari, P. Gadient, O. Nierstrasz, \"Security smells in android\", <em>2017 IEEE 17th International Working Conference on Source Code Analysis and Manipulation (SCAM)</em>, pp. 121-130, Sept 2017.", "title": "Security smells in android", "context": [{"sec": "sec3b", "text": " [29] identified hard-coded secrets and use of weak cryptography algorithms as security smells for Android applications.", "part": "1"}], "links": {"documentLink": "/document/8090145", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8090145", "abstract": "The ubiquity of smartphones, and their very broad capabilities and usage, make the security of these devices tremendously important. Unfortunately, despite all progress in security and privacy mechanisms, vulnerabilities continue to proliferate.,,Research has shown that many vulnerabilities are due to insecure programming practices. However, each study has often dealt with a specific issue, making the results less actionable for practitioners. To promote secure programming practices, we have rev...", "pdfSize": "1361KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Security+smells+in+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "M. Egele, D. Brumley, Y. Fratantonio, C. Kruegel, \"An empirical study of cryptographic misuse in android applications\", <em>Proceedings of the 2013 ACM SIGSAC Conference on Computer and Communications Security ser. CCS'13</em>, pp. 73-84, 2013.", "title": "An empirical study of cryptographic misuse in android applications", "context": [{"sec": "sec3b", "text": " [30] and Kruger et al. [31] in separate studies analyzed use of weak or wrong cryptography algorithms.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516693", "abstract": "Developers use cryptographic APIs in Android with the intent of securing data such as passwords and personal information on mobile devices. In this paper, we ask whether developers use the cryptographic APIs in a fashion that provides typical cryptographic notions of security, e.g., IND-CPA security. We develop program analysis techniques to automatically check programs on the Google Play marketplace, and find that 10.327 out of 11,748 applications that use cryptographic APIs -- 88% overall -- m...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+cryptographic+misuse+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "S. Kruger, J. Spath, K. Ali, E. Bodden, M. Mezini, \"Crysl: Validating correct usage of cryptographic apis\", <em>CoRR</em>, vol. abs/1710.00564, 2017.", "title": "Crysl: Validating correct usage of cryptographic apis", "context": [{"sec": "sec3b", "text": " [31] in separate studies analyzed use of weak or wrong cryptography algorithms.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Crysl%3A+Validating+correct+usage+of+cryptographic+apis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "J. Sliwerski, T. Zimmermann, A. Zeller, \"When do changes induce fixes?\", <em>Proceedings of the 2005 International Workshop on Mining Software Repositories ser. MSR'05</em>, pp. 1-5, 2005.", "title": "When do changes induce fixes?", "context": [], "links": {"acmLink": "https://doi.org/10.1145/1083142.1083147", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+do+changes+induce+fixes%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "I. K. Ratol, M. P. Robillard, \"Detecting fragile comments\", <em>Proceedings of the 32Nd IEEE/ACM International Conference on Automated Software Engineering ser. ASE 2017</em>, pp. 112-122, 2017.", "title": "Detecting fragile comments", "context": [{"sec": "sec4a", "text": "We take motivation from prior work [33] [34] and use a rule-based approach to detect security smells.", "part": "1"}, {"sec": "sec4a", "text": " We use rules because (i) unlike keyword-based searching, rules are less susceptible to false positives [33] [34]; and (ii) rules can be applicable for IaC tools irrespective of their syntax.", "part": "1"}], "links": {"documentLink": "/document/8115624", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115624", "abstract": "Refactoring is a common software development practice and many simple refactorings can be performed automatically by tools. Identifier renaming is a widely performed refactoring activity. With tool support, rename refactorings can rely on the program structure to ensure correctness of the code transformation. Unfortunately, the textual references to the renamed identifier present in the unstructured comment text cannot be formally detected through the syntax of the language, and are thus fragile...", "pdfSize": "151KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+fragile+comments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "L. Tan, D. Yuan, G. Krishna, Y. Zhou, \"/*icomment: Bugs or bad comments?*/\", <em>Proceedings of Twenty-first ACM SIGOPS Symposium on Operating Systems Principles ser. SOSP'07</em>, pp. 145-158, 2007.", "title": "/*icomment: Bugs or bad comments?*/", "context": [{"sec": "sec4a", "text": "We take motivation from prior work [33] [34] and use a rule-based approach to detect security smells.", "part": "1"}, {"sec": "sec4a", "text": " We use rules because (i) unlike keyword-based searching, rules are less susceptible to false positives [33] [34]; and (ii) rules can be applicable for IaC tools irrespective of their syntax.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1294261.1294276", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=%2F*icomment%3A+Bugs+or+bad+comments%3F*%2F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "A. Bosu, J. C. Carver, M. Hafiz, P. Hilley, D. Janni, \"Identifying the characteristics of vulnerable code changes: An empirical study\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2014</em>, pp. 257-268, 2014.", "title": "Identifying the characteristics of vulnerable code changes: An empirical study", "context": [{"sec": "sec4a", "text": " We apply a string pattern-based matching strategy similar to prior work [35] [36], where we check if the value satisfies the necessary condition.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635880", "abstract": "To focus the efforts of security experts, the goals of this empirical study are to analyze which security vulnerabilities can be discovered by code review, identify characteristics of vulnerable code changes, and identify characteristics of developers likely to introduce vulnerabilities. Using a three-stage manual and automated process, we analyzed 267,046 code review requests from 10 open source projects and identified 413 Vulnerable Code Changes (VCC). Some key results include: (1) code review...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Identifying+the+characteristics+of+vulnerable+code+changes%3A+An+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "S. Bugiel, S. Nurnberger, T. Poppelmann, A.-R. Sadeghi, T. Schneider, \"Amazon IA: When elasticity snaps back\", <em>Proceedings of the 18th ACM Conference on Computer and Communications Security ser. CCS'11</em>, pp. 389-400, 2011.", "title": "Amazon IA: When elasticity snaps back", "context": [{"sec": "sec4a", "text": " We apply a string pattern-based matching strategy similar to prior work [35] [36], where we check if the value satisfies the necessary condition.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Amazon+IA%3A+When+elasticity+snaps+back&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "B. Chen, Z. M. Jiang, \"Characterizing and detecting anti-patterns in the logging code\", <em>2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)</em>, pp. 71-81, May 2017.", "title": "Characterizing and detecting anti-patterns in the logging code", "context": [{"sec": "sec4b", "text": " [37].", "part": "1"}], "links": {"documentLink": "/document/7985651", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985651", "abstract": "Snippets of logging code are output statements (e.g., LOG.info or System.out.println) that developers insert into a software system. Although more logging code can provide more execution context of the system&#39;s behavior during runtime, it is undesirable to instrument the system with too much logging code due to maintenance overhead. Furthermore, excessive logging may cause unexpected side-effects like performance slow-down or high disk I/O bandwidth. Recent studies show that there are no well-de...", "pdfSize": "1276KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+and+detecting+anti-patterns+in+the+logging+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "J. R. Landis, G. G. Koch, \"The measurement of observer agreement for categorical data\", <em>Biometrics</em>, vol. 33, no. 1, pp. 159-174, 1977.", "title": "The measurement of observer agreement for categorical data", "context": [{"sec": "sec4b", "text": " According to Landis and Koch's interpretation [38], the reported agreement is \u2018fair\u2019.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2307/2529310", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+measurement+of+observer+agreement+for+categorical+data&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "A. Rahman, C. Parnin, L. Williams, <em>The Seven Sins: Security Smells in Infrastructure as Code Scripts</em>, 2019,  [online]  Available: https://doi.org/10.6084/m9.figshare.6943316.", "title": "The Seven Sins: Security Smells in Infrastructure as Code Scripts", "context": [{"sec": "sec4b", "text": "The source code of SLIC and all constructed datasets are available online [39].", "part": "1"}], "links": {"documentLink": "/document/8812041", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8812041", "abstract": "Practitioners use infrastructure as code (IaC) scripts to provision servers and development environments. While developing IaC scripts, practitioners may inadvertently introduce security smells. Security smells are recurring coding patterns that are indicative of security weakness and can potentially lead to security breaches. The goal of this paper is to help practitioners avoid insecure coding practices while developing infrastructure as code (IaC) scripts through an empirical study of securit...", "pdfSize": "778KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Seven+Sins%3A+Security+Smells+in+Infrastructure+as+Code+Scripts&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "R. Krishna, A. Agrawal, A. Rahman, A. Sobran, T. Menzies, \"What is the connection between issues bugs and enhancements?: Lessons learned from 800+ software projects\", <em>Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice ser. ICSE-SEIP'18</em>, pp. 306-315, 2018.", "title": "What is the connection between issues, bugs, and enhancements?: Lessons learned from 800+ software projects", "context": [{"sec": "sec5b", "text": " To assess the prevalence of the identified smells and increase generalizability of our findings, we include repositories from Github, as companies tend to host their popular OSS projects on GitHub [40] [41].", "part": "1"}, {"sec": "sec5b", "text": " Previously, researchers have used the cutoff of at least nine contributors [40] [41] [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183519.3183548", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+is+the+connection+between+issues%2C+bugs%2C+and+enhancements%3F%3A+Lessons+learned+from+800%2B+software+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "A. Agrawal, A. Rahman, R. Krishna, A. Sobran, T. Menzies, \"We don't need another hero?: The impact of \u201cheroes\u201d on software development\", <em>Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice ser. ICSE-SEIP'18</em>, pp. 245-253, 2018.", "title": "We don't need another hero?: The impact of \u201cheroes\u201d on software development", "context": [{"sec": "sec5b", "text": " To assess the prevalence of the identified smells and increase generalizability of our findings, we include repositories from Github, as companies tend to host their popular OSS projects on GitHub [40] [41].", "part": "1"}, {"sec": "sec5b", "text": " Previously, researchers have used the cutoff of at least nine contributors [40] [41] [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3183519.3183549", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=We+don%27t+need+another+hero%3F%3A+The+impact+of+%E2%80%9Cheroes%E2%80%9D+on+software+development&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "N. Munaiah, S. Kroh, C. Cabrey, M. Nagappan, \"Curating github for engineered software projects\", <em>Empirical Software Engineering</em>, pp. 1-35, 2017.", "title": "Curating github for engineered software projects", "context": [{"sec": "sec5b", "text": "As advocated by prior research [42], OSS repositories need to be curated.", "part": "1"}, {"sec": "sec5b", "text": " [42] used the threshold of at least two commits per month to determine which repositories have enough software development activity.", "part": "1"}, {"sec": "sec5b", "text": " [42] used the threshold of at least two commits per month to determine which repositories have enough software development activity.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-017-9512-6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Curating+github+for+engineered+software+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "A. Rahman, A. Agrawal, R. Krishna, A. Sobran, \"Characterizing the influence of continuous integration: Empirical results from 250+ open source and proprietary projects\", <em>Proceedings of the 4th ACM SIGSOFT International Workshop on Software Analytics ser. SWAN 2018</em>, pp. 8-14, 2018.", "title": "Characterizing the influence of continuous integration: Empirical results from 250+ open source and proprietary projects", "context": [{"sec": "sec5b", "text": " Previously, researchers have used the cutoff of at least nine contributors [40] [41] [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3278142.3278149", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+the+influence+of+continuous+integration%3A+Empirical+results+from+250%2B+open+source+and+proprietary+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "N. Nagappan, T. Ball, \"Static analysis tools as early indicators of pre-release defect density\", <em>Proceedings of the 27th International Conference on Software Engineering ser. ICSE'05</em>, pp. 580-586, 2005.", "title": "Static analysis tools as early indicators of pre-release defect density", "context": [{"sec": "sec5c1", "text": "Smell Density: Similar to prior research that have used defect density [44] [45] and vulnerability density [46], we use smell density to measure the frequency of a security smell \\$x\\$, for every 1000 lines of code (LOC).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+analysis+tools+as+early+indicators+of+pre-release+defect+density&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "J. C. Kelly, J. S. Sherif, J. Hops, \"An analysis of defect densities found during software inspections\", <em>Journal of Systems and Software</em>, vol. 17, no. 2, pp. 111-117, 1992.", "title": "An analysis of defect densities found during software inspections", "context": [{"sec": "sec5c1", "text": "Smell Density: Similar to prior research that have used defect density [44] [45] and vulnerability density [46], we use smell density to measure the frequency of a security smell \\$x\\$, for every 1000 lines of code (LOC).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0164-1212(92)90089-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+analysis+of+defect+densities+found+during+software+inspections&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "O. H. Alhazmi, Y. K. Malaiya, \"Quantitative vulnerability assessment of systems software\", <em>Annual Reliability and Maintainability Symposium 2005. Proceedings.</em>, pp. 615-620, Jan 2005.", "title": "Quantitative vulnerability assessment of systems software", "context": [{"sec": "sec5c1", "text": "Smell Density: Similar to prior research that have used defect density [44] [45] and vulnerability density [46], we use smell density to measure the frequency of a security smell \\$x\\$, for every 1000 lines of code (LOC).", "part": "1"}], "links": {"documentLink": "/document/1408432", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1408432", "abstract": "This paper addresses feasibility of vulnerabilities present in the software. Vulnerabilities present in such software represent significant security risks. For Windows 98 and Windows NT 4.0, we present plots for cumulative numbers of vulnerabilities found. A time-based model for the total vulnerabilities discovered is proposed and is fitted to the data for two operating systems. We introduce a measure termed equivalent effort and propose an alternative model which is analogous to the software re...", "pdfSize": "724KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quantitative+vulnerability+assessment+of+systems+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "T. Menzies, J. Greenwald, A. Frank, \"Data mining static code attributes to learn defect predictors\", <em>IEEE Transactions on Software Engineering</em>, vol. 33, no. 1, pp. 2-13, Jan 2007.", "title": "Data mining static code attributes to learn defect predictors", "context": [{"sec": "sec5c1", "text": "Proportion of Scripts (Script%): Similar to prior work in defect analysis [14] [47], we use the metric \u2018Proportion of Scripts\u2019 to quantify how many scripts have at least one security smell.", "part": "1"}], "links": {"documentLink": "/document/4027145", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4027145", "abstract": "The value of using static code attributes to learn defect predictors has been widely debated. Prior work has explored issues like the merits of &#34;McCabes versus Halstead versus lines of code counts&#34; for generating defect predictors. We show here that such debates are irrelevant since how the attributes are used to build predictors is much more important than which particular attributes are used. Also, contrary to prior pessimism, we show that such defect predictors are demonstrably useful and, on...", "pdfSize": "2114KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data+mining+static+code+attributes+to+learn+defect+predictors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "T. Hall, M. Zhang, D. Bowes, Y. Sun, \"Some code smells have a significant but small effect on faults\", <em>ACM Trans. Softw. Eng. Methodol.</em>, vol. 23, no. 4, pp. 33:1-33:39, Sep. 2014.", "title": "Some code smells have a significant but small effect on faults", "context": [{"sec": "sec6c", "text": " Possible explanations for disagreements can also be attributed to perception of practitioners: smells in code have subjective interpretation [48], and programmers do not uniformly agree with all smell occurrences [49], [50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2629648", "abstract": "We investigate the relationship between faults and five of Fowler et al.&#39;s least-studied smells in code: Data Clumps, Switch Statements, Speculative Generality, Message Chains, and Middle Man. We developed a tool to detect these five smells in three open-source systems: Eclipse, ArgoUML, and Apache Commons. We collected fault data from the change and fault repositories of each system. We built Negative Binomial regression models to analyse the relationships between smells and faults and report t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Some+code+smells+have+a+significant+but+small+effect+on+faults&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "M. V. Mantyla, C. Lassenius, \"Subjective evaluation of software evolvability using code smells: An empirical study\", <em>Empirical Softw. Engg.</em>, vol. 11, no. 3, pp. 395-431, Sep. 2006.", "title": "Subjective evaluation of software evolvability using code smells: An empirical study", "context": [{"sec": "sec6c", "text": " Possible explanations for disagreements can also be attributed to perception of practitioners: smells in code have subjective interpretation [48], and programmers do not uniformly agree with all smell occurrences [49], [50].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-006-9002-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Subjective+evaluation+of+software+evolvability+using+code+smells%3A+An+empirical+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "F. Palomba, G. Bavota, M. D. Penta, R. Oliveto, A. D. Lucia, \"Do they really smell bad? a study on developers' perception of bad code smells\", <em>Proceedings of the 2014 IEEE International Conference on Software Maintenance and Evolution ser. ICSME'14</em>, pp. 101-110, 2014.", "title": "Do they really smell bad? a study on developers' perception of bad code smells", "context": [{"sec": "sec6c", "text": " Possible explanations for disagreements can also be attributed to perception of practitioners: smells in code have subjective interpretation [48], and programmers do not uniformly agree with all smell occurrences [49], [50].", "part": "1"}], "links": {"documentLink": "/document/6976076", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6976076", "abstract": "In the last decade several catalogues have been defined to characterize bad code smells, i.e., symptoms of poor design and implementation choices. On top of such catalogues, researchers have defined methods and tools to automatically detect and/or remove bad smells. Nevertheless, there is an ongoing debate regarding the extent to which developers perceive bad smells as serious design problems. Indeed, there seems to be a gap between theory and practice, i.e., what is believed to be a problem (th...", "pdfSize": "426KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+they+really+smell+bad%3F+a+study+on+developers%27+perception+of+bad+code+smells&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "Y. Acar, M. Backes, S. Fahl, S. Garfinkel, D. Kim, M. L. Mazurek, C. Stransky, \"Comparing the usability of cryptographic apis\", <em>2017 IEEE Symposium on Security and Privacy (SP)</em>, pp. 154-171, May 2017.", "title": "Comparing the usability of cryptographic apis", "context": [{"sec": "sec6c", "text": " Furthermore, researchers [51] have observed programmers' bias to perceive their code snippets as secure, even if the code snippets are insecure.", "part": "1"}], "links": {"documentLink": "/document/7958576", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7958576", "abstract": "Potentially dangerous cryptography errors are well-documented in many applications. Conventional wisdom suggests that many of these errors are caused by cryptographic Application Programming Interfaces (APIs) that are too complicated, have insecure defaults, or are poorly documented. To address this problem, researchers have created several cryptographic libraries that they claim are more usable, however, none of these libraries have been empirically evaluated for their ability to promote more s...", "pdfSize": "1285KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Comparing+the+usability+of+cryptographic+apis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "J. H. Saltzer, M. D. Schroeder, \"The protection of information in computer systems\", <em>Proceedings of the IEEE</em>, vol. 63, no. 9, pp. 1278-1308, Sept 1975.", "title": "The protection of information in computer systems", "context": [{"sec": "sec7a", "text": " Recommendations from Saltzer and Schroeder [52] may be helpful in this regard.", "part": "1"}], "links": {"documentLink": "/document/1451869", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1451869", "abstract": "This tutorial paper explores the mechanics of protecting computer-stored information from unauthorized use or modification. It concentrates on those architectural structures-whether hardware or software-that are necessary to support information protection. The paper develops in three main sections. Section I describes desired functions, design principles, and examples of elementary protection and authentication mechanisms. Any reader familiar with computers should find the first section to be re...", "pdfSize": "3829KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+protection+of+information+in+computer+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "E. Barker, \"Guideline for using cryptographic standards in the federal government: Cryptographic mechanisms\", <em>National Institute of Standards and Technology Gaithersburg Maryland Tech. Rep.</em>, August 2016,  [online]  Available: https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-175b.pdf.", "title": "Guideline for using cryptographic standards in the federal government: Cryptographic mechanisms", "context": [{"sec": "sec7a", "text": "We advise programmers to use cryptography algorithms recommended by the National Institute of Standards and Technology [53] to mitigate this smell.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.6028/NIST.SP.800-175B", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guideline+for+using+cryptographic+standards+in+the+federal+government%3A+Cryptographic+mechanisms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "Y. Acar, C. Stransky, D. Wermke, C. Weir, M. L. Mazurek, S. Fahl, \"Developers need support too: A survey of security advice for software developers\", <em>2017 IEEE Cybersecurity Development (SecDev)</em>, pp. 22-26, Sept 2017.", "title": "Developers need support, too: A survey of security advice for software developers", "context": [{"sec": "sec7b", "text": " [54] into account, and include easy to understand, task-specific examples on how to write IaC scripts in a secure manner.", "part": "1"}], "links": {"documentLink": "/document/8077802", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8077802", "abstract": "Increasingly developers are becoming aware of the importance of software security, as frequent high-profile security incidents emphasize the need for secure code. Faced with this new problem, most developers will use their normal approach: web search. But are the resulting web resources useful and effective at promoting security in practice? Recent research has identified security problems arising from Q&A resources that help with specific secure-programming problems, but the web also contains m...", "pdfSize": "228KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Developers+need+support%2C+too%3A+A+survey+of+security+advice+for+software+developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "T. Zimmermann, N. Nagappan, L. Williams, \"Searching for a needle in a haystack: Predicting security vulnerabilities for windows vista\", <em>2010 Third International Conference on Software Testing Verification and Validation</em>, pp. 421-428, April 2010.", "title": "Searching for a needle in a haystack: Predicting security vulnerabilities for windows vista", "context": [{"sec": "sec7b", "text": " Researchers can also investigate if metric-based prediction techniques proposed in prior research [55] [56] can be used to identify IaC scripts that are more likely to include security smells, which can benefit from more scrutiny.", "part": "1"}], "links": {"documentLink": "/document/5477059", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5477059", "abstract": "Many factors are believed to increase the vulnerability of software system; for example, the more widely deployed or popular is a software system the more likely it is to be attacked. Early identification of defects has been a widely investigated topic in software engineering research. Early identification of software vulnerabilities can help mitigate these attacks to a large degree by focusing better security verification efforts in these components. Predicting vulnerabilities is complicated by...", "pdfSize": "321KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Searching+for+a+needle+in+a+haystack%3A+Predicting+security+vulnerabilities+for+windows+vista&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "A. Rahman, P. Pradhan, A. Partho, L. Williams, \"Predicting android application security and privacy risk with static code metrics\", <em>2017 IEEE/ACM 4th International Conference on Mobile Software Engineering and Systems (MOBILESoft)</em>, pp. 149-153, May 2017.", "title": "Predicting android application security and privacy risk with static code metrics", "context": [{"sec": "sec7b", "text": " Researchers can also investigate if metric-based prediction techniques proposed in prior research [55] [56] can be used to identify IaC scripts that are more likely to include security smells, which can benefit from more scrutiny.", "part": "1"}], "links": {"documentLink": "/document/7972729", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7972729", "abstract": "Android applications pose security and privacy risks for end-users. These risks are often quantified by performing dynamic analysis and permission analysis of the Android applications after release. Prediction of security and privacy risks associated with Android applications at early stages of application development, e.g. when the developer (s) are writing the code of the application, might help Android application developers in releasing applications to end-users that have less security and p...", "pdfSize": "330KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+android+application+security+and+privacy+risk+with+static+code+metrics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812041", "articleId": "8812041", "startPage": "164", "endPage": "175", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 6, "citationCountPatent": 0, "totalDownloads": 184}}
{"title": "IconIntent: Automatic Identification of Sensitive UI Widgets Based on Icon Classification for Android Apps", "authors": [{"name": "Xusheng Xiao", "affiliation": "Case Western Reserve University", "firstName": "Xusheng", "lastName": "Xiao", "id": "37086872571"}, {"name": "Xiaoyin Wang", "affiliation": "The University of Texas at San Antonio", "firstName": "Xiaoyin", "lastName": "Wang", "id": "37311498400"}, {"name": "Zhihao Cao", "affiliation": "Case Western Reserve University", "firstName": "Zhihao", "lastName": "Cao", "id": "37086953014"}, {"name": "Hanlin Wang", "affiliation": "Case Western Reserve University", "firstName": "Hanlin", "lastName": "Wang", "id": "37086950119"}, {"name": "Peng Gao", "affiliation": "Princeton University", "firstName": "Peng", "lastName": "Gao", "id": "37086433148"}], "abstract": "Many mobile applications (i.e., apps) include UI widgets to use or collect users' sensitive data. Thus, to identify suspicious sensitive data usage such as UI-permission mismatch, it is crucial to understand the intentions of UI widgets. However, many UI widgets leverage icons of specific shapes (object icons) and icons embedded with text (text icons) to express their intentions, posing challenges for existing detection techniques that analyze only textual data to identify sensitive UI widgets. In this work, we propose a novel app analysis framework, ICONINTENT, that synergistically combines program analysis and icon classification to identify sensitive UI widgets in Android apps. ICONINTENT automatically associates UI widgets and icons via static analysis on app's UI layout files and code, and then adapts computer vision techniques to classify the associated icons into eight categories of sensitive data. Our evaluations of ICONINTENT on 150 apps from Google Play show that ICONINTENT can detect 248 sensitive UI widgets in 97 apps, achieving a precision of 82.4%. When combined with SUPOR, the state-of-the-art sensitive UI widget identification technique based on text analysis, SUPOR +ICONINTENT can detect 487 sensitive UI widgets (101.2% improvement over SUPOR only), and reduces suspicious permissions to be inspected by 50.7% (129.4% improvement over SUPOR only).", "keywords": [{"type": "IEEE Keywords", "kwd": ["Layout", "Image color analysis", "Optical character recognition software", "Static analysis", "Global Positioning System", "Feature extraction", "Shape"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "computer vision", "graphical user interfaces", "image classification", "mobile computing", "program diagnostics", "text analysis", "user interfaces"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["icon classification", "android apps", "suspicious sensitive data usage", "UI widget identification technique", "sensitive UI widgets", "ICONINTENT", "SUPOR", "suspicious permissions", "Google Play", "mobile applications", "user sensitive data", "textual data", "computer vision techniques"]}, {"type": "Author Keywords ", "kwd": ["Mobile Security", "Program Analysis", "Computer Vision", "Icon Recognition"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00041", "ref": [{"order": "1", "text": "K. W. Miller, J. Voas, G. F. Hurlburt, \"Byod: Security and privacy considerations\", <em>IT Professional</em>, vol. 14, no. 5, pp. 53-55, 2012.", "title": "Byod: Security and privacy considerations", "context": [{"sec": "sec1", "text": "Mobile apps are playing an increasingly important part in our daily life [1], [2].", "part": "1"}], "links": {"documentLink": "/document/6320585", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6320585", "abstract": "Clearly, there are several important advantages for employees and employers when employees bring their own devices to work. But there are also significant concerns about security privacy. Companies and individuals involved, or thinking about getting involved with BYOD should think carefully about the risks as well as the rewards.", "pdfSize": "215KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Byod%3A+Security+and+privacy+considerations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Research: 74 percent using or adopting byod</em>, 2015,  [online]  Available: http://www.zdnet.com/article/research-74-percent-using-or-adopting-byod.", "title": "Research: 74 percent using or adopting byod", "context": [{"sec": "sec1", "text": "Mobile apps are playing an increasingly important part in our daily life [1], [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Research%3A+74+percent+using+or+adopting+byod&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "Y. Zhou, X. Jiang, \"Dissecting android malware: Characterization and evolution\", <em>IEEE Symposium on Security and Privacy (IEEE S & P)</em>, 2012.", "title": "Dissecting android malware: Characterization and evolution", "context": [{"sec": "sec1", "text": " Despite the capabilities to meet users' needs, the increasingly access to users' sensitive data, such as location and finance information [3]\u2013[5], raises privacy concerns.", "part": "1"}], "links": {"documentLink": "/document/6234407", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6234407", "abstract": "The popularity and adoption of smart phones has greatly stimulated the spread of mobile malware, especially on the popular platforms such as Android. In light of their rapid growth, there is a pressing need to develop effective solutions. However, our defense capability is largely constrained by the limited understanding of these emerging mobile malware and the lack of timely access to related samples. In this paper, we focus on the Android platform and aim to systematize or characterize existin...", "pdfSize": "454KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dissecting+android+malware%3A+Characterization+and+evolution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "B. Liu, B. Liu, H. Jin, R. Govindan, \"Medusa: A programming framework for crowd-sensing applications\", <em>International Conference on Mobile Systems Applications and Services (MobiSys)</em>, 2015.", "title": "Medusa: A programming framework for crowd-sensing applications", "context": [{"sec": "sec1", "text": " Despite the capabilities to meet users' needs, the increasingly access to users' sensitive data, such as location and finance information [3]\u2013[4][5], raises privacy concerns.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Medusa%3A+A+programming+framework+for+crowd-sensing+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "S. Rosen, Z. Qian, Z. M. Mao, \"Appprofiler: A flexible method of exposing privacy-related behavior in android applications to end users\", <em>ACM Conference on Data and Application Security and Privacy (CODASPY)</em>, 2013.", "title": "Appprofiler: A flexible method of exposing privacy-related behavior in android applications to end users", "context": [{"sec": "sec1", "text": " Despite the capabilities to meet users' needs, the increasingly access to users' sensitive data, such as location and finance information [3]\u2013[5], raises privacy concerns.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2435349.2435380", "abstract": "Although Android&#39;s permission system is intended to allow users to make informed decisions about their privacy, it is often ineffective at conveying meaningful, useful information on how a user&#39;s privacy might be impacted by using an application. We present an alternate approach to providing users the knowledge needed to make informed decisions about the applications they install. First, we create a knowledge base of mappings between API calls and fine-grained privacy-related behaviors. We then ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Appprofiler%3A+A+flexible+method+of+exposing+privacy-related+behavior+in+android+applications+to+end+users&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "W. Enck, P. Gilbert, B.-G. Chun, L. P. Cox, J. Jung, P. McDaniel, A. N. Sheth, \"TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones\", <em>USENIX Symposium on Operating Systems Design and Implementation (OSDI)</em>, 2010.", "title": "TaintDroid: An Information-Flow Tracking System for Realtime Privacy Monitoring on Smartphones", "context": [{"sec": "sec1", "text": " Prior works on smartphone privacy protection focus on analyzing mobile apps' code to detect information leaks of the sensitive data managed by the framework APIs, such as device identifiers (e.g., IMEI), location, and contact [6]\u2013[8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=TaintDroid%3A+An+Information-Flow+Tracking+System+for+Realtime+Privacy+Monitoring+on+Smartphones&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. Le Traon, D. Octeau, P. McDaniel, \"Flowdroid: Precise context flow field object-sensitive and lifecycle-aware taint analysis for android apps\", <em>ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, 2014.", "title": "Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for android apps", "context": [{"sec": "sec1", "text": " Prior works on smartphone privacy protection focus on analyzing mobile apps' code to detect information leaks of the sensitive data managed by the framework APIs, such as device identifiers (e.g., IMEI), location, and contact [6]\u2013[7][8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Flowdroid%3A+Precise+context%2C+flow%2C+field%2C+object-sensitive+and+lifecycle-aware+taint+analysis+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "L. Lu, Z. Li, Z. Wu, W. Lee, G. Jiang, \"CHEX: Statically vetting android apps for component hijacking vulnerabilities\", <em>the ACM Conference on Computer and Communications Security (CCS)</em>, 2012.", "title": "CHEX: Statically vetting android apps for component hijacking vulnerabilities", "context": [{"sec": "sec1", "text": " Prior works on smartphone privacy protection focus on analyzing mobile apps' code to detect information leaks of the sensitive data managed by the framework APIs, such as device identifiers (e.g., IMEI), location, and contact [6]\u2013[8].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2382196.2382223", "abstract": "An enormous number of apps have been developed for Android in recent years, making it one of the most popular mobile operating systems. However, the quality of the booming apps can be a concern [4]. Poorly engineered apps may contain security vulnerabilities that can severally undermine users&#39; security and privacy. In this paper, we study a general category of vulnerabilities found in Android apps, namely the component hijacking vulnerabilities. Several types of previously reported app vulnerabi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CHEX%3A+Statically+vetting+android+apps+for+component+hijacking+vulnerabilities&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "J. Huang, Z. Li, X. Xiao, Z. Wu, K. Lu, X. Zhang, G. Jiang, \"SUPOR: precise and scalable sensitive user input detection for android apps\", <em>USENIX Security Symposium</em>, 2015.", "title": "SUPOR: precise and scalable sensitive user input detection for android apps", "context": [{"sec": "sec1", "text": "It is crucial to understand the intentions of UI widgets by analyzing apps' UIs, for the app stores to inspect suspicious permissions (i.e., UI-permission mismatches [9]), for lawyers or managers to write more precise privacy policies [10], and for developers to better inform users about sensitive data usages.", "part": "1"}, {"sec": "sec1", "text": " Recent works have made progress in detecting disclosure of sensitive user inputs [9], [11], [12] by analyzing textual data in the UIs.", "part": "1"}, {"sec": "sec2a", "text": " Existing works [9], [11], [12] that analyze texts in the UIs face challenges in identifying this sensitive UI widget, since no sensitive texts can be extracted from the UI.", "part": "1"}, {"sec": "sec3d1", "text": " We choose these eight sensitive user-input categories because the app functionality related to these categories are popular, represent tangible sensitive resources that users can understand, and have significant security and privacy implications [9], [22], [23].", "part": "1"}, {"sec": "sec3d5", "text": " Therefore, keyword matching [9], [11], [12] can be adapted to effectively classify the text icons.", "part": "1"}, {"sec": "sec4a2", "text": " Since apps that have UI widgets to collect sensitive user inputs are not distributed evenly across app categories [9], [11], [12] and we have to manually label all the apps in our test dataset to obtain the ground truth, we choose as our test set the top 150 apps with appearances of sensitive keywords as mentioned in Section III-D1 in their UI layout files.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SUPOR%3A+precise+and+scalable+sensitive+user+input+detection+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "X. Wang, X. Qin, M. B. Hosseini, R. Slavin, T. D. Breaux, J. Niu, \"GUILeak: Tracing privacy policy claims on user input data for android applications\", <em>International Conference on Software Engineering (ICSE)</em>, 2018.", "title": "GUILeak: Tracing privacy policy claims on user input data for android applications", "context": [{"sec": "sec1", "text": "It is crucial to understand the intentions of UI widgets by analyzing apps' UIs, for the app stores to inspect suspicious permissions (i.e., UI-permission mismatches [9]), for lawyers or managers to write more precise privacy policies [10], and for developers to better inform users about sensitive data usages.", "part": "1"}, {"sec": "sec6", "text": " ICONINTENT can be integrated with various privacy analysis tools, such as GUILeak [10] to help developers trace information types mentioned in privacy policies to icons.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180196", "abstract": "The Android mobile platform supports billions of devices across more than 190 countries around the world. This popularity coupled with user data collection by Android apps has made privacy protection a well-known challenge in the Android ecosystem. In practice, app producers provide privacy policies disclosing what information is collected and processed by the app. However, it is difficult to trace such claims to the corresponding app code to verify whether the implementation is consistent with ...", "pdfSize": "640KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=GUILeak%3A+Tracing+privacy+policy+claims+on+user+input+data+for+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "Y. Nan, M. Yang, Z. Yang, S. Zhou, G. Gu, X. Wang, \"UIPicker: User-input privacy identification in mobile applications\", <em>USENIX Security Symposium</em>, 2015.", "title": "UIPicker: User-input privacy identification in mobile applications", "context": [{"sec": "sec1", "text": " Recent works have made progress in detecting disclosure of sensitive user inputs [9], [11], [12] by analyzing textual data in the UIs.", "part": "1"}, {"sec": "sec2a", "text": " Existing works [9], [11], [12] that analyze texts in the UIs face challenges in identifying this sensitive UI widget, since no sensitive texts can be extracted from the UI.", "part": "1"}, {"sec": "sec3d5", "text": " Therefore, keyword matching [9], [11], [12] can be adapted to effectively classify the text icons.", "part": "1"}, {"sec": "sec4a2", "text": " Since apps that have UI widgets to collect sensitive user inputs are not distributed evenly across app categories [9], [11], [12] and we have to manually label all the apps in our test dataset to obtain the ground truth, we choose as our test set the top 150 apps with appearances of sensitive keywords as mentioned in Section III-D1 in their UI layout files.", "part": "1"}, {"sec": "sec5", "text": " SUPOR [9], UIPicker [11], and UiRef [12] are among the first works to analyze the descriptive texts in apps' UI for determining whether the corresponding user inputs contain sensitive data.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=UIPicker%3A+User-input+privacy+identification+in+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "B. Andow, A. Acharya, D. Li, W. Enck, K. Singh, T. Xie, \"UIRef: Analysis of sensitive user inputs in android applications\", <em>ACM Conference on Security and Privacy in Wireless and Mobile Networks (WiSec)</em>, 2017.", "title": "UIRef: Analysis of sensitive user inputs in android applications", "context": [{"sec": "sec1", "text": " Recent works have made progress in detecting disclosure of sensitive user inputs [9], [11], [12] by analyzing textual data in the UIs.", "part": "1"}, {"sec": "sec2a", "text": " Existing works [9], [11], [12] that analyze texts in the UIs face challenges in identifying this sensitive UI widget, since no sensitive texts can be extracted from the UI.", "part": "1"}, {"sec": "sec3d5", "text": " Therefore, keyword matching [9], [11], [12] can be adapted to effectively classify the text icons.", "part": "1"}, {"sec": "sec4a2", "text": " Since apps that have UI widgets to collect sensitive user inputs are not distributed evenly across app categories [9], [11], [12] and we have to manually label all the apps in our test dataset to obtain the ground truth, we choose as our test set the top 150 apps with appearances of sensitive keywords as mentioned in Section III-D1 in their UI layout files.", "part": "1"}, {"sec": "sec5", "text": " SUPOR [9], UIPicker [11], and UiRef [12] are among the first works to analyze the descriptive texts in apps' UI for determining whether the corresponding user inputs contain sensitive data.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3098243.3098247", "abstract": "Mobile applications frequently request sensitive data. While prior work has focused on analyzing sensitive-data uses originating from well-defined API calls in the system, the security and privacy implications of inputs requested via application user interfaces have been widely unexplored. In this paper, our goal is to understand the broad implications of such requests in terms of the type of sensitive data being requested by applications. To this end, we propose UiRef (User Input REsolution Fra...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=UIRef%3A+Analysis+of+sensitive+user+inputs+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "N. Babich, <em>Ghost buttons in UX design</em>, 2016,  [online]  Available: https://www.techinasia.com/talk/ghost-buttons-ux-design.", "title": "Ghost buttons in UX design", "context": [{"sec": "sec1", "text": " The diversified colors and opacities in fonts and backgrounds (e.g., ghost button [13]) make it difficult to directly apply Optical Character Recognition (OCR) [14], which works best for icons having black texts and white backgrounds.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ghost+buttons+in+UX+design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "S. Mori, H. Nishida, H. Yamada, Optical character recognition, John Wiley & Sons, Inc., 1999.", "title": "Optical character recognition", "context": [{"sec": "sec1", "text": " The diversified colors and opacities in fonts and backgrounds (e.g., ghost button [13]) make it difficult to directly apply Optical Character Recognition (OCR) [14], which works best for icons having black texts and white backgrounds.", "part": "1"}, {"sec": "sec4", "text": "We implemented IconIntent upon Gator [28]\u2013[30] for static analysis and upon OpenCV [31] and Asprise OCR [14], [32] for icon classification.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Optical+character+recognition&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "D. G. Lowe, \"Distinctive image features from scale-invariant keypoints\", <em>International Journal of Computer Vision (IJCV)</em>, vol. 60, no. 2, pp. 91-110, 2004.", "title": "Distinctive image features from scale-invariant keypoints", "context": [{"sec": "sec1", "text": " The icon classification module adapts SIFT [15], a state-of-the-art image feature engineering technique, with our novel key-location increasing and relative one-to-one matching techniques to enhance its effectiveness in classifying icons.", "part": "1"}, {"sec": "sec3d2", "text": "Classifying icons based on objects inside it brings new challenges to object recognition techniques such as Scale-Invariant-Feature-Transform (SIFT) [15], [24] in computer vision.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/B:VISI.0000029664.99615.94", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Distinctive+image+features+from+scale-invariant+keypoints&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>Android view system</em>, 2017,  [online]  Available: https://developer.android.com/guide/topics/ui/declaring-layout.html.", "title": "Android view system", "context": [{"sec": "sec2a", "text": "An Android app usually consists of multiple activities, where each activity provides the window to draw the UI [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+view+system&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "Z. Cao, <em>Sensitive text icon classification for android apps</em>, 2017.", "title": "Sensitive text icon classification for android apps", "context": [{"sec": "sec2b", "text": "Our preliminary study on 300 text icons extracted from apps in Google Play shows that directly applying existing OCR techniques can infer semantic information from less than 10% of the studied icons [17].", "part": "1"}, {"sec": "sec3d5", "text": " Based on our preliminary studies on about 300 text icons collected from top Google Play apps, more than 95% of the text icons contain 1 to 3 words [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sensitive+text+icon+classification+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "C. Kanan, G. W. Cottrell, \"Color-to-grayscale: does the method matter in image recognition?\", <em>PloS one</em>, vol. 7, no. 1, 2012.", "title": "Color-to-grayscale: does the method matter in image recognition?", "context": [{"sec": "sec3c", "text": " Motivated by the app icon variety shown in Figure 4, IconIntent leverages five commonly-used image mutation techniques [18], [19].", "part": "1"}, {"sec": "sec3c", "text": "Grayscale Conversion: This technique converts an image to another image in which the value of each pixel just represents only the amount of light [18].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1371/journal.pone.0029740", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Color-to-grayscale%3A+does+the+method+matter+in+image+recognition%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "R. J. Schalkoff, Digital image processing and computer vision, New York:Wiley, vol. 286, 1989.", "title": "Digital image processing and computer vision", "context": [{"sec": "sec3c", "text": " Motivated by the app icon variety shown in Figure 4, IconIntent leverages five commonly-used image mutation techniques [18], [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Digital+image+processing+and+computer+vision&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "<em>RGB color model</em>, 2003,  [online]  Available: https://en.wikipedia.org/wiki/RGB_color_model.", "title": "RGB color model", "context": [{"sec": "sec3c", "text": " A color in the RGB color model [20] is expressed as an RGB triplet \\$\\langle r, g, b\\rangle\\$ where \\$^{\\prime\\prime}r^{\\prime\\prime}, ^{\\prime\\prime}g^{\\prime\\prime}\\$ and \\$^{\\prime\\prime}b^{\\prime\\prime}\\$ are the numeric values that describe how much red, green, and blue are included in the color, respectively.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=RGB+color+model&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "K. Turkowski, \"Filters for common resampling tasks\" in Graphics gems, Academic Press Professional, Inc., pp. 147-165, 1990.", "title": "Filters for common resampling tasks", "context": [{"sec": "sec3c", "text": " A commonly used technique is to resample pixel values using nearby pixels [21] for the scaled image.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/B978-0-08-050753-8.50042-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Filters+for+common+resampling+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "R. Pandita, X. Xiao, W. Yang, W. Enck, T. Xie, \"WHYPER: Towards automating risk assessment of mobile applications\", <em>USENIX Security Symposium</em>, 2013.", "title": "WHYPER: Towards automating risk assessment of mobile applications", "context": [{"sec": "sec3d1", "text": " We choose these eight sensitive user-input categories because the app functionality related to these categories are popular, represent tangible sensitive resources that users can understand, and have significant security and privacy implications [9], [22], [23].", "part": "1"}, {"sec": "sec5", "text": " WHYPER [22] and AutoCog [43] adapt natural language processing techniques for analyzing apps' descriptions and infer the mapping between sentences in app descriptions and permissions.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=WHYPER%3A+Towards+automating+risk+assessment+of+mobile+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "A. P. Felt, E. Ha, S. Egelman, A. Haney, E. Chin, D. Wagner, \"Android permissions: User attention comprehension and behavior\", <em>Symposium on Usable Privacy and Security (SOUPS)</em>, 2012.", "title": "Android permissions: User attention, comprehension, and behavior", "context": [{"sec": "sec3d1", "text": " We choose these eight sensitive user-input categories because the app functionality related to these categories are popular, represent tangible sensitive resources that users can understand, and have significant security and privacy implications [9], [22], [23].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2335356.2335360", "abstract": "Android&#39;s permission system is intended to inform users about the risks of installing applications. When a user installs an application, he or she has the opportunity to review the application&#39;s permission requests and cancel the installation if the permissions are excessive or objectionable. We examine whether the Android permission system is effective at warning users. In particular, we evaluate whether Android users pay attention to, understand, and act on permission information during instal...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+permissions%3A+User+attention%2C+comprehension%2C+and+behavior&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "D. G. Lowe, \"Object recognition from local scale-invariant features\", <em>International Conference on Computer Vision (ICCV)</em>, 1999.", "title": "Object recognition from local scale-invariant features", "context": [{"sec": "sec3d2", "text": "Classifying icons based on objects inside it brings new challenges to object recognition techniques such as Scale-Invariant-Feature-Transform (SIFT) [15], [24] in computer vision.", "part": "1"}], "links": {"documentLink": "/document/790410", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=790410", "abstract": "An object recognition system has been developed that uses a new class of local image features. The features are invariant to image scaling, translation, and rotation, and partially invariant to illumination changes and affine or 3D projection. These features share similar properties with neurons in inferior temporal cortex that are used for object recognition in primate vision. Features are efficiently detected through a staged filtering approach that identifies stable points in scale space. Ima...", "pdfSize": "225KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Object+recognition+from+local+scale-invariant+features&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "E. Rosten, R. Porter, T. Drummond, \"Faster and better: A machine learning approach to corner detection\", <em>IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI)</em>, vol. 32, no. 1, pp. 105-119, 2010.", "title": "Faster and better: A machine learning approach to corner detection", "context": [{"sec": "sec3d3", "text": " Second, we switch to FAST algorithm [25], an alternative technique ex- tracting many low quality key locations instead of a few high quality key locations (as in SIFT).", "part": "1"}], "links": {"documentLink": "/document/4674368", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4674368", "abstract": "The repeatability and efficiency of a corner detector determines how likely it is to be useful in a real-world application. The repeatability is important because the same scene viewed from different positions should yield features which correspond to the same real-world 3D locations. The efficiency is important because this determines whether the detector combined with further processing can operate at frame rate. Three advances are described in this paper. First, we present a new heuristic for...", "pdfSize": "3001KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Faster+and+better%3A+A+machine+learning+approach+to+corner+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "E. S. Ristad, P. N. Yianilos, \"Learning string-edit distance\", <em>IEEE Transactions on Pattern Analysis and Machine Intelligence (TPAMI)</em>, vol. 20, no. 5, pp. 522-532, 1998.", "title": "Learning string-edit distance", "context": [{"sec": "sec3d5", "text": " Our algorithm adapts edit distance [26] with n-gram substring generation, and relative length computation to compute the similarity between the extracted text from a text icon and the keywords in the sensitive user-input categories.", "part": "1"}, {"sec": "sec3d5", "text": " Since keywords have different lengths, in many cases the Levenshtein distance [26] does not reflect the similarity as expected.", "part": "1"}], "links": {"documentLink": "/document/682181", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=682181", "abstract": "In many applications, it is necessary to determine the similarity of two strings. A widely-used notion of string similarity is the edit distance: the minimum number of insertions, deletions, and substitutions required to transform one string into the other. In this report, we provide a stochastic model for string-edit distance. Our stochastic model allows us to learn a string-edit distance function from a corpus of examples. We illustrate the utility of our approach by applying it to the difficu...", "pdfSize": "462KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+string-edit+distance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "G. Kondrak, \"N-gram similarity and distance\", <em>International Symposium on String Processing and Information Retrieval (SPIRE)</em>, pp. 115-126, 2005.", "title": "N-gram similarity and distance", "context": [{"sec": "sec3d5", "text": " To address this problem, we introduce \\$n\\$ -gram substring generation [27].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/11575832_13", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=N-gram+similarity+and+distance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "A. Rountev, D. Yan, \"Static reference analysis for gui objects in android software\", <em>IEEE/ACM International Symposium on Code Generation and Optimization (CGO)</em>, 2014.", "title": "Static reference analysis for gui objects in android software", "context": [{"sec": "sec4", "text": "We implemented IconIntent upon Gator [28]\u2013[30] for static analysis and upon OpenCV [31] and Asprise OCR [14], [32] for icon classification.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2581122.2544159", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+reference+analysis+for+gui+objects+in+android+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "S. Yang, D. Yan, H. Wu, Y. Wang, A. Rountev, \"Static control-flow analysis of user-driven callbacks in Android applications\", <em>International Conference on Software Engineering (ICSE)</em>, 2015.", "title": "Static control-flow analysis of user-driven callbacks in Android applications", "context": [{"sec": "sec4", "text": "We implemented IconIntent upon Gator [28]\u2013[29][30] for static analysis and upon OpenCV [31] and Asprise OCR [14], [32] for icon classification.", "part": "1"}], "links": {"documentLink": "/document/7194564", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194564", "abstract": "Android software presents many challenges for static program analysis. In this work we focus on the fundamental problem of static control-flow analysis. Traditional analyses cannot be directly applied to Android because the applications are framework-based and event-driven. We consider user-event-driven components and the related sequences of callbacks from the Android framework to the application code, both for lifecycle callbacks and for event handler callbacks. We propose a program representa...", "pdfSize": "849KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+control-flow+analysis+of+user-driven+callbacks+in+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "S. Yang, H. Zhang, H. Wu, Y. Wang, D. Yan, A. Rountev, \"Static window transition graphs for android (t)\", <em>IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, 2015.", "title": "Static window transition graphs for android (t)", "context": [{"sec": "sec4", "text": "We implemented IconIntent upon Gator [28]\u2013[30] for static analysis and upon OpenCV [31] and Asprise OCR [14], [32] for icon classification.", "part": "1"}], "links": {"documentLink": "/document/7372053", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372053", "abstract": "This work develops a static analysis to create a model of the behavior of an Android application&#39;s GUI. We propose the window transition graph (WTG), a model representing the possible GUI window sequences and their associated events and callbacks. A key component and contribution of our work is the careful modeling of the stack of currently-active windows, the changes to this stack, and the effects of callbacks related to these changes. To the best of our knowledge, this is the first detailed st...", "pdfSize": "284KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+window+transition+graphs+for+android+%28t%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "O. team, <em>OpenCV</em>, 2017,  [online]  Available: http://opencv.org/.", "title": "OpenCV", "context": [{"sec": "sec4", "text": "We implemented IconIntent upon Gator [28]\u2013[30] for static analysis and upon OpenCV [31] and Asprise OCR [14], [32] for icon classification.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=OpenCV&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "<em>Asprise ocr and barcode recognition</em>, 2017,  [online]  Available: http://asprise.com/royalty-free-library/java-ocr-api-overview.html.", "title": "Asprise ocr and barcode recognition", "context": [{"sec": "sec4", "text": "We implemented IconIntent upon Gator [28]\u2013[30] for static analysis and upon OpenCV [31] and Asprise OCR [14], [32] for icon classification.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Asprise+ocr+and+barcode+recognition&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "B. Pan, <em>dex2jar: Tools to work with android. dex and java. class files</em>, 2017,  [online]  Available: https://github.com/pxb1988/dex2jar.", "title": "dex2jar: Tools to work with android. dex and java. class files", "context": [{"sec": "sec4b1", "text": " Thus, to fairly evaluate effectiveness of our technique, we make two improvements to make Supor applicable to other UI widgets: (1) we expand the UI widgets types to include buttons, radio buttons, check boxes, and other commonly used UI widgets that accept user inputs; (2) we leverage dex2jar [33] to convert dex bytecode in APK files to Java bytecode, so that SUpoR can support custom widgets.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=dex2jar%3A+Tools+to+work+with+android.+dex+and+java.+class+files&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "T. A. Nguyen, C. Csallner, \"Reverse engineering mobile application user interfaces with REMAUI\", <em>IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, 2015.", "title": "Reverse engineering mobile application user interfaces with REMAUI", "context": [{"sec": "sec5", "text": " REMAUI [34] applies computer vision techniques for reverse engineering UIs of mobile apps.", "part": "1"}], "links": {"documentLink": "/document/7372013", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372013", "abstract": "When developing the user interface code of a mobile application, in practice a big gap exists between the digital conceptual drawings of graphic artists and working user interface code. Currently, programmers bridge this gap manually, by reimplementing the conceptual drawings in code, which is cumbersome and expensive. To bridge this gap, we introduce the first technique to automatically Reverse Engineer Mobile Application User Interfaces (REMAUI). On a given input bitmap REMAUI identifies user ...", "pdfSize": "2000KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reverse+engineering+mobile+application+user+interfaces+with+REMAUI&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "T. Yeh, T. Chang, R. C. Miller, \"Sikuli: using GUI screenshots for search and automation\", <em>the ACM Symposium on User Interface Software and Technology (UIST)</em>, 2009.", "title": "Sikuli: using GUI screenshots for search and automation", "context": [{"sec": "sec5", "text": " Sikuli [35], [36] uses image recognition to identify and control UI components for automating UI testing.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1622176.1622213", "abstract": "We present Sikuli, a visual approach to search and automation of graphical user interfaces using screenshots. Sikuli allows users to take a screenshot of a GUI element (such as a toolbar button, icon, or dialog box) and query a help system using the screenshot instead of the element&#39;s name. Sikuli also provides a visual scripting API for automating GUI interactions, using screenshot patterns to direct mouse and keyboard events. We report a web-based user study showing that searching by screensho...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sikuli%3A+using+GUI+screenshots+for+search+and+automation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "T. Chang, T. Yeh, R. C. Miller, \"GUI testing using computer vision\", <em>International Conference on Human Factors in Computing Systems (CHI)</em>, 2010.", "title": "GUI testing using computer vision", "context": [{"sec": "sec5", "text": " Sikuli [35], [36] uses image recognition to identify and control UI components for automating UI testing.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1753326.1753555", "abstract": "Testing a GUI&#39;s visual behavior typically requires human testers to interact with the GUI and to observe whether the expected results of interaction are presented. This paper presents a new approach to GUI testing using computer vision for testers to automate their tasks. Testers can write a visual test script that uses images to specify which GUI components to interact with and what visual feedback to be observed. Testers can also generate visual test scripts by demonstration. By recording both...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=GUI+testing+using+computer+vision&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "S. R. Choudhary, H. Versee, A. Orso, \"WEBDIFF: automated identification of cross-browser issues in web applications\", <em>IEEE International Conference on Software Maintenance (ICSM)</em>, 2010.", "title": "WEBDIFF: automated identification of cross-browser issues in web applications", "context": [{"sec": "sec5", "text": " WebDiff [37] and XPERT [38] leverage computer vision techniques to detect visual differences, assisting the task of detecting cross browser rendering issues.", "part": "1"}], "links": {"documentLink": "/document/5609723", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5609723", "abstract": "Cross-browser (and cross-platform) issues are prevalent in modern web based applications and range from minor cosmetic bugs to critical functional failures. In spite of the relevance of these issues, cross-browser testing of web applications is still a fairly immature field. Existing tools and techniques require a considerable manual effort to identify such issues and provide limited support to developers for fixing the underlying cause of the issues. To address these limitations, we propose a t...", "pdfSize": "752KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=WEBDIFF%3A+automated+identification+of+cross-browser+issues+in+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "S. R. Choudhary, M. R. Prasad, A. Orso, \"X-PERT: a web application testing tool for cross-browser inconsistency detection\", <em>International Symposium on Software Testing and Analysis (ISSTA)</em>, 2014.", "title": "X-PERT: a web application testing tool for cross-browser inconsistency detection", "context": [{"sec": "sec5", "text": " WebDiff [37] and XPERT [38] leverage computer vision techniques to detect visual differences, assisting the task of detecting cross browser rendering issues.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2628057", "abstract": "Web applications are popular among developers because of the ease of development and deployment through the ubiquitous web browsing platform. However, differences in a web application&#39;s execution across different web browsers manifest as Cross-browser Inconsistencies (XBIs), which are a serious concern for web developers. Testing for XBIs manually is a laborious and error-prone process. In this demo we present X-PERT, which is a tool to identify XBIs in web applications automatically, without re...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=X-PERT%3A+a+web+application+testing+tool+for+cross-browser+inconsistency+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "J. Huang, X. Zhang, L. Tan, P. Wang, B. Liang, \"AsDroid: Detecting stealthy behaviors in android applications by user interface and program behavior contradiction\", <em>International Conference on Software Engineering (ICSE)</em>, 2014.", "title": "AsDroid: Detecting stealthy behaviors in android applications by user interface and program behavior contradiction", "context": [{"sec": "sec5", "text": " AsDroid [39] checks the compatibility of the descriptive texts and the intentions represented by the sensitive APIs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568301", "abstract": "Android smartphones are becoming increasingly popular. The open nature of Android allows users to install miscellaneous applications, including the malicious ones, from third-party marketplaces without rigorous sanity checks. A large portion of existing malwares perform stealthy operations such as sending short messages, making phone calls and HTTP connections, and installing additional malicious components. In this paper, we propose a novel technique to detect such stealthy behavior. We model s...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AsDroid%3A+Detecting+stealthy+behaviors+in+android+applications+by+user+interface+and+program+behavior+contradiction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "Z. Yang, M. Yang, Y. Zhang, G. Gu, P. Ning, X. S. Wang, \"AppIntent: analyzing sensitive data transmission in android for privacy leakage detection\", <em>ACM SIGSAC Conference on Computer and Communications Security (CCS)</em>, 2013.", "title": "AppIntent: analyzing sensitive data transmission in android for privacy leakage detection", "context": [], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516676", "abstract": "Android phones often carry personal information, attracting malicious developers to embed code in Android applications to steal sensitive data. With known techniques in the literature, one may easily determine if sensitive data is being transmitted out of an Android phone. However, transmission of sensitive data in itself does not necessarily indicate privacy leakage; a better indicator may be whether the transmission is by user intention or not. When transmission is not intended by the user, it...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AppIntent%3A+analyzing+sensitive+data+transmission+in+android+for+privacy+leakage+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "Y. Li, Y. Guo, X. Chen, \"PERUIM: Understanding mobile application privacy with permission-ui mapping\", <em>ACM International Joint Conference on Pervasive and Ubiquitous Computing (UbiComp)</em>, 2016.", "title": "PERUIM: Understanding mobile application privacy with permission-ui mapping", "context": [{"sec": "sec5", "text": " PERUIM [41] extracts the permission-UI mapping from an app based on both dynamic and static analysis, helping users understand the requested permissions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2971648.2971693", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=PERUIM%3A+Understanding+mobile+application+privacy+with+permission-ui+mapping&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "T. F. Liu, M. Craft, J. Situ, E. Yumer, R. Mech, R. Kumar, \"Learning design semantics for mobile apps\", <em>ACM Symposium on User Interface Software and Technology (UIST)</em>, 2018.", "title": "Learning design semantics for mobile apps", "context": [{"sec": "sec5", "text": " [42] propose an automatic approach for annotating mobile UI elements with both structural semantics such as buttons or toolbars and functional semantics such as add or search.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3242587.3242650", "abstract": "Recently, researchers have developed black-box approaches to mine design and interaction data from mobile apps. Although the data captured during this interaction mining is descriptive, it does not expose the design semantics of UIs: what elements on the screen mean and how they are used. This paper introduces an automatic approach for generating semantic annotations for mobile app UIs. Through an iterative open coding of 73k UI elements and 720 screens, we contribute a lexical database of 25 ty...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+design+semantics+for+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "Z. Qu, V. Rastogi, X. Zhang, Y. Chen, T. Zhu, Z. Chen, \"Autocog: Measuring the description-to-permission fidelity in android applications\", <em>ACM SIGSAC Conference on Computer and Communications Security (CCS)</em>, 2014.", "title": "Autocog: Measuring the description-to-permission fidelity in android applications", "context": [{"sec": "sec5", "text": " WHYPER [22] and AutoCog [43] adapt natural language processing techniques for analyzing apps' descriptions and infer the mapping between sentences in app descriptions and permissions.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2660267.2660287", "abstract": "The booming popularity of smartphones is partly a result of application markets where users can easily download wide range of third-party applications. However, due to the open nature of markets, especially on Android, there have been several privacy and security concerns with these applications. On Google Play, as with most other markets, users have direct access to natural-language descriptions of those applications, which give an intuitive idea of the functionality including the security-rela...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Autocog%3A+Measuring+the+description-to-permission+fidelity+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "A. Gorla, I. Tavecchia, F. Gross, A. Zeller, \"Checking app behavior against app descriptions\", <em>International Conference on Software Engineering (ICSE)</em>, 2014.", "title": "Checking app behavior against app descriptions", "context": [{"sec": "sec5", "text": " CHABADA [44] clusters app descriptions' topics and identifies outliers in each cluster with respect to their API usage.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568276", "abstract": "How do we know a program does what it claims to do? After clustering Android apps by their description topics, we identify outliers in each cluster with respect to their API usage. A &#34;weather&#34; app that sends messages thus becomes an anomaly; likewise, a &#34;messaging&#34; app would typically not be expected to access the current location. Applied on a set of 22,500+ Android applications, our CHABADA prototype identified several anomalies; additionally, it flagged 56% of novel malware as such, without r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Checking+app+behavior+against+app+descriptions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "J. Huang, X. Zhang, L. Tan, \"Detecting sensitive data disclosure via bi-directional text correlation analysis\", <em>ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE)</em>, 2016.", "title": "Detecting sensitive data disclosure via bi-directional text correlation analysis", "context": [{"sec": "sec5", "text": " BidText [45] detects sensitive data disclosures by performing bi-directional data flow analysis to detect variables that are at the sink points and are correlated with sensitive text labels.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2950290.2950348", "abstract": "Traditional sensitive data disclosure analysis faces two challenges: to identify sensitive data that is not generated by specific API calls, and to report the potential disclosures when the disclosed data is recognized as sensitive only after the sink operations. We address these issues by developing BidText, a novel static technique to detect sensitive data disclosures. BidText formulates the problem as a type system, in which variables are typed with the text labels that they encounter (e.g., ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+sensitive+data+disclosure+via+bi-directional+text+correlation+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812108", "articleId": "8812108", "startPage": "257", "endPage": "268", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 1, "citationCountPatent": 0, "totalDownloads": 137}}
{"title": "Detecting Atomicity Violations for Event-Driven Node.js Applications", "authors": [{"name": "Xiaoning Chang", "affiliation": "State Key Lab of Computer Sciences", "firstName": "Xiaoning", "lastName": "Chang", "id": "37086948470"}, {"name": "Wensheng Dou", "affiliation": "State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China", "firstName": "Wensheng", "lastName": "Dou", "id": "38553396800"}, {"name": "Yu Gao", "affiliation": "State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China", "firstName": "Yu", "lastName": "Gao", "id": "37086240095"}, {"name": "Jie Wang", "affiliation": "State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China", "firstName": "Jie", "lastName": "Wang", "id": "37085624558"}, {"name": "Jun Wei", "affiliation": "State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China", "firstName": "Jun", "lastName": "Wei", "id": "37279094100"}, {"name": "Tao Huang", "affiliation": "State Key Lab of Computer Sciences, Institute of Software, Chinese Academy of Sciences, China", "firstName": "Tao", "lastName": "Huang", "id": "37418921900"}], "abstract": "Node.js has been widely-used as an event-driven server-side architecture. To improve performance, a task in a Node.js application is usually divided into a group of events, which are non-deterministically scheduled by Node.js. Developers may assume that the group of events (named atomic event group) should be atomically processed, without interruption. However, the atomicity of an atomic event group is not guaranteed by Node.js, and thus other events may interrupt the execution of the atomic event group, break down the atomicity and cause unexpected results. Existing approaches mainly focus on event race among two events, and cannot detect high-level atomicity violations among a group of events. In this paper, we propose NodeAV, which can predictively detect atomicity violations in Node.js applications based on an execution trace. Based on happens-before relations among events in an execution trace, we automatically identify a pair of events that should be atomically processed, and use predefined atomicity violation patterns to detect atomicity violations. We have evaluated NodeAV on real-world Node.js applications. The experimental results show that NodeAV can effectively detect atomicity violations in these Node.js applications.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Task analysis", "Programming", "Instruction sets", "Computer architecture", "Message systems", "Concurrent computing", "Computer bugs"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Java", "program testing", "scheduling"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["event-driven server-side architecture", "Node.js application", "atomic event group", "event race", "atomicity violation patterns", "event-driven Node.js applications", "NodeAV"]}, {"type": "Author Keywords ", "kwd": ["Node.js", "event-driven architecture", "atomicity violation", "happens-before"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00073", "ref": [{"order": "1", "text": "<em>Node.js Foundation</em>,  [online]  Available: https://nodejs.org/en/.", "title": "Node.js Foundation", "context": [{"sec": "sec1", "text": "Node.js [1] is a popular event-driven framework for developing server-side JavaScript applications.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Node.js+Foundation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Tracking the Explosive Growth of Open-Source Software</em>,  [online]  Available: https://techcrunch.com/2017/04/07/tracking-the-explosive-growth-of-open-source-software/.", "title": "Tracking the Explosive Growth of Open-Source Software", "context": [{"sec": "sec1", "text": " Since its birth in 2009, Node.js has caught much attention and becomes one of the leading open-source projects, like Linux, Git and MySQL [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracking+the+Explosive+Growth+of+Open-Source+Software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>The npm Repository</em>,  [online]  Available: https://www.npmjs.com/.", "title": "The npm Repository", "context": [{"sec": "sec1", "text": " One evidence is that, the package ecosystem in Node.js, npm [3], has managed 700,000 building blocks in August 2018, which is the largest package registry so far.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+npm+Repository&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>Node.js in PayPal</em>,  [online]  Available: https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/.", "title": "Node.js in PayPal", "context": [{"sec": "sec1", "text": " Node.js has also been widely used in industry, such as PayPal [4], LinkedIn [5], Yahoo [6] and Mozilla [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Node.js+in+PayPal&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>Node.js in LinkedIn</em>,  [online]  Available: https://venturebeat.com/2011/08/16/linkedin-node/.", "title": "Node.js in LinkedIn", "context": [{"sec": "sec1", "text": " Node.js has also been widely used in industry, such as PayPal [4], LinkedIn [5], Yahoo [6] and Mozilla [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Node.js+in+LinkedIn&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Node.js in Yahoo</em>,  [online]  Available: https://yahooeng.tumblr.com/node.", "title": "Node.js in Yahoo", "context": [{"sec": "sec1", "text": " Node.js has also been widely used in industry, such as PayPal [4], LinkedIn [5], Yahoo [6] and Mozilla [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Node.js+in+Yahoo&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>Node.js in Mozila</em>,  [online]  Available: https://medium.com/mozilla-tech/mozilla-and-node-js-33c13e29beb1.", "title": "Node.js in Mozila", "context": [{"sec": "sec1", "text": " Node.js has also been widely used in industry, such as PayPal [4], LinkedIn [5], Yahoo [6] and Mozilla [7].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Node.js+in+Mozila&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "J. Wang et al., \"A Comprehensive Study on Real World Concurrency Bugs in Node.js\", <em>Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 520-531, 2017.", "title": "A Comprehensive Study on Real World Concurrency Bugs in Node.js", "context": [{"sec": "sec1", "text": " Recent studies on Node.js [8] [9] have shown that atomicity violations are common, and at least 65% of concurrency bugs in Node.js are atomicity violations.", "part": "1"}, {"sec": "sec2c", "text": " We need to address four technical challenges. (1) How can we model the contention on external resources, e.g., the file in Fig. 1? Existing studies [8] [9] have shown that about a half of concurrency bugs in Node.js applications contend against external resources. (2) Node.js has various mechanisms for event-driven programming, including several system-specific scheduling APIs, e.g., process.nextTick and promise [22] [25].", "part": "1"}, {"sec": "sec5a", "text": "To verify whether NodeAV can effectively detect known atomicity violations in Node.js applications, we build dataset-1 based on Node.fz [9] and NodeCB [8], which contain atomicity violations in realworld Node.js applications.", "part": "1"}, {"sec": "sec6a", "text": " Second, these atomicity violations have been used in existing studies, e.g., NodeCB [8] and Node.fz [9].", "part": "1"}, {"sec": "sec7", "text": " NodeCB [8] studies 57 concurrency bugs in real-world Node.js applications and obtains some interesting findings, e.g., 65% of concurrency bugs in Node.js are atomicity violations.", "part": "1"}], "links": {"documentLink": "/document/8115663", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115663", "abstract": "Node.js becomes increasingly popular in building server-side JavaScript applications. It adopts an event-driven model, which supports asynchronous I/O and non-deterministic event processing. This asynchrony and non-determinism can introduce intricate concurrency bugs, and leads to unpredictable behaviors. An in-depth understanding of real world concurrency bugs in Node.js applications will significantly promote effective techniques in bug detection, testing and fixing for Node.js. In this paper,...", "pdfSize": "352KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Comprehensive+Study+on+Real+World+Concurrency+Bugs+in+Node.js&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "J. Davis, A. Thekumparampil, D. Lee, \"Node. fz: Fuzzing the Server-Side Event-Driven Architecture\", <em>Proceedings of the 12th European Conference on Computer Systems (EuroSys)</em>, pp. 145-160, 2017.", "title": "Node. fz: Fuzzing the Server-Side Event-Driven Architecture", "context": [{"sec": "sec1", "text": " Recent studies on Node.js [8] [9] have shown that atomicity violations are common, and at least 65% of concurrency bugs in Node.js are atomicity violations.", "part": "1"}, {"sec": "sec2c", "text": " We need to address four technical challenges. (1) How can we model the contention on external resources, e.g., the file in Fig. 1? Existing studies [8] [9] have shown that about a half of concurrency bugs in Node.js applications contend against external resources. (2) Node.js has various mechanisms for event-driven programming, including several system-specific scheduling APIs, e.g., process.nextTick and promise [22] [25].", "part": "1"}, {"sec": "sec5a", "text": "To verify whether NodeAV can effectively detect known atomicity violations in Node.js applications, we build dataset-1 based on Node.fz [9] and NodeCB [8], which contain atomicity violations in realworld Node.js applications.", "part": "1"}, {"sec": "sec6a", "text": " Second, these atomicity violations have been used in existing studies, e.g., NodeCB [8] and Node.fz [9].", "part": "1"}, {"sec": "sec7", "text": " Node.fz [9] is an event fuzzing tool for Node.js applications.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3064176.3064188", "abstract": "The importance of the Event-Driven Architecture (EDA) has never been greater. Web servers and the IoT alike have begun to adopt the EDA, and the popular server-side EDA framework, Node.js, boasts the world&#39;s largest package ecosystem. While multi-threaded programming has been well studied in the literature, concurrency bug characteristics and useful development tools remain largely unexplored for server-side EDA-based applications. We present the first (to the best of our knowledge) concurrency ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Node.+fz%3A+Fuzzing+the+Server-Side+Event-Driven+Architecture&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S. Lu, J. Tucek, F. Qin, Y. Zhou, \"AVIO: Detecting Atomicity Violations via Access-Interleaving Invariants\", <em>Proceedings of the 12th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 37-48, 2006.", "title": "AVIO: Detecting Atomicity Violations via Access-Interleaving Invariants", "context": [{"sec": "sec1", "text": "Existing approaches on atomicity violation detection [10]\u2013[13] mainly focus on multithreaded programs.", "part": "1"}, {"sec": "sec1", "text": " We adapt unserializable schedules in multithreaded programs [10] on Node.js applications and summarize the atomicity violation patterns to detect atomicity violations in Node.js applications.", "part": "1"}, {"sec": "sec2c", "text": " We borrow the idea from the serializability in multithreaded programs [10], and apply atomicity violation patterns on event-driven Node.js applications.", "part": "1"}, {"sec": "sec3c", "text": "Inspired by existing studies on atomicity violations in multithreaded programs [10], we borrow the idea of serializability from multithreaded programs, and design atomicity violation patterns based on shared resource accessing types.", "part": "1"}, {"sec": "sec3c", "text": " Based on the atomicity violation patterns in multithreaded program [10], for each atomicity violation scenario in Fig. 6a-c, we design four resource accessing patterns that can cause different execution results.", "part": "1"}, {"sec": "sec7", "text": " Many approaches and tools have been developed to identify concurrency bugs in multithreaded programs, e.g., FastTrack [37], Eraser [38] for data races, AVIO [10], CTrigger [11], and Atomizer [39] for atomicity violations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1168857.1168864", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=AVIO%3A+Detecting+Atomicity+Violations+via+Access-Interleaving+Invariants&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "S. Park, S. Lu, Y. Zhou, \"CTrigger: Exposing Atomicity Violation Bugs from Their Hiding Places\", <em>Proceedings of the 14th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 25-36, 2009.", "title": "CTrigger: Exposing Atomicity Violation Bugs from Their Hiding Places", "context": [{"sec": "sec1", "text": "Existing approaches on atomicity violation detection [10]\u2013[11][13] mainly focus on multithreaded programs.", "part": "1"}, {"sec": "sec7", "text": " Many approaches and tools have been developed to identify concurrency bugs in multithreaded programs, e.g., FastTrack [37], Eraser [38] for data races, AVIO [10], CTrigger [11], and Atomizer [39] for atomicity violations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1508244.1508249", "abstract": "Multicore hardware is making concurrent programs pervasive. Unfortunately, concurrent programs are prone to bugs. Among different types of concurrency bugs, atomicity violation bugs are common and important. Existing techniques to detect atomicity violation bugs suffer from one limitation: requiring bugs to manifest during monitored runs, which is an open problem in concurrent program testing. This paper makes two contributions. First, it studies the interleaving characteristics of the common pr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=CTrigger%3A+Exposing+Atomicity+Violation+Bugs+from+Their+Hiding+Places&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "B. Lucia, J. Devietti, K. Strauss, L. Ceze, \"Atom-Aid: Detecting and Surviving Atomicity Violations\", <em>Proceedings of the 35th Annual International Symposium on Computer Architecture (ISCA)</em>, pp. 277-288, 2008.", "title": "Atom-Aid: Detecting and Surviving Atomicity Violations", "context": [{"sec": "sec1", "text": "Existing approaches on atomicity violation detection [10]\u2013[12][13] mainly focus on multithreaded programs.", "part": "1"}], "links": {"documentLink": "/document/4556733", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4556733", "abstract": "Writing shared-memory parallel programs is error-prone. Among the concurrency errors that programmers often face are atomicity violations, which are especially challenging. They happen when programmers make incorrect assumptions about atomicity and fail to enclose memory accesses that should occur atomically inside the same critical section. If these accesses happen to be interleaved with conflicting accesses from different threads, the program might behave incorrectly. Recent architectural prop...", "pdfSize": "579KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Atom-Aid%3A+Detecting+and+Surviving+Atomicity+Violations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "G. Upadhyaya, S. P. Midkiff, V. S. Pai, \"Automatic Atomic Region Identification in Shared Memory SPMD Programs\", <em>Proceedings of the ACM International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA)</em>, pp. 652-670, 2010.", "title": "Automatic Atomic Region Identification in Shared Memory SPMD Programs", "context": [{"sec": "sec1", "text": "Existing approaches on atomicity violation detection [10]\u2013[13] mainly focus on multithreaded programs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1869459.1869513", "abstract": "This paper presents TransFinder, a compile-time tool that automatically determines which statements of an unsynchronized multithreaded program must be enclosed in atomic regions to enforce conflict-serializability. Unlike previous tools, TransFinder requires no programmer input (beyond the program) and is more efficient in both time and space. Our implementation shows that the generated atomic regions range from being identical to, or smaller than, the programmer-specified transactions in the th...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+Atomic+Region+Identification+in+Shared+Memory+SPMD+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "C.-H. Hsiao et al., \"Race Detection for Event-Driven Mobile Applications\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 326-336, 2014.", "title": "Race Detection for Event-Driven Mobile Applications", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}, {"sec": "sec1", "text": " For example, Android mostly concerns the Android GUI model and asynchronous tasks executed in other threads [14] [15], and client-side JavaScript applications mostly concern about the features like DOM and AJAX [16] [17], while Node.js does not have such features.", "part": "1"}, {"sec": "sec7", "text": " CAFA [14], DroidRacer [15] and EventTrack [40] use dynamic analysis approaches to detect event races in Android applications.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+Detection+for+Event-Driven+Mobile+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "P. Maiya, A. Kanade, R. Majumdar, \"Race Detection For Android Applications\", <em>Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 316-325, 2014.", "title": "Race Detection For Android Applications", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[15][21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}, {"sec": "sec1", "text": " For example, Android mostly concerns the Android GUI model and asynchronous tasks executed in other threads [14] [15], and client-side JavaScript applications mostly concern about the features like DOM and AJAX [16] [17], while Node.js does not have such features.", "part": "1"}, {"sec": "sec7", "text": " CAFA [14], DroidRacer [15] and EventTrack [40] use dynamic analysis approaches to detect event races in Android applications.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2666356.2594311", "abstract": "Programming environments for smartphones expose a concurrency model that combines multi-threading and asynchronous event-based dispatch. While this enables the development of efficient and feature-rich applications, unforeseen thread interleavings coupled with non-deterministic reorderings of asynchronous tasks can lead to subtle concurrency errors in the applications. In this paper, we formalize the concurrency semantics of the Android programming model. We further define the happens-before rel...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+Detection+For+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "S. Hong, Y. Park, M. Kim, \"Detecting Concurrency Errors in Client-Side Java Script Web Applications\", <em>Proceedings of the 17th International Conference on Software Testing Verification and Validation (ICST)</em>, pp. 61-70, 2014.", "title": "Detecting Concurrency Errors in Client-Side Java Script Web Applications", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[16][21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}, {"sec": "sec1", "text": " For example, Android mostly concerns the Android GUI model and asynchronous tasks executed in other threads [14] [15], and client-side JavaScript applications mostly concern about the features like DOM and AJAX [16] [17], while Node.js does not have such features.", "part": "1"}, {"sec": "sec7", "text": " WAVE [16], WebRacer [17] and EventRacer [42] present the happens-before relation for client-side JavaScript applications, and further detect races in them.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+Concurrency+Errors+in+Client-Side+Java+Script+Web+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "B. Petrov, M. Vechev, M. Sridharan, J. Dolby, \"Race Detection for Web Applications\", <em>Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)</em>, pp. 251-262, 2012.", "title": "Race Detection for Web Applications", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[17][21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}, {"sec": "sec1", "text": " For example, Android mostly concerns the Android GUI model and asynchronous tasks executed in other threads [14] [15], and client-side JavaScript applications mostly concern about the features like DOM and AJAX [16] [17], while Node.js does not have such features.", "part": "1"}, {"sec": "sec7", "text": " WAVE [16], WebRacer [17] and EventRacer [42] present the happens-before relation for client-side JavaScript applications, and further detect races in them.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2254064.2254095", "abstract": "Modern web pages are becoming increasingly full-featured, and this additional functionality often requires greater use of asynchrony. Unfortunately, this asynchrony can trigger unexpected concurrency errors, even though web page scripts are executed sequentially. We present the first formulation of a happens-before relation for common web platform features. Developing this relation was a non-trivial task, due to complex feature interactions and browser differences. We also present a logical memo...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Race+Detection+for+Web+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "G. Safi, A. Shahbazian, W. G. J. Halfond, N. Medvidovic, \"Detecting Event Anomalies in Event-Based Systems\", <em>Proceedings of the 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 25-37, 2015.", "title": "Detecting Event Anomalies in Event-Based Systems", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[18][21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786836", "abstract": "Event-based interaction is an attractive paradigm because its use can lead to highly flexible and adaptable systems. One problem in this paradigm is that events are sent, received, and processed nondeterministically, due to the systems\u2019 reliance on implicit invocation and implicit concurrency. This nondeterminism can lead to event anomalies, which occur when an event-based system receives multiple events that lead to the write of a shared field or memory location. Event anomalies can lead to unr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+Event+Anomalies+in+Event-Based+Systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "S. Artzi, J. Dolby, S. H. Jensen, A. Moller, F. Tip, \"A Framework for Automated Testing of JavaScript Web Applications\", <em>Proceedings of the 33rd International Conference on Software Engineering (ICSE)</em>, pp. 571-580, 2011.", "title": "A Framework for Automated Testing of JavaScript Web Applications", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[19][21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985871", "abstract": "Current practice in testing JavaScript web applications requires manual construction of test cases, which is difficult and tedious. We present a framework for feedback-directed automated test generation for JavaScript in which execution is monitored to collect information that directs the test generator towards inputs that yield increased coverage. We implemented several instantiations of the framework, corresponding to variations on feedback-directed random testing, in a tool called Artemis. Ex...", "pdfSize": "2253KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Framework+for+Automated+Testing+of+JavaScript+Web+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "P. Bielik, V. Raychev, M. Vechev, \"Scalable Race Detection for Android Applications\", <em>Proceedings of the ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages and Applications (OOPSLA)</em>, pp. 332-348, 2015.", "title": "Scalable Race Detection for Android Applications", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[20][21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2814270.2814303", "abstract": "We present a complete end-to-end dynamic analysis system for finding data races in mobile Android applications. The capabilities of our system significantly exceed the state of the art: our system can analyze real-world application interactions in minutes rather than hours, finds errors inherently beyond the reach of existing approaches, while still (critically) reporting very few false positives. Our system is based on three key concepts: (i) a thorough happens-before model of Android-specific ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+Race+Detection+for+Android+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Y. Hu, I. Neamtiu, A. Alavi, \"Automatically Verifying and Reproducing Event-Based Races in Android Apps\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 377-388, 2016.", "title": "Automatically Verifying and Reproducing Event-Based Races in Android Apps", "context": [{"sec": "sec1", "text": " For event-driven architectures, e.g., Android and client-side JavaScript applications, researchers have proposed many interesting approaches [14]\u2013[21] to detect event races, in which two events access to the same resource (at least one is write), and can be processed in any order.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931069", "abstract": "Concurrency has been a perpetual problem in Android apps, mainly due to event-based races. Several event-based race detectors have been proposed, but they produce false positives, cannot reproduce races, and cannot distinguish be- tween benign and harmful races. To address these issues, we introduce a race verification and reproduction approach named ERVA. Given a race report produced by a race detector, ERVA uses event dependency graphs, event flipping, and replay to verify the race and determi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+Verifying+and+Reproducing+Event-Based+Races+in+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>Seven Event Queues in Node.js</em>,  [online]  Available: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/.", "title": "Seven Event Queues in Node.js", "context": [{"sec": "sec2a", "text": " According to the official Node.js documents [22], events can be categorized into five types according to their sources: Timeout, Immediate, nextTick, promise, and IO, whose events are generated by setTimeout(), setImmediate(), process.nextTick(), promise, and asynchronous I/O, respectively.", "part": "1"}, {"sec": "sec2a", "text": " Node.js consists of seven event queues that hold different types of events: timers, I/O, pending, idle, prepare, check, and close [22].", "part": "1"}, {"sec": "sec2c", "text": " We need to address four technical challenges. (1) How can we model the contention on external resources, e.g., the file in Fig. 1? Existing studies [8] [9] have shown that about a half of concurrency bugs in Node.js applications contend against external resources. (2) Node.js has various mechanisms for event-driven programming, including several system-specific scheduling APIs, e.g., process.nextTick and promise [22] [25].", "part": "1"}, {"sec": "sec3b", "text": " According to the Node.js official documents [22] and implementation, events in different event queues have different priorities to be processed by the looper thread.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Seven+Event+Queues+in+Node.js&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>A Node.js Application: Change Propagation</em>,  [online]  Available: https://github.com/wikimedia/change-propagation.", "title": "A Node.js Application: Change Propagation", "context": [{"sec": "sec2b", "text": "Fig. 2 shows the simplified code snippet extracted from a real-world Node.js application, change propagation [23], which contains an atomicity violation reported in [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Node.js+Application%3A+Change+Propagation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "<em>No.84 Issue in Change Propagation</em>,  [online]  Available: https://github.com/wikimedia/change-propagation/pull/84.", "title": "No.84 Issue in Change Propagation", "context": [{"sec": "sec2b", "text": "Fig. 2 shows the simplified code snippet extracted from a real-world Node.js application, change propagation [23], which contains an atomicity violation reported in [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=No.84+Issue+in+Change+Propagation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "<em>Promises</em>,  [online]  Available: https://www.promisejs.org/.", "title": "Promises", "context": [{"sec": "sec2c", "text": " We need to address four technical challenges. (1) How can we model the contention on external resources, e.g., the file in Fig. 1? Existing studies [8] [9] have shown that about a half of concurrency bugs in Node.js applications contend against external resources. (2) Node.js has various mechanisms for event-driven programming, including several system-specific scheduling APIs, e.g., process.nextTick and promise [22] [25].", "part": "1"}, {"sec": "sec3a", "text": " In Node.js applications, developers can use system-specific APIs to generate specific events, e.g., process.nextTick, setImmediate, and function resolve in promise [25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Promises&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "<em>Libuv</em>,  [online]  Available: https://github.com/libuv/libuv.", "title": "Libuv", "context": [{"sec": "sec3a", "text": "trigger(libuv, u): Node.js underlying platform (i.e., libuv [26]) can generate timeout events and I/O events, etc.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Libuv&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>Standard Built-in Objects</em>,  [online]  Available: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects.", "title": "Standard Built-in Objects", "context": [{"sec": "sec3a", "text": " JavaScript predefines a large number of native objects [27], such as Array and String.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Standard+Built-in+Objects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "M. C. Loring, M. Marron, D. Leijen, \"Semantics of Asynchronous JavaScript\", <em>Proceedings of the 13th ACM SIGPLAN International Symposium on on Dynamic Languages (DLS)</em>, pp. 51-62, 2017.", "title": "Semantics of Asynchronous JavaScript", "context": [{"sec": "sec3b", "text": " The Node strategy in [28] precisely models the Node.js scheduling: If there exist events of priority 0, then Node.js executes all these events with priority 0 recursively; Otherwise, for events with other priorities (i.e., 1, 2 and 3), Node.js picks one event to execute, regardless of its priority.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3133841.3133846", "abstract": "JavaScript code running in the Node.js runtime is a major platform for developers building cloud, mobile, or IoT applications. A fundamental concept in Node.js programming is the use of asynchronous callbacks and event loops to provide highly responsive applications. While conceptually simple, this programming model contains numerous subtleties and behaviors that are defined implicitly by the current Node.js implementation. This paper presents the first comprehensive formalization of the Node.js...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Semantics+of+Asynchronous+JavaScript&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "<em>Async Hooks</em>,  [online]  Available: https://nodejs.org/api/async_hooks.html.", "title": "Async Hooks", "context": [{"sec": "sec4", "text": "Node.js utilizes the async_hooks module [29], which is introduced in Node.js 8.6, to collect event scheduling operations, namely start(e), end(e), register(e, listener) and \\$trigger(e,u)\\$. async_hooks provides four APIs to track the lifetime of each event: init, before, after and promiseResolve, which are triggered when a callback is registered, before and after an event and when resolve method is invoked.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Async+Hooks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "K. Sen, S. Kalasapur, T. Brutch, S. Gibbs, \"Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for JavaScript\", <em>Proceedings of the 9th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 488-498, 2013.", "title": "Jalangi: A Selective Record-Replay and Dynamic Analysis Framework for JavaScript", "context": [{"sec": "sec4", "text": "NodeAV utilizes Jalangi [30] to collect resource accessing operations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491447", "abstract": "JavaScript is widely used for writing client-side web applications and is getting increasingly popular for writing mobile applications. However, unlike C, C++, and Java, there are not that many tools available for analysis and testing of JavaScript applications. In this paper, we present a simple yet powerful framework, called Jalangi, for writing heavy-weight dynamic analyses. Our framework incorporates two key techniques: 1) selective record-replay, a technique which enables to record and to f...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jalangi%3A+A+Selective+Record-Replay+and+Dynamic+Analysis+Framework+for+JavaScript&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "<em>Cloc: count lines of code</em>,  [online]  Available: https://github.com/A1Danial/cloc.", "title": "Cloc: count lines of code", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cloc%3A+count+lines+of+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "<em>Net - Node.js v11.7.0 Documentation</em>,  [online]  Available: https://nodejs.org/api/net.html#net_socket_destroy_exception.", "title": "Net - Node.js v11.7.0 Documentation", "context": [{"sec": "sec5b", "text": " It is because we do not model the Net API destroy() [32] in Section III.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Net+-+Node.js+v11.7.0+Documentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "<em>A race condition_log() while closing the endpoint</em>,  [online]  Available: https://github.com/michaelwittig/node-logger-file/issues/5.", "title": "A race condition_log() while closing the endpoint", "context": [{"sec": "sec5b", "text": " We have reported these atomicity violations on GitHub [33]\u2013[35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+race+condition_log%28%29+while+closing+the+endpoint&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "<em>A race condtion logging a file while rolling a file</em>,  [online]  Available: https://github.com/michaelwittig/node-logger-file/issues/4.", "title": "A race condtion logging a file while rolling a file", "context": [{"sec": "sec5b", "text": " We have reported these atomicity violations on GitHub [33]\u2013[34][35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+race+condtion+logging+a+file+while+rolling+a+file&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "<em>A race condition invalidateToken while authenticating a request</em>,  [online]  Available: https://github.com/telefonicaid/fiware-pep-steelskin/issues/412.", "title": "A race condition invalidateToken while authenticating a request", "context": [{"sec": "sec5b", "text": " We have reported these atomicity violations on GitHub [33]\u2013[35].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+race+condition+invalidateToken+while+authenticating+a+request&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "Q. Gao, W. Zhang, Z. Chen, M. Zheng, F. Qin, \"2ndStrike: Toward Manifesting Hidden Concurrency Typestate Bugs\", <em>Proceedings of the 16th International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 239-250, 2011.", "title": "2ndStrike: Toward Manifesting Hidden Concurrency Typestate Bugs", "context": [{"sec": "sec6b", "text": " A more precise model about file systems, e.g., the state machine in 2ndStrike [36] can be integrated into NodeAV.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1950365.1950394", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=2ndStrike%3A+Toward+Manifesting+Hidden+Concurrency+Typestate+Bugs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "C. Flanagan, S. N. Freund, \"FastTrack: Efficient and Precise Dynamic Race Detection\", <em>Acm Sigplan Not.</em>, vol. 44, no. 6, pp. 121-133, 2009.", "title": "FastTrack: Efficient and Precise Dynamic Race Detection", "context": [{"sec": "sec7", "text": " Many approaches and tools have been developed to identify concurrency bugs in multithreaded programs, e.g., FastTrack [37], Eraser [38] for data races, AVIO [10], CTrigger [11], and Atomizer [39] for atomicity violations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1543135.1542490", "abstract": "\\begin{abstract} Multithreaded programs are notoriously prone to race conditions. Prior work on dynamic race detectors includes fast but imprecise race detectors that report false alarms, as well as slow but precise race detectors that never report false alarms. The latter typically use expensive vector clock operations that require time linear in the number of program threads. This paper exploits the insight that the full generality of vector clocks is unnecessary in most cases. That is, we can...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=FastTrack%3A+Efficient+and+Precise+Dynamic+Race+Detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "S. Savage, M. Burrows, G. Nelson, P. Sobalvarro, T. Anderson, \"Eraser: A Dynamic Data Race Detector for Multithreaded Programs\", <em>ACM Trans. Comput. Syst.</em>, vol. 15, no. 4, pp. 391-411, 1997.", "title": "Eraser: A Dynamic Data Race Detector for Multithreaded Programs", "context": [{"sec": "sec7", "text": " Many approaches and tools have been developed to identify concurrency bugs in multithreaded programs, e.g., FastTrack [37], Eraser [38] for data races, AVIO [10], CTrigger [11], and Atomizer [39] for atomicity violations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/265924.265927", "abstract": "Multithreaded programming is difficult and error prone. It is easy to make a mistake in synchronization that produces a data race, yet it can be extremely hard to locate this mistake during debugging. This article describes a new tool, called Eraser, for dynamically detecting data races in lock-based multithreaded programs. Eraser uses binary rewriting techniques to monitor every shared-monory reference and verify that consistent locking behavior is observed. We present several case studies, inc...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eraser%3A+A+Dynamic+Data+Race+Detector+for+Multithreaded+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "C. Flanagan, S. N. Freund, \"Atomizer: A Dynamic Atomicity Checker for Multithreaded Programs\", <em>Proceedings of the 31st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL)</em>, pp. 256-267, 2004.", "title": "Atomizer: A Dynamic Atomicity Checker for Multithreaded Programs", "context": [{"sec": "sec7", "text": " Many approaches and tools have been developed to identify concurrency bugs in multithreaded programs, e.g., FastTrack [37], Eraser [38] for data races, AVIO [10], CTrigger [11], and Atomizer [39] for atomicity violations.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/964001.964023", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Atomizer%3A+A+Dynamic+Atomicity+Checker+for+Multithreaded+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "P. Maiya, A. Kanade, \"Efficient Computation of Happens-Before Relation for Event-Driven Programs\", <em>Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 102-112, 2017.", "title": "Efficient Computation of Happens-Before Relation for Event-Driven Programs", "context": [{"sec": "sec7", "text": " CAFA [14], DroidRacer [15] and EventTrack [40] use dynamic analysis approaches to detect event races in Android applications.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3092703.3092733", "abstract": "An emerging style of programming is to use both threads and events to achieve better scalability. The improved scalability comes at the price of increased complexity, as both threads and events can follow non-deterministic schedules. The happens-before (HB) relation captures the space of possible schedules and forms the basis of various concurrency analyses. Improving efficiency of the HB computation can speed up these analyses. In this paper, we identify a major bottleneck in computation of the...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+Computation+of+Happens-Before+Relation+for+Event-Driven+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "Y. Hu, I. Neamtiu, \"Static Detection of Event-based Races in Android Apps\", <em>Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS)</em>, pp. 257-270, 2018.", "title": "Static Detection of Event-based Races in Android Apps", "context": [{"sec": "sec7", "text": " SIERRA [41] proposes a precise and scalable static approach for detecting Android event races.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3173162.3173173", "abstract": "Event-based races are the main source of concurrency errors in Android apps. Prior approaches for scalable detection of event-based races have been dynamic. Due to their dynamic nature, these approaches suffer from coverage and false negative issues. We introduce a precise and scalable static approach and tool, named SIERRA, for detecting Android event-based races. SIERRA is centered around a new concept of &#34;concurrency action&#34; (that reifies threads, events/messages, system and user actions) and...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+Detection+of+Event-based+Races+in+Android+Apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "V. Raychev, M. Vechev, M. Sridharan, \"Effective Race Detection for Event-Driven Programs\", <em>Proceedings of the ACM SIGPLAN International Conference on Object Oriented Programming Systems Languages & Applications (OOPSLA)</em>, pp. 151-166, 2013.", "title": "Effective Race Detection for Event-Driven Programs", "context": [], "links": {"acmLink": "https://doi.org/10.1145/2509136.2509538", "abstract": "Like shared-memory multi-threaded programs, event-driven programs such as client-side web applications are susceptible to data races that are hard to reproduce and debug. Race detection for such programs is hampered by their pervasive use of ad hoc synchronization, which can lead to a prohibitive number of false positives. Race detection also faces a scalability challenge, as a large number of short-running event handlers can quickly overwhelm standard vector-clock-based techniques. This paper p...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+Race+Detection+for+Event-Driven+Programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "W. Wang, Y. Zheng, P. Liu, L. Xu, X. Zhang, P. Eugster, \"ARROW: Automated Repair of Races on Client-Side Web Pages\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis (ISSTA)</em>, pp. 201-212, 2016.", "title": "ARROW: Automated Repair of Races on Client-Side Web Pages", "context": [{"sec": "sec7", "text": " ARROW [43] further proposes to automatically fix races in client-side JavaScript applications.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931052", "abstract": "Modern browsers have a highly concurrent page rendering process in order to be more responsive. However, such a concurrent execution model leads to various race issues. In this paper, we present ARROW, a static technique that can automatically, safely, and cost effectively patch certain race issues on client side pages. It works by statically modeling a web page as a causal graph denoting happens-before relations between page elements, according to the rendering process in browsers. Races are de...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=ARROW%3A+Automated+Repair+of+Races+on+Client-Side+Web+Pages&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "D. Bonetta, L. Salucci, S. Marr, W. Binder, \"GEMs: Shared-Memory Parallel Programming for Node.js\", <em>Proceedings of ACM SIGPLAN International Conference on Object-Oriented Programming Systems Languages & Applications (OOPSLA)</em>, pp. 531-547, 2016.", "title": "GEMs: Shared-Memory Parallel Programming for Node.js", "context": [{"sec": "sec7", "text": " GEMs [44] presents a new parallel programming abstraction in Node.js, which combines message passing and shared-memory parallelism.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2983990.2984039", "abstract": "JavaScript is the most popular programming language for client-side Web applications, and Node.js has popularized the language for server-side computing, too. In this domain, the minimal support for parallel programming remains however a major limitation. In this paper we introduce a novel parallel programming abstraction called Generic Messages (GEMs). GEMs allow one to combine message passing and shared-memory parallelism, extending the classes of parallel applications that can be built with N...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=GEMs%3A+Shared-Memory+Parallel+Programming+for+Node.js&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "M. Madsen, F. Tip, O. Lhot\u00e1k, \"Static Analysis of Event-Driven Node.js JavaScript Applications\", <em>Acm Sigplan Not.</em>, vol. 50, no. 10, pp. 505-519, 2015.", "title": "Static Analysis of Event-Driven Node.js JavaScript Applications", "context": [{"sec": "sec7", "text": " [45] proposes a static analysis approach to build the event-based call graph and detect bugs related to event handling, e.g., unhandled events and listeners registered too late.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2858965.2814272", "abstract": "Many JavaScript programs are written in an event-driven style. In particular, in server-side Node.js applications, operations involving sockets, streams, and files are typically performed in an asynchronous manner, where the execution of listeners is triggered by events. Several types of programming errors are specific to such event-based programs (e.g., unhandled events, and listeners that are registered too late). We present the event-based call graph, a program representation that can be used...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+Analysis+of+Event-Driven+Node.js+JavaScript+Applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "J. Davis, G. Kildow, D. Lee, \"The Case of the Poisoned Event Handler: Weaknesses in the Node.js Event-Driven Architecture\", <em>Proceedings of the European Workshop on Systems Security (EuroSec)</em>, pp. 1-6, 2017.", "title": "The Case of the Poisoned Event Handler: Weaknesses in the Node.js Event-Driven Architecture", "context": [{"sec": "sec7", "text": " Since Node.js heavily depends on event handlers to achieve effective responsiveness, if an event handler performs a heavy computation, then it can block the event loop, and cause denial of service attacks [46].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3065913.3065916", "abstract": "Node.js has seen rapid adoption in industry and the open-source community. Unfortunately, its event-driven architecture exposes Node.js applications to Event Handler-Poisoning denial of service attacks. Our evaluation of the state of practice in Node.js--- combining a study of 353 publicly reported security vulnerabilities and a survey of 151 representative npm modules --- demonstrates that the community is not equipped to combat this class of attack. We recommend several changes to the state of...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Case+of+the+Poisoned+Event+Handler%3A+Weaknesses+in+the+Node.js+Event-Driven+Architecture&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "A. Ojamaa, K. D\u00fc\u00fcna, \"Assessing the Security of Node. js Platform\", <em>Proceedings of the International Conference for Internet Technology and Secured Transactions (ICITST)</em>, pp. 348-355, 2012.", "title": "Assessing the Security of Node. js Platform", "context": [{"sec": "sec7", "text": " [47] argue how the Node.js design affects the security of Node.js applications.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Assessing+the+Security+of+Node.+js+Platform&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "C.-A. Staicu, M. Pradel, B. Livshits, \"Understanding and Automatically Preventing Injection Attacks on Node.js\", <em>Proceedings of Network and Distributed Systems Security (NDSS)</em>, 2018.", "title": "Understanding and Automatically Preventing Injection Attacks on Node.js", "context": [{"sec": "sec7", "text": " Synode [48] proposes a static analysis approach to prevent injection attack.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.14722/ndss.2018.23071", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+and+Automatically+Preventing+Injection+Attacks+on+Node.js&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811949", "articleId": "8811949", "startPage": "631", "endPage": "642", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 77}}
{"title": "Dynamic Slicing for Android", "authors": [{"name": "Tanzirul Azim", "affiliation": "University of California, Riverside", "firstName": "Tanzirul", "lastName": "Azim", "id": "37075147200"}, {"name": "Arash Alavi", "affiliation": "University of California, Riverside", "firstName": "Arash", "lastName": "Alavi", "id": "37086951452"}, {"name": "Iulian Neamtiu", "affiliation": "New Jersey Institute of Technology", "firstName": "Iulian", "lastName": "Neamtiu", "id": "37269709800"}, {"name": "Rajiv Gupta", "affiliation": "University of California, Riverside", "firstName": "Rajiv", "lastName": "Gupta", "id": "37272679200"}], "abstract": "Dynamic program slicing is useful for a variety of tasks, from testing to debugging to security. Prior slicing approaches have targeted traditional desktop/server platforms, rather than mobile platforms such as Android. Slicing mobile, event-based systems is challenging due to their asynchronous callback construction and the IPC (interprocess communication)- heavy, sensor-driven, timing-sensitive nature of the platform. To address these problems, we introduce AndroidSlicer1, the first slicing approach for Android. AndroidSlicer combines a novel asynchronous slicing approach for modeling data and control dependences in the presence of callbacks with lightweight and precise instrumentation; this allows slicing for apps running on actual phones, and without requiring the app's source code. Our slicer is capable of handling a wide array of inputs that Android supports without adding any noticeable overhead. Experiments on 60 apps from Google Play show that AndroidSlicer is effective (reducing the number of instructions to be examined to 0.3% of executed instructions) and efficient (app instrumentation and post-processing combined takes 31 seconds); all while imposing a runtime overhead of just 4%. We present three applications of AndroidSlicer that are particularly relevant in the mobile domain: (1) finding and tracking input parts responsible for an error/crash, (2) fault localization, i.e., finding the instructions responsible for an error/crash, and (3) reducing the regression test suite. Experiments with these applications on an additional set of 18 popular apps indicate that AndroidSlicer is effective for Android testing and debugging.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Smart phones", "Registers", "Computer crashes", "Testing", "Runtime", "Debugging", "Pins"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "mobile computing", "program debugging", "program slicing", "program testing"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["timing-sensitive nature", "AndroidSlicer1", "modeling data", "control dependences", "lightweight instrumentation", "precise instrumentation", "executed instructions", "mobile domain", "tracking input parts", "regression test suite", "Android testing", "debugging", "dynamic program slicing", "mobile platforms", "mobile event-based systems", "asynchronous callback construction", "IPC", "interprocess communication", "asynchronous slicing approach"]}, {"type": "Author Keywords ", "kwd": ["Mobile apps, Android, Dynamic analysis"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00118", "ref": [{"order": "1", "text": "B. Popper, <em>Google announces over 2 billion monthly active devices on android</em>,  [online]  Available: https://www.theverge.com/2017/5/17/15654454/android-reaches-2-billion-monthly-active-users.", "title": "Google announces over 2 billion monthly active devices on android", "context": [{"sec": "sec1", "text": "While mobile platforms have been very successful - Android alone runs on more than 2 billion devices [1] - they are prone to development, testing, and reliability issues that affect users, developers, and manufacturers [2], [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google+announces+over+2+billion+monthly+active+devices+on+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "B. Zhou, I. Neamtiu, R. Gupta, \"Experience report: How do bug characteristics differ across severity classes: A multi-platform study\", <em>Software Reliability Engineering (ISSRE) 2015 IEEE 26th International Symposium</em>, pp. 507-517, Nov 2015.", "title": "Experience report: How do bug characteristics differ across severity classes: A multi-platform study", "context": [{"sec": "sec1", "text": "While mobile platforms have been very successful - Android alone runs on more than 2 billion devices [1] - they are prone to development, testing, and reliability issues that affect users, developers, and manufacturers [2], [3].", "part": "1"}], "links": {"documentLink": "/document/7381843", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7381843", "abstract": "Bugs of different severities have so far been put into the same category, but their characteristics differ significantly. Moreover, the nature of issues with the same severity, e.g., high, differs markedly between desktops and smartphones. To understand these differences, we perform an empirical study on 72 Android and desktop projects. We first define three bug severity classes: high, medium, and low. Next, we study how severity changes and quantify differences between classes in terms of bug-f...", "pdfSize": "226KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Experience+report%3A+How+do+bug+characteristics+differ+across+severity+classes%3A+A+multi-platform+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "\"A cross-platform analysis of bugs and bug-fixing in open source projects: Desktop vs. android vs. ios\", <em>19th International Conference on Evaluation and Assessment in Software Engineering EASE 2015</em>, pp. 10, April 2015.", "title": "A cross-platform analysis of bugs and bug-fixing in open source projects: Desktop vs. android vs. ios", "context": [{"sec": "sec1", "text": "While mobile platforms have been very successful - Android alone runs on more than 2 billion devices [1] - they are prone to development, testing, and reliability issues that affect users, developers, and manufacturers [2], [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+cross-platform+analysis+of+bugs+and+bug-fixing+in+open+source+projects%3A+Desktop+vs.+android+vs.+ios&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "B. Korel, J. Laski, \"Dynamic program slicing\", <em>Information Processing Letters</em>, vol. 29, pp. 155-163, October 1988.", "title": "Dynamic program slicing", "context": [{"sec": "sec1", "text": " Slicing has proven useful in many contexts, from security (e.g., taint analysis) to debugging (e.g., fault localization) and testing, but prior slicing approaches have not targeted mobile platforms [4]\u2013[6].", "part": "1"}, {"sec": "sec2", "text": " Dynamic program slicing, a class of dynamic analysis, was introduced by Korel and Laski [4].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0020-0190(88)90054-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+program+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "N. Sasirekha, A. E. Robert, M. Hemalatha, \"Program slicing techniques and its applications\", <em>CoRR</em>, vol. abs/1108.1352, 2011.", "title": "Program slicing techniques and its applications", "context": [{"sec": "sec1", "text": " Slicing has proven useful in many contexts, from security (e.g., taint analysis) to debugging (e.g., fault localization) and testing, but prior slicing approaches have not targeted mobile platforms [4]\u2013[5][6].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.5121/ijsea.2011.2304", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program+slicing+techniques+and+its+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "J. Maras, J. Carlson, I. Crnkovic, \"Client-side web application slicing\", <em>ASE</em>, 2011.", "title": "Client-side web application slicing", "context": [{"sec": "sec1", "text": " Slicing has proven useful in many contexts, from security (e.g., taint analysis) to debugging (e.g., fault localization) and testing, but prior slicing approaches have not targeted mobile platforms [4]\u2013[6].", "part": "1"}, {"sec": "sec8", "text": "Slicing event-based programs has been investigated for Web applications [6], [15], [16] written in HTML, PHP, and JavaScript.", "part": "1"}, {"sec": "sec8", "text": " These approaches record traces through a browser plugin [6] and construct the UI model to generate the event nodes.", "part": "1"}], "links": {"documentLink": "/document/6100110", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6100110", "abstract": "Highly interactive web applications that offer user experience and responsiveness of standard desktop applications are becoming prevalent in the web application domain. However, with these benefits come certain drawbacks. For example, the event-based architectural style, and poor support for code organization, often lead to a situation where code responsible for a certain behavior is intermixed with irrelevant code. This makes development, debugging and reuse difficult. One way of locating code ...", "pdfSize": "109KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Client-side+web+application+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C.-K. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, K. Hazelwood, \"Pin: Building customized program analysis tools with dynamic instrumentation\", <em>Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI \u201805</em>, pp. 190-200, 2005.", "title": "Pin: Building customized program analysis tools with dynamic instrumentation", "context": [{"sec": "sec1", "text": " Capturing this input correctly without losing precision is challenging, and introduces significant overhead in other tools, e.g., Pin [7].", "part": "1"}, {"sec": "sec4a", "text": " First, even just attaching the standard dynamic analyzer Pin [7] to an Android app - a trivial operation on desktop/server - can have unacceptable overhead, or outright crash the app.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1065010.1065034", "abstract": "Robust and powerful software instrumentation tools are essential for program analysis tasks such as profiling, performance evaluation, and bug detection. To meet this need, we have developed a new instrumentation system called Pin. Our goals are to provide easy-to-use, portable, transparent, and efficient instrumentation. Instrumentation tools (called Pintools) are written in C/C++ using Pin&#39;s rich API. Pin follows the model of ATOM, allowing the tool writer to analyze an application at the inst...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pin%3A+Building+customized+program+analysis+tools+with+dynamic+instrumentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "\"App Components\", <em>Android Developers</em>, 2017,  [online]  Available: https://developer.android.com/guide/components/index.html.", "title": "App Components", "context": [{"sec": "fn3", "text": " There are other component types such as Services, Content Providers, and Broadcast Receiver [8] but these are used much more sparsely.", "type": "footnote"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=App+Components&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "L. Gomez, I. Neamtiu, T. Azim, T. Millstein, \"Reran: Timing- and touch-sensitive record and replay for android\", <em>ICSE 2013</em>.", "title": "Reran: Timing- and touch-sensitive record and replay for android", "context": [{"sec": "sec4a", "text": " Second, introducing delays in GUI event processing can alter the semantics of the event: an instrumented app running slower might interpret one long swipe as two shorter swipes [9].", "part": "1"}, {"sec": "sec4b", "text": " A simple swipe gesture is 301 events per second [9].", "part": "1"}], "links": {"documentLink": "/document/7190045", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7190045", "abstract": "Touchscreen-based devices such as smartphones and tablets are gaining popularity but their rich input capabilities pose new development and testing complications. To alleviate this problem, we present an approach and tool named RERAN that permits record-and-replay for the Android smartphone platform. Existing GUI-level record-and-replay approaches are inadequate due to the expressiveness of the smartphone domain, in which applications support sophisticated GUI gestures, depend on inputs from a v...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reran%3A+Timing-+and+touch-sensitive+record+and+replay+for+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "Y. Hu, T. Azim, I. Neamtiu, \"Versatile yet lightweight record-and-replay for android\", <em>Proc. of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming Systems Languages and Applications ser. OOPSLA 2015</em>, pp. 349-366, 2015.", "title": "Versatile yet lightweight record-and-replay for android", "context": [{"sec": "sec4a", "text": " Third, harmful interference due to delays in GPS timing, or in event delivery and scheduling, can easily derail an execution [10].", "part": "1"}, {"sec": "sec4b", "text": " Typical per-second event rates are 70 for GPS, 54 for the camera, 386 for audio, and 250 for network [10].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2814270.2814320", "abstract": "Recording and replaying the execution of smartphone apps is useful in a variety of contexts, from reproducing bugs to profiling and testing. Achieving effective record-and-replay is a balancing act between accuracy and overhead. On smartphones, the act is particularly complicated, because smartphone apps receive a high-bandwidth stream of input (e.g., network, GPS, camera, microphone, touchscreen) and concurrency events, but the stream has to be recorded and replayed with minimal overhead, to av...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Versatile+yet+lightweight+record-and-replay+for+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "R. Vall\u00e9e-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, V. Sundaresan, \"Soot - a java bytecode optimization framework\", <em>Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collaborative Research ser. CASCON \u201899</em>, pp. 13, 1999.", "title": "Soot - a java bytecode optimization framework", "context": [{"sec": "sec5a", "text": " We add tracing capabilities via Soot [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Soot+-+a+java+bytecode+optimization+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "H. Agrawal, J. R. Horgan, E. W. Krauser, S. London, \"Incremental regression testing\", <em>Proceedings of the Conference on Software Maintenance ser. ICSM \u201893</em>, pp. 348-357, 1993.", "title": "Incremental regression testing", "context": [{"sec": "sec6c", "text": " Prior work [12], [13] has shown that slicing reduces the number of test cases that have to be rerun during regression testing (though for traditional apps).", "part": "1"}, {"sec": "sec6c", "text": " [12] used dynamic slicing to find \\$\\mathrm{T}_{2}\\$ as follows: given a program, its test cases, and slices for test cases, after the program is modified, rerun only those test cases whose slices contain a modified statement.", "part": "1"}, {"sec": "sec6c", "text": " This reduces the test suite because only a subset of program statements (the statements in the slice) have an effect on the slicing start point (program output, in their approach [12]).", "part": "1"}], "links": {"documentLink": "/document/366927", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=366927", "abstract": "The purpose of regression testing is to ensure that bug fixes and new functionality introduced in a new version of a software do not adversely affect the correct functionality inherited from the previous version. Efficient methods of selecting small subsets of regression test sets that can be used to ensure correct functionality are explored.<>", "pdfSize": "962KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Incremental+regression+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "R. Gupta, M. J. Harrold, M. L. Soffa, \"An approach to regression testing using slicing\", <em>Proceedings Conference on Software Maintenance 1992</em>, pp. 299-308, Nov 1992.", "title": "An approach to regression testing using slicing", "context": [{"sec": "sec6c", "text": " Prior work [12], [13] has shown that slicing reduces the number of test cases that have to be rerun during regression testing (though for traditional apps).", "part": "1"}], "links": {"documentLink": "/document/242531", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=242531", "abstract": "The authors present a novel approach to data-flow-based regression testing that uses slicing type algorithms to explicitly detect definition-use pairs that are affected by a program change. An important benefit of the slicing technique is that, unlike previous techniques, no data flow history is needed nor is the recomputation of data flow for the entire program required to detect affected definition-use pairs. The program changes drive the recomputation of the required partial data flow through...", "pdfSize": "737KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+approach+to+regression+testing+using+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "\"UI/Application Exerciser Monkey\", <em>Android Developers</em>, November 2017,  [online]  Available: http://developer.android.com/tools/help/monkey.html.", "title": "UI/Application Exerciser Monkey", "context": [{"sec": "sec7a", "text": " To drive app execution, we used Monkey [14] to send the app 1,000 UI events and then collected traces for offline analysis.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=UI%2FApplication+Exerciser+Monkey&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "P. Tonella, F. Ricca, \"Web application slicing in presence of dynamic code generation\", <em>Automated Software Engg.</em>, pp. 259-288.", "title": "Web application slicing in presence of dynamic code generation", "context": [{"sec": "sec8", "text": "Slicing event-based programs has been investigated for Web applications [6], [15], [16] written in HTML, PHP, and JavaScript.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-005-6208-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Web+application+slicing+in+presence+of+dynamic+code+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "F. Ricca, P. Tonella, \"Construction of the system dependence graph for web application slicing\", <em>Proceedings of the Second IEEE International Workshop on Source Code Analysis and Manipulation ser. SCAM \u201802</em>, pp. 123, 2002.", "title": "Construction of the system dependence graph for web application slicing", "context": [{"sec": "sec8", "text": "Slicing event-based programs has been investigated for Web applications [6], [15], [16] written in HTML, PHP, and JavaScript.", "part": "1"}], "links": {"documentLink": "/document/1134112", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1134112", "abstract": "The computation of program slices on Web applications may be useful during debugging, when the amount of code to be inspected can be reduced, and during understanding, since the search for a given functionality can be better focused. The system dependence graph is an appropriate data structure for slice computation, in that it explicitly represents all dependences that have to be taken into account in slice determination. In this paper the main problems related to the construction of the system ...", "pdfSize": "548KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Construction+of+the+system+dependence+graph+for+web+application+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "T. Wang, A. Roychoudhury, Using compressed bytecode traces for slicing java programs, 2004.", "title": "Using compressed bytecode traces for slicing java programs", "context": [{"sec": "sec8", "text": "Traditional program slicing of Java bytecode has only targeted single-entry sequential Java programs [17]\u2013[20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+compressed+bytecode+traces+for+slicing+java+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "T. Wang, A. Roychoudhury, \"Dynamic slicing on java bytecode traces\", <em>ACM Trans. Program. Lang. Syst.</em>, pp. 10:1-10:49, 2008.", "title": "Dynamic slicing on java bytecode traces", "context": [{"sec": "sec8", "text": "Traditional program slicing of Java bytecode has only targeted single-entry sequential Java programs [17]\u2013[18][20].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1330017.1330021", "abstract": "Dynamic slicing is a well-known technique for program analysis, debugging and understanding. Given a program P and input I, it finds all program statements which directly/indirectly affect the values of some variables&#39; occurrences when P is executed with I. In this article, we develop a dynamic slicing method for Java programs. Our technique proceeds by backwards traversal of the bytecode trace produced by an input I in a given program P. Since such traces can be huge, we use results from data c...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+slicing+on+java+bytecode+traces&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "\"jslice\", November 2017,  [online]  Available: http://jslice.sourceforge.net/.", "title": "jslice", "context": [{"sec": "sec8", "text": "Traditional program slicing of Java bytecode has only targeted single-entry sequential Java programs [17]\u2013[19][20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=jslice&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "A. Szegedi, T. Gyimothy, \"Dynamic slicing of java bytecode programs\", <em>2013 IEEE 13th International Working Conference on Source Code Analysis and Manipulation (SCAM)</em>, pp. 35-44, 2005.", "title": "Dynamic slicing of java bytecode programs", "context": [{"sec": "sec8", "text": "Traditional program slicing of Java bytecode has only targeted single-entry sequential Java programs [17]\u2013[20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+slicing+of+java+bytecode+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Y. Zhou, L. Wu, Z. Wang, X. Jiang, \"Harvesting developer credentials in android apps\", <em>Proceedings of the 8th ACM Conference on Security & Privacy in Wireless and Mobile Networks ser. WiSec \u201815</em>, pp. 23: 1-23: 12, 2015.", "title": "Harvesting developer credentials in android apps", "context": [{"sec": "sec8", "text": " [21] and Zeng et al. [22] have used bytecode slicing for Android apps, but to achieve entirely different goals: mining sensitive credentials inside the app and generating low-level equivalent C code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2766498.2766499", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Harvesting+developer+credentials+in+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "J. Zeng, Y. Fu, K. A. Miller, Z. Lin, X. Zhang, D. Xu, \"Obfuscation resilient binary code reuse through trace-oriented programming\", <em>Proceedings of the 2013 ACM SIGSAC Conference on Computer & Communications Security ser. CCS \u201813</em>, pp. 487-498, 2013.", "title": "Obfuscation resilient binary code reuse through trace-oriented programming", "context": [{"sec": "sec8", "text": " [22] have used bytecode slicing for Android apps, but to achieve entirely different goals: mining sensitive credentials inside the app and generating low-level equivalent C code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516664", "abstract": "With the wide existence of binary code, it is desirable to reuse it in many security applications, such as malware analysis and software patching. While prior approaches have shown that binary code can be extracted and reused, they are often based on static analysis and face challenges when coping with obfuscated binaries. This paper introduces trace-oriented programming (TOP), a general framework for generating new software from existing binary code by elevating the low-level binary code to C c...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Obfuscation+resilient+binary+code+reuse+through+trace-oriented+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "H. Agrawal, J. R. Horgan, \"Dynamic program slicing\", <em>Proceedings of the ACM SIGPLAN 1990 Conference on Programming Language Design and Implementation ser. PLDI \u201890</em>, pp. 246-256, 1990.", "title": "Dynamic program slicing", "context": [{"sec": "sec8", "text": "Compared to Agrawal and Horgan's slicing for traditional programs [23], we add support for Android's intricacies, node merging for control dependence edges, dealing with slicing in the presence of restarts as well as asynchronous callback invocation.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/93542.93576", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+program+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "X. Zhang, S. Tallam, R. Gupta, \"Dynamic slicing long running programs through execution fast forwarding\", <em>ser. SIGSOFT \u201806/FSE-14</em>, pp. 81-91, 2006.", "title": "Dynamic slicing long running programs through execution fast forwarding", "context": [{"sec": "sec8", "text": " Slicing multithreaded programs is tangentially related work, where slicing was used to debug multithreaded C programs [24]\u2013[28] - this setup differs greatly from ours.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1181775.1181786", "abstract": "Fixing runtime bugs in long running programs using trace based analyses such as dynamic slicing was believed to be prohibitively expensive. In this paper, we present a novel execution fast forwarding technique that makes this feasible. While a naive solution is to divide the entire execution by checkpoints, and then apply dynamic slicing enabled by tracing to one checkpoint interval at a time, it is still too costly even with state-of-the-art tracing techniques. Our technique is derived from two...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+slicing+long+running+programs+through+execution+fast+forwarding&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "S. Tallam, C. Tian, R. Gupta, X. Zhang, \"Enabling tracing of long-running multithreaded programs via dynamic execution reduction\", <em>ser. ISSTA \u201807</em>, pp. 207-218, 2007.", "title": "Enabling tracing of long-running multithreaded programs via dynamic execution reduction", "context": [{"sec": "sec8", "text": " Slicing multithreaded programs is tangentially related work, where slicing was used to debug multithreaded C programs [24]\u2013[25][28] - this setup differs greatly from ours.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1273463.1273491", "abstract": "Debugging long running multithreaded programs is a very challenging problem when using tracing-based analyses. Since such programs are non-deterministic, reproducing the bug is non-trivial and generating and inspecting traces for long running programs can be prohibitively expensive. We propose a framework in which, to overcome the problem of bug reproducibility, a lightweight logging technique is used to log the events during the original execution. When a bug is encountered, it is reproduced us...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enabling+tracing+of+long-running+multithreaded+programs+via+dynamic+execution+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "S. Tallam, C. Tian, R. Gupta, \"Dynamic slicing of multithreaded programs for race detection\", <em>ICSM'08</em>, pp. 97-106, 2008.", "title": "Dynamic slicing of multithreaded programs for race detection", "context": [{"sec": "sec8", "text": " Slicing multithreaded programs is tangentially related work, where slicing was used to debug multithreaded C programs [24]\u2013[26][28] - this setup differs greatly from ours.", "part": "1"}], "links": {"documentLink": "/document/4658058", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4658058", "abstract": "Prior work has shown that computing dynamic slices of erroneous program values can greatly assist in locating the root cause of erroneous behavior by identifying faulty statements in sequential programs. These dynamic slices represent backward transitive closure over exercised read-after-write data dependences and control dependences. However, for a multithreaded program executing on a processor, data races represent an additional source of errors which are not captured by dynamic slices. We pre...", "pdfSize": "331KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dynamic+slicing+of+multithreaded+programs+for+race+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "D. Weeratunge, X. Zhang, W. N. Sumner, S. Jagannathan, \"Analyzing concurrency bugs using dual slicing\", <em>ser. ISSTA'10</em>, pp. 253-264, 2010.", "title": "Analyzing concurrency bugs using dual slicing", "context": [{"sec": "sec8", "text": " Slicing multithreaded programs is tangentially related work, where slicing was used to debug multithreaded C programs [24]\u2013[27][28] - this setup differs greatly from ours.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1831708.1831740", "abstract": "Recently, there has been much interest in developing analyzes to detect concurrency bugs that arise because of data races, atomicity violations, execution omission, etc. However, determining whether reported bugs are in fact real, and understanding how these bugs lead to incorrect behavior, remains a labor-intensive process. This paper proposes a novel dynamic analysis that automatically produces the causal path of a concurrent failure leading from the root cause to the failure. Given two schedu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analyzing+concurrency+bugs+using+dual+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "Y. Wang, H. Patil, C. Pereira, G. Lueck, R. Gupta, I. Neamtiu, \"Drdebug: Deterministic replay based cyclic debugging with dynamic slicing\", <em>Proceedings of Annual IEEE/ACM International Symposium on Code Generation and Optimization ser. CGO \u201814</em>, pp. 98:98-98: 108, 2014.", "title": "Drdebug: Deterministic replay based cyclic debugging with dynamic slicing", "context": [{"sec": "sec8", "text": " Slicing multithreaded programs is tangentially related work, where slicing was used to debug multithreaded C programs [24]\u2013[28] - this setup differs greatly from ours.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2581122.2544152", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Drdebug%3A+Deterministic+replay+based+cyclic+debugging+with+dynamic+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "J. Hoffmann, M. Ussath, T. Holz, M. Spreitzenbarth, \"Slicing droids: Program slicing for smali code\", <em>Proceedings of the 28th Annual ACM Symposium on Applied Computing ser. SAC \u201813</em>, pp. 1844-1851, 2013.", "title": "Slicing droids: Program slicing for smali code", "context": [{"sec": "sec8", "text": "Hoffmann et. al. developed SAAF [29], a static slicing framework for Android apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2480362.2480706", "abstract": "The popularity of mobile devices like smartphones and tablets has increased significantly in the last few years with many millions of sold devices. This growth also has its drawbacks: attackers have realized that smartphones are an attractive target and in the last months many different kinds of malicious software (short: malware) for such devices have emerged. This worrisome development has the potential to hamper the prospering ecosystem of mobile devices and the potential for damage is huge. ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Slicing+droids%3A+Program+slicing+for+smali+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "D. Binkley, S. Danicic, T. Gyimothy, M. Harman, A. Kiss, B. Korel, \"Theoretical foundations of dynamic program slicing\", <em>Theoretical Computer Science</em>, pp. 23-41, 2006.", "title": "Theoretical foundations of dynamic program slicing", "context": [{"sec": "sec9", "text": " In the future we plan to investigate forward slicing [30], [31] and language-agnostic slicing that would permit slicing apps containing code written in different programming languages [32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.tcs.2006.01.012", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Theoretical+foundations+of+dynamic+program+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "S. Horwitz, T. Reps, D. Binkley, \"Interprocedural slicing using dependence graphs\", <em>ACM Transactions on Programming Languages and Systems</em>, pp. 26-61, 1990.", "title": "Interprocedural slicing using dependence graphs", "context": [{"sec": "sec9", "text": " In the future we plan to investigate forward slicing [30], [31] and language-agnostic slicing that would permit slicing apps containing code written in different programming languages [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/77606.77608", "abstract": "The notion of a program slice, originally introduced by Mark Weiser, is useful in program debugging, automatic parallelization, and program integration. A slice of a program is taken with respect to a program point p and a variable x; the slice consists of all statements of the program that might affect the value of x at point p. This paper concerns the problem of interprocedural slicing\u2014generating a slice of an entire program, where the slice crosses the boundaries of procedure calls. To solve ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Interprocedural+slicing+using+dependence+graphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "D. Binkley, N. Gold, M. Harman, S. Islam, J. Krinke, S. Yoo, \"Orbs: Language-independent program slicing\", <em>Proceedings of the 22Nd ACM SIGSOFT International Symposium on Foundations of Software Engineering ser. FSE 2014</em>, 2014.", "title": "Orbs: Language-independent program slicing", "context": [{"sec": "sec9", "text": " In the future we plan to investigate forward slicing [30], [31] and language-agnostic slicing that would permit slicing apps containing code written in different programming languages [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635893", "abstract": "Current slicing techniques cannot handle systems written in multiple programming languages. Observation-Based Slicing (ORBS) is a language-independent slicing technique capable of slicing multi-language systems, including systems which contain (third party) binary components. A potential slice obtained through repeated statement deletion is validated by observing the behaviour of the program: if the slice and original program behave the same under the slicing criterion, the deletion is accepted....", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Orbs%3A+Language-independent+program+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811953", "articleId": "8811953", "startPage": "1154", "endPage": "1164", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 132}}
{"title": "The Product Backlog", "authors": [{"name": "Todd Sedano", "affiliation": "Carnegie Mellon University, Silicon Valley Campus", "firstName": "Todd", "lastName": "Sedano", "id": "38015621200"}, {"name": "Paul Ralph", "affiliation": "University of Auckland", "firstName": "Paul", "lastName": "Ralph", "id": "37946728700"}, {"name": "C\u00e9cile P\u00e9raire", "affiliation": "Carnegie Mellon University, Silicon Valley Campus", "firstName": "C\u00e9cile", "lastName": "P\u00e9raire", "id": "37085532862"}], "abstract": "Context: One of the most common artifacts in contemporary software projects is a product backlog comprising user stories, bugs, chores or other work items. However, little research has investigated how the backlog is generated or the precise role it plays in a project. Objective: The purpose of this paper is to determine what is a product backlog, what is its role, and how does it emerge? Method: Following Constructivist Grounded Theory, we conducted a two-year, five-month participant-observation study of eight software development projects at Pivotal, a large, international software company. We interviewed 56 software engineers, product designers, and product managers.We conducted a survey of 27 product designers. We alternated between analysis and theoretical sampling until achieving theoretical saturation. Results: We observed 13 practices and 6 obstacles related to product backlog generation. Limitations: Grounded Theory does not support statistical generalization. While the proposed theory of product backlogs appears widely applicable, organizations with different software development cultures may use different practices. Conclusion: The product backlog is simultaneously a model of work to be done and a boundary object that helps bridge the gap between the processes of generating user stories and realizing them in working code. It emerges from sensemaking (the team making sense of the project context) and coevolution (a cognitive process where the team simultaneously refines its understanding of the problematic context and fledgling solution concepts).", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software", "Interviews", "Programming", "Companies", "Buildings", "Stakeholders", "Data collection"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["project management"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["software development projects", "product backlog generation", "puser stories", "software development cultures", "constructivist grounded theory"]}, {"type": "Author Keywords ", "kwd": ["Product-backlog", "dual-track-agile", "scrum", "lean", "extreme-programming", "user-stories", "design-thinking", "user-centered-design", "feature-engineering"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00036", "ref": [{"order": "1", "text": "P. Checkland, Systems Thinking Systems Practice, Chichester, UK:Wiley, 1999.", "title": "Systems Thinking, Systems Practice", "context": [{"sec": "sec1", "text": " Users have vague, unreliable, conflicting, evanescent preferences' values, beliefs, and guesses about what might make a product successful [1], [2].", "part": "1"}, {"sec": "sec3b", "text": " In reality, stakeholders often agree that a situation is problematic but disagree on the exact nature of the problem(s)[1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Systems+Thinking%2C+Systems+Practice&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "S. Lichtenstein, P. Slovic, The Construction of Preference, Cambridge, UK:Cambridge University Press, Aug. 2006.", "title": "The Construction of Preference", "context": [{"sec": "sec1", "text": " Users have vague, unreliable, conflicting, evanescent preferences' values, beliefs, and guesses about what might make a product successful [1], [2].", "part": "1"}, {"sec": "sec3a", "text": " Rather, the interviewee and interviewer spontaneously co-construct evanescent preferences [2].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1017/CBO9780511618031", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Construction+of+Preference&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "N. Maiden, S. Jones, K. Karlsen, R. Neill, K. Zachos, A. Milne, \"Requirements engineering as creative problem solving: a research agenda for idea finding\", <em>Proceedings of the 18th IEEE International Requirements Engineering Conference</em>, pp. 57-66, 2010.", "title": "Requirements engineering as creative problem solving: a research agenda for idea finding", "context": [{"sec": "sec1", "text": "Design is a creative process-one must imagine a solution [3], [4].", "part": "1"}], "links": {"documentLink": "/document/5636900", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5636900", "abstract": "This vision paper frames requirements engineering as a creative problem solving process. Its purpose is to enable requirements researchers and practitioners to recruit relevant theories, models, techniques and tools from creative problem solving to understand and support requirements processes more effectively. It uses 4 drivers to motivate the case for requirements engineering as a creative problem solving process. It then maps established requirements activities onto one of the longest-establi...", "pdfSize": "1151KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Requirements+engineering+as+creative+problem+solving%3A+a+research+agenda+for+idea+finding&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "D. H. Jonassen, \"Instructional design models for well-structured and III-structured problem-solving learning outcomes\", <em>Educational Technology Research and Development</em>, vol. 45, no. 1, pp. 65-94, 1997.", "title": "Instructional design models for well-structured and III-structured problem-solving learning outcomes", "context": [{"sec": "sec1", "text": "Design is a creative process-one must imagine a solution [3], [4].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF02299613", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Instructional+design+models+for+well-structured+and+III-structured+problem-solving+learning+outcomes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "K. Charmaz, Constructing Grounded Theory, SAGE Publications, 2014.", "title": "Constructing Grounded Theory", "context": [{"sec": "sec2", "text": " We used Constructivist Grounded Theory [5], which involves iteratively collecting and analyzing data to generate and refine a theory.", "part": "1"}, {"sec": "sec2b", "text": " Intensive interviews of 56 product designers, product managers, and software engineers who had experience with Pivotal's software development process from ten different offices helped us enter into participants' perspectives. (\u201cIntensive interviews\u201d are \u201copen-ended yet directed, shaped yet emergent, and paced yet unrestricted\u201d [5].) An informal online questionnaire, with responses from 27 of 71 total product designers (a 38% response rate), produced further insights into their practices.", "part": "1"}, {"sec": "sec2b", "text": "The first author iteratively collected and analyzed field notes and interviews; used line-by-line coding [5] to identify nuanced interactions in the data and avoid jumping to conclusions; and reviewed the initial codes while reading the transcripts and listening to the audio recordings.", "part": "1"}, {"sec": "sec2b", "text": " Theoretical saturation was not truly achieved until midway through writing this paper, which is normal for Grounded Theory studies [5, p. 285].", "part": "1"}, {"sec": "sec4", "text": "This section evaluates our study using appropriate quality criteria, including those proposed by Charmaz [5].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Constructing+Grounded+Theory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "T. Sedano, P. Ralph, C. P\u00e9raire, \"Sustainable software development through overlapping pair rotation\", <em>Proceedings of the International Symposium on Empirical Software Engineering and Measurement International Conference on Software Engineering ser. ESEM</em>, 2016.", "title": "Sustainable software development through overlapping pair rotation", "context": [{"sec": "sec2", "text": "Because this study is so large, multiple core categories emerged, including sustainable software development [6], team code ownership [7], software development waste [8], and the topic of this paper: the product backlog.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2961111.2962590", "abstract": "Context: Conventional wisdom says that team disruptions (like team churn) should be avoided. However, we have observed software development projects that succeed despite high disruption. Objective: The purpose of this paper is to understand how to develop software effectively, even in the face of team disruption. Method: We followed Constructivist Grounded Theory. The primary researcher conducted participant-observation of several projects at Pivotal (a software development company), and intervi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sustainable+software+development+through+overlapping+pair+rotation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "T. Sedano, P. Ralph, C. P\u00e9raire, \"Practice and perception of team code ownership\", <em>Proceedings of the 20th International Conference on Evaluation and Assessment in Software Engineering ser. EASE</em>, 2016.", "title": "Practice and perception of team code ownership", "context": [{"sec": "sec2", "text": "Because this study is so large, multiple core categories emerged, including sustainable software development [6], team code ownership [7], software development waste [8], and the topic of this paper: the product backlog.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2915970.2916002", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practice+and+perception+of+team+code+ownership&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "T. Sedano, P. Ralph, C. P\u00e9raire, \"Software development waste\", <em>Proceedings of the 2017 International Conference on Software Engineering ser. ICSE \u201817</em>, 2017.", "title": "Software development waste", "context": [{"sec": "sec2", "text": "Because this study is so large, multiple core categories emerged, including sustainable software development [6], team code ownership [7], software development waste [8], and the topic of this paper: the product backlog.", "part": "1"}, {"sec": "sec3b", "text": " However, this led to substantial stress and rework, which are both intrinsically wasteful [8].", "part": "1"}], "links": {"documentLink": "/document/7985656", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985656", "abstract": "Context: Since software development is a complex socio-technical activity that involves coordinating different disciplines and skill sets, it provides ample opportunities for waste to emerge. Waste is any activity that produces no value for the customer or user. Objective: The purpose of this paper is to identify and describe different types of waste in software development. Method: Following Constructivist Grounded Theory, we conducted a two-year five-month participant-observation study of eigh...", "pdfSize": "205KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+development+waste&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "K. Beck, C. Andres, Extreme Programming Explained: Embrace Change (2nd Edition), Addison-Wesley Professional, 2004.", "title": "Extreme Programming Explained: Embrace Change (2nd Edition)", "context": [{"sec": "sec2a", "text": " Client personnel work with Pivotal personnel at a Pivotal office where they can experience Extreme Programming [9] in an environment conducive to agile development.", "part": "1"}, {"sec": "sec2a", "text": "Pivotal has practiced Extreme Programming [9] since the late 1990s.", "part": "1"}, {"sec": "sec5", "text": "Extreme Programming [9] similarly offers little guidance for determining what to build.", "part": "1"}, {"sec": "sec5", "text": " In the Real Customer Involvement practice [9], an on site customer provides features through story cards.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Extreme+Programming+Explained%3A+Embrace+Change+%282nd+Edition%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "T. Sedano, <em>Sustainable software development: Evolving extreme programming</em>, 2017.", "title": "Sustainable software development: Evolving extreme programming", "context": [{"sec": "sec2a", "text": " Project details are available elsewhere [10].", "part": "1"}, {"sec": "sec2b", "text": " A more detailed account of our data collection and analysis strategy is available elsewhere [10], [13].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sustainable+software+development%3A+Evolving+extreme+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "B. Glaser, Theoretical Sensitivity: Advances in the Methodology of Grounded Theory, Sociology Press, 1978.", "title": "Theoretical Sensitivity: Advances in the Methodology of Grounded Theory", "context": [{"sec": "sec2b", "text": " We discussed the coding during weekly research collaboration meetings and recorded insights from these discussions as grounded theory memos [11].", "part": "1"}, {"sec": "sec3c", "text": " Cutting points are very important in theory generation since they indicate where the difference occurs which has differential effects\u201d [11, p. 76].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Theoretical+Sensitivity%3A+Advances+in+the+Methodology+of+Grounded+Theory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "B. Glaser, Doing Grounded Theory: Issues and Discussions, Sociology Press, 1998.", "title": "Doing Grounded Theory: Issues and Discussions", "context": [{"sec": "sec2b", "text": " Since line-by-line coding of such documents is intractable, we instead wrote memos about them, as recommended by Glaser [12, p. 98].", "part": "1"}, {"sec": "sec4", "text": " Similarly, prior knowledge can not only help the researcher interpret events and select lines of inquiry but also blind the researcher to alternative explanations [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Doing+Grounded+Theory%3A+Issues+and+Discussions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "T. Sedano, P. Ralph, C. P\u00e9raire, \"Lessons learned from an extended participant observation grounded theory study\", <em>Proceedings of the 5th International Workshop on Conducting Empirical Studies in Industry ser. CESI \u201817</em>, 2017.", "title": "Lessons learned from an extended participant observation grounded theory study", "context": [{"sec": "sec2b", "text": " A more detailed account of our data collection and analysis strategy is available elsewhere [10], [13].", "part": "1"}], "links": {"documentLink": "/document/7968162", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7968162", "abstract": "Context: Conducting a Grounded Theory study is rigorous, demanding, and challenging. Misperceptions exist within the software engineering community [1]. Objective: The purpose of this paper is to describe one extended participant observation Grounded Theory study for aiding new empirical researchers wanting to run similar research studies. Method: Following Constructivist Grounded Theory, we conducted a two-year five-month participant-observation of eight software development projects at Pivotal...", "pdfSize": "366KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lessons+learned+from+an+extended+participant+observation+grounded+theory+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "J. Thomson, <em>Trust and balanced teams</em>,  [online]  Available: https://medium.com/product-labs/trust-and-balanced-teams-919456ad57cf.", "title": "Trust and balanced teams", "context": [{"sec": "sec3a", "text": "A balanced team, as illustrated in Figure 1, \u201cis an autonomous group of people with a variety of skills and perspectives that support each other towards a shared goal\u201d [14].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Trust+and+balanced+teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "B. Fitzgerald, K.-J. Stol, \"Continuous software engineering: A roadmap and agenda\", <em>Journal of Systems and Software</em>, vol. 123, no. C, pp. 176-189, Jan. 2017.", "title": "Continuous software engineering: A roadmap and agenda", "context": [{"sec": "sec3a", "text": "Meanwhile, dual-track agile is a kind of continuous software engineering [15] in which activities are organized into two groups.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2015.06.063", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Continuous+software+engineering%3A+A+roadmap+and+agenda&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "S. Madsen, L. Nielsen, \"Exploring Persona-Scenarios - Using Storytelling to Create Design Ideas\" in Human Work Interaction Design: Usability in Social Cultural and Organizational Contexts, Berlin, Heidelberg:Springer Berlin Heidelberg, pp. 57-66, 2010.", "title": "Exploring Persona-Scenarios - Using Storytelling to Create Design Ideas", "context": [{"sec": "sec3a", "text": "We observed product designers leading the team in defining one or more proto-personas. \u201cA persona is a description of a fictitious user based on data from user research\u201d [16, p. 58; emphasis ours].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-11762-6_5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+Persona-Scenarios+-+Using+Storytelling+to+Create+Design+Ideas&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Farleo, <em>Personas vs proto-personas</em>,  [online]  Available: https://newmediadenver.com/personas-vs-proto-personas.", "title": "Personas vs proto-personas", "context": [{"sec": "sec3a", "text": " A proto-persona is a description of a fictitious user that is based on intuition or simply made up [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Personas+vs+proto-personas&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "M. Seaman, <em>The right number of user interviews</em>,  [online]  Available: https://medium.com/@mitchelseaman/the-right-number-of-user-interviews-de11c7815d9.", "title": "The right number of user interviews", "context": [{"sec": "sec3a", "text": " They typically began with about five interviews per proto-persona [18]: \u201cI have had projects where there are multiple personas so I would say like five for one persona is good\u201d (Participant 41).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+right+number+of+user+interviews&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J. Kawakita, Hassouhou-Souzousei kaihatsu no tame ni - A way of thinking that developes creativity, Chuokoron-Shinsha, 1967.", "title": "Hassouhou-Souzousei kaihatsu no tame ni - A way of thinking that developes creativity", "context": [{"sec": "sec3a", "text": "We observed teams synthesizing what was learned during interviews using affinity mapping [19].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Hassouhou-Souzousei+kaihatsu+no+tame+ni+-+A+way+of+thinking+that+developes+creativity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "A. Alliance, <em>Role-feature-reason</em>, 2017,  [online]  Available: https://www.agilealliance.org/glossary/role-feature/.", "title": "Role-feature-reason", "context": [{"sec": "sec3a", "text": " This is some-times called the Connextra template [20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Role-feature-reason&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "M. Wynne, A. Hellesoy, The Cucumber Book: Behaviour-Driven Development for Testers and Developers, Pragmatic Bookshelf, 2012.", "title": "The Cucumber Book: Behaviour-Driven Development for Testers and Developers", "context": [{"sec": "sec3a", "text": " This is sometimes called Gherkin syntax [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Cucumber+Book%3A+Behaviour-Driven+Development+for+Testers+and+Developers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "N. Cross, C. Eastman, W. Newstetter, M. McCracken, \"Design cognition: results from protocol and other empirical studies of design activity\" in Design knowing and learning: Cognition in design education, Oxford, UK:Elsevier Science, pp. 79-103, 2001.", "title": "Design cognition: results from protocol and other empirical studies of design activity", "context": [{"sec": "sec3a", "text": " [22], [23]).", "part": "1"}, {"sec": "sec3b", "text": "Expert designers in other fields exhibit similar patterns [22].", "part": "1"}, {"sec": "sec3c", "text": "A designer's thoughts oscillate between a tentative problem frame and fledgling solutions, such that understanding of the problematic context and solution concepts coevolve [23], [22], [32].", "part": "1"}, {"sec": "sec4", "text": " Sensemaking and context-solution coevolution have been established by previous research as practically universal phenomena in design generally and software engineering specifically [22], [36], [37].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/B978-008043868-9/50005-X", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Design+cognition%3A+results+from+protocol+and+other+empirical+studies+of+design+activity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "N. Cross, K. Dorst, N. Roozenburg, Research in Design Thinking, Delft University Press, 1992.", "title": "Research in Design Thinking", "context": [{"sec": "sec3a", "text": "Much has been written about how design thinking involves-but is not limited to-writing, drawing, problem-solving, and decision making (cf. [22], [23]).", "part": "1"}, {"sec": "sec3b", "text": " Despite the common advice to generate several alternative solution ideas, expert designers tend to converge rapidly on a single concept and resist radical reformulations [23].", "part": "1"}, {"sec": "sec3c", "text": "A designer's thoughts oscillate between a tentative problem frame and fledgling solutions, such that understanding of the problematic context and solution concepts coevolve [23], [22], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Research+in+Design+Thinking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "P. Ralph, Y. Wand, K. Lyytinen, P. Loucopoulos, J. Mylopoulos, W. Robinson, \"A Proposal for a Formal Definition of the Design Concept\" in Design Requirements Engineering: A Ten-Year Perspective, Cleveland, OH, USA:Springer-Verlag, pp. 103-136, Jun. 2009.", "title": "A Proposal for a Formal Definition of the Design Concept", "context": [{"sec": "sec3b", "text": " In the broadest sense, design means specifying the properties of an object [24], including what it does (feature selection), how users interact with it (interaction design), how it looks (visual design), how it is organized (architectural design), and exactly how it works (low-level design).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-540-92966-6_6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+Proposal+for+a+Formal+Definition+of+the+Design+Concept&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "D. A. Sch\u00f6n, The reflective practitioner: how professionals think in action, USA:Basic Books, 1983.", "title": "The reflective practitioner: how professionals think in action", "context": [{"sec": "sec3b", "text": " Moreover, framing a problem and generating a solution concept are the same cognitive process [25].", "part": "1"}, {"sec": "sec3c", "text": " Regardless of whether a project is outsourced, offshored, or in-house, \u201cTo convert a problematic situation to a problem, a practitioner must\u2026 make sense of an uncertain situation that initially makes no sense\u201d [25, p. 40].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+reflective+practitioner%3A+how+professionals+think+in+action&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "P. Ralph, R. Mohanani, \"Is requirements engineering inherently counterproductive?\", <em>Proceedings of the 5th International Workshop on the Twin Peaks of Requirements and Architecture</em>, pp. 20-23, May 2015.", "title": "Is requirements engineering inherently counterproductive?", "context": [{"sec": "sec3b", "text": " Overspecifying a problem for the designer actually impedes effective solution generation [26].", "part": "1"}], "links": {"documentLink": "/document/7184708", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7184708", "abstract": "This paper explores the possibility that requirements engineering is, in principle, detrimental to software project success. Requirements engineering is conceptually divided into two distinct processes: sense making (learning about the project context) and problem structuring (specifying problems, goals, requirements, constraints, etc.). An interdisciplinary literature review revealed substantial evidence that while sense making improves design performance, problem structuring reduces design per...", "pdfSize": "176KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Is+requirements+engineering+inherently+counterproductive%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "P. J. Silvia, B. P. Winterstein, J. T. Willse, C. M. Barona, J. T. Cram, K. I. Hess, J. L. Martinez, C. A. Richard, \"Assessing creativity with divergent thinking tasks: Exploring the reliability and validity of new subjective scoring methods\", <em>Psychology of Aesthetics Creativity and the Arts</em>, vol. 2, no. 2, 2008.", "title": "Assessing creativity with divergent thinking tasks: Exploring the reliability and validity of new subjective scoring methods", "context": [{"sec": "sec3b", "text": "Creative design is closely related to divergent thinking [27]; that is, exploring many dissimilar ideas.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/1931-3896.2.2.68", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Assessing+creativity+with+divergent+thinking+tasks%3A+Exploring+the+reliability+and+validity+of+new+subjective+scoring+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "S. L. Star, J. R. Griesemer, \"Institutional Ecology \u2018Translations\u2019 and Boundary Objects: Amateurs and Professionals in Berkeley's Museum of Vertebrate Zoology 1907\u201339\", <em>Social Studies of Science</em>, vol. 19, no. 3, pp. 387-420, 1989.", "title": "Institutional Ecology, \u2018Translations\u2019 and Boundary Objects: Amateurs and Professionals in Berkeley's Museum of Vertebrate Zoology, 1907\u201339", "context": [{"sec": "sec3c", "text": "A boundary object is an artifact that different people can use and interpret in different ways [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/030631289019003001", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Institutional+Ecology%2C+%E2%80%98Translations%E2%80%99+and+Boundary+Objects%3A+Amateurs+and+Professionals+in+Berkeley%27s+Museum+of+Vertebrate+Zoology%2C+1907%E2%80%9339&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "B. A. Bechky, \"Sharing meaning across occupational communities: The transformation of understanding on a production floor\", <em>Organization Science</em>, vol. 14, no. 3, pp. 312-330, 2003.", "title": "Sharing meaning across occupational communities: The transformation of understanding on a production floor", "context": [{"sec": "sec3c", "text": " Boundary objects not only facilitate knowledge sharing and coordination [29] but also help groups cooperate without consensus [30].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/orsc.14.3.312.15162", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sharing+meaning+across+occupational+communities%3A+The+transformation+of+understanding+on+a+production+floor&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "S. L. Star, \"This is Not a Boundary Object: Reflections on the Origin of a Concept\", <em>Science Technology & Human Values</em>, vol. 35, no. 5, pp. 601-617, 2010.", "title": "This is Not a Boundary Object: Reflections on the Origin of a Concept", "context": [{"sec": "sec3c", "text": " Boundary objects not only facilitate knowledge sharing and coordination [29] but also help groups cooperate without consensus [30].", "part": "1"}, {"sec": "sec3c", "text": "Conceptualizing the product backlog as a boundary object assumes that it mediates communication between different groups or roles [30].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1177/0162243910377624", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=This+is+Not+a+Boundary+Object%3A+Reflections+on+the+Origin+of+a+Concept&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "K. E. Weick, K. M. Sutcliffe, D. Obstfeld, \"Organizing and the Process of Sensemaking\", <em>Organization Science</em>, vol. 16, no. 4, pp. 409-421, 2005.", "title": "Organizing and the Process of Sensemaking", "context": [{"sec": "sec3c", "text": " In sociology and management as well as software engineering, this activity is called sensemaking [31], [32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/orsc.1050.0133", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Organizing+and+the+Process+of+Sensemaking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "P. Ralph, \"The Sensemaking-coevolution-implementation theory of software design\", <em>Science of Computer Programming</em>, vol. 101, pp. 21-41, 2015.", "title": "The Sensemaking-coevolution-implementation theory of software design", "context": [{"sec": "sec3c", "text": " In sociology and management as well as software engineering, this activity is called sensemaking [31], [32].", "part": "1"}, {"sec": "sec3c", "text": "A designer's thoughts oscillate between a tentative problem frame and fledgling solutions, such that understanding of the problematic context and solution concepts coevolve [23], [22], [32].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.scico.2014.11.007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Sensemaking-coevolution-implementation+theory+of+software+design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "H. Aldrich, D. Herker, \"Boundary spanning roles and organization structure\", <em>Academy of management review</em>, vol. 2, no. 2, pp. 217-230, 1977.", "title": "Boundary spanning roles and organization structure", "context": [{"sec": "sec3c", "text": " Having those check-ins really help.\u201d Following previous research, we call this category boundary spanning [33], [34].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.5465/AMR.1977.4409044", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Boundary+spanning+roles+and+organization+structure&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "M. L. Tushman, T. J. Scanlan, \"Boundary spanning individuals: Their role in information transfer and their antecedents\", <em>Academy of management journal</em>, vol. 24, no. 2, pp. 289-305, 1981.", "title": "Boundary spanning individuals: Their role in information transfer and their antecedents", "context": [{"sec": "sec3c", "text": " Having those check-ins really help.\u201d Following previous research, we call this category boundary spanning [33], [34].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Boundary+spanning+individuals%3A+Their+role+in+information+transfer+and+their+antecedents&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "J. W. Creswell, D. L. Miller, \"Determining validity in qualitative inquiry\", <em>Theory Into Practice</em>, vol. 39, no. 3, 2000.", "title": "Determining validity in qualitative inquiry", "context": [{"sec": "sec4", "text": " Six participants reviewed the results and this paper for member checking [35].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1207/s15430421tip3903_2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Determining+validity+in+qualitative+inquiry&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "J. Kolko, \"Abductive thinking and sensemaking: The drivers of design synthesis\", <em>Design Issues</em>, vol. 26, no. 1, pp. 15-28, 2010.", "title": "Abductive thinking and sensemaking: The drivers of design synthesis", "context": [{"sec": "sec4", "text": " Sensemaking and context-solution coevolution have been established by previous research as practically universal phenomena in design generally and software engineering specifically [22], [36], [37].", "part": "1"}], "links": {"documentLink": "/document/6792168", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6792168", "pdfSize": "465KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Abductive+thinking+and+sensemaking%3A+The+drivers+of+design+synthesis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "P. Ralph, \"Software engineering process theory: A multi-method comparison of Sensemaking-Coevolution-Implementation Theory and Function-Behavior-Structure Theory\", <em>Information and Software Technology</em>, vol. 70, pp. 232-250, 2016.", "title": "Software engineering process theory: A multi-method comparison of Sensemaking-Coevolution-Implementation Theory and Function-Behavior-Structure Theory", "context": [{"sec": "sec4", "text": " Sensemaking and context-solution coevolution have been established by previous research as practically universal phenomena in design generally and software engineering specifically [22], [36], [37].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2015.06.010", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+engineering+process+theory%3A+A+multi-method+comparison+of+Sensemaking-Coevolution-Implementation+Theory+and+Function-Behavior-Structure+Theory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "N. Levina, \"Collaborating on Multiparty Information Systems Development Projects: A Collective Reflection-in-Action View\", <em>Information Systems Research</em>, vol. 16, no. 2, pp. 109-130, 2005.", "title": "Collaborating on Multiparty Information Systems Development Projects: A Collective Reflection-in-Action View", "context": [{"sec": "sec4", "text": " The research on boundary objects and spanners suggests that boundary spanning is fundamental to contemporary software engineering-or at least projects where professionals with different roles and backgrounds collaborate [38].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1287/isre.1050.0055", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Collaborating+on+Multiparty+Information+Systems+Development+Projects%3A+A+Collective+Reflection-in-Action+View&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "K. Schwaber, J. Sutherland, D. Patel, C. Casanave, J. Miller, G. Hollowell, \"SCRUM Development Process\", <em>Business Object Design and Implementation: OOPSLA Workshop Proceedings October Austin Texas</em>, 1997.", "title": "SCRUM Development Process", "context": [{"sec": "sec5", "text": "It appears that our current understanding of a product backlog as a list of work items for software developers was invented or at least popularized by proponents of Scrum, Although this is difficult to determine with certainty, the earliest reference to a modern product backlog we can find is Schwaber's presentation at OOPSLA 1995 [39].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4471-0947-1_11", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=SCRUM+Development+Process&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "K. Schwaber, J. Sutherland, <em>Scrum guide</em>, 2015,  [online]  Available: http://www.scrumguides.org/.", "title": "Scrum guide", "context": [{"sec": "sec5", "text": "The Scrum Guide defines \u201cthe Product Backlog [as]an ordered list of everything that is known to be needed in the product\u201d [40].", "part": "1"}, {"sec": "sec5", "text": "The Scrum Guide states: \u201cAt any point in time, the total work remaining to reach a goal can be summed\u201d [40].", "part": "1"}, {"sec": "sec5", "text": " Scrum simply assigns the job of writing user stories to the \u201cProduct Owner\u201d but says little about user research, the creative process of designing the system, or writing and refining these stories [40], [46], [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scrum+guide&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "S. Ambler, <em>Agile best practice: Prioritized requirements</em>, 2010,  [online]  Available: http://agilemodeling.com/essays/prioritizedRequirements.htm.", "title": "Agile best practice: Prioritized requirements", "context": [{"sec": "sec5", "text": " Ambler extends this definition to include different kinds of work items such as training or reviewing other teams' products [41] and therefore calls it a \u201cwork item list.\u201d Scrum's and Ambler's view of the backlog broadly align with our observations in Section III-C1.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Agile+best+practice%3A+Prioritized+requirements&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "A. Silva, A. Silva, T. Araujo, R. Willamy, F. Ramos, A. Costa, M. Perkusich, E. Dilorenzo, \"Ordering the product backlog in agile software development projects: A systematic literature review\", <em>Proceedings of the 29th International Conference on Software Engineering & Knowledge Engineering SEKE 2017</em>, 07 2017.", "title": "Ordering the product backlog in agile software development projects: A systematic literature review", "context": [{"sec": "sec5", "text": " A systematic review of 13 such studies found no consensus about how items should be prioritized [42] and concluded that \u201cthe average quality of studies is low\u201d (p. 5).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.18293/SEKE2017-007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ordering+the+product+backlog+in+agile+software+development+projects%3A+A+systematic+literature+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "Z. Racheva, M. Daneva, A. Herrmann, R. J. Wieringa, \"A conceptual model and process for client-driven agile requirements prioritization\", <em>Research Challenges in Information Science (RCIS) 2010 Fourth International Conference</em>, pp. 287-298, 2010.", "title": "A conceptual model and process for client-driven agile requirements prioritization", "context": [{"sec": "sec5", "text": " [43] synthesized a lifecycle theory of backlog prioritization from existing literature.", "part": "1"}], "links": {"documentLink": "/document/5507388", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5507388", "abstract": "Continuous customer-centric requirements reprioritization is essential in successfully performing agile software development. Yet, in the agile RE literature, very little is known about how agile reprioritization happens in practice. Generic conceptual models about this process are missing, which in turn, makes it difficult for both practitioners and researchers to reason about requirements decision-making at inter-iteration time. This paper presents a Grounded Theory study on agile requirements...", "pdfSize": "461KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+conceptual+model+and+process+for+client-driven+agile+requirements+prioritization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "P. Ralph, \"Toward Methodological Guidelines for Process Theories and Taxonomies in Software Engineering\", <em>IEEE Transactions on Software Engineering</em>, 2018.", "title": "Toward Methodological Guidelines for Process Theories and Taxonomies in Software Engineering", "context": [{"sec": "sec5", "text": " However, lifecycle theories are typically inappropriate for modeling human behavior [44].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Toward+Methodological+Guidelines+for+Process+Theories+and+Taxonomies+in+Software+Engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "N. Bolloju, S. Alter, A. Gupta, S. Gupta, S. Jain, \"Improving scrum user stories and product backlog using work system snapshots\", <em>Proceedings of the Americas Conference on Information Systems</em>, 2017.", "title": "Improving scrum user stories and product backlog using work system snapshots", "context": [{"sec": "sec5", "text": "We found only one backlog-focused experiment, which showed that students using the work system snapshot conceptual modeling technique wrote better backlog items [45].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+scrum+user+stories+and+product+backlog+using+work+system+snapshots&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "K. Schwaber, M. Beedle, Agile Software Development with Scrum, Prentice Hall, 2001.", "title": "Agile Software Development with Scrum", "context": [{"sec": "sec5", "text": " Scrum simply assigns the job of writing user stories to the \u201cProduct Owner\u201d but says little about user research, the creative process of designing the system, or writing and refining these stories [40], [46], [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Agile+Software+Development+with+Scrum&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "K. Schwaber, Agile Project Management with Scrum, Microsoft Press, 2004.", "title": "Agile Project Management with Scrum", "context": [{"sec": "sec5", "text": " Scrum simply assigns the job of writing user stories to the \u201cProduct Owner\u201d but says little about user research, the creative process of designing the system, or writing and refining these stories [40], [46], [47].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Agile+Project+Management+with+Scrum&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "D. M. Russell, M. J. Stefik, P. Pirolli, S. K. Card, \"The cost structure of sensemaking\", <em>Proceedings of the INTERACT \u201893 and CHI \u201893 Conference on Human Factors in Computing Systems ser. CHI \u201893</em>, pp. 269-276, 1993.", "title": "The cost structure of sensemaking", "context": [{"sec": "sec5", "text": " HCI incorporated the concept of sensemaking as early as 1993 [48], and many of the practices described above are well-known in user-centered design [49].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/169059.169209", "abstract": "Making sense of a body of data is a common activity in any kind of analysis. Sensemaking is the process of searching for a representation and encoding data in that representation to answer task-specific questions. Different operations during sensemaking require different cognitive and external resources. Representations are chosen and changed to reduce the cost of operations in an information processing task. The power of these representational shifts is generally under-appreciated as is the rel...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+cost+structure+of+sensemaking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "B. Martin, B. Hanington, Universal Methods of Design: 100 Ways to Research Complex Problems Develop Innovative Ideas and Design Effective Solutions, Rockport Publishers, 2012.", "title": "Universal Methods of Design: 100 Ways to Research Complex Problems, Develop Innovative Ideas, and Design Effective Solutions", "context": [{"sec": "sec5", "text": " HCI incorporated the concept of sensemaking as early as 1993 [48], and many of the practices described above are well-known in user-centered design [49].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Universal+Methods+of+Design%3A+100+Ways+to+Research+Complex+Problems%2C+Develop+Innovative+Ideas%2C+and+Design+Effective+Solutions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "A. Seffah, E. Metzker, \"The obstacles and myths of usability and software engineering\", <em>Commun. ACM</em>, vol. 47, no. 12, pp. 71-76, Dec. 2004.", "title": "The obstacles and myths of usability and software engineering", "context": [{"sec": "sec5", "text": " These processes and practices remain decoupled from mainstream SE methods [50].", "part": "1"}, {"sec": "sec5", "text": " Some in the SE community are consequently under \u201cthe impression that the user-centered design approach and usability engineering methods are only for decorating a thin component sitting on top of the software or the \u2018real\u2019 system\u201d [50].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1035134.1035136", "abstract": "Avoiding the usability pitfalls involved in managing the software development life cycle.", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+obstacles+and+myths+of+usability+and+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "M. Brhel, H. Meth, A. Maedche, K. Werder, \"Exploring principles of user-centered agile software development: A literature review systematic review paper\", <em>Information and Software Technology</em>, vol. 61, no. C, pp. 163-181, May 2015.", "title": "Exploring principles of user-centered agile software development: A literature review, systematic review paper", "context": [{"sec": "sec5", "text": "Several systematic literature reviews [51]\u2013[53] have recently attempted to correct this misunderstanding and bridge the gap between the SE community's focus on how to build and the HCI community's focus on what to build.", "part": "1"}, {"sec": "sec5", "text": " [51] identify five principles underlying user-centered agile development: (1) separate product discovery and product creation, (2) iterative and incremental design and development, (3) parallel interwoven tracks of design and development, (4) continuous stakeholder involvement, and (5) artifact-mediated communication.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2015.01.004", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Exploring+principles+of+user-centered+agile+software+development%3A+A+literature+review%2C+systematic+review+paper&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "D. Salah, R. F. Paige, P. Cairns, \"A systematic literature review for agile development processes and user centred design integration\", <em>Proceedings of the 18th International Conference on Evaluation and Assessment in Software Engineering ser. EASE \u201814</em>, pp. 5:1-5:10, 2014.", "title": "A systematic literature review for agile development processes and user centred design integration", "context": [{"sec": "sec5", "text": "Several systematic literature reviews [51]\u2013[52][53] have recently attempted to correct this misunderstanding and bridge the gap between the SE community's focus on how to build and the HCI community's focus on what to build.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2601248.2601276", "abstract": "Agile development processes and User Centred Design (UCD) integration have been gaining increased interest, in part due to the complementarity of the techniques, the benefits each can apply to the other, and the challenges associated with their combination. This paper describes a Systematic Literature Review (SLR) that was conducted on Agile and UCD integration. The aim of this SLR was to identify various challenging factors that restrict Agile and User Centred Design Integration (AUCDI) and exp...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+literature+review+for+agile+development+processes+and+user+centred+design+integration&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "C. Salvador, A. Nakasone, J. A. Pow-Sang, \"A systematic review of usability techniques in agile methodologies\", <em>Proceedings of the 7th Euro American Conference on Telematics and Information Systems ser. EATIS \u201814</em>, pp. 17:1-17:6, 2014.", "title": "A systematic review of usability techniques in agile methodologies", "context": [{"sec": "sec5", "text": "Several systematic literature reviews [51]\u2013[53] have recently attempted to correct this misunderstanding and bridge the gap between the SE community's focus on how to build and the HCI community's focus on what to build.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2590651.2590668", "abstract": "In this paper, we present the results of a systematic review involving the use of usability techniques in software developments where agile methodologies were used. The search strategy identified 307 studies, where only 32 were finally selected for the review. We found that complementary techniques are the most frequent techniques used with agile methodologies. In addition, most studies performed usability evaluations only during the implementation phase, and these evaluations were mostly constr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+review+of+usability+techniques+in+agile+methodologies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "A. Garcia, T. Da Silva, M. Silveira, \"Artifacts for agile user-centered design: A systematic mapping\", <em>Hawaii International Conference on System Sciences 01 2017</em>.", "title": "Artifacts for agile user-centered design: A systematic mapping", "context": [{"sec": "sec5", "text": " [54] further investigate principle (5) and concluded that user stories are one of the main artifacts mediating communication.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.24251/HICSS.2017.706", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Artifacts+for+agile+user-centered+design%3A+A+systematic+mapping&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "L. Miller, \"Case study of customer input for a successful product\", <em>Proceedings of Agile 2005</em>, pp. 225-234, 2005.", "title": "Case study of customer input for a successful product", "context": [{"sec": "sec5", "text": " The term dual-track agile originates from articles describing software development at Alias (now part of Autodesk)[55] [56].", "part": "1"}], "links": {"documentLink": "/document/1609826", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1609826", "abstract": "Both agile development and user centered design stress collaboration between customers and product teams, but getting these methodologies to work well together is not easy. This paper describes one company's efforts to merge these processes by creating interconnected parallel design and development tracks. The benefits of this approach are demonstrated by showing how, when and why customer input was incorporated during the release of a successful software product.", "pdfSize": "354KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Case+study+of+customer+input+for+a+successful+product&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "D. Sy, \"Adapting usability investigations for agile user-centered design\", <em>J. Usability Studies</em>, vol. 2, no. 3, pp. 112-132, May 2007.", "title": "Adapting usability investigations for agile user-centered design", "context": [{"sec": "sec5", "text": " The term dual-track agile originates from articles describing software development at Alias (now part of Autodesk)[55] [56].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adapting+usability+investigations+for+agile+user-centered+design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "K. Albrecht, <em>Dual track agile: Focusing on customer value</em>, 2015,  [online]  Available: https://medium.com/kevin-on-code/dual-track-agile-focusing-on-customer-value-a2e39312585b.", "title": "Dual track agile: Focusing on customer value", "context": [{"sec": "sec5", "text": "Recently, several professional articles present various accounts of dual-track agile [57], [58].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dual+track+agile%3A+Focusing+on+customer+value&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "J. De Litchenberg, <em>Dual-track agile: Why messy leads to innovation</em>, 2017,  [online]  Available: https://www.mindtheproduct.com/2017/04/dual-track-agile-messy-leads-innovation/.", "title": "Dual-track agile: Why messy leads to innovation", "context": [{"sec": "sec5", "text": "Recently, several professional articles present various accounts of dual-track agile [57], [58].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dual-track+agile%3A+Why+messy+leads+to+innovation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812076", "articleId": "8812076", "startPage": "200", "endPage": "211", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 174}}
{"title": "How Do Developers Fix Cross-Project Correlated Bugs? A Case Study on the GitHub Scientific Python Ecosystem", "authors": [{"name": "Wanwangying Ma", "affiliation": "State Key Lab. for Novel Software Technol., Nanjing Univ., Nanjing, China", "firstName": "Wanwangying", "lastName": "Ma", "id": "37085700082"}, {"name": "Lin Chen", "affiliation": "State Key Lab. for Novel Software Technol., Nanjing Univ., Nanjing, China", "firstName": "Lin", "lastName": "Chen", "id": "37538820300"}, {"name": "Xiangyu Zhang", "affiliation": "Dept. of Comput. Sci., Purdue Univ., West Lafayette, IN, USA", "firstName": "Xiangyu", "lastName": "Zhang", "id": "37279346200"}, {"name": "Yuming Zhou", "affiliation": "State Key Lab. for Novel Software Technol., Nanjing Univ., Nanjing, China", "firstName": "Yuming", "lastName": "Zhou", "id": "37629464300"}, {"name": "Baowen Xu", "affiliation": "State Key Lab. for Novel Software Technol., Nanjing Univ., Nanjing, China", "firstName": "Baowen", "lastName": "Xu", "id": "37276983200"}], "abstract": "GitHub, a popular social-software-development platform, has fostered a variety of software ecosystems where projects depend on one another and practitioners interact with each other. Projects within an ecosystem often have complex inter-dependencies that impose new challenges in bug reporting and fixing. In this paper, we conduct an empirical study on cross-project correlated bugs, i.e., causally related bugs reported to different projects, focusing on two aspects: 1) how developers track the root causes across projects, and 2) how the downstream developers coordinate to deal with upstream bugs. Through manual inspection of bug reports collected from the scientific Python ecosystem and an online survey with developers, this study reveals the common practices of developers and the various factors in fixing cross-project bugs. These findings provide implications for future software bug analysis in the scope of ecosystem, as well as shed light on the requirements of issue trackers for such bugs.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Computer bugs", "Ecosystems", "Software", "Collaboration", "Maintenance engineering", "Tools", "Software engineering"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["configuration management", "object-oriented languages", "program debugging", "project management", "software development management"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["cross-project correlated bugs", "GitHub scientific Python ecosystem", "upstream bugs", "bug reports"]}, {"type": "Author Keywords ", "kwd": ["GitHub ecosystems", "cross-project correlated bugs", "root causes tracking", "coordinate"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.42", "ref": [{"order": "1", "text": "E. Kalliamvakou, G. Gousios, K. Blincoe, L. Singer, D.M. German, D. Damian, \"An in-depth study of the promises and perils of mining GitHub\", <em>Empirical Software Engineering</em>, pp. 1-37, 2015.", "title": "An in-depth study of the promises and perils of mining GitHub", "context": [{"sec": "sec1", "text": "GitHub, currently the largest code repository in the open source world, provides a convenient way for software practitioners to collaborate and share code with one another [1].", "part": "1"}, {"sec": "sec3a", "text": "GitHub provides an issue tracking system for projects to record and follow the progress of any problem that their developers and users encounter during development, maintenance, or use [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+in-depth+study+of+the+promises+and+perils+of+mining+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "I. Aranda, G. Venolia, \"The secret life of bugs: Going past the errors and omissions in software repositories\", <em>Procedings of 2009 IEEE 31st International Conference on Software Engineering</em>, pp. 298-308, 2009.", "title": "The secret life of bugs: Going past the errors and omissions in software repositories", "context": [{"sec": "sec1", "text": " Aranda and Venolia identified the common bug fixing coordination patterns [2]; Guo et al. investigated factors that affected which bug could be fix [3] and characterized the bug reassignment process [4]; Breu et al. highlighted the importance of effectively and efficiently engaging user community in bug fixing activities [5].", "part": "1"}, {"sec": "sec2a", "text": " Aranda and Venolia [2] used a combination of case studies and a survey of software professionals to investigate coordination activities during bug fixing.", "part": "1"}], "links": {"abstract": "Every bug has a story behind it. The people that discover and resolve it need to coordinate, to get information from documents, tools, or other people, and to navigate through issues of accountability, ownership, and organizational structure. This paper reports on a field study of coordination activities around bug fixing that used a combination of case study research and a survey of software professionals. Results show that the histories of even simple bugs are strongly dependent on social, org...", "pdfSize": "193KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+secret+life+of+bugs%3A+Going+past+the+errors+and+omissions+in+software+repositories&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "P.J. Guo, T. Zimmermann, N. Nagappan, B. Murphy, \"Characterizing and predicting which bugs get fixed: an empirical study of Microsoft Windows\", <em>Proceedings of the 32nd International Conference on Software Engineering</em>, pp. 495-504, 2010.", "title": "Characterizing and predicting which bugs get fixed: an empirical study of Microsoft Windows", "context": [{"sec": "sec1", "text": " Aranda and Venolia identified the common bug fixing coordination patterns [2]; Guo et al. investigated factors that affected which bug could be fix [3] and characterized the bug reassignment process [4]; Breu et al. highlighted the importance of effectively and efficiently engaging user community in bug fixing activities [5].", "part": "1"}, {"sec": "sec2a", "text": " [3] described how the chances of fixing a bug was influenced by people's reputations, bug report edit activities, and geographical and organizational relationships.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806871", "abstract": "We performed an empirical study to characterize factors that affect which bugs get fixed in Windows Vista and Windows 7, focusing on factors related to bug report edits and relationships between people involved in handling the bug. We found that bugs reported by people with better reputations were more likely to get fixed, as were bugs handled by people on the same team and working in geographical proximity. We reinforce these quantitative results with survey feedback from 358 Microsoft employee...", "pdfSize": "189KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+and+predicting+which+bugs+get+fixed%3A+an+empirical+study+of+Microsoft+Windows&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "P.J. Guo, T. Zimmermann, N. Nagappan, B. Murphy, \"Not my bug! and other reasons for software bug report reassignments\", <em>Proceedings of the ACM 2011 Conference on Computer Supported Cooperative Work</em>, pp. 395-404, 2011.", "title": "Not my bug! and other reasons for software bug report reassignments", "context": [{"sec": "sec1", "text": " Aranda and Venolia identified the common bug fixing coordination patterns [2]; Guo et al. investigated factors that affected which bug could be fix [3] and characterized the bug reassignment process [4]; Breu et al. highlighted the importance of effectively and efficiently engaging user community in bug fixing activities [5].", "part": "1"}, {"sec": "sec2a", "text": " [4] continued to analyze the bug reassignment process in Windows Vista and classified five primary reasons for reassignment.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1958824.1958887", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Not+my+bug%21+and+other+reasons+for+software+bug+report+reassignments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "S. Breu, R. Premraj, J. Sillito, T. Zimmermann, \"Information needs in bug reports: improving cooperation between developers and users\", <em>Proceedings of the 2010 ACM conference on Computer supported cooperative work</em>, pp. 301-310, 2010.", "title": "Information needs in bug reports: improving cooperation between developers and users", "context": [{"sec": "sec1", "text": " Aranda and Venolia identified the common bug fixing coordination patterns [2]; Guo et al. investigated factors that affected which bug could be fix [3] and characterized the bug reassignment process [4]; Breu et al. highlighted the importance of effectively and efficiently engaging user community in bug fixing activities [5].", "part": "1"}, {"sec": "sec2a", "text": " [5] found that active and ongoing participation of reporters was beneficial for a quick bug fix.", "part": "1"}, {"sec": "sec4b1a", "text": "Previous studies have shown that bug reports containing stack traces, i.e., the sequences of calls that lead to the failure, will get fixed sooner [5], [31].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1718918.1718973", "abstract": "For many software projects, bug tracking systems play a central role in supporting collaboration between the developers and the users of the software. To better understand this collaboration and how tool support can be improved, we have quantitatively and qualitatively analysed the questions asked in a sample of 600 bug reports from the MOZILLA and ECLIPSE projects. We categorised the questions and analysed response rates and times by category and project. Our results show that the role of users...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Information+needs+in+bug+reports%3A+improving+cooperation+between+developers+and+users&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "K. Blincoe, F. Harrison, D. Damian, \"Ecosystems in GitHub and a method for ecosystem identification using reference coupling\", <em>Proceedings of the 12th Working Conference on Mining Software Repositories</em>, pp. 202-207, 2015.", "title": "Ecosystems in GitHub and a method for ecosystem identification using reference coupling", "context": [{"sec": "sec1", "text": " We base our study on the scientific Python ecosystem, one of the most prominent ecosystems on GitHub [6].", "part": "1"}, {"sec": "sec3b", "text": " [6] has shown that the scientific Python ecosystem is one of the most prominent ecosystems on GitHub with complicated dependencies among projects.", "part": "1"}], "links": {"documentLink": "/document/7180080", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180080", "abstract": "Software projects are not developed in isolation. Recent research has shifted to studying software ecosystems, communities of projects that depend on each other and are developed together. However, identifying technical dependencies at the ecosystem level can be challenging. In this paper, we propose a new method, known as reference coupling, for detecting technical dependencies between projects. The method establishes dependencies through user-specified cross-references between projects. We use...", "pdfSize": "624KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ecosystems+in+GitHub+and+a+method+for+ecosystem+identification+using+reference+coupling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "T. Zimmermann, N. Nagappan, P.J. Guo, B. Murphy, \"Characterizing and predicting which bugs get reopened\", <em>Proceedings of the 34th International Conference on Software Engineering</em>, pp. 1074-1083, 2012.", "title": "Characterizing and predicting which bugs get reopened", "context": [{"sec": "sec2a", "text": " [7] characterized the bug reopen process using a mixed-method approach and quantitatively assessed the impact of various factors.", "part": "1"}], "links": {"documentLink": "/document/6227112", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227112", "abstract": "Fixing bugs is an important part of the software development process. An underlying aspect is the effectiveness of fixes: if a fair number of fixed bugs are reopened, it could indicate instability in the software system. To the best of our knowledge there has been on little prior work on understanding the dynamics of bug reopens. Towards that end, in this paper, we characterize when bug reports are reopened by using the Microsoft Windows operating system project as an empirical case study. Our a...", "pdfSize": "608KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Characterizing+and+predicting+which+bugs+get+reopened&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "G. Canfora, L. Cerulo, M. Cimitile, M. Di Penta, \"Social interactions around cross-system bug fixings: the case of FreeBSD and OpenBSD\", <em>Procedings of 8th Working Conference on Mining Software Repositories</em>, pp. 143-152, 2011.", "title": "Social interactions around cross-system bug fixings: the case of FreeBSD and OpenBSD", "context": [{"sec": "sec2a", "text": " [8] investigated Cross-System-Bug-Fixings (CSBFs) in FreeBSD and OpenBSD kernels and associated their occurrences to social characteristics of contributors using social network analysis.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985441.1985463", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Social+interactions+around+cross-system+bug+fixings%3A+the+case+of+FreeBSD+and+OpenBSD&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "J. Bosch, P.M. Bosch-Sijtsema, \"Softwares product lines global development and ecosystems: collaboration in software engineering\", <em>Collaborative Software Engineering</em>, pp. 77-92, 2010.", "title": "Softwares product lines, global development and ecosystems: collaboration in software engineering", "context": [{"sec": "sec2b", "text": " Early analysis on software ecosystems mainly focus on defining the field and its limits [9]\u2013[11].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-10294-3_4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Softwares+product+lines%2C+global+development+and+ecosystems%3A+collaboration+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "S. Jansen, A. Finkelstein, S. Brinkkemper, \"A sense of community: a research agenda for software ecosystems\", <em>Procedings of 31st International Conference on Software Engineering \u2014 Companion Volume</em>, pp. 187-190, 2009.", "title": "A sense of community: a research agenda for software ecosystems", "context": [{"sec": "sec2b", "text": " Early analysis on software ecosystems mainly focus on defining the field and its limits [9]\u2013[10][11].", "part": "1"}], "links": {"documentLink": "/document/5070978", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070978", "abstract": "Software vendors lack the perspective to develop software within a software ecosystem. The inability to function in a software ecosystem has already led to the demise of many software vendors, leading to loss of competition, intellectual property, and eventually jobs in the software industry. In this paper we present a research agenda on software ecosystems to study both the technical and the business aspects of software engineering in vibrant ecosystems. The results of such research enable soft...", "pdfSize": "616KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+sense+of+community%3A+a+research+agenda+for+software+ecosystems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "D.G. Messerschmitt, C. Szyperski, <em>Software Ecosystem: Understanding an Indispensable Technology and Industry</em>, vol. 1, 2003.", "title": "Software Ecosystem: Understanding an Indispensable Technology and Industry", "context": [{"sec": "sec2b", "text": " Early analysis on software ecosystems mainly focus on defining the field and its limits [9]\u2013[11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+Ecosystem%3A+Understanding+an+Indispensable+Technology+and+Industry&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "M. Lungu, M. Lanza, T. G\u00eerba, R. Robbes, \"The small project observatory: visualizing software ecosystems\", <em>Science of Computer Programming</em>, vol. 75, no. 4, pp. 264-275, 2010.", "title": "The small project observatory: visualizing software ecosystems", "context": [{"sec": "sec2b", "text": " In this study, we consider a software ecosystem as \u201ca collection of software projects which are developed and evolve together in the same environment\u201d [12].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.scico.2009.09.004", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+small+project+observatory%3A+visualizing+software+ecosystems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "A. Hora, R. Robbes, N. Anquetil, A. Etien, S. Ducasse, M.T. Valente, \"How do developers react to API evolution? The Pharo ecosystem case\", <em>Procedings of 2015 IEEE International Conference on Software Maintenance and Evolution</em>, pp. 251-260, 2015.", "title": "How do developers react to API evolution? The Pharo ecosystem case", "context": [{"sec": "sec2b", "text": " [13] observed API evolution and its impact on Pharo ecosystem, as well as analyzed how developers reacted to API changes.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+developers+react+to+API+evolution%3F+The+Pharo+ecosystem+case&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "R. Robbes, M. Lungu, D. R\u00f6thlisberger, \"How do developers react to API deprecation? The case of a Smalltalk ecosystem\", <em>Proceedings of the ACM SIGSOFT 20th International Symposium on the Foundations of Software Engineering</em>, pp. 56: 1-56:11, 2012.", "title": "How do developers react to API deprecation? The case of a Smalltalk ecosystem", "context": [{"sec": "sec2b", "text": " [14] investigated the ripple effects of API deprecations across a Smalltalk ecosystem.", "part": "1"}, {"sec": "sec5a", "text": " First, it is often impossible to get the complete list of downstream projects, and developers even may not know how their projects are used by the downstream ones [14].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+developers+react+to+API+deprecation%3F+The+case+of+a+Smalltalk+ecosystem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "G. Bavota, G. Canfora, M. Di Penta, R. Oliveto, S. Panichella, \"How the Apache community upgrades dependencies: an evolutionary study\", <em>Empirical Software Engineering</em>, vol. 20, no. 5, pp. 1275-1317, Oct. 2015.", "title": "How the Apache community upgrades dependencies: an evolutionary study", "context": [{"sec": "sec2b", "text": " [15] analyzed the evolution of project inter-dependencies in the Java subset of the Apache ecosystem.", "part": "1"}, {"sec": "sec5a", "text": " The downstream developers are always waiting for a new upstream release with the corresponding bug fixes, and they tend to upgrade their dependencies when the upstream side perform bug fix activities [15].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-014-9325-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+the+Apache+community+upgrades+dependencies%3A+an+evolutionary+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "A. Decan, T. Mens, M. Claes, P. Grosjean, \"On the development and distribution of R packages: an empirical analysis of the R ecosystem\", <em>Proceedings of the 2015 European Conference on Software Architecture Workshops</em>, pp. 41:1-41:6, 2015.", "title": "On the development and distribution of R packages: an empirical analysis of the R ecosystem", "context": [{"sec": "sec2b", "text": " [16] studied the development of the R ecosystem on four repositories.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+development+and+distribution+of+R+packages%3A+an+empirical+analysis+of+the+R+ecosystem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "A. Decan, T. Mens, M. Claes, P. Grosjean, \"When GitHub meets CRAN: an analysis of inter-repository package dependency problems\", <em>Procedings of International Conference on Software Analysis Evolution and Reengineering</em>, pp. 493-504, 2016.", "title": "When GitHub meets CRAN: an analysis of inter-repository package dependency problems", "context": [{"sec": "sec2b", "text": " They then further concentrated on inter-repository package dependency problems, discussing how GitHub influenced the R ecosystem [17].", "part": "1"}, {"sec": "sec6", "text": " Decan et al. reported that the developers in R ecosystems felt it more and more of a pain if the upstream packages broke [17].", "part": "1"}], "links": {"documentLink": "/document/7476669", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7476669", "abstract": "When developing software packages in a software ecosystem, an important and well-known challenge is how to deal with dependencies to other packages. In presence of multiple package repositories, dependency management tends to become even more problematic. For the R ecosystem of statistical computing, dependency management is currently insufficient to deal with multiple package versions and inter-repository package dependencies. We explore how the use of GitHub influences the R ecosystem, both fo...", "pdfSize": "313KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+GitHub+meets+CRAN%3A+an+analysis+of+inter-repository+package+dependency+problems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "J. Sheoran, K. Blincoe, E. Kalliamvakou, D. Damian, J. Ell, \"Understanding \u201cwatchers\u201d on GitHub\", <em>Proceedings of the 11th Working Conference on Mining Software Repositories</em>, pp. 336-339, 2014.", "title": "Understanding \u201cwatchers\u201d on GitHub", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2597073.2597114", "abstract": "Users on GitHub can watch repositories to receive notifications about project activity. This introduces a new type of passive project membership. In this paper, we investigate the behavior of watchers and their contribution to the projects they watch. We find that a subset of project watchers begin contributing to the project and those contributors account for a significant percentage of contributors on the project. As contributors, watchers are more confident and contribute over a longer period...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+%E2%80%9Cwatchers%E2%80%9D+on+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "W. Wang, G. Poo-Caamano, E. Wilde, D.M. German, \"What is the gist? Understanding the use of public gists on GitHub\", <em>Procedings of 2015 IEEE/ACM 12th Working Conference on Mining Software Repositories</em>, pp. 314-323, 2015.", "title": "What is the gist? Understanding the use of public gists on GitHub", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[26].", "part": "1"}], "links": {"documentLink": "/document/7180090", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7180090", "abstract": "GitHub is a popular source code hosting site which serves as a collaborative coding platform. The many features of GitHub have greatly facilitated developers&#39; collaboration, communication, and coordination. Gists are one feature of GitHub, which defines them as &#34;a simple way to share snippets and pastes with others.&#34; This three-part study explores how users are using Gists. The first part is a quantitative analysis of Gist metadata and contents. The second part investigates the information conta...", "pdfSize": "188KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+is+the+gist%3F+Understanding+the+use+of+public+gists+on+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "L. Dabbish, C. Stuart, J. Tsay, J. Herbsleb, \"Social coding in GitHub: transparency and collaboration in an open software repository\", <em>Proceedings of the ACM 2012 Conference on Computer Supported Cooperative Work</em>, pp. 1277-1286, 2012.", "title": "Social coding in GitHub: transparency and collaboration in an open software repository", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[26].", "part": "1"}, {"sec": "sec2c", "text": " [20] examined the collaborative utility of activity transparency based on a series of in-depth interviews with central and peripheral GitHub users.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2145204.2145396", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Social+coding+in+GitHub%3A+transparency+and+collaboration+in+an+open+software+repository&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "E. Kalliamvakou et al., \"Open source-style collaborative development practices in commercial projects using GitHub\", <em>Proceedings of 2015 IEEE/ACM 37th IEEE International Conference on Software Engineering</em>, pp. 574-585, 2015.", "title": "Open source-style collaborative development practices in commercial projects using GitHub", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[21][26].", "part": "1"}], "links": {"abstract": "Researchers are currently drawn to study projects hosted on GitHub due to its popularity, ease of obtaining data, and its distinctive built-in social features. GitHub has been found to create a transparent development environment, which together with a pull request-based workflow, provides a lightweight mechanism for committing, reviewing and managing code changes. These features impact how GitHub is used and the benefits it provides to teams&#39; development and collaboration. While most of the evi...", "pdfSize": "1198KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Open+source-style+collaborative+development+practices+in+commercial+projects+using+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "A. Lima, L. Rossi, M. Musolesi, \"Coding together at scale: GitHub as a collaborative social network\", <em>Proceedings of the 8th International Conference on Weblogs and Social Media ICWSM 2014</em>, pp. 295-304, 2014.", "title": "Coding together at scale: GitHub as a collaborative social network", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[22][26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Coding+together+at+scale%3A+GitHub+as+a+collaborative+social+network&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "J. Tsay, L. Dabbish, J. Herbsleb, \"Influence of social and technical factors for evaluating contribution in GitHub\", <em>Proceedings of 36th International Conference on Software Engineering</em>, pp. 356-366, 2014.", "title": "Influence of social and technical factors for evaluating contribution in GitHub", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[23][26].", "part": "1"}, {"sec": "sec2c", "text": " [23] quantitatively analyzed how various technical and social measures were used to evaluate contributions in open source projects.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568315", "abstract": "Open source software is commonly portrayed as a meritocracy, where decisions are based solely on their technical merit. However, literature on open source suggests a complex social structure underlying the meritocracy. Social work environments such as GitHub make the relationships between users and between users and work artifacts transparent. This transparency enables developers to better use information such as technical value and social connections when making work decisions. We present a stu...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Influence+of+social+and+technical+factors+for+evaluating+contribution+in+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "J. Tsay, L. Dabbish, J. Herbsleb, \"Let's talk about it: evaluating contributions through discussion in GitHub\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 144-154, 2014.", "title": "Let's talk about it: evaluating contributions through discussion in GitHub", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[24][26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635882", "abstract": "Open source software projects often rely on code contributions from a wide variety of developers to extend the capabilities of their software. Project members evaluate these contributions and often engage in extended discussions to decide whether to integrate changes. These discussions have important implications for project management regarding new contributors and evolution of project requirements and direction. We present a study of how developers in open work environments evaluate and discus...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Let%27s+talk+about+it%3A+evaluating+contributions+through+discussion+in+GitHub&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "G. Gousios, A. Zaidman, M.A. Storey, A. Van Deursen, \"Work practices and challenges in pull-based development: the integrator's perspective\", <em>Procedings of the 37th International Conference on Software Engineering</em>, pp. 358-368, 2015.", "title": "Work practices and challenges in pull-based development: the integrator's perspective", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[25][26].", "part": "1"}, {"sec": "sec2c", "text": " Gousios et al. studied the practices and challenges in pull-based development from the perspectives of the integrators [25] and the contributors [26].", "part": "1"}], "links": {"abstract": "In the pull-based development model, the integrator has the crucial role of managing and integrating contributions. This work focuses on the role of the integrator and investigates working habits and challenges alike. We set up an exploratory qualitative study involving a large-scale survey of 749 integrators, to which we add quantitative data from the integrator&#39;s project. Our results provide insights into the factors they consider in their decision making process to accept or reject a contribu...", "pdfSize": "1141KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Work+practices+and+challenges+in+pull-based+development%3A+the+integrator%27s+perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "G. Georgios, A. Bacchelli, \"Work practices and challenges in pull-based development: the contributor's perspective\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 285-296, 2014.", "title": "Work practices and challenges in pull-based development: the contributor's perspective", "context": [{"sec": "sec2c", "text": " Due to its prominent feature of social coding and pull-based model, a large number of research works on GitHub emphasize its social media [18], [19] and the collaboration between developers [20]\u2013[26].", "part": "1"}, {"sec": "sec2c", "text": " Gousios et al. studied the practices and challenges in pull-based development from the perspectives of the integrators [25] and the contributors [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Work+practices+and+challenges+in+pull-based+development%3A+the+contributor%27s+perspective&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>GitHub Octoverse 2016</em>, 2016,  [online]  Available: https://octoverse.github.com/.", "title": "GitHub Octoverse 2016", "context": [{"sec": "sec3b", "text": " Python is one of the top three most popular programming languages used on GitHub in 2016 [27].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=GitHub+Octoverse+2016&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "F. Perez, B.E. Granger, J.D. Hunter, \"Python: an ecosystem for scientific computing\", <em>Computing in Science & Engineering</em>, vol. 13, no. 2, pp. 13-21, Mar. 2011.", "title": "Python: an ecosystem for scientific computing", "context": [{"sec": "sec3b", "text": " Augmented with a stack of open source tools for computation in mathematics, science, and engineering tasks developed by a diverse group of scientists and engineers, Python provides a computational ecosystem that is capable of tackling various challenges in scientific computing [28].", "part": "1"}], "links": {"documentLink": "/document/5582063", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5582063", "abstract": "As the relationship between research and computing evolves, new tools are required to not only treat numerical problems, but also to solve various problems that involve large datasets in different formats, new algorithms, and computational systems such as databases and Internet servers. Python can help develop these computational research tools by providing a balance of clarity and flexibility without sacrificing performance.", "pdfSize": "217KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Python%3A+an+ecosystem+for+scientific+computing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "<em>Topical software \u2014 SciPy.org</em>,  [online]  Available: http://scipy.org/topical-software.html.", "title": "Topical software \u2014 SciPy.org", "context": [{"sec": "sec3b", "text": " Second, they are located at different layers in the scientific computing hierarchy, e.g., IPython is a working environment, NumPy and SciPy are tools providing primitives, Pandas provides high-performance data manipulation and analysis, Matplotlib is a supporting tool for data visualization, and Scikit-learn, and Astropy are designed for specific scientific fields (machine learning and astronomy, respectively [29]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Topical+software+%E2%80%94+SciPy.org&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "T. Punter, M. Ciolkowski, B. Freimut, I. John, \"Conducting on-line surveys in software engineering\", <em>Proceedings of 2003 International Symposium on Empirical Software Engineering</em>, pp. 80-88, 2003.", "title": "Conducting on-line surveys in software engineering", "context": [{"sec": "sec3d2c", "text": " It is acceptable since the response rate for online surveys in software engineering is usually within the 14-20% range [30].", "part": "1"}, {"sec": "sec6", "text": " To encourage responses, the amount and type of the questions in the questionnaires were carefully designed according to [30].", "part": "1"}], "links": {"abstract": "One purpose of empirical software engineering is to enable an understanding of factors that influence software development. Surveys are an appropriate empirical strategy to gather data from a large population (e.g., about methods, tools, developers, companies) and to achieve an understanding of that population. Although surveys are quite often performed, for example, in social sciences and marketing research, they are underrepresented in empirical software engineering research, which most often ...", "pdfSize": "244KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Conducting+on-line+surveys+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "N. Bettenburg, S. Just, A. Schr\u00f6ter, C. Weiss, R. Premraj, T. Zimmermann, \"What makes a good bug report?\", <em>Proceedings of the 16th ACM SIGSOFT International Symposium on Foundations of software engineering</em>, pp. 308-318, 2008.", "title": "What makes a good bug report?", "context": [{"sec": "sec4b1a", "text": "Previous studies have shown that bug reports containing stack traces, i.e., the sequences of calls that lead to the failure, will get fixed sooner [5], [31].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1453101.1453146", "abstract": "In software development, bug reports provide crucial information to developers. However, these reports widely differ in their quality. We conducted a survey among developers and users of APACHE, ECLIPSE, and MOZILLA to find out what makes a good bug report. The analysis of the 466 responses revealed an information mismatch between what developers need and what users supply. Most developers consider steps to reproduce, stack traces, and test cases as helpful, which are at the same time most diffi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=What+makes+a+good+bug+report%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "J. Anvik, L. Hiew, G.C. Murphy, \"Who should fix this bug?\", <em>Proceeding of 28th international conference on Software engineering</em>, pp. 361-370, 2006.", "title": "Who should fix this bug?", "context": [{"sec": "sec4b1c", "text": "When fixing a within-project bug, the developer with expertise in the buggy component is the preferable assignee of the task, since he is familiar with the code and likely to fix it quickly [32], [33].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134336", "abstract": "Open source development projects typically support an open bug repository to which both developers and users can report bugs. The reports that appear in this repository must be triaged to determine if the report is one which requires attention and if it is, which developer will be assigned the responsibility of resolving the report. Large open source developments are burdened by the rate at which new bug reports appear in the bug repository. In this paper, we present a semi-automated approach in...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Who+should+fix+this+bug%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "T.T. Nguyen, T.N. Nguyen, E. Duesterwald, T. Klinger, P. Santhanam, \"Inferring developer expertise through defect analysis\", <em>Proceedings of 34th International Conference on Software Engineering</em>, pp. 1297-1300, 2012.", "title": "Inferring developer expertise through defect analysis", "context": [{"sec": "sec4b1c", "text": "When fixing a within-project bug, the developer with expertise in the buggy component is the preferable assignee of the task, since he is familiar with the code and likely to fix it quickly [32], [33].", "part": "1"}], "links": {"documentLink": "/document/6227095", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227095", "abstract": "Fixing defects is an essential software development activity. For commercial software vendors, the time to repair defects in deployed business-critical software products or applications is a key quality metric for sustained customer satisfaction. In this paper, we report on the analysis of about 1,500 defect records from an IBM middle-ware product collected over a five-year period. The analysis includes a characterization of each repaired defect by topic and a ranking of developers by inferred e...", "pdfSize": "126KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inferring+developer+expertise+through+defect+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "M. Ohira, A.E. Hassan, N. Osawa, K. Matsumoto, \"The impact of bug management patterns on bug fixing: a case study of Eclipse projects\", <em>Proceedings of 2012 28th IEEE International Conference on Software Maintenance</em>, pp. 264-273, 2012.", "title": "The impact of bug management patterns on bug fixing: a case study of Eclipse projects", "context": [{"sec": "sec4b2", "text": " It is consistent with study on within-project bugs, as Ohira et al. pointed out that developers could fix bugs more efficiently through more discussions before assigning them [34].", "part": "1"}], "links": {"documentLink": "/document/6405281", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6405281", "abstract": "An efficient bug management process is critical for the success of software projects. Prior work has focused on improving this process, for example, by automating bug triaging, detecting duplicate bugs, and understanding the rationale for re-opening bugs. This paper continues this line of work by exploring the people who are involved in the bug management process. In particular we develop four patterns that distill the different relations between the people involved in the process: the reporter,...", "pdfSize": "503KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+impact+of+bug+management+patterns+on+bug+fixing%3A+a+case+study+of+Eclipse+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "E. Murphy-Hill, T. Zimmermann, C. Bird, N. Nagappan, \"The design of bug fixes\", <em>Proceedings of 35th International Conference on Software Engineering</em>, pp. 332-341, 2013.", "title": "The design of bug fixes", "context": [{"sec": "sec4c2a", "text": " Murphy-Hill et al. summarized six factors that affect developers' decisions, that is, risk management, interface breakage, consistency, user behavior, cause understanding, and social factors [35].", "part": "1"}], "links": {"abstract": "When software engineers fix bugs, they may have several options as to how to fix those bugs. Which fix they choose has many implications, both for practitioners and researchers: What is the risk of introducing other bugs during the fix? Is the bug fix in the same code that caused the bug? Is the change fixing the cause or just covering a symptom? In this paper, we investigate alternative fixes to bugs and present an empirical study of how engineers make design choices about how to fix bugs. Base...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+design+of+bug+fixes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "C. Bogart, C. Kastner, J. Herbsleb, \"When it breaks it breaks: how ecosystem developers reason about the stability of dependencies\", <em>Procedings of 2015 30th IEEE/ACM InternationalConference on Automated Software Engineering Workshop</em>, pp. 86-89, 2015.", "title": "When it breaks, it breaks: how ecosystem developers reason about the stability of dependencies", "context": [{"sec": "sec5a", "text": " Though GitHub users could subscribe to their interested issues to track the issue status and receive notifications of every new comment, they may easily be overloaded with a large volume of messages/notifications [36] and miss the information of bug fixing.", "part": "1"}], "links": {"abstract": "Dependencies among software projects and libraries are an indicator of the often implicit collaboration among many developers in software ecosystems. Negotiating change can be tricky: changes to one module may cause ripple effects to many other modules that depend on it, yet insisting on only backward-compatible changes may incur significant opportunity cost and stifle change. We argue that awareness mechanisms based on various notions of stability can enable developers to make decisions that ar...", "pdfSize": "173KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=When+it+breaks%2C+it+breaks%3A+how+ecosystem+developers+reason+about+the+stability+of+dependencies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "<em>Add explicit \u2018+1\u2019 feature for issues that isn't a comment</em>, 2013,  [online]  Available: https:llgithub.com/isaacs/github/issues/9.", "title": "Add explicit \u2018+1\u2019 feature for issues that isn't a comment", "context": [{"sec": "sec5b2", "text": " Many users of GitHub issue tracker have suggested this feature [37], [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Add+explicit+%E2%80%98%2B1%E2%80%99+feature+for+issues+that+isn%27t+a+comment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "<em>Idea: A voting system for comments</em>, 2014,  [online]  Available: https://github.com/isaacs/github/issues/209.", "title": "Idea: A voting system for comments", "context": [{"sec": "sec5b2", "text": " Many users of GitHub issue tracker have suggested this feature [37], [38].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Idea%3A+A+voting+system+for+comments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "R. Holmes, R.J. Walker, \"Customized awareness: recommending relevant external change events\", <em>Proceedings of the 32nd InternationalConference on Software Engineering</em>, pp. 465-474, 2010.", "title": "Customized awareness: recommending relevant external change events", "context": [{"sec": "sec6", "text": " Holmes and Walker also described similar problems in other platforms [39].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806867", "abstract": "It is often assumed that developers&#39; view of their system and its environment is always consistent with everyone else&#39;s; in practice, this assumption can be false, as the developer has little practical control over changes to the environments in which their code will be deployed. To proactively respond to such situations, developers must constantly monitor a flood of information involving changes to the deployment environments; unfortunately, the vast majority of this information is irrelevant t...", "pdfSize": "350KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Customized+awareness%3A+recommending+relevant+external+change+events&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985678", "articleId": "7985678", "startPage": "381", "endPage": "392", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 9, "citationCountPatent": 0, "totalDownloads": 730}}
{"title": "DeepPerf: Performance Prediction for Configurable Software with Deep Sparse Neural Network", "authors": [{"name": "Huong Ha", "affiliation": "The University of Newcastle, Australia", "firstName": "Huong", "lastName": "Ha", "id": "37085537616"}, {"name": "Hongyu Zhang", "affiliation": "The University of Newcastle, Australia", "firstName": "Hongyu", "lastName": "Zhang", "id": "37085471743"}], "abstract": "Many software systems provide users with a set of configuration options and different configurations may lead to different runtime performance of the system. As the combination of configurations could be exponential, it is difficult to exhaustively deploy and measure system performance under all possible configurations. Recently, several learning methods have been proposed to build a performance prediction model based on performance data collected from a small sample of configurations, and then use the model to predict system performance under a new configuration. In this paper, we propose a novel approach to model highly configurable software system using a deep feedforward neural network (FNN) combined with a sparsity regularization technique, e.g. the L1 regularization. Besides, we also design a practical search strategy for automatically tuning the network hyperparameters efficiently. Our method, called DeepPerf, can predict performance values of highly configurable software systems with binary and/or numeric configuration options at much higher prediction accuracy with less training data than the state-of-the art approaches. Experimental results on eleven public real-world datasets confirm the effectiveness of our approach.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Software systems", "Predictive models", "Software performance", "Tuning", "System performance", "Biological neural networks", "Data models"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["feedforward neural nets", "learning (artificial intelligence)"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["deep feedforward neural network", "network hyperparameters", "performance values", "binary configuration options", "numeric configuration options", "deep sparse neural network", "system performance", "performance prediction model", "performance data", "configurable software system", "configurable software systems", "runtime performance"]}, {"type": "Author Keywords ", "kwd": ["software performance prediction, deep sparse feedforward neural network, highly configurable systems, sparsity regularization"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00113", "ref": [{"order": "1", "text": "<em>DECART project</em>,  [online]  Available: https://github.com/jmguo/DECART.", "title": "DECART project", "context": [{"sec": "sec4c", "text": "To replicate the DECART results, we utilize the code published on their project page [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DECART+project&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>SPLConqueror project page</em>,  [online]  Available: http://www.fosd.de/SPLConqueror.", "title": "SPLConqueror project page", "context": [{"sec": "sec4b", "text": " These software systems were measured and published online [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=SPLConqueror+project+page&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "M. Abadi, P. Barham et al., \"Tensorflow: A system for large-scale machine learning\", <em>12th USENIX Symposium on Operating Systems Design and Implementation (OSDI)</em>, pp. 265-283, 2016.", "title": "Tensorflow: A system for large-scale machine learning", "context": [{"sec": "sec3e", "text": "We implement our proposed approach, DeepPerf, using Python 3.6 and Tensorflow 1.8.0 [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tensorflow%3A+A+system+for+large-scale+machine+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "M. Anthony, \"Boolean functions and artificial neural networks\", <em>Technical Report CMU/SEI-90-TR-021</em>, 2003.", "title": "Boolean functions and artificial neural networks", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Boolean+functions+and+artificial+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "A. R. Barron, \"Universal approximation bounds for superpositions of a sigmoidal function\", <em>IEEE Transactions on Information Theory</em>, vol. 39, no. 3, pp. 930-945, 1993.", "title": "Universal approximation bounds for superpositions of a sigmoidal function", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}, {"sec": "sec3a", "text": " However, to achieve a high level of accuracy, in the worst case, the number of neurons needed for a shallow FNN with one single hidden layer is an exponential number of the inputs [5].", "part": "1"}], "links": {"documentLink": "/document/256500", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=256500", "abstract": "Approximation properties of a class of artificial neural networks are established. It is shown that feedforward networks with one layer of sigmoidal nonlinearities achieve integrated squared error of order O(1/n), where n is the number of nodes. The approximated function is assumed to have a bound on the first moment of the magnitude distribution of the Fourier transform. The nonlinear parameters associated with the sigmoidal nodes, as well as the parameters of linear combination, are adjusted i...", "pdfSize": "1801KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Universal+approximation+bounds+for+superpositions+of+a+sigmoidal+function&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "D. Batory, D. Benavides, A. Ruiz-Cortes, \"Automated analysis of feature models: Challenges ahead\", <em>Communications of the ACM</em>, vol. 49, no. 12, pp. 45-47, December 2006.", "title": "Automated analysis of feature models: Challenges ahead", "context": [{"sec": "sec5", "text": " A large body of work has been devoted to modeling features and checking consistency of feature configurations (e.g., [6], [12], [47], [52]).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1183236.1183264", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+analysis+of+feature+models%3A+Challenges+ahead&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "J. Bergstra, Y. Bengio, \"Random search for hyperparameter optimization\", <em>The Journal of Machine Learning Research</em>, vol. 13, pp. 281-305, 2012.", "title": "Random search for hyperparameter optimization", "context": [{"sec": "sec2c", "text": " The problem of identifying a good set of hyperparameters. \\$\\eta\\$, is called hyperparameter optmization [7].", "part": "1"}, {"sec": "sec2c", "text": " The critical step in hyperparameter optimization is to choose the set of trials \\$\\{\\eta^{(1)},\\ \\eta^{(2)},\\ \\ldots\\}\\$ effectively [7].", "part": "1"}, {"sec": "sec2c", "text": " There are several widely used approaches to choose this set of trials from the hyperparameter space: grid search, random search [7], bayesian optimization [44], etc.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Random+search+for+hyperparameter+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "M. Calder, M. Kolberg, E. Magill, S. Reiff-Marganiec, \"Feature interaction: A critical review and considered forecast\", <em>Computer Networks</em>, vol. 41, no. 1, pp. 115-141, 2003.", "title": "Feature interaction: A critical review and considered forecast", "context": [{"sec": "sec1", "text": "The challenge for building a performance prediction model is in the interactions between configuration options (features), i.e. a particular combination of features causes an unexpected behaviour on the system performance while their individual presences do not [8], [34], [42].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S1389-1286(02)00352-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+interaction%3A+A+critical+review+and+considered+forecast&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "C. Chang, C.J. Lin, \"LIBSVM: A library for support vector machines\", <em>ACM Transactions on Intelligent Systems and Technology</em>, pp. 2:27:1-27:27, 2011.", "title": "LIBSVM: A library for support vector machines", "context": [{"sec": "sec4e", "text": " Scikit-learn SVR function is implemented using libsvm, an SVM library proposed in [9].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1961189.1961199", "abstract": "LIBSVM is a library for Support Vector Machines (SVMs). We have been actively developing this package since the year 2000. The goal is to help users to easily apply SVM to their applications. LIBSVM has gained wide popularity in machine learning and many other areas. In this article, we present all implementation details of LIBSVM. Issues such as solving SVM optimization problems theoretical convergence multiclass classification probability estimates and parameter selection are discussed in deta...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=LIBSVM%3A+A+library+for+support+vector+machines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "C. Cortes, V. Vladimir, \"Support-vector networks\", <em>Machine learning</em>, vol. 20, no. 3, pp. 273-297, 1995.", "title": "Support-vector networks", "context": [{"sec": "sec4e", "text": " We compare DeepPerf with the SVM regression method [10] and other design alternatives that were discussed in Section III-B:\n\n\n1)\nDeep FNN with the \\$L_{1}\\$ regularization applied to all layers (L1-all-FNN)\n\n\n2)\nDeep FNN without regularization (Plain-FNN)\n\n\n3)\nDeep FNN with the \\$L_{2}\\$ regularization [50] (L2-FNN)\n\n\n4)\nDeep FNN with the dropout technique [45] (Dropout-FNN)\n\n\n Five binary subject systems in Table II with three sample sizes per system will be used to evaluate the approaches.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF00994018", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Support-vector+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "G. Cybenko, \"Approximation by superpositions of a sigmoidal function\", <em>Mathematics of Control Signals and Systems</em>, vol. 2, no. 4, pp. 303-314, 1989.", "title": "Approximation by superpositions of a sigmoidal function", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}, {"sec": "sec3a", "text": "As stated in the universal approximation theorem [11], [23], [28], a shallow FNN having one linear output layer and one hidden layer with enough neurons and a suitable activation function (e.g. sigmoid, ReLU) can approximate any continuous function from one finite dimensional space to the other at any level of accuracy.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/BF02551274", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Approximation+by+superpositions+of+a+sigmoidal+function&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "K. Czarnecki, A. Wasowski, \"Feature diagrams and logics: There and back again\", <em>Proceedings of the 11 th International Software Product Line Conference (SPLC)</em>, pp. 23-34, 2007.", "title": "Feature diagrams and logics: There and back again", "context": [{"sec": "sec5", "text": " A large body of work has been devoted to modeling features and checking consistency of feature configurations (e.g., [6], [12], [47], [52]).", "part": "1"}], "links": {"documentLink": "/document/4339252", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4339252", "abstract": "Feature modeling is a notation and an approach for modeling commonality and variability in product families. In their basic form, feature models contain mandatory/optional features, feature groups, and implies and excludes relationships. It is known that such feature models can be translated into propositional formulas, which enables the analysis and configuration using existing logic- based tools. In this paper, we consider the opposite translation problem, that is, the extraction of feature mo...", "pdfSize": "191KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+diagrams+and+logics%3A+There+and+back+again&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "R. Eldan, O. Shamir, \"The power of depth for feedforward neural networks\", <em>Proceedings of the JMLR: Workshop and Conference</em>, vol. 49, pp. 1-34, 2016.", "title": "The power of depth for feedforward neural networks", "context": [{"sec": "sec3a", "text": " When using FNNs to approximate functions, for a given upper bound of the approximation error, shallow FNNs require exponential more parameters than deep FNNs [13], [29], [53].", "part": "1"}, {"sec": "sec3c", "text": " Previous studies also show that the network depth is what matters most [13], [29], [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+power+of+depth+for+feedforward+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "T. Foss, E. Stensrud, B. Kitchenham, I. Myrtveit, \"A simulation study of the model evaluation criterion mmre\", <em>IEEE Transactions on Software Engineering</em>, vol. 29, no. 11, pp. 985-995, 2003.", "title": "A simulation study of the model evaluation criterion mmre", "context": [{"sec": "sec4a", "text": " We choose this metric as it is widely used to measure the accuracy of prediction models [14], [21], [25], [41].", "part": "1"}, {"sec": "sec5", "text": " Their method is good for quality attributes (such as security, reusability, etc) that are \u201chard to define, impossible to measure, easy to recognize [14]\u201d.", "part": "1"}], "links": {"documentLink": "/document/1245300", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1245300", "abstract": "The mean magnitude of relative error, MMRE, is probably the most widely used evaluation criterion for assessing the performance of competing software prediction models. One purpose of MMRE is to assist us to select the best model. In this paper, we have performed a simulation study demonstrating that MMRE does not always select the best model. Our findings cast some doubt on the conclusions of any study of competing software prediction models that use MMRE as a basis of model comparison. We ther...", "pdfSize": "624KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+simulation+study+of+the+model+evaluation+criterion+mmre&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "K. Funahashi, \"On the approximate realization of continuous mappings by neural networks\", <em>Neural Networks</em>, vol. 2, no. 3, pp. 183-192, 1989.", "title": "On the approximate realization of continuous mappings by neural networks", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0893-6080(89)90003-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+approximate+realization+of+continuous+mappings+by+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "X. Glorot, Y. Bengio, \"Understanding the difficulty of training deep feedforward neural networks\", <em>Proceedings of the 13th International Conference on Artificial Intelligence and Statistics (AISTATS)</em>, pp. 249-256, 2010.", "title": "Understanding the difficulty of training deep feedforward neural networks", "context": [{"sec": "sec3d", "text": " In addition, we utilize Xavier initialization [16] to initialize weights of all the hidden layers in the network.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+the+difficulty+of+training+deep+feedforward+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "X. Glorot, A. Bordes, Y. Bengio, \"Deep sparse rectifier neural networks\", <em>Proceedings of the 14th International Conference on Artificial Intelligence and Statistics (AISTATS)</em>, pp. 315-323, 2011.", "title": "Deep sparse rectifier neural networks", "context": [{"sec": "sec2b", "text": " Nowadays, \\$L_{1}\\$ regularization is not only applied in linear regression, but also in other models such as logistic regression [33] or neural network [17], [51].", "part": "1"}, {"sec": "sec3a", "text": " Meanwhile, the ReLU is chosen as the activation function of the hidden layers due to its ability to learn much faster in networks with many layers compared to other non-linear activation functions [17], [30].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+sparse+rectifier+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "I. Goodfellow, Y. Bengio, A. Courville, Deep Learning, MIT Press, 2016.", "title": "Deep Learning", "context": [{"sec": "sec1", "text": " A deep FNN is a multilayer stack of computational units (neurons), with the first layer taking the input, the last layer producing the output and the middle layers (hidden layers) connecting the input and the output layer [18].", "part": "1"}, {"sec": "sec3a", "text": " Unfortunately, in practice, there is no guarantee we can train such a neural network that has a very large number of neurons [18].", "part": "1"}, {"sec": "sec3a", "text": " The reasons are: (1) the optimization algorithm used might not be able to find the values of the parameters corresponding to the desired function, (2) the training algorithm might choose the wrong function [18].", "part": "1"}, {"sec": "sec3c", "text": " The reason we need to add a few layers after finding the optimal non-regularized FNN architecture is that when we apply regularization to a network, the network needs to be deeper compared to a non-regularized one in order to achieve high prediction accuracy [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+Learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "J. Guo, K. Czarnecki, S. Apel, N. Siegmund, A. Wsowski, \"Variability-aware performance prediction: A statistical learning approach\", <em>Proceedings of the 28th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 301-311, 2013.", "title": "Variability-aware performance prediction: A statistical learning approach", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": "Another approach is to consider the performance prediction problem as a non-linear regression problem and apply a statistical learning method, e.g. the Classification And Regression Trees (CART) technique, to find this non-linear model [19].", "part": "1"}, {"sec": "sec4c", "text": "As mentioned in Introduction, at present, there are many learning methods for predicting performance values of software systems with binary options, including SPLConqueror [41], [42], Fourierl.eaming [55], and DECART [21] (the improved version of CART [19]).", "part": "1"}, {"sec": "sec5", "text": " In Introduction, we have described pros and cons of some state-of-the-art methods including SPLConqueror [40], [42], CARTIDECART [19], [21] and FourierLearning [55].", "part": "1"}], "links": {"documentLink": "/document/6693089", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693089", "abstract": "Configurable software systems allow stakeholders to derive program variants by selecting features. Understanding the correlation between feature selections and performance is important for stakeholders to be able to derive a program variant that meets their requirements. A major challenge in practice is to accurately predict performance based on a small sample of measured variants, especially when features interact. We propose a variability-aware approach to performance prediction via statistica...", "pdfSize": "413KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Variability-aware+performance+prediction%3A+A+statistical+learning+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "J. Guo, J. White, G. Wang, J. Li, Y. Wang, \"A genetic algorithm for optimized feature selection with resource constraints in software product lines\", <em>Journal of Systems and Software</em>, vol. 84, no. 12, pp. 2208-2221, 2011.", "title": "A genetic algorithm for optimized feature selection with resource constraints in software product lines", "context": [{"sec": "sec5", "text": " A quantitative analysis of these quality attributes can be complementary to the qualitative analysis [20].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2011.06.026", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+genetic+algorithm+for+optimized+feature+selection+with+resource+constraints+in+software+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "J. Guo, D. Yang, N. Siegmund, S. Apel, A. Sarkar, P. Valov, K. Czarnecki, A. Wasowski, H. Yu, \"Data-efficient performance learning for configurable systems\", <em>Empirical Software Engineering</em>, vol. 23, no. 3, pp. 1826-1867, 2018.", "title": "Data-efficient performance learning for configurable systems", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": " Besides, SPLConqueror usually requires more sample than other approaches as their focus is to make the influences of configuration options and their interactions explicit [21], [37], [41].", "part": "1"}, {"sec": "sec1", "text": " Recently, it was further extended by combining with various resampling and machine learning hyperparameter tuning techniques and became a more data-efficient performance learning algorithm (DECART) [21].", "part": "1"}, {"sec": "sec1", "text": " That is, compared to CART, DE-CART uses less measurement effort to learn and validate a performance-prediction model [21].", "part": "1"}, {"sec": "sec4a", "text": " We choose this metric as it is widely used to measure the accuracy of prediction models [14], [21], [25], [41].", "part": "1"}, {"sec": "sec4b", "text": "For the experiments, we use eleven real-world configurable software systems: six of these systems have only binary configuration options and were used in [21], [31], [37], [42], [55], the other five systems have both binary and numeric configuration options and were used in [41].", "part": "1"}, {"sec": "sec4c", "text": "As mentioned in Introduction, at present, there are many learning methods for predicting performance values of software systems with binary options, including SPLConqueror [41], [42], Fourierl.eaming [55], and DECART [21] (the improved version of CART [19]).", "part": "1"}, {"sec": "sec4c", "text": " Among these approaches, DE-CART is recently proposed and can achieve higher prediction accuracy than others [21].", "part": "1"}, {"sec": "sec4c", "text": " These six subject systems were also used in [21].", "part": "1"}, {"sec": "sec4c", "text": "Here, we adopt the experiment setup in [21].", "part": "1"}, {"sec": "sec4c", "text": " We ran DECART with the best hyperparameter tuning technique suggested in their paper [21]: grid search combined with 10- fold cross-validation.", "part": "1"}, {"sec": "sec4c", "text": " Other hyperparameter settings are the same as described in Section 4 of [21].", "part": "1"}, {"sec": "sec5", "text": " In Introduction, we have described pros and cons of some state-of-the-art methods including SPLConqueror [40], [42], CARTIDECART [19], [21] and FourierLearning [55].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-017-9573-6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Data-efficient+performance+learning+for+configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "K. Hornik, \"Approximation capabilities of multilayer feedforward networks\", <em>Neural Networks</em>, vol. 4, no. 2, pp. 251-257, 1991.", "title": "Approximation capabilities of multilayer feedforward networks", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0893-6080(91)90009-T", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Approximation+capabilities+of+multilayer+feedforward+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "K. Hornik, M. Stinchcombe, H. White, \"Multilayer feedforward networks are universal approximators\", <em>Neural Networks</em>, vol. 2, no. 5, pp. 359-366, 1989.", "title": "Multilayer feedforward networks are universal approximators", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}, {"sec": "sec3a", "text": "As stated in the universal approximation theorem [11], [23], [28], a shallow FNN having one linear output layer and one hidden layer with enough neurons and a suitable activation function (e.g. sigmoid, ReLU) can approximate any continuous function from one finite dimensional space to the other at any level of accuracy.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/0893-6080(89)90020-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multilayer+feedforward+networks+are+universal+approximators&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "P. Jamshidi, N. Siegmund, M. Velez, C. K\u00e4stner, A. Patel, Y. Agarwal, \"Transfer learning for performance modeling of configurable systems: An exploratory analysis\", <em>Proceedings of the 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 497-508, 2017.", "title": "Transfer learning for performance modeling of configurable systems: An exploratory analysis", "context": [{"sec": "sec1", "text": " For configurable software systems, it has been observed that the software performance functions are usually very sparse (i.e. only a small number of configurations and their interactions have significant impact on system performance)[24], [27], [40], [42].", "part": "1"}, {"sec": "sec3b", "text": "For configurable software systems, it has been widely observed that even though the possible number of interactions among configuration options is exponential, a very large portion of potential interactions has no influence on the performance of software systems [24], [27], [40], [42].", "part": "1"}], "links": {"documentLink": "/document/8115661", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8115661", "abstract": "Modern software systems provide many configuration options which significantly influence their non-functional properties. To understand and predict the effect of configuration options, several sampling and learning strategies have been proposed, albeit often with significant cost to cover the highly dimensional configuration space. Recently, transfer learning has been applied to reduce the effort of constructing performance models by transferring knowledge about performance behavior across envir...", "pdfSize": "321KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Transfer+learning+for+performance+modeling+of+configurable+systems%3A+An+exploratory+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "M. Jorgensen, M. Shepperd, \"A systematic review of software development cost estimation studies\", <em>IEEE Transactions on Software Engineering</em>, vol. 33, no. 1, pp. 33-53, 2007.", "title": "A systematic review of software development cost estimation studies", "context": [{"sec": "sec4a", "text": " We choose this metric as it is widely used to measure the accuracy of prediction models [14], [21], [25], [41].", "part": "1"}], "links": {"documentLink": "/document/4027147", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4027147", "abstract": "This paper aims to provide a basis for the improvement of software-estimation research through a systematic review of previous work. The review identifies 304 software cost estimation papers in 76 journals and classifies the papers according to research topic, estimation approach, research approach, study context and data set. A Web-based library of these cost estimation papers is provided to ease the identification of relevant estimation research results. The review results combined with other ...", "pdfSize": "2298KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+review+of+software+development+cost+estimation+studies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "D. Kingma, J. Ba, \"Adam: A method for stochastic optimization\", <em>Proceedings of the 3rd International Conference for Learning Representations (ICLR)</em>, 2015.", "title": "Adam: A method for stochastic optimization", "context": [{"sec": "sec3d", "text": "Optimization algorithm: We use the Adam optimizer to train the neural network as it is a very computational efficient method [26].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Adam%3A+A+method+for+stochastic+optimization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "D.R. Kuhn, R.N. Kacker, Y. Lei, Introduction to combinatorial testing, CRC Press, 2013.", "title": "Introduction to combinatorial testing", "context": [{"sec": "sec1", "text": " For configurable software systems, it has been observed that the software performance functions are usually very sparse (i.e. only a small number of configurations and their interactions have significant impact on system performance)[24], [27], [40], [42].", "part": "1"}, {"sec": "sec3b", "text": "For configurable software systems, it has been widely observed that even though the possible number of interactions among configuration options is exponential, a very large portion of potential interactions has no influence on the performance of software systems [24], [27], [40], [42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introduction+to+combinatorial+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "M. Leshno, V.Y. Lin, A. Pinkus, S. Schocken, \"Multilayer feedforward networks with a nonpolynomial activation function can approximate any function\", <em>Neural Networks</em>, vol. 6, no. 6, pp. 861-867, 1993.", "title": "Multilayer feedforward networks with a nonpolynomial activation function can approximate any function", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}, {"sec": "sec3a", "text": "As stated in the universal approximation theorem [11], [23], [28], a shallow FNN having one linear output layer and one hidden layer with enough neurons and a suitable activation function (e.g. sigmoid, ReLU) can approximate any continuous function from one finite dimensional space to the other at any level of accuracy.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0893-6080(05)80131-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multilayer+feedforward+networks+with+a+nonpolynomial+activation+function+can+approximate+any+function&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "S. Liang, R. Srikant, \"Why deep neural network for function approximation?\", <em>Proceedings of the 5th International Conference on Learning Representation (ICLR)</em>, 2017.", "title": "Why deep neural network for function approximation?", "context": [{"sec": "sec3a", "text": " When using FNNs to approximate functions, for a given upper bound of the approximation error, shallow FNNs require exponential more parameters than deep FNNs [13], [29], [53].", "part": "1"}, {"sec": "sec3c", "text": " Previous studies also show that the network depth is what matters most [13], [29], [36].", "part": "1"}, {"sec": "sec6", "text": "In the future, we will explore the universal property of neural networks in approximations of different function classes [29] to further improve the design of our model.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+deep+neural+network+for+function+approximation%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "V. Nair, G.E. Hinton, \"Rectified linear units improve restricted boltzmann machines\", <em>Proceedings of the 27th International Conference on Machine Learning (ICML)</em>, pp. 807-814, 2010.", "title": "Rectified linear units improve restricted boltzmann machines", "context": [{"sec": "sec3a", "text": " Meanwhile, the ReLU is chosen as the activation function of the hidden layers due to its ability to learn much faster in networks with many layers compared to other non-linear activation functions [17], [30].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rectified+linear+units+improve+restricted+boltzmann+machines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "V. Nair, T. Menzies, N. Siegmund, S. Apel, \"Using bad learners to find good configurations\", <em>Proceedings of the 11th Joint Meeting on Foundations of Software. Engineering (ESEC/FSE)</em>, pp. 257-267, 2017.", "title": "Using bad learners to find good configurations", "context": [{"sec": "sec4b", "text": "For the experiments, we use eleven real-world configurable software systems: six of these systems have only binary configuration options and were used in [21], [31], [37], [42], [55], the other five systems have both binary and numeric configuration options and were used in [41].", "part": "1"}, {"sec": "sec5", "text": " Later, they also proposed a rank-based approach [31], which can reduce the cost (in terms of the number of configurations to be measured) as well as the time required to build performance models.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106238", "abstract": "Finding the optimally performing configuration of a software system for a given setting is often challenging. Recent approaches address this challenge by learning performance models based on a sample set of configurations. However, building an accurate performance model can be very expensive (and is often infeasible in practice). The central insight of this paper is that exact performance values (e.g., the response time of a software system) are not required to rank configurations and to identif...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+bad+learners+to+find+good+configurations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "V. Nair, T. Menzies, N. Siegmund, S. Apel, \"Faster discovery of faster system configurations with spectral learning\", <em>Automated Software Engineering</em>, vol. 25, no. 2, pp. 247-277, Jun 2018.", "title": "Faster discovery of faster system configurations with spectral learning", "context": [{"sec": "sec5", "text": " [32] proposed to use the WHAT spectral learner to select a small number of configurations.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-017-0225-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Faster+discovery+of+faster+system+configurations+with+spectral+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "A.Y. Ng, \"Feature selection 11 vs. 12 regularization and rotational invariance\", <em>Proceedings of the 21st International Conference on Machine Learning (ICML)</em>, 2004.", "title": "Feature selection, 11 vs. 12 regularization, and rotational invariance", "context": [{"sec": "sec2b", "text": " In practice, it has been frequently observed that \\$L_{1}\\$ regularization can cause many parameters to be equal to zero, which makes the parameter vector sparse [33].", "part": "1"}, {"sec": "sec2b", "text": " Nowadays, \\$L_{1}\\$ regularization is not only applied in linear regression, but also in other models such as logistic regression [33] or neural network [17], [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+selection%2C+11+vs.+12+regularization%2C+and+rotational+invariance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "A. Nhlabatsi, R. Laney, B. Nuseibeh, \"Feature interaction: The security threat from within software systems\", <em>Progress in Informatics</em>, vol. 5, pp. 75-89, 2008.", "title": "Feature interaction: The security threat from within software systems", "context": [{"sec": "sec1", "text": "The challenge for building a performance prediction model is in the interactions between configuration options (features), i.e. a particular combination of features causes an unexpected behaviour on the system performance while their individual presences do not [8], [34], [42].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.2201/NiiPi.2008.5.8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Feature+interaction%3A+The+security+threat+from+within+software+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "F. Pedregosa, G. Varoquaux et al., \"Scikit-learn: Machine learning in python\", <em>The Journal of Machine Learning Research</em>, vol. 12, pp. 2825-2830, 2011.", "title": "Scikit-learn: Machine learning in python", "context": [{"sec": "sec4e", "text": "For the SVM regression method, we use the function SVR in scikit-learn package [35] to perform model training and prediction.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scikit-learn%3A+Machine+learning+in+python&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "T. Poggio, H. Mhaskar, L. Rosasco, B. Miranda, Q. Liao, \"Wh and when can deep-but not shallow-networks avoid the curse of dimensionality: A review\", <em>International Journal of Automation and Computing</em>, vol. 14, no. 5, pp. 503-519, 2017.", "title": "Wh and when can deep-but not shallow-networks avoid the curse of dimensionality: A review", "context": [{"sec": "sec3a", "text": "Deep FNNs, on the other hand, can avoid the curse of dimensionality that shallow networks encounter [36].", "part": "1"}, {"sec": "sec3c", "text": " Previous studies also show that the network depth is what matters most [13], [29], [36].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s11633-017-1054-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Wh+and+when+can+deep-but+not+shallow-networks+avoid+the+curse+of+dimensionality%3A+A+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "A. Sarkar, J. Guo, N. Siegmund, S. Apel, K. Czarnecki, \"Cost-efficient sampling for performance prediction of configurable systems\", <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 342-352, 2015.", "title": "Cost-efficient sampling for performance prediction of configurable systems", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": " Besides, SPLConqueror usually requires more sample than other approaches as their focus is to make the influences of configuration options and their interactions explicit [21], [37], [41].", "part": "1"}, {"sec": "sec4b", "text": "For the experiments, we use eleven real-world configurable software systems: six of these systems have only binary configuration options and were used in [21], [31], [37], [42], [55], the other five systems have both binary and numeric configuration options and were used in [41].", "part": "1"}, {"sec": "sec5", "text": " [37] used projective sampling and feature-frequency heuristic to determine sample that is small enough to decrease the measurement effort and large enough to increase the prediction accuracy.", "part": "1"}], "links": {"documentLink": "/document/7372023", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372023", "abstract": "A key challenge of the development and maintenanceof configurable systems is to predict the performance ofindividual system variants based on the features selected. It isusually infeasible to measure the performance of all possible variants, due to feature combinatorics. Previous approaches predictperformance based on small samples of measured variants, butit is still open how to dynamically determine an ideal samplethat balances prediction accuracy and measurement effort. Inthis paper, we adapt...", "pdfSize": "299KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cost-efficient+sampling+for+performance+prediction+of+configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "A.S. Sayyad, J. Ingram, T. Menzies, H. Ammar, \"Scalable product line configuration: A straw to break the camel's back\", <em>Proceedings of the 28th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 465-474, 2013.", "title": "Scalable product line configuration: A straw to break the camel's back", "context": [{"sec": "sec5", "text": " [38], [39] utilized evolutionary algorithms to select optimal features regarding multiple objectives.", "part": "1"}], "links": {"documentLink": "/document/6693104", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693104", "abstract": "Software product lines are hard to configure. Techniques that work for medium sized product lines fail for much larger product lines such as the Linux kernel with 6000+ features. This paper presents simple heuristics that help the Indicator-Based Evolutionary Algorithm (IBEA) in finding sound and optimum configurations of very large variability models in the presence of competing objectives. We employ a combination of static and evolutionary learning of model structure, in addition to utilizing ...", "pdfSize": "1132KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+product+line+configuration%3A+A+straw+to+break+the+camel%27s+back&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "A.S. Sayyad, T. Menzies, H. Ammar, \"On the value of user preferences in search-based software engineering: A case study in software product lines\", <em>Proceedings of the 35th International Conference on Software Engineering (ICSE)</em>, pp. 492-501, 2013.", "title": "On the value of user preferences in search-based software engineering: A case study in software product lines", "context": [{"sec": "sec5", "text": " For example, Sayyad et al. [38], [39] utilized evolutionary algorithms to select optimal features regarding multiple objectives.", "part": "1"}], "links": {"documentLink": "/document/7190087", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7190087", "abstract": "Software design is a process of trading off competing objectives. If the user objective space is rich, then we should use optimizers that can fully exploit that richness. For example, this study configures software product lines (expressed as feature maps) using various search-based software engineering methods. As we increase the number of optimization objectives, we find that methods in widespread use (e.g. NSGA-II, SPEA2) perform much worse than IBEA (Indicator-Based Evolutionary Algorithm). ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+value+of+user+preferences+in+search-based+software+engineering%3A+A+case+study+in+software+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "N. Siegmund, A. Grebhahn, A. Apel, C. K\u00e4stner, \"Performance-influence models for highly configurable systems\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 284-294, 2015.", "title": "Performance-influence models for highly configurable systems", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": " For configurable software systems, it has been observed that the software performance functions are usually very sparse (i.e. only a small number of configurations and their interactions have significant impact on system performance)[24], [27], [40], [42].", "part": "1"}, {"sec": "sec3b", "text": "For configurable software systems, it has been widely observed that even though the possible number of interactions among configuration options is exponential, a very large portion of potential interactions has no influence on the performance of software systems [24], [27], [40], [42].", "part": "1"}, {"sec": "sec5", "text": " In Introduction, we have described pros and cons of some state-of-the-art methods including SPLConqueror [40], [42], CARTIDECART [19], [21] and FourierLearning [55].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786845", "abstract": "Almost every complex software system today is configurable. While configurability has many benefits, it challenges performance prediction, optimization, and debugging. Often, the influences of individual configuration options on performance are unknown. Worse, configuration options may interact, giving rise to a configuration space of possibly exponential size. Addressing this challenge, we propose an approach that derives a performance-influence model for a given configurable system, describing...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Performance-influence+models+for+highly+configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "N. Siegmund, A. Grebhahn, S. Apel, C. K\u00e4stner, \"Performance-influence models for highly configurable systems\", <em>Proceedings of the 10th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 284-294, 2015.", "title": "Performance-influence models for highly configurable systems", "context": [{"sec": "sec1", "text": " To address this challenge, an approach, namely SPLConqueror, aims to learn the influences of individual configuration options and their interactions from the differences among the measurements of the sample [41]\u2013[43].", "part": "1"}, {"sec": "sec1", "text": " Besides, SPLConqueror usually requires more sample than other approaches as their focus is to make the influences of configuration options and their interactions explicit [21], [37], [41].", "part": "1"}, {"sec": "sec4a", "text": " We choose this metric as it is widely used to measure the accuracy of prediction models [14], [21], [25], [41].", "part": "1"}, {"sec": "sec4b", "text": "For the experiments, we use eleven real-world configurable software systems: six of these systems have only binary configuration options and were used in [21], [31], [37], [42], [55], the other five systems have both binary and numeric configuration options and were used in [41].", "part": "1"}, {"sec": "sec4b", "text": " More information about these systems and how they were measured can be found in [41], [42].", "part": "1"}, {"sec": "sec4c", "text": "As mentioned in Introduction, at present, there are many learning methods for predicting performance values of software systems with binary options, including SPLConqueror [41], [42], Fourierl.eaming [55], and DECART [21] (the improved version of CART [19]).", "part": "1"}, {"sec": "sec4d", "text": " These subject systems are also used in [41] for evaluating SPLConqueror.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786845", "abstract": "Almost every complex software system today is configurable. While configurability has many benefits, it challenges performance prediction, optimization, and debugging. Often, the influences of individual configuration options on performance are unknown. Worse, configuration options may interact, giving rise to a configuration space of possibly exponential size. Addressing this challenge, we propose an approach that derives a performance-influence model for a given configurable system, describing...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Performance-influence+models+for+highly+configurable+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "N. Siegmund, S. Kolesnikov, C. K\u00e4stner, S. Apel, D. Ba-tory, M. Rosenm\u00fcller, G. Saake, \"Predicting performance via automated feature-interaction detection\", <em>Proceedings of the 34th International Conference on Software Engineering (ICSE)</em>, pp. 167-177, 2012.", "title": "Predicting performance via automated feature-interaction detection", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": "The challenge for building a performance prediction model is in the interactions between configuration options (features), i.e. a particular combination of features causes an unexpected behaviour on the system performance while their individual presences do not [8], [34], [42].", "part": "1"}, {"sec": "sec1", "text": " To address this challenge, an approach, namely SPLConqueror, aims to learn the influences of individual configuration options and their interactions from the differences among the measurements of the sample [41]\u2013[42][43].", "part": "1"}, {"sec": "sec1", "text": " For configurable software systems, it has been observed that the software performance functions are usually very sparse (i.e. only a small number of configurations and their interactions have significant impact on system performance)[24], [27], [40], [42].", "part": "1"}, {"sec": "sec3b", "text": "For configurable software systems, it has been widely observed that even though the possible number of interactions among configuration options is exponential, a very large portion of potential interactions has no influence on the performance of software systems [24], [27], [40], [42].", "part": "1"}, {"sec": "sec4b", "text": "For the experiments, we use eleven real-world configurable software systems: six of these systems have only binary configuration options and were used in [21], [31], [37], [42], [55], the other five systems have both binary and numeric configuration options and were used in [41].", "part": "1"}, {"sec": "sec4b", "text": " More information about these systems and how they were measured can be found in [41], [42].", "part": "1"}, {"sec": "sec4c", "text": "As mentioned in Introduction, at present, there are many learning methods for predicting performance values of software systems with binary options, including SPLConqueror [41], [42], Fourierl.eaming [55], and DECART [21] (the improved version of CART [19]).", "part": "1"}, {"sec": "sec5", "text": " In Introduction, we have described pros and cons of some state-of-the-art methods including SPLConqueror [40], [42], CARTIDECART [19], [21] and FourierLearning [55].", "part": "1"}], "links": {"documentLink": "/document/6227196", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6227196", "abstract": "Customizable programs and program families provide user-selectable features to allow users to tailor a program to an application scenario. Knowing in advance which feature selection yields the best performance is difficult because a direct measurement of all possible feature combinations is infeasible. Our work aims at predicting program performance based on selected features. However, when features interact, accurate predictions are challenging. An interaction occurs when a particular feature c...", "pdfSize": "580KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predicting+performance+via+automated+feature-interaction+detection&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "N. Siegmund, M. Rosenm\u00fcller, C. K\u00e4stner, P.G. Giar-russo, S. Apel, S. S. Kolesnikov, \"Scalable prediction of non-functional properties in software product lines\", <em>International Software Product Line Conference</em>, pp. 160-169, 2011.", "title": "Scalable prediction of non-functional properties in software product lines", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": " To address this challenge, an approach, namely SPLConqueror, aims to learn the influences of individual configuration options and their interactions from the differences among the measurements of the sample [41]\u2013[43].", "part": "1"}], "links": {"documentLink": "/document/6030057", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6030057", "abstract": "A software product line is a family of related software products, typically, generated from a set of common assets. Users can select features to derive a product that fulfills their needs. Often, users expect a product to have specific non-functional properties, such as a small footprint or a minimum response time. Because a product line can contain millions of products, it is usually not feasible to generate and measure non-functional properties for each possible product of a product line. Henc...", "pdfSize": "274KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+prediction+of+non-functional+properties+in+software+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "J. Snoek, H. Larochelle, R.P. Adams, \"Practical bayesian optimization of machine learning algorithms\", <em>Proceedings of the 25th International Conference on Neural Information Processing Systems (NIPS)</em>, vol. 2, pp. 2951-2959, 2012.", "title": "Practical bayesian optimization of machine learning algorithms", "context": [{"sec": "sec2c", "text": " There are several widely used approaches to choose this set of trials from the hyperparameter space: grid search, random search [7], bayesian optimization [44], etc.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+bayesian+optimization+of+machine+learning+algorithms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "N. Srivastava, G. Hinton, A. Krizhevsky, I. Sutskever, R. Salakhutdinov, \"Dropout: A simple way to prevent neural networks from overfitting\", <em>The Journal of Machine Learning Research</em>, vol. 15, no. 1, pp. 1929-1958, 2014.", "title": "Dropout: A simple way to prevent neural networks from overfitting", "context": [{"sec": "sec3b", "text": " Dropout technique was specifically proposed for neural networks [45].", "part": "1"}, {"sec": "sec4e", "text": "Deep FNN with the dropout technique [45] (Dropout-FNN).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dropout%3A+A+simple+way+to+prevent+neural+networks+from+overfitting&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "B. Steinbach, R. Kohut, \"Neural Networks: A Model of Boolean Functions\", <em>Proceedings of the 5th International Workshop on Boolean Problems</em>, pp. 223-240, 2002.", "title": "Neural Networks: A Model of Boolean Functions", "context": [{"sec": "sec1", "text": " The idea of approximating performance function by a deep FNN is possible, as it has been shown that FNNs with hidden layers provide a universal framework, i.e. an FNN with a linear output layer and at least one hidden layer with some specific activation functions and sufficient number of neurons can approximate various function classes, from Boolean functions [4], [46] to continuous real-valued functions [5], [11], [15], [22], [23], [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Neural+Networks%3A+A+Model+of+Boolean+Functions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "J. Sun, H. Zhang, Y. Fang, L.H. Wang, \"Formal semantics and verification for feature modeling\", <em>Proceedings of the IEEE International Conference on Engineering of Complex Computer Systems (ICECCS)</em>, pp. 303-312, 2005.", "title": "Formal semantics and verification for feature modeling", "context": [{"sec": "sec5", "text": " A large body of work has been devoted to modeling features and checking consistency of feature configurations (e.g., [6], [12], [47], [52]).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Formal+semantics+and+verification+for+feature+modeling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "E. Thereska, B. Doebel, A.X. Zheng, P. Nobel, \"Practical performance models for complex popular applications\", <em>ACM SIGMETRICS Performance Evaluation Review</em>, vol. 38, no. 1, pp. 1-12, 2010.", "title": "Practical performance models for complex, popular applications", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1811099.1811041", "abstract": "Perhaps surprisingly, no practical performance models exist for popular (and complex) client applications such as Adobe&#39;s Creative Suite, Microsoft&#39;s Office and Visual Studio, Mozilla, Halo 3, etc. There is currently no tool that automatically answers program developers&#39;, IT administrators&#39; and end-users&#39; simple what-if questions like &#34;what happens to the performance of my favorite application X if I upgrade from Windows Vista to Windows 7?&#34;. This paper describes our approach towards constructin...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+performance+models+for+complex%2C+popular+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "R. Tibshirani, \"Regression shrinkage and selection via the lasso\", <em>Journal of the Royal Statistical Society Series B</em>, vol. 58, pp. 267-288, 1996.", "title": "Regression shrinkage and selection via the lasso", "context": [{"sec": "sec1", "text": " To construct a deep sparse FNN, we will combine a normal deep FNN with a sparsity regularization technique, e.g. the \\$L_{1}\\$ regularization [49].", "part": "1"}, {"sec": "sec2b", "text": "The \\$L_{1}\\$ regularization technique was first introduced by Tibshirani [49] for linear regression with independent Gaussian noise, which is called Least Absolute Shrinkage and Selection Operator (LASSO).", "part": "1"}, {"sec": "sec3b", "text": " As described in Section II-B, the idea of \\$L_{1}\\$ regularization is to add to the loss function a penalty term which is constructed by applying an \\$L_{1}\\$ norm on the parameters [49].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1111/j.2517-6161.1996.tb02080.x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Regression+shrinkage+and+selection+via+the+lasso&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "A.N. Tikhonov, V.Y. Arsenin, Solutions of Ill-Posed Problems, Washington, D.C.:Winston & Sons, 1977.", "title": "Solutions of Ill-Posed Problems", "context": [{"sec": "sec3b", "text": " Similar to \\$L_{1}\\$ regularization, \\$L_{2}\\$ regularization works by adding a penalty term to the loss function, however, in this case, an \\$L_{2}\\$ norm is being used to generate the penalty term [50]. \\$L_{2}\\$ regularization is arguably the most popular technique in machine learning to combat overfitting.", "part": "1"}, {"sec": "sec4e", "text": "Deep FNN with the \\$L_{2}\\$ regularization [50] (L2-FNN).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Solutions+of+Ill-Posed+Problems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "L. T\u00f3th, \"Phone recognition with deep sparse rectifier neural networks\", <em>Proceedings of the 2013 IEEE International Conference on Acoustics Speech and Signal Processing</em>, pp. 6985-6989, 2013.", "title": "Phone recognition with deep sparse rectifier neural networks", "context": [{"sec": "sec2b", "text": " Nowadays, \\$L_{1}\\$ regularization is not only applied in linear regression, but also in other models such as logistic regression [33] or neural network [17], [51].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Phone+recognition+with+deep+sparse+rectifier+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "H.H. Wang, Y.F. Li, J. Sun, H. Zhang, J. Pan, \"Verifying feature models using OWL\", <em>Web Semantics: Science Services and Agents on the World Wide Web</em>, vol. 5, no. 2, pp. 117-129, 2007.", "title": "Verifying feature models using OWL", "context": [{"sec": "sec5", "text": " A large body of work has been devoted to modeling features and checking consistency of feature configurations (e.g., [6], [12], [47], [52]).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.websem.2006.11.006", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Verifying+feature+models+using+OWL&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "D. Yarotsky, \"Error bounds for approximations with deep relu networks\", <em>Neural Networks</em>, vol. 94, pp. 103-114, 2017.", "title": "Error bounds for approximations with deep relu networks", "context": [{"sec": "sec3a", "text": " When using FNNs to approximate functions, for a given upper bound of the approximation error, shallow FNNs require exponential more parameters than deep FNNs [13], [29], [53].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.neunet.2017.07.002", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Error+bounds+for+approximations+with+deep+relu+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "H. Zhang, S. Jarzabek, B. Yang, \"Quality prediction and assessment for product lines\", <em>Proceedings of the International Conference on Advanced Information Systems Engineering (CAiSE)</em>, pp. 681-695, 2003.", "title": "Quality prediction and assessment for product lines", "context": [{"sec": "sec5", "text": " [54] proposed a Bayesian Belief Network (BBN) based approach.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/3-540-45017-3_45", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Quality+prediction+and+assessment+for+product+lines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "Y. Zhang, J. Guo, E. Blais, K. Czarnecki, \"Performance prediction of configurable software systems by fourier learning\", <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)</em>, pp. 365-373, 2015.", "title": "Performance prediction of configurable software systems by fourier learning", "context": [{"sec": "sec1", "text": "In recent years, researchers have proposed to measure the performance of a system with only a limited set of configurations (sample), build a performance prediction model, and then use the model to predict the performance of the system under new configurations (population) [19, 21, 37, 40, 42, 43, 48, [55]].", "part": "1"}, {"sec": "sec1", "text": " [55] addressed this challenge by for- mulating the software performance function as a Boolean function.", "part": "1"}, {"sec": "sec1", "text": " Although the algorithm can derive a sample size that guarantees a theoretical boundary of the prediction accuracy, the size of sample required to achieve a desired accuracy is still very large (sometimes even more than the whole population of the system), especially for a relatively small system [55].", "part": "1"}, {"sec": "sec3a", "text": " For example, representing Boolean performance function using Fourier learning [55] can be considered similar to using a shallow FNN with one hidden layer and a large number of neurons per layer \\$(2^{n}\\$ neurons, where \\$n\\$ is the number of configuration options).", "part": "1"}, {"sec": "sec4b", "text": "For the experiments, we use eleven real-world configurable software systems: six of these systems have only binary configuration options and were used in [21], [31], [37], [42], [55], the other five systems have both binary and numeric configuration options and were used in [41].", "part": "1"}, {"sec": "sec4c", "text": "As mentioned in Introduction, at present, there are many learning methods for predicting performance values of software systems with binary options, including SPLConqueror [41], [42], Fourierl.eaming [55], and DECART [21] (the improved version of CART [19]).", "part": "1"}, {"sec": "sec5", "text": " In Introduction, we have described pros and cons of some state-of-the-art methods including SPLConqueror [40], [42], CARTIDECART [19], [21] and FourierLearning [55].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Performance+prediction+of+configurable+software+systems+by+fourier+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811988", "articleId": "8811988", "startPage": "1095", "endPage": "1106", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 3, "citationCountPatent": 0, "totalDownloads": 158}}
{"title": "Heuristically Matching Solution Spaces of Arithmetic Formulas to Efficiently Reuse Solutions", "authors": [{"name": "Andrea Aquino", "affiliation": "Univ. della Svizzera Italiana, Lugano, Switzerland", "firstName": "Andrea", "lastName": "Aquino", "id": "37086033905"}, {"name": "Giovanni Denaro", "affiliation": "Univ. of Milano-Bicocca, Milan, Italy", "firstName": "Giovanni", "lastName": "Denaro", "id": "37314201800"}, {"name": "Mauro Pezz\u00e8", "affiliation": "Univ. della Svizzera Italiana, Lugano, Switzerland", "firstName": "Mauro", "lastName": "Pezz\u00e8", "id": "37267493000"}], "abstract": "Many symbolic program analysis techniques rely on SMT solvers to verify properties of programs. Despite the remarkable progress made in the development of such tools, SMT solvers still represent a main bottleneck to the scalability of these techniques. Recent approaches tackle this bottleneck by reusing solutions of formulas that recur during program analysis, thus reducing the number of queries to SMT solvers. Current approaches only reuse solutions across formulas that are equivalent to, contained in or implied by other formulas, as identified through a set of predefined rules, and cannot reuse solutions across formulas that differ in their structure, even if they share some potentially reusable solutions. In this paper, we propose a novel approach that can reuse solutions across formulas that share at least one solution, regardless of their structural resemblance. Our approach exploits a novel heuristic to efficiently identify solutions computed for previously solved formulas and most likely shared by new formulas. The results of an empirical evaluation of our approach on two different logics show that our approach can identify on average more reuse opportunities and is markedly faster than competing approaches.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Scalability", "Terminology", "Heuristic algorithms", "Software engineering", "Tools", "Operating systems", "Mission critical systems"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["computability", "program diagnostics"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["heuristically matching solution spaces", "arithmetic formulas", "symbolic program analysis techniques", "SMT solvers", "structural resemblance"]}, {"type": "Author Keywords ", "kwd": ["SMT-based program analysis", "symbolic execution", "SMT solvers", "solution reuse"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.46", "ref": [{"order": "1", "text": "A. Aquino, F.A. Bianchi, M. Chen, G. Denaro, M. Pezz\u00e8, \"Reusing constraint proofs in program analysis\", <em>Proceedings of the International Symposium on Software Testing and Analysis ISSTA '15</em>, pp. 305-315, 2015.", "title": "Reusing constraint proofs in program analysis", "context": [{"sec": "sec1", "text": " [1] have proposed techniques to reduce the number of queries issued by SMT-based program analysis techniques to SMT solvers.", "part": "1"}, {"sec": "sec3c", "text": " We compare Utopia with Green [19], GreenTrie [11], Recal and Recal+ [1].", "part": "1"}, {"sec": "sec5", "text": "Aquino et al. have designed Recal [1], a caching framework that targets formulas belonging to the quantifier-free linear integer arithmetic logic.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2771783.2771802", "abstract": "Symbolic analysis techniques have largely improved over the years, and are now approaching an industrial maturity level. One of the main limitations to the scalability of symbolic analysis is the impact of constraint solving that is still a relevant bottleneck for the applicability of symbolic techniques, despite the dramatic improvements of the last decades. In this paper we discuss a novel approach to deal with the constraint solving bottleneck. Starting from the observation that constraints m...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reusing+constraint+proofs+in+program+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "S. Artzi, A. Kiezun, J. Dolby, F. Tip, D. Dig, A. Paradkar, M.D. Ernst, \"Finding bugs in dynamic web applications\", <em>Proceedings of the International Symposium on Software Testing and Analysis ISSTA '08</em>, pp. 261-272, 2008.", "title": "Finding bugs in dynamic web applications", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1390630.1390662", "abstract": "Web script crashes and malformed dynamically-generated Web pages are common errors, and they seriously impact usability of Web applications. Current tools for Web-page validation cannot handle the dynamically-generated pages that are ubiquitous on today&#39;s Internet. In this work, we apply a dynamic test generation technique, based on combined concrete and symbolic execution, to the domain of dynamic Web applications. The technique generates tests automatically, uses the tests to detect failures, ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Finding+bugs+in+dynamic+web+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "E. Bounimova, P. Godefroid, D. Molnar, \"Billions and billions of constraints: Whitebox fuzz testing in production\", <em>Proceedings of the International Conference on Software Engineering ICSE '13</em>, pp. 122-131, 2013.", "title": "Billions and billions of constraints: Whitebox fuzz testing in production", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "links": {"abstract": "We report experiences with constraint-based whitebox fuzz testing in production across hundreds of large Windows applications and over 500 machine years of computation from 2007 to 2013. Whitebox fuzzing leverages symbolic execution on binary traces and constraint solving to construct new inputs to a program. These inputs execute previously uncovered paths or trigger security vulnerabilities. Whitebox fuzzing has found one-third of all file fuzzing bugs during the development of Windows 7, savin...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Billions+and+billions+of+constraints%3A+Whitebox+fuzz+testing+in+production&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "P. Braione, G. Denaro, M. Pezz\u00e8, \"Enhancing symbolic execution with built-in term rewriting and constrained lazy initialization\", <em>Proceedings of the European Software Engineering Conference held jointly with the ACM SIGSOFT International Symposium on Foundations of Software En gineering ESEC/FSE '13</em>, pp. 411-421, 2013.", "title": "Enhancing symbolic execution with built-in term rewriting and constrained lazy initialization", "context": [{"sec": "sec3b", "text": " We produced the second benchmark running the model checker Gk-tail [4] on 16 Java classes belonging to the GraphStream and Google Guava libraries.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491433", "abstract": "Symbolic execution suffers from problems when analyzing programs that handle complex data structures as their inputs and take decisions over non-linear expressions. For these programs, symbolic execution may incur invalid inputs or unidentified infeasible traces, and may raise large amounts of false alarms. Some symbolic executors tackle these problems by introducing executable preconditions to exclude invalid inputs, and some solvers exploit rewrite rules to address non linear problems. In this...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enhancing+symbolic+execution+with+built-in+term+rewriting+and+constrained+lazy+initialization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "J. Burnim, K. Sen, \"Heuristics for scalable dynamic test generation\", <em>Proceedings of the International Conference on Automated Software Engineering</em>, pp. 443-446, 2008.", "title": "Heuristics for scalable dynamic test generation", "context": [{"sec": "sec3b", "text": " We produced the first benchmark running the symbolic executors Crest [5] and JBSE [14] on 22 C and Java programs.", "part": "1"}], "links": {"abstract": "Recently there has been great success in using symbolic execution to automatically generate test inputs for small software systems. A primary challenge in scaling such approaches to larger programs is the combinatorial explosion of the path space. It is likely that sophisticated strategies for searching this path space are needed to generate inputs that effectively test large programs (by, e.g., achieving significant branch coverage). We present several such heuristic search strategies, includin...", "pdfSize": "199KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Heuristics+for+scalable+dynamic+test+generation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "C. Cadar, D. Dunbar, D. Engler, \"Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs\", <em>Proceedings of the Symposium on Operating Systems Design and Implementation OSDI '08</em>, pp. 209-224, 2008.", "title": "Klee: Unassisted and automatic generation of high-coverage tests for complex systems programs", "context": [{"sec": "sec1", "text": "Despite the remarkable progress in the theory and the maturity of modern solvers, SMT solvers still represent a main bottleneck to the scalability of SMT-based program analysis techniques [6], [13], since the problem of determining the satisfiability of a formula is very hard in general, for instance NP-complete for propositional logic and undecidable for nonlinear integer arithmetic.", "part": "1"}, {"sec": "sec1", "text": " [6], Visser et al. [19], Jia et al. [11] and Aquino et al. [1] have proposed techniques to reduce the number of queries issued by SMT-based program analysis techniques to SMT solvers.", "part": "1"}, {"sec": "sec3a", "text": " This process is known as formula slicing [6] and is currently exploited by all competing approaches.", "part": "1"}, {"sec": "sec5", "text": "Cadar et al. have designed Klee [6], a symbolic executor that includes two caching frameworks that target formulas belonging to the quantifier-free theory of bit-vectors and bit-vector arrays.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Klee%3A+Unassisted+and+automatic+generation+of+high-coverage+tests+for+complex+systems+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "C. Cadar, P. Godefroid, S. Khurshid, C.S. P\u0103s\u0103reanu, K. Sen, N. Tillmann, W. Visser, \"Symbolic execution for software testing in practice: Preliminary assessment\", <em>Proceedings of the International Conference on Software Engineering ICSE '11</em>, pp. 1066-1071, 2011.", "title": "Symbolic execution for software testing in practice: Preliminary assessment", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985995", "abstract": "We present results for the &#34;Impact Project Focus Area&#34; on the topic of symbolic execution as used in software testing. Symbolic execution is a program analysis technique introduced in the 70s that has received renewed interest in recent years, due to algorithmic advances and increased availability of computational power and constraint solving technology. We review classical symbolic execution and some modern extensions such as generalized symbolic execution and dynamic test generation. We also g...", "pdfSize": "254KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+execution+for+software+testing+in+practice%3A+Preliminary+assessment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "L. De Moura, N. Bj\u00f8rner, \"Z3: An efficient SMT solver\", <em>Proceedings of the International Conference on Tools and Algorithms for Construction and Analysis of Systems TACAS/ETAPS '08</em>, pp. 337-340, 2008.", "title": "Z3: An efficient SMT solver", "context": [{"sec": "sec3a", "text": " If not, our prototype reports a cache miss, calls the Microsoft Z3 SMT solver [8] to produce a solution for the target formula and stores the target formula paired with its solution in the relevant repository.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Z3%3A+An+efficient+SMT+solver&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "I. Erete, A. Orso, \"Optimizing constraint solving to better support symbolic execution\", <em>Proceedings of the International Conference on Software Testing Verification and Validation ICST '11</em>, pp. 310-315, 2011.", "title": "Optimizing constraint solving to better support symbolic execution", "context": [{"sec": "sec5", "text": " Erete and Orso have proposed a technique that exploits contextual information to restricts the domain of formulas generated during the dynamic symbolic execution of a program to eliminate potentially irrelevant constraints [9].", "part": "1"}], "links": {"documentLink": "/document/5954425", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5954425", "abstract": "Constraint solving is an integral part of symbolic execution, as most symbolic execution techniques rely heavily on an underlying constraint solver. In fact, the performance of the constraint solver used by a symbolic execution technique can considerably affect its overall performance. Unfortunately, constraint solvers are mostly used in a black-box fashion within symbolic execution, without leveraging any of the contextual and domain information available. Because constraint solvers are optimiz...", "pdfSize": "965KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Optimizing+constraint+solving+to+better+support+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "P. Godefroid, M.Y. Levin, D. Molnar, Sage: Whitebox fuzzing for security testing, ACM Queue, vol. 10, no. 1, pp. 20-27, 2012.", "title": "Sage: Whitebox fuzzing for security testing", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sage%3A+Whitebox+fuzzing+for+security+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "X. Jia, C. Ghezzi, S. Ying, \"Enhancing reuse of constraint solutions to improve symbolic execution\", <em>Proceedings of the International Symposium on Software Testing and Analysis ISSTA '15</em>, pp. 177-187, 2015.", "title": "Enhancing reuse of constraint solutions to improve symbolic execution", "context": [{"sec": "sec1", "text": " [11] and Aquino et al. [1] have proposed techniques to reduce the number of queries issued by SMT-based program analysis techniques to SMT solvers.", "part": "1"}, {"sec": "sec3c", "text": " We compare Utopia with Green [19], GreenTrie [11], Recal and Recal+ [1].", "part": "1"}, {"sec": "sec5", "text": "Jia et al. have designed GreenTrie [11], an extension of the Green caching framework that also targets formulas belonging to the quantifier-free linear integer arithmetic logic.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2771783.2771806", "abstract": "Constraint solution reuse is an effective approach to save the time of constraint solving in symbolic execution. Most of the existing reuse approaches are based on syntactic or semantic equivalence of constraints. For example, the Green framework can reuse constraints which have different representations but are semantically equivalent, through canonizing constraints into syntactically equivalent normal forms. KLEE reuses constraints based on subset/superset querying. However, both equivalence-b...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enhancing+reuse+of+constraint+solutions+to+improve+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "X. Li, Y. Liang, H. Qian, Y.-Q. Hu, L. Bu, Y. Yu, X. Chen, X. Li, \"Symbolic execution of complex program driven by machine learning based constraint solving\", <em>Proceedings of the International Conference on Automated Software Engineering</em>, pp. 554-559, 2016.", "title": "Symbolic execution of complex program driven by machine learning based constraint solving", "context": [{"sec": "sec5", "text": "Li et al. exploit machine learning approaches to satisfy complex formulas that cannot be solved with modern solvers [12].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2970276.2970364", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Symbolic+execution+of+complex+program+driven+by+machine+learning+based+constraint+solving&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "T. Liu, M. Ara\u00fajo, M. d'Amorim, M. Taghdiri, \"A comparative study of incremental constraint solving approaches in symbolic execution\", <em>Proceedings of the Haifa Verification Conference HVC '14</em>, pp. 284-299, 2014.", "title": "A comparative study of incremental constraint solving approaches in symbolic execution", "context": [{"sec": "sec1", "text": "Despite the remarkable progress in the theory and the maturity of modern solvers, SMT solvers still represent a main bottleneck to the scalability of SMT-based program analysis techniques [6], [13], since the problem of determining the satisfiability of a formula is very hard in general, for instance NP-complete for propositional logic and undecidable for nonlinear integer arithmetic.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+comparative+study+of+incremental+constraint+solving+approaches+in+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "D. Lorenzoli, L. Mariani, M. Pezz\u00e8, \"Automatic generation of software behavioral models\", <em>ICSE '08: Proceedings of the 30th International Conference on Software Engineering</em>, 2008.", "title": "Automatic generation of software behavioral models", "context": [{"sec": "sec3b", "text": " We produced the first benchmark running the symbolic executors Crest [5] and JBSE [14] on 22 C and Java programs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368157", "abstract": "Dynamic analysis of software systems produces behavioral models that are useful for analysis, verification and testing. The main techniques for extracting models of functional behavior generate either models of constraints on data, usually in the form of Boolean expressions, or models of interactions between components, usually in the form of finite state machines. Both data and interaction models are useful for analyzing and verifying different aspects of software behavior, but none of them cap...", "pdfSize": "683KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+generation+of+software+behavioral+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "J. Morse, L. Cordeiro, D. Nicole, B. Fischer, \"Model checking Itl properties over ansi-c programs with bounded traces\", <em>Software & Systems Modeling</em>, vol. 14, no. 1, pp. 65-81, 2015.", "title": "Model checking Itl properties over ansi-c programs with bounded traces", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10270-013-0366-0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Model+checking+Itl+properties+over+ansi-c+programs+with+bounded+traces&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "H. Palikareva, C. Cadar, \"Multi-solver support in symbolic execution\", <em>Proceedings of the International Conference on Computer Aided Verification CAV '13</em>, pp. 53-68, 2013.", "title": "Multi-solver support in symbolic execution", "context": [{"sec": "sec5", "text": " Palikareva et al. have observed that modern SMT solvers have different strengths and that, for most queries, it is impossible to tell in advance which solver will perform better [16].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Multi-solver+support+in+symbolic+execution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "C.S. P\u0103s\u0103reanu, P.C. Mehlitz, D.H. Bushnell, K. Gundy-Burlet, M. Lowry, S. Person, M. Pape, \"Combining unit-level symbolic execution and system-level concrete execution for testing nasa software\", <em>Proceedings of the International Symposium on Software Testing and Analysis ISSTA '08</em>, pp. 15-26, 2008.", "title": "Combining unit-level symbolic execution and system-level concrete execution for testing nasa software", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combining+unit-level+symbolic+execution+and+system-level+concrete+execution+for+testing+nasa+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "R. Sasnauskas, O.S. Dustmann, B.L. Kaminski, K. Wehrle, C. Weise, S. Kowalewski, \"Scalable symbolic execution of distributed systems\", <em>Proceedings of the International Conference on Distributed Computing Systems ICDCS'11</em>, pp. 333-342, 2011.", "title": "Scalable symbolic execution of distributed systems", "context": [{"sec": "sec1", "text": "Program analysis techniques automatically determine whether properties hold on programs, and find important industrial applications in many relevant domains, such as wireless sensor networks and distributed systems [7], [18], drivers of popular operating systems [3], [10], firmware of medical devices [15], and mission critical software applications [2], [17].", "part": "1"}], "links": {"abstract": "Recent advances in symbolic execution have proposed a number of promising solutions to automatically achieve high-coverage and explore non-determinism during testing. This attractive testing technique of unmodified software assists developers with concrete inputs and deterministic schedules to analyze erroneous program paths. Being able to handle complex systems&#39; software, these tools only consider single software instances and not their distributed execution which forms the core of distributed ...", "pdfSize": "458KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Scalable+symbolic+execution+of+distributed+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "W. Visser, J. Geldenhuys, M.B. Dwyer, \"Green: Reducing reusing and recycling constraints in program analysis\", <em>Proceedings of the ACM SIGSOFT International Symposium on Foundations of Software Engineering FSE '12</em>, pp. 1-11, 2012.", "title": "Green: Reducing, reusing and recycling constraints in program analysis", "context": [{"sec": "sec1", "text": " [19], Jia et al. [11] and Aquino et al. [1] have proposed techniques to reduce the number of queries issued by SMT-based program analysis techniques to SMT solvers.", "part": "1"}, {"sec": "sec3c", "text": " We compare Utopia with Green [19], GreenTrie [11], Recal and Recal+ [1].", "part": "1"}, {"sec": "sec5", "text": "Visser et al. have designed Green [19], a caching framework that targets formulas belonging to the quantifier-free linear integer arithmetic logic.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2393596.2393665", "abstract": "The analysis of constraints plays an important role in many aspects of software engineering, for example constraint satisfiability checking is central to symbolic execution. However, the norm is to recompute results in each analysis. We propose a different approach where every call to the solver is wrapped in a check to see if the result is not already available. While many tools use some form of results caching, the novelty of our approach is the persistence of results across runs, across progr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Green%3A+Reducing%2C+reusing+and+recycling+constraints+in+program+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985682", "articleId": "7985682", "startPage": "427", "endPage": "437", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 2, "citationCountPatent": 0, "totalDownloads": 239}}
{"title": "Developer Reading Behavior While Summarizing Java Methods: Size and Context Matters", "authors": [{"name": "Nahla J. Abid", "affiliation": "Taibah University, Saudi Arabia", "firstName": "Nahla J.", "lastName": "Abid", "id": "37085689826"}, {"name": "Bonita Sharif", "affiliation": "University of Nebraska - Lincoln, USA", "firstName": "Bonita", "lastName": "Sharif", "id": "37397581200"}, {"name": "Natalia Dragan", "affiliation": "Kent State University, USA", "firstName": "Natalia", "lastName": "Dragan", "id": "37591057000"}, {"name": "Hend Alrasheed", "affiliation": "King Saud University, Saudi Arabia", "firstName": "Hend", "lastName": "Alrasheed", "id": "37085561713"}, {"name": "Jonathan I. Maletic", "affiliation": "Kent State University, USA", "firstName": "Jonathan I.", "lastName": "Maletic", "id": "37265100800"}], "abstract": "An eye-tracking study of 18 developers reading and summarizing Java methods is presented. The developers provide a written summary for methods assigned to them. In total, 63 methods are used from five different systems. Previous studies on this topic use only short methods presented in isolation usually as images. In contrast, this work presents the study in the Eclipse IDE allowing access to all the source code in the system. The developer can navigate via scrolling and switching files while writing the summary. New eye-tracking infrastructure allows for this improvement in the study environment. Data collected includes eye gazes on source code, written summaries, and time to complete each summary. Unlike prior work that concluded developers focus on the signature the most, these results indicate that they tend to focus on the method body more than the signature. Moreover, both experts and novices tend to revisit control flow terms rather than reading them for a long period. They also spend a significant amount of gaze time and have higher gaze visits when they read call terms. Experts tend to revisit the body of the method significantly more frequently than its signature as the size of the method increases. Moreover, experts tend to write their summaries from source code lines that they read the most.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Java", "Gaze tracking", "Task analysis", "Natural languages", "Software engineering", "Switches"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["gaze tracking", "human factors", "Java"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["Java methods", "written summary", "gaze time", "source code lines", "eye gazes", "eye tracking infrastructure", "developer reading behavior", "Eclipse IDE", "control flow"]}, {"type": "Author Keywords ", "kwd": ["source code summarization", "eye tracking", "program comprehension", "empirical study"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00052", "ref": [{"order": "1", "text": "A. J. Ko, B. A. Myers, M. J. Coblenz, H. H. Aung, \"An exploratory study of how developers seek relate and collect relevant information during software maintenance tasks\", <em>IEEE Transactions on Software Engineering</em>, vol. 32, no. 12, pp. 971-987, 2006.", "title": "An exploratory study of how developers seek, relate, and collect relevant information during software maintenance tasks", "context": [{"sec": "sec1", "text": "Source code reading and comprehension is an essential and time-consuming task that programmers perform during software maintenance [1], [2].", "part": "1"}], "links": {"documentLink": "/document/4016573", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4016573", "abstract": "Much of software developers&#39; time is spent understanding unfamiliar code. To better understand how developers gain this understanding and how software development environments might be involved, a study was performed in which developers were given an unfamiliar program and asked to work on two debugging tasks and three enhancement tasks for 70 minutes. The study found that developers interleaved three activities. They began by searching for relevant code both manually and using search tools; how...", "pdfSize": "3888KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+exploratory+study+of+how+developers+seek%2C+relate%2C+and+collect+relevant+information+during+software+maintenance+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "T. D. LaToza, G. Venolia, R. DeLine, \"Maintaining mental models: A study of developer work habits\", <em>Proceedings of the 28th International Conference on Software Engineering ser. ICSE '06</em>, pp. 492-501, 2006.", "title": "Maintaining mental models: A study of developer work habits", "context": [{"sec": "sec1", "text": "Source code reading and comprehension is an essential and time-consuming task that programmers perform during software maintenance [1], [2].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134355", "abstract": "To understand developers&#39; typical tools, activities, and practices and their satisfaction with each, we conducted two surveys and eleven interviews. We found that many problems arose because developers were forced to invest great effort recovering implicit knowledge by exploring code and interrupting teammates and this knowledge was only saved in their memory. Contrary to expectations that email and IM prevent expensive task switches caused by face-to-face interruptions, we found that face-to-fa...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Maintaining+mental+models%3A+A+study+of+developer+work+habits&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "B. Fluri, M. Wursch, H. C. Gall, \"Do code and comments co-evolve? on the relation between source code and comment changes\", <em>14th Working Conference on Reverse Engineering (WCRE 2007)</em>, pp. 70-79, 2007.", "title": "Do code and comments co-evolve? on the relation between source code and comment changes", "context": [{"sec": "sec1", "text": " Natural language documentation and code summarizations are found to be critical to improve code comprehension [3].", "part": "1"}], "links": {"documentLink": "/document/4400153", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4400153", "abstract": "Comments are valuable especially for program understanding and maintenance, but do developers comment their code? To which extent do they add comments or adapt them when they evolve the code? We examine the question whether source code and associated comments are really changed together along the evolutionary history of a software system. In this paper, we describe an approach to map code and comments to observe their co-evolution over multiple versions. We investigated three open source systems...", "pdfSize": "638KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+code+and+comments+co-evolve%3F+on+the+relation+between+source+code+and+comment+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "M. E. Crosby, J. Stelovsky, \"How do we read algorithms? a case study\", <em>Computer</em>, vol. 23, no. 1, pp. 25-35, 1990.", "title": "How do we read algorithms? a case study", "context": [{"sec": "sec1", "text": " In fact, expert and novice programmers tend to read comments more than the source code during comprehension activities [4].", "part": "1"}, {"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " [4] conducted an early eye-tracking study of high and low experience programmers reading a binary search algorithm.", "part": "1"}, {"sec": "sec7", "text": " As developers mostly rely on comments to understand methods [4], we remove all comments from the source code (similar to the Rodeghero study).", "part": "1"}], "links": {"documentLink": "/document/48797", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=48797", "abstract": "The authors report on an experiment that explored the way subjects view an algorithm, written in Pascal, and the graphical representation of its behavior. They designed the experiment to examine the influence of programming experience on how subjects view a short but complex algorithm, and they analyzed the scan patterns of eye movement for subjects at two experience levels. They describe the experimental procedure in detail, and discuss the results. An important finding was that all subjects ne...", "pdfSize": "1010KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+do+we+read+algorithms%3F+a+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "S. C. B. de Souza, N. Anquetil, K. M. de Oliveira, \"A study of the documentation essential to software maintenance\", <em>Proceedings of the 23rd Annual International Conference on Design of Communication: Documenting &Amp; Designing for Pervasive Information ser. SIG-DOC '05</em>, pp. 68-75, 2005.", "title": "A study of the documentation essential to software maintenance", "context": [{"sec": "sec1", "text": " Unfortunately, comments are oftentimes incomplete [5] or outdated due to changes in code during maintenance.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1085313.1085331", "abstract": "Software engineering has been striving for years to improve the practice of software development and maintenance. Documentation has long been prominent on the list of recommended practices to improve development and help maintenance. Recently however, agile methods started to shake this view, arguing that the goal of the game is to produce software and that documentation is only useful as long as it helps to reach this goal.On the other hand, in the re-engineering field, people wish they could r...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+study+of+the+documentation+essential+to+software+maintenance&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "G. Sridhara, E. Hill, D. Muppaneni, L. Pollock, K. Vijay-Shanker, \"Towards automatically generating summary comments for java methods\", <em>Proceedings of the IEEE/ACM International Conference on Automated Software Engineering ser. ASE '10</em>, pp. 43-52, 2010.", "title": "Towards automatically generating summary comments for java methods", "context": [{"sec": "sec1", "text": " Several approaches are proposed to generate automatic summaries using Natural Language Processing (NLP) [6], [7], text retrieval [8], [9], and static analysis [10], [11].", "part": "1"}, {"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec1", "text": " Therefore, we conclude that gaze time can substantially predict lines that are important for summarizing a method [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec2", "text": "With regards to code summarization approaches, Sridhara et al. propose techniques to automatically generate natural language comments for Java methods [6], sequences of statements [13], and formal parameters [12] using NLP.", "part": "1"}, {"sec": "sec6d", "text": " We found that 119 (out of 124) of lines used by experts belong to one of the summary units proposed in previous literature on source code summarization [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec6d", "text": " [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec8", "text": " Last void call is the main summary unit that is often used (15 times) by experts as methods often perform a set of steps to accomplish a final action [6].", "part": "1"}, {"sec": "sec8", "text": " The same action [6] summary unit should also be used when applicable.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1858996.1859006", "abstract": "Studies have shown that good comments can help programmers quickly understand what a method does, aiding program comprehension and software maintenance. Unfortunately, few software projects adequately comment the code. One way to overcome the lack of human-written summary comments, and guard against obsolete comments, is to automatically generate them. In this paper, we present a novel technique to automatically generate descriptive summary comments for Java methods. Given the signature and body...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+automatically+generating+summary+comments+for+java+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "P. W. McBurney, C. McMillan, \"Automatic documentation generation via source code summarization of method context\", <em>Proceedings of the 22Nd International Conference on Program Comprehension ser. ICPC 2014</em>, pp. 279-290, 2014.", "title": "Automatic documentation generation via source code summarization of method context", "context": [{"sec": "sec1", "text": " Several approaches are proposed to generate automatic summaries using Natural Language Processing (NLP) [6], [7], text retrieval [8], [9], and static analysis [10], [11].", "part": "1"}, {"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[7][8], [11]\u2013[16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec1", "text": " Therefore, we conclude that gaze time can substantially predict lines that are important for summarizing a method [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec2", "text": " McBurney and McMillan propose generating documentation summaries for Java methods using the call graph [7].", "part": "1"}, {"sec": "sec6d", "text": " We found that 119 (out of 124) of lines used by experts belong to one of the summary units proposed in previous literature on source code summarization [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec6d", "text": " For example, the method name is commonly used to summarize a method [7], [11], [17] as it describes the goal of a method.", "part": "1"}, {"sec": "sec6d", "text": " The lines used by experts are actually the same lines that past literature has proposed. [6], [7], [11], [12], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2597008.2597149", "abstract": "A documentation generator is a programming tool that creates documentation for software by analyzing the statements and comments in the software&#39;s source code. While many of these tools are manual, in that they require specially-formatted metadata written by programmers, new research has made inroads towards automatic generation of documentation. These approaches work by stitching together keywords from the source code into readable natural language sentences. These approaches have been shown to...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+documentation+generation+via+source+code+summarization+of+method+context&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "S. Haiduc, J. Aponte, L. Moreno, A. Marcus, \"On the use of automated text summarization techniques for summarizing source code\", <em>2010 17th Working Conference on Reverse Engineering</em>, pp. 35-44, 2010.", "title": "On the use of automated text summarization techniques for summarizing source code", "context": [{"sec": "sec1", "text": " Several approaches are proposed to generate automatic summaries using Natural Language Processing (NLP) [6], [7], text retrieval [8], [9], and static analysis [10], [11].", "part": "1"}, {"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec1", "text": " They use this information to give more weight to terms that developers look at more often during summarization (i.e., signature is given more weight compared to call statements) as heuristics for their automated summarization approach that was adapted from prior work [8].", "part": "1"}, {"sec": "sec2", "text": " [8] investigate the suitability of several text summarization techniques to automatically generate term-based summaries for methods and classes.", "part": "1"}], "links": {"documentLink": "/document/5645482", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5645482", "abstract": "During maintenance developers cannot read the entire code of large systems. They need a way to get a quick understanding of source code entities (such as, classes, methods, packages, etc.), so they can efficiently identify and then focus on the ones related to their task at hand. Sometimes reading just a method header or a class name does not tell enough about its purpose and meaning, while reading the entire implementation takes too long. We study a solution which mitigates the two approaches, ...", "pdfSize": "192KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+use+of+automated+text+summarization+techniques+for+summarizing+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "B. P. Eddy, J. A. Robinson, N. A. Kraft, J. C. Carver, \"Evaluating source code summarization techniques: Replication and expansion\", <em>2013 21st International Conference on Program Comprehension (ICPC)</em>, pp. 13-22, 2013.", "title": "Evaluating source code summarization techniques: Replication and expansion", "context": [{"sec": "sec1", "text": " Several approaches are proposed to generate automatic summaries using Natural Language Processing (NLP) [6], [7], text retrieval [8], [9], and static analysis [10], [11].", "part": "1"}, {"sec": "sec2", "text": " [9] using a new technique named Hierarchical PAM.", "part": "1"}], "links": {"documentLink": "/document/6613829", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6613829", "abstract": "During software evolution a developer must investigate source code to locate then understand the entities that must be modified to complete a change task. To help developers in this task, Haiduc et al. proposed text summarization based approaches to the automatic generation of class and method summaries, and via a study of four developers, they evaluated source code summaries generated using their techniques. In this paper we propose a new topic modeling based approach to source code summarizati...", "pdfSize": "208KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Evaluating+source+code+summarization+techniques%3A+Replication+and+expansion&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "L. Moreno, J. Aponte, G. Sridhara, A. Marcus, L. Pollock, K. Vijay-Shanker, \"Automatic generation of natural language summaries for java classes\", <em>2013 21st International Conference on Program Comprehension (ICPC)</em>, pp. 23-32, 2013.", "title": "Automatic generation of natural language summaries for java classes", "context": [{"sec": "sec1", "text": " Several approaches are proposed to generate automatic summaries using Natural Language Processing (NLP) [6], [7], text retrieval [8], [9], and static analysis [10], [11].", "part": "1"}, {"sec": "sec2", "text": " [10] use method stereotypes [39] and class stereotypes [40] to generate natural language summaries for Java classes.", "part": "1"}], "links": {"documentLink": "/document/6613830", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6613830", "abstract": "Most software engineering tasks require developers to understand parts of the source code. When faced with unfamiliar code, developers often rely on (internal or external) documentation to gain an overall understanding of the code and determine whether it is relevant for the current task. Unfortunately, the documentation is often absent or outdated. This paper presents a technique to automatically generate human readable summaries for Java classes, assuming no documentation exists. The summaries...", "pdfSize": "666KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+generation+of+natural+language+summaries+for+java+classes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "N. J. Abid, N. Dragan, M. L. Collard, J. I. Maletic, \"Using stereotypes in the automatic generation of natural language summaries for c++ methods\", <em>2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 561-565, 2015.", "title": "Using stereotypes in the automatic generation of natural language summaries for c++ methods", "context": [{"sec": "sec1", "text": " Several approaches are proposed to generate automatic summaries using Natural Language Processing (NLP) [6], [7], text retrieval [8], [9], and static analysis [10], [11].", "part": "1"}, {"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec1", "text": " Therefore, we conclude that gaze time can substantially predict lines that are important for summarizing a method [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec2", "text": " [11] [41] use method stereotypes to generate a standard summary for C++ methods via static analysis.", "part": "1"}, {"sec": "sec6d", "text": " We found that 119 (out of 124) of lines used by experts belong to one of the summary units proposed in previous literature on source code summarization [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec6d", "text": " For example, the method name is commonly used to summarize a method [7], [11], [17] as it describes the goal of a method.", "part": "1"}, {"sec": "sec6d", "text": " The lines used by experts are actually the same lines that past literature has proposed. [6], [7], [11], [12], [17].", "part": "1"}], "links": {"documentLink": "/document/7332514", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7332514", "abstract": "An approach to automatically generate natural language documentation summaries for C++ methods is presented. The approach uses prior work by the authors on stereotyping methods along with the source code analysis framework srcML. First, each method is automatically assigned a stereotype(s) based on static analysis and a set of heuristics. Then, the approach uses the stereotype information, static analysis, and predefined templates to generate a natural-language summary for each method. This summ...", "pdfSize": "201KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Using+stereotypes+in+the+automatic+generation+of+natural+language+summaries+for+c%2B%2B+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "G. Sridhara, L. Pollock, K. Vijay-Shanker, \"Automat-ically detecting and describing high level actions within methods\", <em>Proceedings of the 33rd International Conference on Software Engineering ser. ICSE '11</em>, pp. 101-110, 2011.", "title": "Automat-ically detecting and describing high level actions within methods", "context": [{"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[12][16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec1", "text": " Therefore, we conclude that gaze time can substantially predict lines that are important for summarizing a method [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec2", "text": "With regards to code summarization approaches, Sridhara et al. propose techniques to automatically generate natural language comments for Java methods [6], sequences of statements [13], and formal parameters [12] using NLP.", "part": "1"}, {"sec": "sec6d", "text": " We found that 119 (out of 124) of lines used by experts belong to one of the summary units proposed in previous literature on source code summarization [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec6d", "text": " The lines used by experts are actually the same lines that past literature has proposed. [6], [7], [11], [12], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1985793.1985808", "abstract": "One approach to easing program comprehension is to reduce the amount of code that a developer has to read. Describing the high level abstract algorithmic actions associated with code fragments using succinct natural language phrases potentially enables a newcomer to focus on fewer and more abstract concepts when trying to understand a given method. Unfortunately, such descriptions are typically missing because it is tedious to create them manually. We present an automatic technique for identifyi...", "pdfSize": "774KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automat-ically+detecting+and+describing+high+level+actions+within+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "G. Sridhara, L. Pollock, K. Vijay-Shanker, \"Generating parameter comments and integrating with method summaries\", <em>2011 IEEE 19th International Conference on Program Comprehension</em>, pp. 71-80, 2011.", "title": "Generating parameter comments and integrating with method summaries", "context": [{"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[13][16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec2", "text": "With regards to code summarization approaches, Sridhara et al. propose techniques to automatically generate natural language comments for Java methods [6], sequences of statements [13], and formal parameters [12] using NLP.", "part": "1"}], "links": {"documentLink": "/document/5970165", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5970165", "abstract": "An important part of the leading comments for a method are the comments for the formal parameters of the method. According to the Java documentation writing guidelines, developers should write a summary of the method&#39;sactions followed by comments for each parameter. In this paper, we describe a novel technique to automatically generate descriptive comments for parameters of Java methods. Such generated comments can help alleviate the lack of developer written parameter comments. In addition, the...", "pdfSize": "928KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Generating+parameter+comments+and+integrating+with+method+summaries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "S. Badihi, A. Heydarnoori, \"Crowdsummarizer: Automated generation of code summaries for java programs through crowdsourcing\", <em>IEEE Software</em>, vol. 34, no. 2, pp. 71-80, 2017.", "title": "Crowdsummarizer: Automated generation of code summaries for java programs through crowdsourcing", "context": [{"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[14][16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}], "links": {"documentLink": "/document/7888409", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7888409", "abstract": "To perform software maintenance, developers must have a relatively good understanding of the program&#39;s source code, which is often written by other developers. Code summaries, which describe a program&#39;s entities (for example, its methods), help developers better comprehend code more quickly. However, generating code summaries can be challenging. To mitigate this problem, CrowdSummarizer exploits crowdsourcing, gamification, and natural-language processing to automatically generate high-level sum...", "pdfSize": "846KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Crowdsummarizer%3A+Automated+generation+of+code+summaries+for+java+programs+through+crowdsourcing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "Y. Wan, Z. Zhao, M. Yang, G. Xu, H. Ying, J. Wu, S. Y. Philip, \"Improving automatic source code summarization via deep reinforcement learning\", <em>The 33rd IEEE/ACM International Conference on Automated Software Engineering</em>, 2018.", "title": "Improving automatic source code summarization via deep reinforcement learning", "context": [{"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[15][16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3238147.3238206", "abstract": "Code summarization provides a high level natural language description of the function performed by code, as it can benefit the software maintenance, code categorization and retrieval. To the best of our knowledge, most state-of-the-art approaches follow an encoder-decoder framework which encodes the code into a hidden space and then decode it into natural language space, suffering from two major drawbacks: a) Their encoders only consider the sequential content of code, ignoring the tree structur...", "pdfSize": "742KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+automatic+source+code+summarization+via+deep+reinforcement+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "L. Moreno, A. Marcus, \"Automatic software summarization: the state of the art\", <em>2017 IEEE/ACM 39th International Conference on Software Engineering Companion (ICSE-C)</em>, pp. 511-512, 2017.", "title": "Automatic software summarization: the state of the art", "context": [{"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}], "links": {"documentLink": "/document/7965408", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7965408", "abstract": "Automatic text summarization has been widely studied for more than fifty years. In software engineering, automatic summarization is an emerging area that shows great potential and poses new and exciting research challenges. This technical briefing provides an introduction to the state of the art and maps future research directions in automatic software summarization.", "pdfSize": "270KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+software+summarization%3A+the+state+of+the+art&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "P. Rodeghero, C. McMillan, P. W. McBurney, N. Bosch, S. D'Mello, \"Improving automated source code summarization via an eye-tracking study of programmers\", <em>Proceedings of the 36th International Conference on Software Engineering ser. ICSE 2014</em>, pp. 390-401, 2014.", "title": "Improving automated source code summarization via an eye-tracking study of programmers", "context": [{"sec": "sec1", "text": " In order to further improve source code summarization techniques [6]\u2013[8], [11]\u2013[16], Rodeghero et al. conducted an eye-tracking study [17] to determine the statements and terms (i.e., identifier names) that programmers view as important when they summarize a method.", "part": "1"}, {"sec": "sec1", "text": " [17] is limited in that the study could not be conducted in a realistic working environment.", "part": "1"}, {"sec": "sec1", "text": " Unlike the prior study that concluded developers mostly focus on the signature [17], the results from our study indicate that developers tend to focus on the method body more than the signature.", "part": "1"}, {"sec": "sec1", "text": " Therefore, we conclude that gaze time can substantially predict lines that are important for summarizing a method [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": "Rodeghero et al. conduct an eye-tracking study on isolated methods to determine statements and terms that programmers view as important when they summarize them [17].", "part": "1"}, {"sec": "sec2", "text": " The same study [17] was further analyzed in [28] to find reading patterns of programmers during summarization.", "part": "1"}, {"sec": "sec2", "text": " [17] with several differences.", "part": "1"}, {"sec": "sec3", "text": " The analysis considers three source-code locations namely, method signatures, method calls, and control flow statements [17], [28], [34].", "part": "1"}, {"sec": "sec3", "text": " These locations were chosen so that we can make comparisons to the Rodeghero study [17].", "part": "1"}, {"sec": "sec3", "text": " Such scope analysis could not be done in the Rodeghero study as the methods were presented in isolation [17].", "part": "1"}, {"sec": "sec4b", "text": " Methods in Rodeghero et al.'s study [17] fall in the first category.", "part": "1"}, {"sec": "sec4d", "text": " As in [17], two types of eye-movement data are used: number of fixations and their durations (gaze time).", "part": "1"}, {"sec": "sec5", "text": " We define call terms to include the method call name and parameters [17].", "part": "1"}, {"sec": "sec6a", "text": " [17].", "part": "1"}, {"sec": "sec6a", "text": " However, one cannot claim to have evidence to order these locations with respect to their importance (even though this is suggested in [17]).", "part": "1"}, {"sec": "sec6a", "text": "As seen in Table III, these results do not reproduce results from the Rodeghero study [17].", "part": "1"}, {"sec": "sec6a", "text": " Furthermore, Rodeghero et al. concluded that control flow terms are read statistically less than other areas of a method [17].", "part": "1"}, {"sec": "sec6d", "text": " We found that 119 (out of 124) of lines used by experts belong to one of the summary units proposed in previous literature on source code summarization [6], [7], [11], [12], [17].", "part": "1"}, {"sec": "sec6d", "text": " For example, the method name is commonly used to summarize a method [7], [11], [17] as it describes the goal of a method.", "part": "1"}, {"sec": "sec6d", "text": " The lines used by experts are actually the same lines that past literature has proposed. [6], [7], [11], [12], [17].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2568225.2568247", "abstract": "Source Code Summarization is an emerging technology for automatically generating brief descriptions of code. Current summarization techniques work by selecting a subset of the statements and keywords from the code, and then including information from those statements and keywords in the summary. The quality of the summary depends heavily on the process of selecting the subset: a high-quality selection would contain the same statements and keywords that a programmer would choose. Unfortunately, l...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+automated+source+code+summarization+via+an+eye-tracking+study+of+programmers&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "T. R. Shaffer, J. L. Wise, B. M. Walters, S. C. Muller, M. Falcone, B. Sharif, \"itrace: Enabling eye tracking on software artifacts within the ide to support software engineering tasks\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering ser. ESEC/FSE 2015</em>, pp. 954-957, 2015.", "title": "itrace: Enabling eye tracking on software artifacts within the ide to support software engineering tasks", "context": [{"sec": "sec1", "text": "We overcome these two limitations by utilizing a new eye-tracking infrastructure call iTrace [18], [19] that is developed specifically for conducting eye-tracking studies within a software Integrated Development Environment (e.g., MS Visual Studio, Eclipse). iTrace supports the implicit tracking of eye movements in the presence of scrolling and switching between files within the IDE.", "part": "1"}, {"sec": "sec4c", "text": " The entire study was conducted inside the Eclipse environment using the Eclipse plugin iTrace [18]. iTrace is able to collect eye tracking data of where a developer is looking and map it on the fly to source code elements looked at even in the presence of file scrolling and file switching.", "part": "1"}, {"sec": "sec4d", "text": "A Tobii eye tracker (X60) was used to collect gaze data within the iTrace [18] environment.", "part": "1"}, {"sec": "sec5", "text": " Information from the eye-tracking tool, iTrace [18], includes information about the line number, the term name and the type of the term (method, variable, conditional statements, or other types).", "part": "1"}, {"sec": "sec6c", "text": "As mentioned earlier, since we used the Eclipse plugin, iTrace [18], the participants were able to context switch to any file if they needed to.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2803188", "abstract": "The paper presents iTrace, an Eclipse plugin that implicitly records developers&#39; eye movements while they work on change tasks. iTrace is the first eye tracking environment that makes it possible for researchers to conduct eye tracking studies on large software systems. An overview of the design and architecture is presented along with features and usage scenarios. iTrace is designed to support a variety of eye trackers. The design is flexible enough to record eye movements on various types of s...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=itrace%3A+Enabling+eye+tracking+on+software+artifacts+within+the+ide+to+support+software+engineering+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "D. T. Guarnera, C. A. Bryant, A. Mishra, J. I. Maletic, B. Sharif, \"itrace: Eye tracking infrastructure for development environments\", <em>Proceedings of the 2018 ACM Symposium on Eye Tracking Research & Applications ser. ETRA '18</em>, pp. 105:1-105:3, 2018.", "title": "itrace: Eye tracking infrastructure for development environments", "context": [{"sec": "sec1", "text": "We overcome these two limitations by utilizing a new eye-tracking infrastructure call iTrace [18], [19] that is developed specifically for conducting eye-tracking studies within a software Integrated Development Environment (e.g., MS Visual Studio, Eclipse). iTrace supports the implicit tracking of eye movements in the presence of scrolling and switching between files within the IDE.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3204493.3208343", "abstract": "The paper presents iTrace, an eye tracking infrastructure, that enables eye tracking in development environments such as Visual Studio and Eclipse. Software developers work with software that is comprised of numerous source code files. This requires frequent switching between project artifacts during program understanding or debugging activities. Additionally, the amount of content contained within each artifact can be quite large and require scrolling or navigation of the content. Current appro...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=itrace%3A+Eye+tracking+infrastructure+for+development+environments&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "Z. Sharafi, Z. Soh, Y. Gueheneuc, \"A systematic literature review on the usage of eye-tracking in software engineering\", <em>Information and Software Technology</em>, vol. 67, pp. 79-107, 2015.", "title": "A systematic literature review on the usage of eye-tracking in software engineering", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.infsof.2015.06.008", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+literature+review+on+the+usage+of+eye-tracking+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "B. Sharif, J. Meinken, T. Shaffer, H. Kagdi, \"Eye movements in software traceability link recovery\", <em>Empirical Software Engineering</em>, vol. 22, no. 3, pp. 1063-1102, Jun 2017.", "title": "Eye movements in software traceability link recovery", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[21][25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-016-9486-9", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eye+movements+in+software+traceability+link+recovery&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "Z. Sharafi, T. Shaffer, B. Sharif, Y. Gueheneuc, \"Eye-tracking metrics in software engineering\", <em>2015 Asia-Pacific Software Engineering Conference (APSEC)</em>, pp. 96-103, 2015.", "title": "Eye-tracking metrics in software engineering", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[22][25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"documentLink": "/document/7467288", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7467288", "abstract": "Eye-tracking studies are getting more prevalent in software engineering. Researchers often use different metrics when publishing their results in eye-tracking studies. Even when the same metrics are used, they are given different names, causing difficulties in comparing studies. To encourage replications and facilitate advancing the state of the art, it is important that the metrics used by researchers be clearly and consistently defined in the literature. There is therefore a need for a survey ...", "pdfSize": "222KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eye-tracking+metrics+in+software+engineering&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "U. Obaidellah, M. Al Haek, P. C.-H. Cheng, \"A survey on the usage of eye-tracking in computer programming\", <em>ACM Comput. Surv></em>, vol. 51, no. 1, pp. 5:1-5:58, Jan. 2018.", "title": "A survey on the usage of eye-tracking in computer programming", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[23][25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3145904", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+survey+on+the+usage+of+eye-tracking+in+computer+programming&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "T. Barik, J. Smith, K. Lubick, E. Holmes, J. Feng, E. Murphy-Hill, C. Parnin, \"Do developers read compiler error messages?\", <em>Proceedings of the 39th International Conference on Software Engineering ser. ICSE '17</em>, pp. 575-585, 2017.", "title": "Do developers read compiler error messages?", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[24][25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"documentLink": "/document/7985695", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7985695", "abstract": "In integrated development environments, developers receive compiler error messages through a variety of textual and visual mechanisms, such as popups and wavy red underlines. Although error messages are the primary means of communicating defects to developers, researchers have a limited understanding on how developers actually use these messages to resolve defects. To understand how developers use error messages, we conducted an eye tracking study with 56 participants from undergraduate and grad...", "pdfSize": "510KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+developers+read+compiler+error+messages%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "R. Bednarik, M. Tukiainen, \"An eye-tracking methodology for characterizing program comprehension processes\", <em>Proceedings of the 2006 Symposium on Eye Tracking Research &Amp; Applications ser. ETRA '06</em>, pp. 125-132, 2006.", "title": "An eye-tracking methodology for characterizing program comprehension processes", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " Bednarik and Tukiainen concluded that low-experience programmers repeatedly fixated on the same code sections, while experienced programmers target the output of the code, such as evaluation expressions [25], [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1117309.1117356", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+eye-tracking+methodology+for+characterizing+program+comprehension+processes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "R. Bednarik, M. Tukiainen, \"Temporal eye-tracking data: Evolution of debugging strategies with multiple representations\", <em>Proceedings of the 2008 Symposium on Eye Tracking Research & Applications ser. ETRA '08</em>, pp. 99-102, 2008.", "title": "Temporal eye-tracking data: Evolution of debugging strategies with multiple representations", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " Bednarik and Tukiainen concluded that low-experience programmers repeatedly fixated on the same code sections, while experienced programmers target the output of the code, such as evaluation expressions [25], [26].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1344471.1344497", "abstract": "The challenges in empirical eye-tracking studies of usability or complex problem solving include 1) how to effectively analyze the eye-tracking data, and 2) how to interpret and relate the resulting measures to the user cognitive processing. We conducted a reanalysis of eye-tracking data from a recent study that involved programmers of two experience groups debugging a program with the help of multiple representations. The proportional fixation time on each area of interest (AOI), frequency of v...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Temporal+eye-tracking+data%3A+Evolution+of+debugging+strategies+with+multiple+representations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "T. Busjahn, R. Bednarik, A. Begel, M. Crosby, J. H. Paterson, C. Schulte, B. Sharif, S. Tamm, \"Eye movements in code reading: Relaxing the linear order\", <em>2015 IEEE 23rd International Conference on Program Comprehension</em>, pp. 255-265, 2015.", "title": "Eye movements in code reading: Relaxing the linear order", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[27][30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " [27] found that experts read code less linearly than novices did.", "part": "1"}], "links": {"documentLink": "/document/7181454", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7181454", "abstract": "Code reading is an important skill in programming. Inspired by the linearity that people exhibit while natural language text reading, we designed local and global gaze-based measures to characterize linearity (left-to-right and top-to-bottom) in reading source code. Unlike natural language text, source code is executable and requires a specific reading approach. To validate these measures, we compared the eye movements of novice and expert programmers who were asked to read and comprehend short ...", "pdfSize": "194KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eye+movements+in+code+reading%3A+Relaxing+the+linear+order&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "P. Rodeghero, C. McMillan, \"An empirical study on the patterns of eye movement during summarization tasks\", <em>2015 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)</em>, vol. 00, pp. 1-10, 2015.", "title": "An empirical study on the patterns of eye movement during summarization tasks", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[28][30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " The same study [17] was further analyzed in [28] to find reading patterns of programmers during summarization.", "part": "1"}, {"sec": "sec3", "text": " The analysis considers three source-code locations namely, method signatures, method calls, and control flow statements [17], [28], [34].", "part": "1"}], "links": {"documentLink": "/document/7321188", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7321188", "abstract": "Eye movement patterns are the order in which keywords or sections of keywords are read. These patterns are an important component of how programmers read source code. One strategy for determining how programmers perform summarization tasks is through eye tracking studies. These studies examine where people focus their attention while viewing text or images. In this study, we expand on eye tracking analysis to determine the eye movement patterns of programmers. We begin the study with a qualitati...", "pdfSize": "13865KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+on+the+patterns+of+eye+movement+during+summarization+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "A. Jbara, D. G. Feitelson, \"How programmers read regular code: a controlled experiment using eye tracking\", <em>Empirical Software Engineering</em>, vol. 22, no. 3, pp. 1440-1477, Jun 2017.", "title": "How programmers read regular code: a controlled experiment using eye tracking", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[29][30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-016-9477-x", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+programmers+read+regular+code%3A+a+controlled+experiment+using+eye+tracking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "S. Lee, D. Hooshyar, H. Ji, K. Nam, H. Lim, \"Mining biometric data to predict programmer expertise and task difficulty\", <em>Cluster Computing</em>, Jan 2017.", "title": "Mining biometric data to predict programmer expertise and task difficulty", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+biometric+data+to+predict+programmer+expertise+and+task+difficulty&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "H. Uwano, M. Nakamura, A. Monden, K.-i. Matsumoto, \"Analyzing individual performance of source code review using reviewers' eye movement\", <em>Proceedings of the 2006 Symposium on Eye Tracking Research &Amp; Applications ser. ETRA '06</em>, pp. 133-140, 2006.", "title": "Analyzing individual performance of source code review using reviewers' eye movement", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " [31] observed that programmers tend to first read through the entire code snippet, and then focus on some parts.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1117309.1117357", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Analyzing+individual+performance+of+source+code+review+using+reviewers%27+eye+movement&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "B. Sharif, M. Falcone, J. I. Maletic, \"An eye-tracking study on the role of scan time in finding source code defects\", <em>Proceedings of the Symposium on Eye Tracking Research and Applications ser. ETRA '12</em>, pp. 381-384, 2012.", "title": "An eye-tracking study on the role of scan time in finding source code defects", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[32][33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " [32] stating that the scan time plays an important role in defect detection time and visual effort required to review source code.", "part": "1"}, {"sec": "sec2", "text": "Moreover, experts tend to focus on defects more than novices [32].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2168556.2168642", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+eye-tracking+study+on+the+role+of+scan+time+in+finding+source+code+defects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "A. Begel, H. Vrzakova, \"Eye movements in code review\", <em>Proceedings of the Workshop on Eye Movements in Programming ser. EMIP '18</em>, pp. 5:1-5:5, 2018.", "title": "Eye movements in code review", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3216723.3216727", "abstract": "In order to ensure sufficient quality, software engineers conduct code reviews to read over one another&#39;s code looking for errors that should be fixed before committing to their source code repositories. Many kinds of errors are spotted, from simple spelling mistakes and syntax errors, to architectural flaws that may span several files. However, we know little about how software developers read code when looking for defects. What kinds of code trigger engineers to check more deeply into suspecte...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eye+movements+in+code+review&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "P. Rodeghero, C. Liu, P. W. McBurney, C. McMillan, \"An eye-tracking study of java programmers and application to source code summarization\", <em>IEEE Transactions on Software Engineering</em>, vol. 41, no. 11, pp. 1038-1054, 2015.", "title": "An eye-tracking study of java programmers and application to source code summarization", "context": [{"sec": "sec2", "text": "Eye-tracking technology is being used in software engineering [20]\u2013[25] to study how programmers read [4], [26]\u2013[30], review [31]\u2013[33], and summarize [17], [28], [34] source code.", "part": "1"}, {"sec": "sec2", "text": " In an extended version [34] of their initial work, they concluded that terms developers used in their method summaries generally have higher tf/idf scores than terms with high gaze times.", "part": "1"}, {"sec": "sec3", "text": " The analysis considers three source-code locations namely, method signatures, method calls, and control flow statements [17], [28], [34].", "part": "1"}, {"sec": "sec6a", "text": " This assists in determining if the significance of results is due to the complexity of the terms (number of characters) [34], [46] or the importance of terms at that location.", "part": "1"}, {"sec": "sec6a", "text": "Rodeghero et al. observed that long identifiers (high number of characters) experienced long gaze time [34] due to their complexity [46].", "part": "1"}, {"sec": "sec6a", "text": " Similarly, we observe that experts read call terms significantly longer than non-call terms when adjusted by number of terms but the result becomes insignificant when time is adjusted by number of characters (no character adjustment was done in [34]).", "part": "1"}], "links": {"documentLink": "/document/7118751", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7118751", "abstract": "Source Code Summarization is an emerging technology for automatically generating brief descriptions of code. Current summarization techniques work by selecting a subset of the statements and keywords from the code, and then including information from those statements and keywords in the summary. The quality of the summary depends heavily on the process of selecting the subset: a high-quality selection would contain the same statements and keywords that a programmer would choose. Unfortunately, l...", "pdfSize": "729KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+eye-tracking+study+of+java+programmers+and+application+to+source+code+summarization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "K. Kevic, B. M. Walters, T. R. Shaffer, B. Sharif, D. C. Shepherd, T. Fritz, \"Tracing software developers' eyes and interactions for change tasks\", <em>Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering ser. ESEC/FSE 2015</em>, pp. 202-213, 2015.", "title": "Tracing software developers' eyes and interactions for change tasks", "context": [{"sec": "sec2", "text": " When it comes to switches between methods, they found developers rarely follow call graph links and mostly switch to the elements in close proximity [35], [36].", "part": "1"}, {"sec": "sec4c", "text": " We extended iTrace for this study to include on-the-fly mapping to more source code constructs such as conditional and looping structures in addition to what was collected in an earlier study (method calls, signatures, and definition and use of variables) [35].", "part": "1"}, {"sec": "sec6a", "text": "Methods are read differently if presented in isolation vs. presented in a realistic environment that developers usually work in [35].", "part": "1"}, {"sec": "sec6a", "text": " [35].", "part": "1"}, {"sec": "sec6c", "text": " This observation confirms the result of [35].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2786805.2786864", "abstract": "What are software developers doing during a change task? While an answer to this question opens countless opportunities to support developers in their work, only little is known about developers&#39; detailed navigation behavior for realistic change tasks. Most empirical studies on developers performing change tasks are limited to very small code snippets or are limited by the granularity or the detail of the data collected for the study. In our research, we try to overcome these limitations by comb...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tracing+software+developers%27+eyes+and+interactions+for+change+tasks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "K. Kevic, B. Walters, T. Shaffer, B. Sharif, D. C. Shepherd, T. Fritz, \"Eye gaze and interaction contexts for change tasks - observations and potential\", <em>Journal of Systems and Software</em>, vol. 128, pp. 252-266, 2017.", "title": "Eye gaze and interaction contexts for change tasks - observations and potential", "context": [{"sec": "sec2", "text": " When it comes to switches between methods, they found developers rarely follow call graph links and mostly switch to the elements in close proximity [35], [36].", "part": "1"}, {"sec": "sec6a", "text": " Developers tend to focus on the method's body more than its signature when the code is presented in a realistic environment [36].", "part": "1"}, {"sec": "sec8", "text": " During maintenance tasks [36], not all lines are equally important.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.jss.2016.03.030", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eye+gaze+and+interaction+contexts+for+change+tasks+-+observations+and+potential&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "X. Wang, L. Pollock, K. Vijay-Shanker, \"Developing a model of loop actions by mining loop characteristics from a large code corpus\", <em>2015 IEEE International Conference on Software Maintenance and Evolution (IC-SME)</em>, pp. 51-60, 2015.", "title": "Developing a model of loop actions by mining loop characteristics from a large code corpus", "context": [{"sec": "sec2", "text": " Furthermore, Wang et al. propose a model that defines the high-level action of loops by analyzing linguistic and structure clues [37].", "part": "1"}], "links": {"documentLink": "/document/7332451", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7332451", "abstract": "Some high level algorithmic steps require more than one statement to implement, but are not large enough to be a method on their own. Specifically, many algorithmic steps (e.g., count, compare pairs of elements, find the maximum) are implemented as loop structures, which lack the higher level abstraction of the action being performed, and can negatively affect both human readers and automatic tools. Additionally, in a study of 14,317 projects, we found that less than 20% of loops are documented ...", "pdfSize": "205KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Developing+a+model+of+loop+actions+by+mining+loop+characteristics+from+a+large+code+corpus&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "X. Wang, L. Pollock, K. Vijay-Shanker, \"Automatically generating natural language descriptions for object-related statement sequences\", <em>2017 IEEE 24th International Conference on Software Analysis Evolution and Reengineering (SANER)</em>, pp. 205-216, 2017.", "title": "Automatically generating natural language descriptions for object-related statement sequences", "context": [{"sec": "sec2", "text": " They also presented an approach to automatically generate a natural language summary of object-oriented action units [38].", "part": "1"}], "links": {"documentLink": "/document/7884622", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7884622", "abstract": "Current source code analyses driving software maintenance tools treat methods as either a single unit or a set of individual statements or words. They often leverage method names and any existing internal comments. However, internal comments are rare, and method names do not typically capture the method&#39;s multiple high-level algorithmic steps that are too small to be a single method, but require more than one statement to implement. Previous work demonstrated feasibility of identifying high leve...", "pdfSize": "185KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+generating+natural+language+descriptions+for+object-related+statement+sequences&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "N. Dragan, M. L. Collard, J. I. Maletic, \"Reverse engineering method stereotypes\", <em>2006 22nd IEEE International Conference on Software Maintenance</em>, pp. 24-34, 2006.", "title": "Reverse engineering method stereotypes", "context": [{"sec": "sec2", "text": "Moreno et al. [10] use method stereotypes [39] and class stereotypes [40] to generate natural language summaries for Java classes.", "part": "1"}], "links": {"documentLink": "/document/4021317", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4021317", "abstract": "An approach to automatically identify the stereotypes of all the methods in an entire system is presented. A taxonomy for object-oriented class method stereotypes is given that unifies and extends the existing literature to address gaps and deficiencies. Based on this taxonomy, a set of definitions is given and method stereotypes are reverse engineered using lightweight static program analysis. Classification is done solely by programming language structures and idioms, in this case C++. The app...", "pdfSize": "240KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reverse+engineering+method+stereotypes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "N. Dragan, M. L. Collard, J. I. Maletic, \"Automatic identification of class stereotypes\", <em>2010 IEEE International Conference on Software Maintenance</em>, pp. 1-10, 2010.", "title": "Automatic identification of class stereotypes", "context": [{"sec": "sec2", "text": "Moreno et al. [10] use method stereotypes [39] and class stereotypes [40] to generate natural language summaries for Java classes.", "part": "1"}], "links": {"documentLink": "/document/5609703", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5609703", "abstract": "An approach is presented to automatically determine a class&#39;s stereotype. The stereotype is based on the frequency and distribution of method stereotypes in the class. Method stereotypes are automatically determined using a defined taxonomy given in previous work. The stereotypes, boundary, control and entity are used as a basis but refined based on an empirical investigation of 21 systems. A number of heuristics, derived from empirical evidence, are used to determine a class&#39;s stereotype. For e...", "pdfSize": "414KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+identification+of+class+stereotypes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "N. Abid, N. Dragan, M. L. Collard, J. I. Maletic, \"The evaluation of an approach for automatic generated documentation\", <em>2017 IEEE International Conference on Software Maintenance and Evolution (ICSME)</em>, pp. 307-317, 2017.", "title": "The evaluation of an approach for automatic generated documentation", "context": [{"sec": "sec2", "text": " Abid et al. [11] [41] use method stereotypes to generate a standard summary for C++ methods via static analysis.", "part": "1"}], "links": {"documentLink": "/document/8094431", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8094431", "abstract": "Two studies are conducted to evaluate an approach to automatically generate natural language documentation summaries for C++ methods. The documentation approach relies on a method&#39;s stereotype information. First, each method is automatically assigned a stereotype(s) based on static analysis and a set of heuristics. Then, the approach uses the stereotype information, static analysis, and predefined templates to generate a natural-language summary/documentation for each method. This documentation ...", "pdfSize": "660KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+evaluation+of+an+approach+for+automatic+generated+documentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "P. W. Mcburney, C. Mcmillan, \"An empirical study of the textual similarity between source code and source code summaries\", <em>Empirical Softw. Engg.</em>, vol. 21, no. 1, pp. 17-42, Feb. 2016.", "title": "An empirical study of the textual similarity between source code and source code summaries", "context": [{"sec": "sec2", "text": " Furthermore, they propose an approach to evaluate a summary using textual similarity of that summary to the source code [42].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-014-9344-6", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+the+textual+similarity+between+source+code+and+source+code+summaries&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "K. Rayner, <em>Eye movements in reading and information processing: 20 years of research</em>, vol. 124, no. 3, pp. 372-422, 1998.", "title": "Eye movements in reading and information processing: 20 years of research", "context": [{"sec": "sec4d", "text": " A fixation is the stabilization of the eyes on some object of interest for a certain duration [43].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Eye+movements+in+reading+and+information+processing%3A+20+years+of+research&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "P. Olsson, Real-time and offline filters for eye tracking, pp. 42, 2007.", "title": "Real-time and offline filters for eye tracking", "context": [{"sec": "sec4d", "text": " A fixation filter [44] is set to count fixations that are more than 100 milliseconds (same as Rodeghero and vendor recommended).", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Real-time+and+offline+filters+for+eye+tracking&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "M. L. Collard, M. J. Decker, J. I. Maletic, \"Lightweight transformation and fact extraction with the srcml toolkit\", <em>2011 IEEE 11th International Working Conference on Source Code Analysis and Manipulation</em>, pp. 173-184, 2011.", "title": "Lightweight transformation and fact extraction with the srcml toolkit", "context": [{"sec": "sec5", "text": " First, for all methods used in the study, the signature lines are extracted from srcML [45], an XML representation of the code.", "part": "1"}], "links": {"documentLink": "/document/6065176", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6065176", "abstract": "The srcML toolkit for lightweight transformation and fact-extraction of source code is described. srcML is an XML format for C/C++/Java source code. The open source toolkit that includes the source-to-srcML and srcML-to-source translators for round-trip reverse engineering is freely available. The direct use of XPath and XSLT is supported, an archive format for large projects is included, and a rich set of input and output formats through a command-line interface is available. Applying transform...", "pdfSize": "330KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lightweight+transformation+and+fact+extraction+with+the+srcml+toolkit&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "B. Liblit, A. Begel, E. Sweetser, \"Cognitive perspectives on the role of naming in computer programs\", <em>Proceedings of the 18th Annual Psychology of Programming Workshop ser. PPIG '06</em>, 2006.", "title": "Cognitive perspectives on the role of naming in computer programs", "context": [{"sec": "sec6a", "text": " This assists in determining if the significance of results is due to the complexity of the terms (number of characters) [34], [46] or the importance of terms at that location.", "part": "1"}, {"sec": "sec6a", "text": "Rodeghero et al. observed that long identifiers (high number of characters) experienced long gaze time [34] due to their complexity [46].", "part": "1"}, {"sec": "sec6a", "text": " This indicates that call terms required longer time due to the complexity of the terms (number of characters) [46].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cognitive+perspectives+on+the+role+of+naming+in+computer+programs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "S. Siegel, Nonparametric statistics for the behavioral sciences ser, McGraw-Hill series in psychology.", "title": "Nonparametric statistics for the behavioral sciences, ser", "context": [{"sec": "sec6d", "text": " Finally, the original list is compared to the adjusted duration using Kendall's tau coefficient (\u03c4), that evaluates the degree of concordance between two sets of ranked data [47], [48] - a suitable test in this case.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Nonparametric+statistics+for+the+behavioral+sciences%2C+ser&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "H. Abdi, <em>The kendall rank correlation coefficient</em>, 2007,  [online]  Available: http://www.utdallas.edu/r-herve/Abdi-KendallCorreiation2007-pretty.pdf.", "title": "The kendall rank correlation coefficient", "context": [{"sec": "sec6d", "text": " Finally, the original list is compared to the adjusted duration using Kendall's tau coefficient (\u03c4), that evaluates the degree of concordance between two sets of ranked data [47], [48] - a suitable test in this case.", "part": "1"}, {"sec": "sec6d", "text": " Since critical value of Kendall's tau depends on n (number of lines in each sample), samples that has less than five lines are eliminated because n is not large enough [48].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+kendall+rank+correlation+coefficient&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812039", "articleId": "8812039", "startPage": "384", "endPage": "395", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 2, "citationCountPatent": 0, "totalDownloads": 64}}
{"title": "SafeCheck: Safety Enhancement of Java Unsafe API", "authors": [{"name": "Shiyou Huang", "affiliation": "Department of Computer Science, Texas A&M University", "firstName": "Shiyou", "lastName": "Huang", "id": "37086949358"}, {"name": "Jianmei Guo", "affiliation": "Alibaba Group, China", "firstName": "Jianmei", "lastName": "Guo", "id": "37086380569"}, {"name": "Sanhong Li", "affiliation": "Alibaba Group, China", "firstName": "Sanhong", "lastName": "Li", "id": "37086451953"}, {"name": "Xiang Li", "affiliation": "Alibaba Group, US.", "firstName": "Xiang", "lastName": "Li", "id": "37086950451"}, {"name": "Yumin Qi", "affiliation": "Alibaba Group, US.", "firstName": "Yumin", "lastName": "Qi", "id": "37086951659"}, {"name": "Kingsum Chow", "affiliation": "Alibaba Group, China", "firstName": "Kingsum", "lastName": "Chow", "id": "37086450785"}, {"name": "Jeff Huang", "affiliation": "Department of Computer Science, Texas A&M University", "firstName": "Jeff", "lastName": "Huang", "id": "37085536205"}], "abstract": "Java is a safe programming language by providing bytecode verification and enforcing memory protection. For instance, programmers cannot directly access the memory but have to use object references. Yet, the Java runtime provides an Unsafe API as a backdoor for the developers to access the low- level system code. Whereas the Unsafe API is designed to be used by the Java core library, a growing community of third-party libraries use it to achieve high performance. The Unsafe API is powerful, but dangerous, which leads to data corruption, resource leaks and difficult-to-diagnose JVM crash if used improperly. In this work, we study the Unsafe crash patterns and propose a memory checker to enforce memory safety, thus avoiding the JVM crash caused by the misuse of the Unsafe API at the bytecode level. We evaluate our technique on real crash cases from the openJDK bug system and real-world applications from AJDK. Our tool reduces the efforts from several days to a few minutes for the developers to diagnose the Unsafe related crashes. We also evaluate the runtime overhead of our tool on projects using intensive Unsafe operations, and the result shows that our tool causes a negligible perturbation to the execution of the applications.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Java", "Safety", "Tools", "Computer bugs", "Runtime", "Libraries"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["application program interfaces", "Java", "program debugging", "security of data", "storage management"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["memory safety", "bytecode verification", "Java runtime", "low- level system code", "Java core library", "memory checker", "memory protection", "safety enhancement", "Java unsafe API", "programming language", "unsafe crash patterns", "openJDK bug system", "JVM crash"]}, {"type": "Author Keywords ", "kwd": ["Java Unsafe API", "Dynamic Analysis", "Bytecode", "Memoey Safety"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00095", "ref": [{"order": "1", "text": "L. Gong, M. Mueller, H. Prafullchandra, R. Schemers, \"Going beyond the sandbox: An overview of the new security architecture in the java development kit 1.2\", <em>USENIX Symposium on Internet Technologies and Systems</em>, pp. 103-112, 1997.", "title": "Going beyond the sandbox: An overview of the new security architecture in the java development kit 1.2", "context": [{"sec": "sec1", "text": "Java is designed as a high-level programming language of strong type and memory safety guarantees [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Going+beyond+the+sandbox%3A+An+overview+of+the+new+security+architecture+in+the+java+development+kit+1.2&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "J. Meyer, T. Downing, Java virtual machine, O'Reilly & Associates, Inc., 1997.", "title": "Java virtual machine", "context": [{"sec": "sec1", "text": " The security model of Java is guaranteed by running the program on the Java Virtual Machine (JVM), which is responsible for loading, linking and executing the Java bytecode in the same way across different platforms [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Java+virtual+machine&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "R. Jones, R. Lins, Garbage collection: algorithms for automatic dynamic memory management, Wiley Chichester, vol. 208, 1996.", "title": "Garbage collection: algorithms for automatic dynamic memory management", "context": [{"sec": "sec1", "text": " Moreover, the JVM provides an automated memory manager (i.e., a garbage collector), and the memory allocation and deallocation in Java is exclusively done by the underlying JVM, thus avoiding the memory problems [3].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Garbage+collection%3A+algorithms+for+automatic+dynamic+memory+management&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "S. Liang, The Java Native Interface: Programmer's Guide and Specification, Addison-Wesley Professional, 1999.", "title": "The Java Native Interface: Programmer's Guide and Specification", "context": [{"sec": "sec1", "text": " Because most methods in sun. misc. unsafe are defined as Java Native Interface (JNI) [4], it provides a backdoor for the programmers to interact with the code written in \\$\\mathrm{C}/\\mathrm{C}++\\$.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Java+Native+Interface%3A+Programmer%27s+Guide+and+Specification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "L. Mastrangelo, L. Ponzanelli, A. Mocci, M. Lanza, M. Hauswirth, N. Nystrom, \"Use at your own risk: The java unsafe api in the wild\", <em>Proceedings of the 2015 ACM SIGPLAN International Conference on Object-Oriented Programming Systems Languages and Applications ser. OOPSLA</em>, 2015.", "title": "Use at your own risk: The java unsafe api in the wild", "context": [{"sec": "sec1", "text": " One prior work [5] analyzed 74 GB of compiled Java bytecode and found out that 25% of code directly or indirectly depend on third parties that use sun. misc. unsafe.", "part": "1"}, {"sec": "sec2b", "text": "The prior work [5] makes a comprehensive study on the usage of the Unsafe API in the wild.", "part": "1"}, {"sec": "sec2c", "text": " The prior work [5] categorizes the features of the methods into 15 groups based on the functionality, including CAS, fence, heap/off-heap operations, and so on.", "part": "1"}, {"sec": "sec2c", "text": "In this work, we mainly focus on methods that perform memory operations such as putInt/getInt and allocateMemory because these methods are used most frequently in practice according to the prior study [5].", "part": "1"}, {"sec": "sec2c", "text": " The data is collected from the prior work [5].", "part": "1"}, {"sec": "sec2c", "text": " In [5], they implemented an analysis on top of ASM [7] to find all the call sites where the call target is of type sun. misc. unsafe.", "part": "1"}, {"sec": "sec8", "text": " The prior work [5] went beyond Sandoz' work to make \\$a\\$ further study on the impact of Java Unsafe API in the wild with respect to what features of Unsafe are used, why they are used, and the potential problems it can cause.", "part": "1"}, {"sec": "sec8", "text": " Different from [5], our work focuses on how to check the security violation caused by the improper use of the Unsafe methods, and we only check the crashes in the domain of memory corruption.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2814270.2814313", "abstract": "Java is a safe language. Its runtime environment provides strong safety guarantees that any Java application can rely on. Or so we think. We show that the runtime actually does not provide these guarantees---for a large fraction of today&#39;s Java code. Unbeknownst to many application developers, the Java runtime includes a &#34;backdoor&#34; that allows expert library and framework developers to circumvent Java&#39;s safety guarantees. This backdoor is there by design, and is well known to experts, as it enab...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Use+at+your+own+risk%3A+The+java+unsafe+api+in+the+wild&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "X. Leroy, \"Java bytecode verification: algorithms and formalizations\", <em>Journal of Automated Reasoning</em>, vol. 30, no. 3-4, pp. 235-269, 2003.", "title": "Java bytecode verification: algorithms and formalizations", "context": [{"sec": "sec2a", "text": " By performing the data-flow analysis on the bytecode, the verifier ensures that the following conditions [6] at least are satisfied:\n\n\n\u2022\nType correctness: the parameters of the bytecode instructions are always of the types expected by the instructions.\n\n\n\u2022\nNo stack overflow or underflow: an instruction never pops an argument off an empty stack, nor pushes a result on a full stack (whose size is equal to the maximal stack size declared for the method).\n\n\n\u2022\nObjects initialization: when an instance of a class C is created, one of the initialization methods for class C (corresponding to the constructors for this class) must be invoked before the class instance can be used.\n\n\n\u2022\nRegister initialization: a load from a register must always follow at least one store in this register.\n\n\n\u2022\nAccess control: private, public, protected, and default accesses are legal.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1023/A:1025055424017", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Java+bytecode+verification%3A+algorithms+and+formalizations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>Asm bytecode analysis framework</em>,  [online]  Available: http://asm.ow2.org/.", "title": "Asm bytecode analysis framework", "context": [{"sec": "sec2c", "text": " In [5], they implemented an analysis on top of ASM [7] to find all the call sites where the call target is of type sun. misc. unsafe.", "part": "1"}, {"sec": "sec6", "text": "We have implemented SafeCheck as a tool on top of ASM [7].", "part": "1"}, {"sec": "sec8", "text": " ASM [7] provides a useful framework to instrument the bytecode, which is widely used in run-time verification including monitoring-oriented programming [21], [22] and predictive trace analysis [23]\u2013[25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Asm+bytecode+analysis+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>A crash in netty 4.0.18</em>,  [online]  Available: https://stackoverfiow.com/questions/25210480/netty-4-java-7-jvm-sigsegv-crash-under-load/25213653#25213653.", "title": "A crash in netty 4.0.18", "context": [{"sec": "sec2d", "text": " [8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+crash+in+netty+4.0.18&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "J. Manson, W. Pugh, S. V. Adve, <em>The Java memory model. ACM</em>, vol. 40, no. 1, 2005.", "title": "The Java memory model. ACM", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+Java+memory+model.+ACM&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "P. Sandoz, <em>Personal communication</em>, 2015.", "title": "Personal communication", "context": [{"sec": "sec8", "text": "Paul Sandoz performed an informal analysis of Maven artifacts and usages in Grepcode [10] and conducted a survey to study how Unsafe is used [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Personal+communication&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "P. Sandoz, <em>Safety not guaranteed: sun. misc. unsafe and the quest for safe alternatives</em>, 2015.", "title": "Safety not guaranteed: sun. misc. unsafe and the quest for safe alternatives", "context": [{"sec": "sec8", "text": "Paul Sandoz performed an informal analysis of Maven artifacts and usages in Grepcode [10] and conducted a survey to study how Unsafe is used [11].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safety+not+guaranteed%3A+sun.+misc.+unsafe+and+the+quest+for+safe+alternatives&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "S. Nagarakatte, J. Zhao, M. M. Martin, S. Zdancewic, \"Softbound: Highly compatible and complete spatial memory safety for c\", <em>Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI \u201809</em>, 2009.", "title": "Softbound: Highly compatible and complete spatial memory safety for c", "context": [{"sec": "sec8", "text": "SoftBound [12] presents a similar approach as ours to enforce the spatial memory safety for C.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1542476.1542504", "abstract": "The serious bugs and security vulnerabilities facilitated by C/C++&#39;s lack of bounds checking are well known, yet C and C++ remain in widespread use. Unfortunately, C&#39;s arbitrary pointer arithmetic, conflation of pointers and arrays, and programmer-visible memory layout make retrofitting C/C++ with spatial safety guarantees extremely challenging. Existing approaches suffer from incompleteness, have high runtime overhead, or require non-trivial changes to the C source code. Thus far, these deficie...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Softbound%3A+Highly+compatible+and+complete+spatial+memory+safety+for+c&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "T. M. Austin, S. E. Breach, G. S. Sohi, \"Efficient detection of all pointer and array access errors\", <em>Proceedings of the ACM SIGPLAN 1994 Conference on Programming Language Design and Implementation ser. PLDI \u201894</em>, 1994.", "title": "Efficient detection of all pointer and array access errors", "context": [{"sec": "sec8", "text": " Unlike prior approaches that change pointer representations and object layouts [13]\u2013[15], SoftBound records the base and bound in a disjoint metadata that is accessed via explicit table lookups on loads and stores of pointer values.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/178243.178446", "abstract": "We present a pointer and array access checking technique that provides complete error coverage through a simple set of program transformations. Our technique, based on an extended safe pointer representation, has a number of novel aspects. Foremost, it is the first technique that detects all spatial and temporal access errors. Its use is not limited by the expressiveness of the language; that is, it can be applied successfully to compiled or interpreted languages with subscripted and mutable poi...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+detection+of+all+pointer+and+array+access+errors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "G. C. Necula, J. Condit, M. Harren, S. McPeak, W. Weimer, \"Ccured: Type-safe retrofitting of legacy software\", <em>ACM Trans. Program. Lang. Syst.</em>, vol. 27, no. 3, May 2005.", "title": "Ccured: Type-safe retrofitting of legacy software", "context": [{"sec": "sec8", "text": " Unlike prior approaches that change pointer representations and object layouts [13]\u2013[14][15], SoftBound records the base and bound in a disjoint metadata that is accessed via explicit table lookups on loads and stores of pointer values.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1065887.1065892", "abstract": "This article describes CCured, a program transformation system that adds type safety guarantees to existing C programs. CCured attempts to verify statically that memory errors cannot occur, and it inserts run-time checks where static verification is insufficient.CCured extends C&#39;s type system by separating pointer types according to their usage, and it uses a surprisingly simple type inference algorithm that is able to infer the appropriate pointer kinds for existing C programs. CCured uses phys...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ccured%3A+Type-safe+retrofitting+of+legacy+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "N. Nethercote, J. Fitzhardinge, \"Bounds-checking entire programs without recompiling\", <em>SPACE</em>, 2004.", "title": "Bounds-checking entire programs without recompiling", "context": [{"sec": "sec8", "text": " Unlike prior approaches that change pointer representations and object layouts [13]\u2013[15], SoftBound records the base and bound in a disjoint metadata that is accessed via explicit table lookups on loads and stores of pointer values.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bounds-checking+entire+programs+without+recompiling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "N. Nethercote, J. Seward, \"Valgrind: A framework for heavyweight dynamic binary instrumentation\", <em>Proceedings of the 28th ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI \u201807</em>, 2007.", "title": "Valgrind: A framework for heavyweight dynamic binary instrumentation", "context": [{"sec": "sec8", "text": "Valgrind [16] is a binary instrumentation tool that uses shadow memory to record whether each byte of the application memory is safe to access.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1250734.1250746", "abstract": "Dynamic binary instrumentation (DBI) frameworks make it easy to build dynamic binary analysis (DBA) tools such as checkers and profilers. Much of the focus on DBI frameworks has been on performance; little attention has been paid to their capabilities. As a result, we believe the potential of DBI has not been fully exploited. In this paper we describe Valgrind, a DBI framework designed for building heavyweight DBA tools. We focus on its unique support for shadow values-a powerful but previously ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Valgrind%3A+A+framework+for+heavyweight+dynamic+binary+instrumentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "K. Serebryany, D. Bruening, A. Potapenko, D. Vyukov, \"Address-sanitizer: A fast address sanity checker\", <em>USENIX Annual Technical Conference</em>, pp. 309-318, 2012.", "title": "Address-sanitizer: A fast address sanity checker", "context": [{"sec": "sec8", "text": " AddressSanitizer (ASAN)[17] by Google takes a similar strategy as Valgrind to detect memory errors.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Address-sanitizer%3A+A+fast+address+sanity+checker&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "G. Tan, A. W. Appel, S. Chakradhar, A. Raghunathan, S. Ravi, D. Wang, \"Safe java native interface\", <em>Proceedings of IEEE International Symposium on Secure Software Engineering</em>, vol. 97, 2006.", "title": "Safe java native interface", "context": [{"sec": "sec8", "text": " It might be interesting to combine them with the work that enforce the security of JNI [18]\u2013[20].", "part": "1"}, {"sec": "sec8", "text": " SafeJNI [18] presented a framework called Safe Java Native Interface, which ensures type safety of heterogeneous programs that contain Java and C components.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safe+java+native+interface&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "G. Tan, J. Croft, \"An empirical security study of the native code in the jdk\", <em>Usenix Security Symposium</em>, pp. 365-378, 2008.", "title": "An empirical security study of the native code in the jdk", "context": [{"sec": "sec8", "text": " It might be interesting to combine them with the work that enforce the security of JNI [18]\u2013[19][20].", "part": "1"}, {"sec": "sec8", "text": " [19] performed an empirical security study to categorize the bugs in the native code of the JDK.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+security+study+of+the+native+code+in+the+jdk&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "D. Chisnall, B. Davis, K. Gudka, D. Brazdil, A. Joannou, J. Woodruff, A. T. Markettos, J. E. Maste, R. Norton, S. Son, M. Roe, S. W. Moore, P. G. Neumann, B. Laurie, R. N. Watson, \"Cheri jni: Sinking the java security model into the c\", <em>Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems ser. ASPLOS</em>, 2017.", "title": "Cheri jni: Sinking the java security model into the c", "context": [{"sec": "sec8", "text": " It might be interesting to combine them with the work that enforce the security of JNI [18]\u2013[20].", "part": "1"}, {"sec": "sec8", "text": " [20] proposed a hardware assisted implementation of the Java native code interface, which extends the guarantees required for Java's security model to native code.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3037697.3037725", "abstract": "Java provides security and robustness by building a high-level security model atop the foundation of memory protection. Unfortunately, any native code linked into a Java program -- including the million lines used to implement the standard library -- is able to bypass both the memory protection and the higher-level policies. We present a hardware-assisted implementation of the Java native code interface, which extends the guarantees required for Java&#39;s security model to native code. Our design s...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cheri+jni%3A+Sinking+the+java+security+model+into+the+c&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "D. Jin, P. O. Meredith, D. Griffith, G. Rosu, \"Garbage collection for monitoring parametric properties\", <em>Programming Language Design and Implementation (PLDI\u201811). ACM</em>, pp. 415-424, 2011.", "title": "Garbage collection for monitoring parametric properties", "context": [{"sec": "sec8", "text": " ASM [7] provides a useful framework to instrument the bytecode, which is widely used in run-time verification including monitoring-oriented programming [21], [22] and predictive trace analysis [23]\u2013[25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1993498.1993547", "abstract": "Parametric properties are behavioral properties over program events that depend on one or more parameters. Parameters are bound to concrete data or objects at runtime, which makes parametric properties particularly suitable for stating multi-object relationships or protocols. Monitoring parametric properties independently of the employed formalism involves slicing traces with respect to parameter instances and sending these slices to appropriate non-parametric monitor instances. The number of su...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Garbage+collection+for+monitoring+parametric+properties&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "P. Meredith, D. Jin, F. Chen, G. Rosu, \"Efficient monitoring of parametric context-free patterns\", <em>Proceedings of the 23rd IEEE/ACM International Conference on Automated Software Engineering(ASE \u201808)</em>, 2008.", "title": "Efficient monitoring of parametric context-free patterns", "context": [{"sec": "sec8", "text": " ASM [7] provides a useful framework to instrument the bytecode, which is widely used in run-time verification including monitoring-oriented programming [21], [22] and predictive trace analysis [23]\u2013[25].", "part": "1"}], "links": {"documentLink": "/document/4639318", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4639318", "abstract": "Recent developments in runtime verification and monitoring show that parametric regular and temporal logic specifications can be efficiently monitored against large programs. However, these logics reduce to ordinary finite automata, limiting their expressivity. For example, neither can specify structured properties that refer to the call stack of the program. While context-free grammars (CFGs) are expressive and well-understood, existing techniques for monitoring CFGs generate large runtime over...", "pdfSize": "198KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+monitoring+of+parametric+context-free+patterns&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "F. Chen, T. F. Serbanuta, G. Rosu, \"jPredictor: a predictive runtime analysis tool for Java\", <em>ICSE \u201808: Proceedings of the 30th International Conference on Software Engineering</em>, 2008.", "title": "jPredictor: a predictive runtime analysis tool for Java", "context": [{"sec": "sec8", "text": " ASM [7] provides a useful framework to instrument the bytecode, which is widely used in run-time verification including monitoring-oriented programming [21], [22] and predictive trace analysis [23]\u2013[25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1368088.1368119", "abstract": "jPredictor is a tool for detecting concurrency errors in Java programs. The Java program is instrumented to emit property-relevant events at runtime and then executed. The resulting execution trace is collected and analyzed by Predictor, which extracts a causality relation sliced using static analysis and refined with lock-atomicity information. The resulting abstract model, a hybrid of a partial order and atomic blocks, is then exhaustively analyzed against the property and errors with counter-...", "pdfSize": "214KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=jPredictor%3A+a+predictive+runtime+analysis+tool+for+Java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "T. F. Serbanuta, F. Chen, G. Rosu, \"Maximal causal models for sequentially consistent systems\", <em>Runtime Verification (RV\u201812)</em>, 2012.", "title": "Maximal causal models for sequentially consistent systems", "context": [{"sec": "sec8", "text": " ASM [7] provides a useful framework to instrument the bytecode, which is widely used in run-time verification including monitoring-oriented programming [21], [22] and predictive trace analysis [23]\u2013[24][25].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Maximal+causal+models+for+sequentially+consistent+systems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "J. Huang, P. O. Meredith, G. Rosu, \"Maximal sound predictive race detection with control flow abstraction\", <em>ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 337-348, 2014.", "title": "Maximal sound predictive race detection with control flow abstraction", "context": [{"sec": "sec8", "text": " ASM [7] provides a useful framework to instrument the bytecode, which is widely used in run-time verification including monitoring-oriented programming [21], [22] and predictive trace analysis [23]\u2013[25].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2594291.2594315", "abstract": "Despite the numerous static and dynamic program analysis techniques in the literature, data races remain one of the most common bugs in modern concurrent software. Further, the techniques that do exist either have limited detection capability or are unsound, meaning that they report false positives. We present a sound race detection technique that achieves a provably higher detection capability than existing sound techniques. A key insight of our technique is the inclusion of abstracted control ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Maximal+sound+predictive+race+detection+with+control+flow+abstraction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "J. Huang, \"Stateless model checking concurrent programs with maximal causality reduction\", <em>Proceedings of the 36th ACM SIGPLAN Conference on Programming Language Design and Implementation ser. PLDI</em>, 2015.", "title": "Stateless model checking concurrent programs with maximal causality reduction", "context": [{"sec": "sec8", "text": " [26]\u2013[28] invented a model checker with maximal causality reduction for Java programs on top of ASM.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2737924.2737975", "abstract": "We present maximal causality reduction (MCR), a new technique for stateless model checking. MCR systematically explores the state-space of concurrent programs with a provably minimal number of executions. Each execution corresponds to a distinct maximal causal model extracted from a given execution trace, which captures the largest possible set of causally equivalent executions. Moreover, MCR is embarrassingly parallel by shifting the runtime exploration cost to offline analysis. We have designe...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Stateless+model+checking+concurrent+programs+with+maximal+causality+reduction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "S. Huang, J. Huang, \"Maximal causality reduction for tso and pso\", <em>Proceedings of the 2016 ACM SIGPLAN International Conference on Object-Oriented Programming Systems Languages and Applications ser. OOPSLA</em>, 2016.", "title": "Maximal causality reduction for tso and pso", "context": [{"sec": "sec8", "text": " Huang et al. [26]\u2013[27][28] invented a model checker with maximal causality reduction for Java programs on top of ASM.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2983990.2984025", "abstract": "Verifying concurrent programs is challenging due to the exponentially large thread interleaving space. The problem is exacerbated by relaxed memory models such as Total Store Order (TSO) and Partial Store Order (PSO) which further explode the interleaving space by reordering instructions. A recent advance, Maximal Causality Reduction (MCR), has shown great promise to improve verification effectiveness by maximally reducing redundant explorations. However, the original MCR only works for the Sequ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Maximal+causality+reduction+for+tso+and+pso&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "S. Huang, J. Huang, \"Speeding Up Maximal Causality Reduction with Static Dependency Analysis\", <em>31st European Conference on Object-Oriented Programming (ECOOP 2017)</em>, 2017.", "title": "Speeding Up Maximal Causality Reduction with Static Dependency Analysis", "context": [{"sec": "sec8", "text": " Huang et al. [26]\u2013[28] invented a model checker with maximal causality reduction for Java programs on top of ASM.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Speeding+Up+Maximal+Causality+Reduction+with+Static+Dependency+Analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8811920", "articleId": "8811920", "startPage": "889", "endPage": "899", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 98}}
{"title": "StoryDroid: Automated Generation of Storyboard for Android Apps", "authors": [{"name": "Sen Chen", "affiliation": "East China Normal University, China", "firstName": "Sen", "lastName": "Chen", "id": "37086105481"}, {"name": "Lingling Fan", "affiliation": "East China Normal University, China", "firstName": "Lingling", "lastName": "Fan", "id": "37086804401"}, {"name": "Chunyang Chen", "affiliation": "Monash University, Australia", "firstName": "Chunyang", "lastName": "Chen", "id": "37086953368"}, {"name": "Ting Su", "affiliation": "Nanyang Technological University, Singapore", "firstName": "Ting", "lastName": "Su", "id": "37085383442"}, {"name": "Wenhe Li", "affiliation": "New York University Shanghai, China", "firstName": "Wenhe", "lastName": "Li", "id": "37086949579"}, {"name": "Yang Liu", "affiliation": "Nanyang Technological University, Singapore", "firstName": "Yang", "lastName": "Liu", "id": "37085480954"}, {"name": "Lihua Xu", "affiliation": "New York University Shanghai, China", "firstName": "Lihua", "lastName": "Xu", "id": "37086102306"}], "abstract": "Mobile apps are now ubiquitous. Before developing a new app, the development team usually endeavors painstaking efforts to review many existing apps with similar purposes. The review process is crucial in the sense that it reduces market risks and provides inspiration for app development. However, manual exploration of hundreds of existing apps by different roles (e.g., product manager, UI/UX designer, developer) in a development team can be ineffective. For example, it is difficult to completely explore all the functionalities of the app in a short period of time. Inspired by the conception of storyboard in movie production, we propose a system, StoryDroid, to automatically generate the storyboard for Android apps, and assist different roles to review apps efficiently. Specifically, StoryDroid extracts the activity transition graph and leverages static analysis techniques to render UI pages to visualize the storyboard with the rendered pages. The mapping relations between UI pages and the corresponding implementation code (e.g., layout code, activity code, and method hierarchy) are also provided to users. Our comprehensive experiments unveil that StoryDroid is effective and indeed useful to assist app development. The outputs of StoryDroid enable several potential applications, such as the recommendation of UI design and layout code.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Layout", "Google", "User interfaces", "Semantics", "Motion pictures", "Production", "Visualization"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["Android (operating system)", "graphical user interfaces", "mobile computing", "program diagnostics"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["storyboard", "Android apps", "mobile apps", "StoryDroid", "activity transition graph", "UI pages", "automated generation", "static analysis techniques"]}, {"type": "Author Keywords ", "kwd": ["Android app", "Storyboard", "Competitive analysis", "App review"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00070", "ref": [{"order": "1", "text": "<em>How to analyze APK and understand it</em>, 2013,  [online]  Available: https://reverseengineering.stackexchange.com/questions/2703/how-do-i-analyze-a-apk-file-and-understand-its-working.", "title": "How to analyze APK and understand it", "context": [{"sec": "sec9", "text": " Android reverse engineering is usually used to understand and analyze apps [1].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+analyze+APK+and+understand+it&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Crawl and download apps from Google Play</em>, 2014,  [online]  Available: https://github.com/dflower/google-play-crawler.", "title": "Crawl and download apps from Google Play", "context": [{"sec": "sec2", "text": " She then inputs all of the VRLs of these apps into Storydroid which automatically download all of these apps with Google Play API [2].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Crawl+and+download+apps+from+Google+Play&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "<em>Mean Absolute Error and Mean Squared Error</em>, 2016,  [online]  Available: https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bdeI3d.", "title": "Mean Absolute Error and Mean Squared Error", "context": [{"sec": "sec6b2", "text": "As for the similarity of the rendered images compared with the ones obtained by Stoat, we use two widely used image similarity metrics [3] (i.e., mean absolute error (MAE) and mean squared error (MSE)) to measure the similarity pixel by pixel.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mean+Absolute+Error+and+Mean+Squared+Error&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "<em>4 steps to develop your app idea</em>, 2018,  [online]  Available: http://apptology.com/blog/tag/mobile-app-storyboard/.", "title": "4 steps to develop your app idea", "context": [{"sec": "sec2", "text": "We detail the typical app review process [4], [22], [34], [54], [55] with our Storydroid for Android apps in term of different roles in the development team.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=4+steps+to+develop+your+app+idea&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "<em>Android Adapter</em>, 2018,  [online]  Available: https://developer.android.com/reference/android/widget/Adapter.", "title": "Android Adapter", "context": [{"sec": "sec3c", "text": "Adapter [5] is a bridge between the AdapterView and the underlying data for the view.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Adapter&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "<em>Android documentation: Activity</em>, 2018,  [online]  Available: https://developer.android.com/reference/android/app/Activity.", "title": "Android documentation: Activity", "context": [{"sec": "sec1", "text": " Specifically, we use activities (i.e., UI screens) to characterize the \u201cscenes\u201d in the storyboard, since activities represent the intuitive impression of the apps in a full-screen window and are the most frequently used components for user interactions [6].", "part": "1"}, {"sec": "sec3a", "text": " Specifically, Activity [6] and Fragment [7] render the user interface and are the visible parts of Android apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+documentation%3A+Activity&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "<em>Android Fragment</em>, 2018,  [online]  Available: https://developer.android.com/reference/android/app/Fragment.", "title": "Android Fragment", "context": [{"sec": "sec1", "text": "To overcome these challenges, we propose a system, STO-RYDROID, to automatically generate the storyboard of apps in three main phases: (1) Activity transition extraction, which extracts ATG from the apks, especially the transitions in fragments [7] (components of activities) and inner classes [19], making ATG more complete. (2) UI page rendering, which first extracts the dynamic components (if any) for each UI page and embeds them into the corresponding static layout.", "part": "1"}, {"sec": "sec3a", "text": " Specifically, Activity [6] and Fragment [7] render the user interface and are the visible parts of Android apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Fragment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "<em>Android naming conventions</em>, 2018,  [online]  Available: https://medium.com/@mikelimantara/overview-of-android-project-structure-and-naming-conventions-b08f6d0b7291.", "title": "Android naming conventions", "context": [{"sec": "sec4c", "text": "In Android app development, activity names of apps are recommended to contain semantic meanings and end with \u201cActivity\u201d [8], thus we assume that the defined activity names by developers have basic semantic meanings of the corresponding functionality.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+naming+conventions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "<em>Android Packer Tehchniques</em>, 2018,  [online]  Available: http://www.ninoishere.com/android-packerl/.", "title": "Android Packer Tehchniques", "context": [{"sec": "sec6b1", "text": " That situation is more severe in closed source apps due to packing [9] and obfuscation.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Android+Packer+Tehchniques&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "<em>Bankdroid</em>, 2018,  [online]  Available: https://play.google.com/store/apps/detailsid=com.liato.bankdroid.", "title": "Bankdroid", "context": [{"sec": "sec8b", "text": " For example, BankDroid [10] is a banking client for the Swedish banks.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bankdroid&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "<em>Competitor analysis before launching a mobile app startup</em>, 2018,  [online]  Available: https://growthbug.com/competitor-analysis-before-launching-a-mobile-app-startup-f2f6aI9f21b7.", "title": "Competitor analysis before launching a mobile app startup", "context": [{"sec": "sec1", "text": "Therefore, for app developers and companies, it is crucial to perform extensive competitive analysis over existing apps with similar purposes [11], [34], [54], [55].", "part": "1"}, {"sec": "sec1", "text": "Typically, to achieve the aforementioned analysis, a freelance developer or a product manager (PM) in a tech company has to download the apps from markets, install them on mobile devices, and use them back-and-forth to identify what she is interested in [11], [34], [54], [55].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Competitor+analysis+before+launching+a+mobile+app+startup&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "<em>Csipsimple</em>, 2018,  [online]  Available: https://github.com/tqcenglish/CSipSimple.", "title": "Csipsimple", "context": [{"sec": "sec6b1", "text": " However, IC3 fails to extract the activity transition. (2) CSipSimple [12] is an online voice communication app, in which the system callback method (SipService.adjustVolume ()) starts a new activity, but IC3 fails to identify the transition.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Csipsimple&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "<em>D3.js</em>, 2018,  [online]  Available: https://d3js.org/.", "title": "D3.js", "context": [{"sec": "sec5", "text": " We use data-driven document (D3) [13] to visualize STORYDROID'S results, which provides a visualized technique based on data in HTML, JavaScript, and CSS.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=D3.js&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "<em>Dex to Java decompiler</em>, 2018,  [online]  Available: https://github.com/skylot/jadx.", "title": "Dex to Java decompiler", "context": [{"sec": "sec5", "text": " STORYDROID is built on top of several off-the-shelf tools: IC3, JADX [14], and Soot [28].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Dex+to+Java+decompiler&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "<em>F-droid Market</em>, 2018,  [online]  Available: https://f-droid.org/en/packagesl.", "title": "F-droid Market", "context": [{"sec": "sec4c", "text": " To verify this assumption, we randomly download 1,000 apps from F-Droid [15], extract all the activity names from each app, and finally get 6,767 activity names.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=F-droid+Market&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "<em>Getting better at design is easy just copy people!</em>, 2018,  [online]  Available: https://medium.com/ux-power-tools/getting-better-at-design-is-easy-just-copy-people-f19ba3be8a62.", "title": "Getting better at design is easy, just copy people!", "context": [{"sec": "sec2", "text": " Then, Alice can develop the UI and user interaction of her app inspired by others' apps [16], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Getting+better+at+design+is+easy%2C+just+copy+people%21&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "<em>Google Monkey for Testing</em>, 2018,  [online]  Available: https://developer.android.com/studio/test/monkey.", "title": "Google Monkey for Testing", "context": [{"sec": "sec1", "text": " Second, to identify all UI pages, a pure static approach may miss parts of UIs that are dynamically rendered (see Section III), whereas a pure dynamic approach [17], [40], [41], [66], [67] may not be able to reach all pages in the app, especially those requiring login.", "part": "1"}, {"sec": "sec6a", "text": " We also use these 100 apps to evaluate the activity coverage of STORYDROID and the state-of-the-art dynamic testing tool, Stoat [67], which has been demonstrated to be more effective on app exploration than other tools such as Monkey [17] and Sapienz [58].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Google+Monkey+for+Testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "<em>How Much Does an App Cost</em>, 2018,  [online]  Available: https://savvyapps.com/blog/how-much-does-app-cost-massive-review-pricing-budget-considerations.", "title": "How Much Does an App Cost", "context": [{"sec": "sec1", "text": " Moreover, researching similar apps also helps developers gain more insight on the actual implementation, given that delivering commercial apps can be time-consuming and expensive [18].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+Much+Does+an+App+Cost&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "<em>Java Inner Class</em>, 2018,  [online]  Available: https://www.tutorialspoint.com/java/java_innerclasses.htm.", "title": "Java Inner Class", "context": [{"sec": "sec1", "text": "To overcome these challenges, we propose a system, STO-RYDROID, to automatically generate the storyboard of apps in three main phases: (1) Activity transition extraction, which extracts ATG from the apks, especially the transitions in fragments [7] (components of activities) and inner classes [19], making ATG more complete. (2) UI page rendering, which first extracts the dynamic components (if any) for each UI page and embeds them into the corresponding static layout.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Java+Inner+Class&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "<em>Kiwix</em>, 2018,  [online]  Available: https://play.google.com/store/apps/details?id=org.kiwix.kiwixmobile.", "title": "Kiwix", "context": [{"sec": "sec8b", "text": " For example, Kiwix [20] lets users read Wikipedia without Internet connections.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Kiwix&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "<em>Mann-Whitney U test</em>, 2018,  [online]  Available: http://www.statisticssolutions.com/mann-whitney-u-test/.", "title": "Mann-Whitney U test", "context": [{"sec": "sec7", "text": " To understand the significance of the differences between without STORYDROID and with STORYDROID, we carry out the Mann-Whitney U test [21], which is designed for small samples.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mann-Whitney+U+test&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>Mobile app development process</em>, 2018,  [online]  Available: https://thebhwgroup.com/blog/mobile-app-development-process.", "title": "Mobile app development process", "context": [{"sec": "sec2", "text": "We detail the typical app review process [4], [22], [34], [54], [55] with our Storydroid for Android apps in term of different roles in the development team.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mobile+app+development+process&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>Mobile Internet use passes desktop for the first time</em>, 2018,  [online]  Available: https://techcrunch.com/2016/11/01/mobile-internet-use-passes-desktop-for-the-first-time-study-finds/.", "title": "Mobile Internet use passes desktop for the first time", "context": [{"sec": "sec1", "text": "Mobile apps now have become the most popular way of accessing the Internet as well as performing daily tasks, e.g., reading, shopping, banking and chatting [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mobile+Internet+use+passes+desktop+for+the+first+time&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "<em>Number of apps available in leading app stores as of 1st quarter</em>, 2018,  [online]  Available: https://www.statista.com/statistics/276623/number-of-apps-available-in-leading-app-stores/.", "title": "Number of apps available in leading app stores as of 1st quarter", "context": [{"sec": "sec1", "text": " Different from traditional desktop applications, mobile apps are typically developed under the time-to-market pressure and facing fierce competitions - over 3.8 million Android apps and 2 million iPhone apps are striving to gain users on Google Play and Apple App Store, the two primary mobile app markets [24].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Number+of+apps+available+in+leading+app+stores+as+of+1st+quarter&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "<em>Overview of StoryDroid</em>, 2018,  [online]  Available: https://sites.google.com/view/storydroid/.", "title": "Overview of StoryDroid", "context": [{"sec": "sec5", "text": " The visualization [25] contains 4 parts: (1) ATG with activity names and corresponding UI pages; (2) The layout code of each UI page; (3) The functional code of each activity; and (4) the method call relations within each activity.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Overview+of+StoryDroid&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "<em>Printlisten</em>, 2018,  [online]  Available: https://f-droid.org/en/packages/com.einmalfel.printlisten/.", "title": "Printlisten", "context": [{"sec": "sec6b1", "text": " For example, (1) PrintListen [26] is a printcast player, and there exists an activity transition in the callback method (DownloadReceiver.onReceive()), which is called when the BroadcastReceiver is receiving an Intent broadcast.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Printlisten&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>Reverse engineering of Android applications</em>, 2018,  [online]  Available: https://github.com/androguard/androguard.", "title": "Reverse engineering of Android applications", "context": [{"sec": "sec9", "text": "The process of reverse engineering of Android apps is that researchers rely on the state-of-the-art tools (e.g., Apktool [29], Andro-guard [27], Dex2jar [30], Soot [28]) for decompiling an APK to intermediate language (e.g., smali, jimple) or Java code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reverse+engineering+of+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "<em>Soot: A Java optimization framework</em>, 2018,  [online]  Available: https://github.com/Sable/soot.", "title": "Soot: A Java optimization framework", "context": [{"sec": "sec5", "text": " STORYDROID is built on top of several off-the-shelf tools: IC3, JADX [14], and Soot [28].", "part": "1"}, {"sec": "sec9", "text": "The process of reverse engineering of Android apps is that researchers rely on the state-of-the-art tools (e.g., Apktool [29], Andro-guard [27], Dex2jar [30], Soot [28]) for decompiling an APK to intermediate language (e.g., smali, jimple) or Java code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Soot%3A+A+Java+optimization+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "<em>A tool for reverse engineering Android apk files</em>, 2018,  [online]  Available: https://ibotpeaches.github.io/Apktool/.", "title": "A tool for reverse engineering Android apk files", "context": [{"sec": "sec9", "text": "The process of reverse engineering of Android apps is that researchers rely on the state-of-the-art tools (e.g., Apktool [29], Andro-guard [27], Dex2jar [30], Soot [28]) for decompiling an APK to intermediate language (e.g., smali, jimple) or Java code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+tool+for+reverse+engineering+Android+apk+files&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "<em>Tools to work with Android. dex and Java. class files</em>, 2018,  [online]  Available: https://github.com/pxb1988/dex2jar.", "title": "Tools to work with Android. dex and Java. class files", "context": [{"sec": "sec9", "text": "The process of reverse engineering of Android apps is that researchers rely on the state-of-the-art tools (e.g., Apktool [29], Andro-guard [27], Dex2jar [30], Soot [28]) for decompiling an APK to intermediate language (e.g., smali, jimple) or Java code.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Tools+to+work+with+Android.+dex+and+Java.+class+files&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "<em>Twitter</em>, 2018,  [online]  Available: https://play.google.com/store/apps/details?id=com.twitter.android.", "title": "Twitter", "context": [{"sec": "sec3b", "text": " Fig. 2 shows the login UI page of a famous social app, Twitter [31], where the component (e.g., TextView) can be implemented in three different layout types.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Twitter&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "<em>Uninvited Redesigns</em>, 2018,  [online]  Available: https://uninvitedredesigns.com/.", "title": "Uninvited Redesigns", "context": [{"sec": "sec2", "text": " Then, Alice can develop the UI and user interaction of her app inspired by others' apps [16], [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Uninvited+Redesigns&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "<em>Vespucci</em>, 2018,  [online]  Available: https://play.google.com/store/apps/details?id=de.blau.android.", "title": "Vespucci", "context": [{"sec": "sec4a", "text": " Fig. 4(a) is the sub ATG of Vespucci [33], a map editor.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Vespucci&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "J. J. Arbon, App quality: Secrets for agile app teams, Jason Arbon, 2014.", "title": "App quality: Secrets for agile app teams", "context": [{"sec": "sec1", "text": "Therefore, for app developers and companies, it is crucial to perform extensive competitive analysis over existing apps with similar purposes [11], [34], [54], [55].", "part": "1"}, {"sec": "sec1", "text": "Typically, to achieve the aforementioned analysis, a freelance developer or a product manager (PM) in a tech company has to download the apps from markets, install them on mobile devices, and use them back-and-forth to identify what she is interested in [11], [34], [54], [55].", "part": "1"}, {"sec": "sec2", "text": "We detail the typical app review process [4], [22], [34], [54], [55] with our Storydroid for Android apps in term of different roles in the development team.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=App+quality%3A+Secrets+for+agile+app+teams&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "S. Arzt, S. Rasthofer, C. Fritz, E. Bodden, A. Bartel, J. Klein, Y. Le Traon, D. Octeau, P. McDaniel, \"Flowdroid: Precise context flow field object-sensitive and lifecycle-aware taint analysis for Android apps\", <em>Acm Sigplan Notices</em>, vol. 49, no. 6, pp. 259-269, 2014.", "title": "Flowdroid: Precise context, flow, field, object-sensitive and lifecycle-aware taint analysis for Android apps", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}, {"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[47], [52], [68].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Flowdroid%3A+Precise+context%2C+flow%2C+field%2C+object-sensitive+and+lifecycle-aware+taint+analysis+for+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "T. Azim, I. Neamtiu, \"Targeted and depth-first exploration for systematic testing of Android apps\", <em>Acm Sigplan Notices</em>, vol. 48, no. 10, pp. 641-660, 2013.", "title": "Targeted and depth-first exploration for systematic testing of Android apps", "context": [{"sec": "sec1", "text": " Additionally, commercial apps can be too complex to manually uncover all functionalities in a reasonable time [36].", "part": "1"}, {"sec": "sec1", "text": " First, ATGs are usually incomplete due to the limitation of static analysis tools [36], [62].", "part": "1"}, {"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}, {"sec": "sec9", "text": " A3E provides two strategies, targeted and depth-first exploration, for systematic testing of Android apps [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Targeted+and+depth-first+exploration+for+systematic+testing+of+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "F. Behrang, S. P. Reiss, A. Orso, \"Guifetch: Supporting app design and development through GUI search\", <em>Proceedings of the 5th International Conference on Mobile Software Engineering and Systems</em>, pp. 236-246, 2018.", "title": "Guifetch: Supporting app design and development through GUI search", "context": [{"sec": "sec9", "text": " Retrieval-based methods [37], [64] are also used to develop the user interfaces.", "part": "1"}, {"sec": "sec9", "text": "GUIFECTCH [37] customizes Reiss's method [64] into Android app UI search by considering the transitions between UIs.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3197231.3197244", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guifetch%3A+Supporting+app+design+and+development+through+GUI+search&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "T. Beltramelli, \"pix2code: Generating code from a graphical user interface screenshot\", <em>Proceedings of the ACM SIGCHI Symposium on Engineering Interactive Computing Systems</em>, pp. 3, 2018.", "title": "pix2code: Generating code from a graphical user interface screenshot", "context": [{"sec": "sec9", "text": " More powerful deep-learning based algorithms [38], [40], [59] are further proposed to leverage the existing big data of Android apps.", "part": "1"}, {"sec": "sec9", "text": " In addition, the UI code generated in prior work [38], [40], [59], [61] is all static layout, which conflicts with our observation in Section III that developers often write Java code to dynamically render the UI.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3220134.3220135", "abstract": "Transforming a graphical user interface screenshot created by a designer into computer code is a typical task conducted by a developer in order to build customized software, websites, and mobile applications. In this paper, we show that deep learning methods can be leveraged to train a model end-to-end to automatically reverse engineer user interfaces and generate code from a single input image with over 77% of accuracy for three different platforms (i.e. iOS, Android and web-based technologies)...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=pix2code%3A+Generating+code+from+a+graphical+user+interface+screenshot&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "M. B\u00f6hmer, B. Hecht, J. Sch\u00f6ning, A. Kr\u00fcger, G. Bauer, \"Falling asleep with Angry Birds Facebook and Kindle: a large scale study on mobile application usage\", <em>Proceedings of the 13th international conference on Human computer interaction with mobile devices and services</em>, pp. 47-56, 2011.", "title": "Falling asleep with Angry Birds, Facebook and Kindle: a large scale study on mobile application usage", "context": [{"sec": "sec7", "text": " We told each participant to complete two tasks with the given apps: (1) manually explore as many functionalities of the apps as possible in 10 minutes, which is far longer than the typical average app session (71.56 seconds) [39], and understand the app functionalities with STORYDROID; (2) identify the corresponding layout code for the given 2 UI pages in 10 minutes.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2037373.2037383", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Falling+asleep+with+Angry+Birds%2C+Facebook+and+Kindle%3A+a+large+scale+study+on+mobile+application+usage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "C. Chen, T. Su, G. Meng, Z. Xing, Y. Liu, \"From UI design image to GUI skeleton: A neural machine translator to bootstrap mobile GUI implementation\", <em>Proceedings of the 40th International Conference on Software Engineering</em>, pp. 665-676, 2018.", "title": "From UI design image to GUI skeleton: A neural machine translator to bootstrap mobile GUI implementation", "context": [{"sec": "sec1", "text": " Second, to identify all UI pages, a pure static approach may miss parts of UIs that are dynamically rendered (see Section III), whereas a pure dynamic approach [17], [40], [41], [66], [67] may not be able to reach all pages in the app, especially those requiring login.", "part": "1"}, {"sec": "sec6a", "text": "For RQ2, we evaluate the similarity of our statically rendered UI pages with the real UI which are dynamically rendered UI by Stoat based on the 100 apps [40].", "part": "1"}, {"sec": "sec9", "text": " More powerful deep-learning based algorithms [38], [40], [59] are further proposed to leverage the existing big data of Android apps.", "part": "1"}, {"sec": "sec9", "text": " In addition, the UI code generated in prior work [38], [40], [59], [61] is all static layout, which conflicts with our observation in Section III that developers often write Java code to dynamically render the UI.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180240", "abstract": "A GUI skeleton is the starting point for implementing a UI design image. To obtain a GUI skeleton from a UI design image, developers have to visually understand UI elements and their spatial layout in the image, and then translate this understanding into proper GUI components and their compositions. Automating this visual understanding and translation would be beneficial for bootstraping mobile GUI implementation, but it is a challenging task due to the diversity of UI designs and the complexity...", "pdfSize": "1228KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=From+UI+design+image+to+GUI+skeleton%3A+A+neural+machine+translator+to+bootstrap+mobile+GUI+implementation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "S. Chen, L. Fan, T. Su, L. Ma, Y. Liu, L. Xu, \"Automated cross-platform GUI code generation for mobile apps\", <em>Proceedings of the 26th IEEE International Conference on Software Analysis Evolution and Reengineering SANER</em>, 2019.", "title": "Automated cross-platform GUI code generation for mobile apps", "context": [{"sec": "sec1", "text": " Second, to identify all UI pages, a pure static approach may miss parts of UIs that are dynamically rendered (see Section III), whereas a pure dynamic approach [17], [40], [41], [66], [67] may not be able to reach all pages in the app, especially those requiring login.", "part": "1"}], "links": {"documentLink": "/document/8672718", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8672718", "abstract": "Android and iOS are the two dominant platforms for building mobile apps. To provide uniform and smooth user experience, app companies typically employ two teams of programmers to develop UIs (and underlying functionalities) for these two platforms, respectively. However, this development practice is costly for both development and maintenance. To reduce the cost, we take the first step in this direction by proposing an automated cross-platform GUI code generation framework. It can transfer the G...", "pdfSize": "2031KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+cross-platform+GUI+code+generation+for+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "S. Chen, G. Meng, T. Su, L. Fan, Y. Xue, Y. Liu, L. Xu, M. Xue, B. Li, S. Hao, AUSERA: Large-scale automated security risk assessment of global mobile banking apps, 2018.", "title": "AUSERA: Large-scale automated security risk assessment of global mobile banking apps", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=AUSERA%3A+Large-scale+automated+security+risk+assessment+of+global+mobile+banking+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "S. Chen, T. Su, L. Fan, G. Meng, M. Xue, Y. Liu, L. Xu, \"Are mobile banking apps secure? What can be improved?\", <em>Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, pp. 797-802, 2018.", "title": "Are mobile banking apps secure? What can be improved?", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3275523", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+mobile+banking+apps+secure%3F+What+can+be+improved%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "S. Chen, M. Xue, L. Fan, S. Hao, L. Xu, H. Zhu, B. Li, \"Automated poisoning attacks and defenses in malware detection systems: An adversarial machine learning approach\", <em>computers & security</em>, vol. 73, pp. 326-344, 2018.", "title": "Automated poisoning attacks and defenses in malware detection systems: An adversarial machine learning approach", "context": [{"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[47], [52], [68].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/j.cose.2017.11.007", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+poisoning+attacks+and+defenses+in+malware+detection+systems%3A+An+adversarial+machine+learning+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "S. Chen, M. Xue, L. Fan, L. Ma, Y. Liu, L. Xu, \"How can we craft large-scale Android malware? An automated poisoning attack\", <em>Proceedings of the 26th IEEE International Conference on Software Analysis Evolution and Reengineering SANER</em>, 2019.", "title": "How can we craft large-scale Android malware? An automated poisoning attack", "context": [{"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[45][47], [52], [68].", "part": "1"}], "links": {"documentLink": "/document/8672691", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8672691", "abstract": "Android malware, is one of the most serious threats to mobile security. Today, machine learning-based approach is one of the most promising approaches in detecting Android malware. However, our previous experiments show that sophisticated attackers can craft large-scale Android malware to pollute training data and pose an automated poisoning attack on machine learning-based malware detection systems (e.g., Drebin, Droidapiminer, Stormdroid and Mamadroid), and eventually mislead the detection too...", "pdfSize": "221KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+can+we+craft+large-scale+Android+malware%3F+An+automated+poisoning+attack&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "S. Chen, M. Xue, Z. Tang, L. Xu, H. Zhu, \"Stormdroid: A streaminglized machine learning-based system for detecting Android malware\", <em>Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security ASI-ACCS</em>, pp. 377-388, 2016.", "title": "Stormdroid: A streaminglized machine learning-based system for detecting Android malware", "context": [{"sec": "sec9", "text": " It also can be used to extract features for Android malware detection [46].", "part": "1"}, {"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[46][47], [52], [68].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Stormdroid%3A+A+streaminglized+machine+learning-based+system+for+detecting+Android+malware&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "S. Chen, M. Xue, L. Xu, \"Towards adversarial detection of mobile malware: poster\", <em>Proceedings of the 22nd Annual International Conference on Mobile Computing and Networking</em>, pp. 415-416, 2016.", "title": "Towards adversarial detection of mobile malware: poster", "context": [{"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[47], [52], [68].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2973750.2985246", "abstract": "Android malware has been found on various third-party online markets, which poses drastic threats to mobile users in terms of security and privacy. Machine learning is one of the promising approaches to discriminate the malicious applications from the benign ones. Despite its higher malware detection capability, a significant challenge remains: in adversarial environment, an attacker can adapt by maximally sabotaging classifiers by polluting training data. This paper proposes KuafuDet, a two-pha...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+adversarial+detection+of+mobile+malware%3A+poster&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "B. Dit, L. Guerrouj, D. Poshyvanyk, G. Antoniol, \"Can better identifier splitting techniques help feature location?\", <em>2011 19th IEEE International Conference on Program Comprehension</em>, pp. 11-20, 2011.", "title": "Can better identifier splitting techniques help feature location?", "context": [{"sec": "sec4c", "text": " Specifically, we rank the activity names based on their frequency, split the camel-case layout name into multiple single words with the regular expression [48], filter out the general words such as \u201cactivity,\u201d \u201clayout,\u201d and compare it with those in the database by keyword matching.", "part": "1"}], "links": {"documentLink": "/document/5970159", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5970159", "abstract": "The paper presents an exploratory study of two feature location techniques utilizing three strategies for splitting identifiers: Camel Case, Samurai and manual splitting of identifiers. The main research question that we ask in this study is if we had a perfect technique for splitting identifiers, would it still help improve accuracy of feature location techniques applied in different scenarios and settings? In order to answer this research question we investigate two feature location techniques...", "pdfSize": "341KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Can+better+identifier+splitting+techniques+help+feature+location%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "S. Dong, M. Li, W. Diao, X. Liu, J. Liu, Z. Li, F. Xu, K. Chen, X. Wang, K. Zhang, Understanding Android obfuscation techniques: A large-scale investigation in the wild, 2018.", "title": "Understanding Android obfuscation techniques: A large-scale investigation in the wild", "context": [{"sec": "sec4c", "text": " However, Android obfuscation techniques are often used in Google Play apps to protect their security [49].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-030-01701-9_10", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Understanding+Android+obfuscation+techniques%3A+A+large-scale+investigation+in+the+wild&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "L. Fan, T. Su, S. Chen, G. Meng, Y. Liu, L. Xu, G. Pu, \"Efficiently manifesting asynchronous programming errors in Android apps\", <em>Proceedings of the 2018 33rd ACM/IEEE International Conference on Automated Software Engineering</em>, pp. 485-496, May 27 - June 03, 2018.", "title": "Efficiently manifesting asynchronous programming errors in Android apps", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3238147.3238170", "abstract": "Android, the #1 mobile app framework, enforces the single-GUI-thread model, in which a single UI thread manages GUI rendering and event dispatching. Due to this model, it is vital to avoid blocking the UI thread for responsiveness. One common practice is to offload long-running tasks into async threads. To achieve this, Android provides various async programming constructs, and leaves developers themselves to obey the rules implied by the model. However, as our study reveals, more than 25% apps ...", "pdfSize": "725KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficiently+manifesting+asynchronous+programming+errors+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "L. Fan, T. Su, S. Chen, G. Meng, Y. Liu, L. Xu, G. Pu, Z. Su, \"Large-scale analysis of framework-specific exceptions in Android apps\", <em>Proceedings of the 40th International Conference on Software Engineering ICSE 2018</em>, pp. 408-419, May 27 - June 03, 2018, 2018.", "title": "Large-scale analysis of framework-specific exceptions in Android apps", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180222", "abstract": "Mobile apps have become ubiquitous. For app developers, it is a key priority to ensure their apps&#39; correctness and reliability. However, many apps still suffer from occasional to frequent crashes, weakening their competitive edge. Large-scale, deep analyses of the characteristics of real-world app crashes can provide useful insights to guide developers, or help improve testing and analysis tools. However, such studies do not exist - this paper fills this gap. Over a four-month long effort, we ha...", "pdfSize": "1046KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Large-scale+analysis+of+framework-specific+exceptions+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "L. Fan, M. Xue, S. Chen, L. Xu, H. Zhu, \"Poster: Accuracy vs. time cost: Detecting Android malware through pareto ensemble pruning\", <em>Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security</em>, pp. 1748-1750, 2016.", "title": "Poster: Accuracy vs. time cost: Detecting Android malware through pareto ensemble pruning", "context": [{"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[47], [52], [68].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2976749.2989055", "abstract": "This paper proposes Begonia, a malware detection system through Pareto ensemble pruning. We convert the malware detection problem into the bi-objective Pareto optimization, aiming to trade off the classification accuracy and the size of classifiers as two objectives. We automatically generate several groups of base classifiers using SVM and generate solutions through bi-objective Pareto optimization. We then select the ensembles with highest accuracy of each group to form the final solutions, am...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Poster%3A+Accuracy+vs.+time+cost%3A+Detecting+Android+malware+through+pareto+ensemble+pruning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "C. Finch, P. Blake, The art of Walt Disney: From Mickey mouse to the magic kingdoms, Abrams, 1995.", "title": "The art of Walt Disney: From Mickey mouse to the magic kingdoms", "context": [{"sec": "sec1", "text": "Inspired by the conception of storyboard11\u201cStoryboard\u201d was developed at Walt Disney Productions, including a sequence of drawings typically with some directions and dialogues, representing the shots planned for a movie or television production. in movie industry [53], we intend to generate the storyboard of an app to visualize its key app behaviors.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+art+of+Walt+Disney%3A+From+Mickey+mouse+to+the+magic+kingdoms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "R. Fox, <em>Mobile app development: The effect of smartphones mobile applications and geolocation services on the tourist experience</em>, 2017.", "title": "Mobile app development: The effect of smartphones, mobile applications and geolocation services on the tourist experience", "context": [{"sec": "sec1", "text": "Therefore, for app developers and companies, it is crucial to perform extensive competitive analysis over existing apps with similar purposes [11], [34], [54], [55].", "part": "1"}, {"sec": "sec1", "text": "Typically, to achieve the aforementioned analysis, a freelance developer or a product manager (PM) in a tech company has to download the apps from markets, install them on mobile devices, and use them back-and-forth to identify what she is interested in [11], [34], [54], [55].", "part": "1"}, {"sec": "sec2", "text": "We detail the typical app review process [4], [22], [34], [54], [55] with our Storydroid for Android apps in term of different roles in the development team.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mobile+app+development%3A+The+effect+of+smartphones%2C+mobile+applications+and+geolocation+services+on+the+tourist+experience&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "L. Guo, R. Sharma, L. Yin, R. Lu, K. Rong, \"Automated competitor analysis using big data analytics: Evidence from the fitness mobile app business\", <em>Business Process Management Journal</em>, vol. 23, no. 3, pp. 735-762, 2017.", "title": "Automated competitor analysis using big data analytics: Evidence from the fitness mobile app business", "context": [{"sec": "sec1", "text": "Therefore, for app developers and companies, it is crucial to perform extensive competitive analysis over existing apps with similar purposes [11], [34], [54], [55].", "part": "1"}, {"sec": "sec1", "text": "Typically, to achieve the aforementioned analysis, a freelance developer or a product manager (PM) in a tech company has to download the apps from markets, install them on mobile devices, and use them back-and-forth to identify what she is interested in [11], [34], [54], [55].", "part": "1"}, {"sec": "sec2", "text": "We detail the typical app review process [4], [22], [34], [54], [55] with our Storydroid for Android apps in term of different roles in the development team.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1108/BPMJ-05-2015-0065", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+competitor+analysis+using+big+data+analytics%3A+Evidence+from+the+fitness+mobile+app+business&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "L. Li, A. Bartel, T. F. Bissyand\u00e9, J. Klein, Y. Le Traon, S. Arzt, S. Rasthofer, E. Bodden, D. Octeau, P. McDaniel, \"Iccta: Detectingz inter-component privacy leaks in Android apps\", <em>Proceedings of the 37th International Conference on Software Engineering-Volume 1</em>, pp. 280-291, 2015.", "title": "Iccta: Detectingz inter-component privacy leaks in Android apps", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}, {"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[47], [52], [68].", "part": "1"}], "links": {"documentLink": "/document/7194581", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194581", "abstract": "Shake Them All is a popular &#34;Wallpaper&#34; application exceeding millions of downloads on Google Play. At installation, this application is given permission to (1) access the Internet (for updating wallpapers) and (2) use the device microphone (to change background following noise changes). With these permissions, the application could silently record user conversations and upload them remotely. To give more confidence about how Shake Them All actually processes what it records, it is necessary to ...", "pdfSize": "724KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Iccta%3A+Detectingz+inter-component+privacy+leaks+in+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "L. Li, A. Bartel, J. Klein, Y. L. Traon, S. Arzt, S. Rasthofer, E. Bodden, D. Octeau, P. Mcdaniel, I know what leaked in your pocket: Uncovering privacy leaks on Android apps with static taint analysis, 2014.", "title": "I know what leaked in your pocket: Uncovering privacy leaks on Android apps with static taint analysis", "context": [{"sec": "sec6a", "text": " This is the only way to exactly know all the transitions even in fragments or inner classes, and this way is widely used in the literature [57].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=I+know+what+leaked+in+your+pocket%3A+Uncovering+privacy+leaks+on+Android+apps+with+static+taint+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "K. Mao, M. Harman, Y. Jia, \"Sapienz: Multi-objective automated testing for Android applications\", <em>Proceedings of the 25th International Symposium on Software Testing and Analysis</em>, pp. 94-105, 2016.", "title": "Sapienz: Multi-objective automated testing for Android applications", "context": [{"sec": "sec6a", "text": " We also use these 100 apps to evaluate the activity coverage of STORYDROID and the state-of-the-art dynamic testing tool, Stoat [67], which has been demonstrated to be more effective on app exploration than other tools such as Monkey [17] and Sapienz [58].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2931037.2931054", "abstract": "We introduce Sapienz, an approach to Android testing that uses multi-objective search-based testing to automatically explore and optimise test sequences, minimising length, while simultaneously maximising coverage and fault revelation. Sapienz combines random fuzzing, systematic and search-based exploration, exploiting seeding and multi-level instrumentation. Sapienz significantly outperforms (with large effect size) both the state-of-the-art technique Dynodroid and the widely-used tool, Android...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sapienz%3A+Multi-objective+automated+testing+for+Android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "K. Moran, C. Bernal-C\u00e1rdenas, M. Curcio, R. Bonett, D. Poshyvanyk, Machine learning-based prototyping of graphical user interfaces for mobile apps, 2018.", "title": "Machine learning-based prototyping of graphical user interfaces for mobile apps", "context": [{"sec": "sec9", "text": " More powerful deep-learning based algorithms [38], [40], [59] are further proposed to leverage the existing big data of Android apps.", "part": "1"}, {"sec": "sec9", "text": " In addition, the UI code generated in prior work [38], [40], [59], [61] is all static layout, which conflicts with our observation in Section III that developers often write Java code to dynamically render the UI.", "part": "1"}], "links": {"abstract": "It is common practice for developers of user-facing software to transform a mock-up of a graphical user interface (GUI) into code. This process takes place both at an application&#39;s inception and in an evolutionary context as GUI changes keep pace with evolving features. Unfortunately, this practice is challenging and time-consuming. In this paper, we present an approach that automates this process by enabling accurate prototyping of GUIs via three tasks: detection, classification, and assembly. ...", "pdfSize": "3996KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Machine+learning-based+prototyping+of+graphical+user+interfaces+for+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "K. Moran, B. Li, C. Bernal-C\u00e1rdenas, D. Jelf, D. Poshy-Vanyk, Automated reporting of GUI design violations for mobile apps, 2018.", "title": "Automated reporting of GUI design violations for mobile apps", "context": [{"sec": "sec9", "text": " Moran et al [60] check whether the UI implementation violates the original UI design by comparing the image similarity with computer vision techniques.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180246", "abstract": "The inception of a mobile app often takes form of a mock-up of the Graphical User Interface (GUI), represented as a static image delineating the proper layout and style of GUI widgets that satisfy requirements. Following this initial mock-up, the design artifacts are then handed off to developers whose goal is to accurately implement these GUIs and the desired functionality in code. Given the sizable abstraction gap between mock-ups and code, developers often introduce mistakes related to the GU...", "pdfSize": "487KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automated+reporting+of+GUI+design+violations+for+mobile+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "T. A. Nguyen, C. Csallner, \"Reverse engineering mobile application user interfaces with remaui (t)\", <em>Automated Software Engineering (ASE) 2015 30th IEEE/ACM International Conference</em>, pp. 248-259, 2015.", "title": "Reverse engineering mobile application user interfaces with remaui (t)", "context": [{"sec": "sec9", "text": " To assist UI implementation, Nguyen and Csallner [61] reverse-engineer the UI screenshots by image processing techniques.", "part": "1"}, {"sec": "sec9", "text": " In addition, the UI code generated in prior work [38], [40], [59], [61] is all static layout, which conflicts with our observation in Section III that developers often write Java code to dynamically render the UI.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reverse+engineering+mobile+application+user+interfaces+with+remaui+%28t%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "D. Octeau, D. Luchaup, M. Dering, S. Jha, P. McDaniel, \"Composite constant propagation: Application to Android inter-component communication analysis\", <em>Proceedings of the 37th International Conference on Software Engineering-Volume 1</em>, pp. 77-88, 2015.", "title": "Composite constant propagation: Application to Android inter-component communication analysis", "context": [{"sec": "sec1", "text": " First, ATGs are usually incomplete due to the limitation of static analysis tools [36], [62].", "part": "1"}, {"sec": "sec1", "text": " STORYDROID extracts nearly 2 times more activity transitions than the state-of-the-art ATG extraction tool (i.e., IC3 [62]) on both open-source apps and closed-source apps.", "part": "1"}, {"sec": "sec4", "text": " Fig. 5 shows the three main phases of Storydroid: (1) Transition Extraction, which enhances the ATG extraction ability of IC3 [62], especially for fragments and inner classes.", "part": "1"}, {"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}, {"sec": "sec9", "text": " ICC [62] significantly outperforms Epicc on the extraction ability of inter-component communication by utilizing the solver for MVC problems based on the proposed COAL lauguage.", "part": "1"}], "links": {"documentLink": "/document/7194563", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7194563", "abstract": "Many program analyses require statically inferring the possible values of composite types. However, current approaches either do not account for correlations between object fields or do so in an ad hoc manner. In this paper, we introduce the problem of composite constant propagation. We develop the first generic solver that infers all possible values of complex objects in an interprocedural, flow and context-sensitive manner, taking field correlations into account. Composite constant propagation...", "pdfSize": "918KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Composite+constant+propagation%3A+Application+to+Android+inter-component+communication+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "D. Octeau, P. McDaniel, S. Jha, A. Bartel, E. Bodden, J. Klein, Y. Le Traon, \"Effective inter-component communication mapping in Android with epicc: An essential step towards holistic security analysis\", <em>Effective Inter-Component Communication Mapping in Android with Epicc: An Essential Step Towards Holistic Security Analysis</em>, 2013.", "title": "Effective inter-component communication mapping in Android with epicc: An essential step towards holistic security analysis", "context": [{"sec": "sec9", "text": "Many static analysis techniques [35], [36], [42], [43], [50], [51], [56], [62], [63] have been proposed for Android apps.", "part": "1"}, {"sec": "sec9", "text": " Epicc is the first work to extract component communication [63], and it determines most Intent attributes to component matching.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Effective+inter-component+communication+mapping+in+Android+with+epicc%3A+An+essential+step+towards+holistic+security+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "S. P. Reiss, Y. Miao, Q. Xin, \"Seeking the user interface\", <em>Automated Software Engineering</em>, pp. 157-193, 2018.", "title": "Seeking the user interface", "context": [{"sec": "sec9", "text": " Retrieval-based methods [37], [64] are also used to develop the user interfaces.", "part": "1"}, {"sec": "sec9", "text": " Reiss [64] parses the sketch into structured queries to search related UIs of Java-based desktop software in the database.", "part": "1"}, {"sec": "sec9", "text": "GUIFECTCH [37] customizes Reiss's method [64] into Android app UI search by considering the transitions between UIs.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-017-0216-3", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Seeking+the+user+interface&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "G. Rothermel, R. H. Untch, C. Chu, M. J. Harrold, \"Prior-itizing test cases for regression testing\", <em>IEEE Transactions on software engineering</em>, vol. 27, no. 10, pp. 929-948, 2001.", "title": "Prior-itizing test cases for regression testing", "context": [{"sec": "sec8a", "text": "Reusing test cases is useful to improve the efficiency of regression testing for Android apps [65].", "part": "1"}], "links": {"documentLink": "/document/962562", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=962562", "abstract": "Test case prioritization techniques schedule test cases for execution in an order that attempts to increase their effectiveness at meeting some performance goal. Various goals are possible; one involves rate of fault detection, a measure of how quickly faults are detected within the testing process. An improved rate of fault detection during testing can provide faster feedback on the system under test and let software engineers begin correcting faults earlier than might otherwise be possible. On...", "pdfSize": "920KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Prior-itizing+test+cases+for+regression+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "T. Su, \"Fsmdroid: guided GUI testing of Android apps\", <em>IEEE/ACM International Conference on Software Engineering Companion (ICSE-C)</em>, pp. 689-691, 2016.", "title": "Fsmdroid: guided GUI testing of Android apps", "context": [{"sec": "sec1", "text": " Second, to identify all UI pages, a pure static approach may miss parts of UIs that are dynamically rendered (see Section III), whereas a pure dynamic approach [17], [40], [41], [66], [67] may not be able to reach all pages in the app, especially those requiring login.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fsmdroid%3A+guided+GUI+testing+of+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "T. Su, G. Meng, Y. Chen, K. Wu, W. Yang, Y. Yao, G. Pu, Y. Liu, Z. Su, \"Guided stochastic model-based GUI testing of Android apps\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, 2017.", "title": "Guided, stochastic model-based GUI testing of Android apps", "context": [{"sec": "sec1", "text": " Second, to identify all UI pages, a pure static approach may miss parts of UIs that are dynamically rendered (see Section III), whereas a pure dynamic approach [17], [40], [41], [66], [67] may not be able to reach all pages in the app, especially those requiring login.", "part": "1"}, {"sec": "sec6a", "text": " We also use these 100 apps to evaluate the activity coverage of STORYDROID and the state-of-the-art dynamic testing tool, Stoat [67], which has been demonstrated to be more effective on app exploration than other tools such as Monkey [17] and Sapienz [58].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106298", "abstract": "Mobile apps are ubiquitous, operate in complex environments and are developed under the time-to-market pressure. Ensuring their correctness and reliability thus becomes an important challenge. This paper introduces Stoat, a novel guided approach to perform stochastic model-based testing on Android apps. Stoat operates in two phases: (1) Given an app as input, it uses dynamic analysis enhanced by a weighted UI exploration strategy and static analysis to reverse engineer a stochastic model of the ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guided%2C+stochastic+model-based+GUI+testing+of+Android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "C. Tang, S. Chen, L. Fan, L. Xu, Y. Liu, Z. Tang, L. Dou, \"A large-scale empirical study on industrial fake apps\", <em>Proceedings of the 41th ACM/IEEE International Conference on Software Engineering ICSE</em>, 2019.", "title": "A large-scale empirical study on industrial fake apps", "context": [{"sec": "sec9", "text": " FLowDROID [35] and IccTA [56] extract call graphs based on Soot for data-flow analysis for detecting data leakage and malicious behaviors [44]\u2013[47], [52], [68].", "part": "1"}], "links": {"documentLink": "/document/8804455", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=8804455", "abstract": "While there have been various studies towards Android apps and their development, there is limited discussion of the broader class of apps that fall in the fake area. Fake apps and their development are distinct from official apps and belong to the mobile underground industry. Due to the lack of knowledge of the mobile underground industry, fake apps, their ecosystem and nature still remain in mystery. To fill the blank, we conduct the first systematic and comprehensive empirical study on a larg...", "pdfSize": "665KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+large-scale+empirical+study+on+industrial+fake+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "B. J. Winer, Statistical principles in experimental design, 1962.", "title": "Statistical principles in experimental design", "context": [{"sec": "sec7", "text": " To avoid potential bias, the order of app category, and the order of using STORYDROID or not using are rotated based on the Latin Square [69].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1037/11774-000", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Statistical+principles+in+experimental+design&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "K. Zhang, D. Shasha, \"Simple fast algorithms for the editing distance between trees and related problems\", <em>SIAM journal on computing</em>, vol. 18, no. 6, pp. 1245-1262, 1989.", "title": "Simple fast algorithms for the editing distance between trees and related problems", "context": [{"sec": "sec4c", "text": " Given the XML file (layout file) and XML name of the obfuscated activity, we infer its semantic name by the following three steps: (1) layout hierarchy extraction, which extracts the layout tree (T) from the XML file; (2) similarity comparison, which computes the similarity between \\$T\\$ and the trees in our database by leveraging the tree edit distance (TED) algorithm [70], which is defined as the minimum-cost sequence of node edit operations that transform one tree into another.", "part": "1"}, {"sec": "sec6a", "text": " We collect the corresponding layout files from source files, and further utilize our method based on TED [70] to obtain the semantic names for the 100 activities based on our collection of layout trees (i.e., 13,792 layout files).", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1137/0218082", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Simple+fast+algorithms+for+the+editing+distance+between+trees+and+related+problems&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812043", "articleId": "8812043", "startPage": "596", "endPage": "607", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 2, "citationCountPatent": 0, "totalDownloads": 143}}
{"title": "Exposing Library API Misuses Via Mutation Analysis", "authors": [{"name": "Ming Wen", "affiliation": "The Hong Kong University of Science and Technology, Hong Kong, China", "firstName": "Ming", "lastName": "Wen", "id": "37086462619"}, {"name": "Yepang Liu", "affiliation": "Shenzhen Key Laboratory of Computational Intelligence Southern University of Science and Technology, Shenzhen, China", "firstName": "Yepang", "lastName": "Liu", "id": "37086798862"}, {"name": "Rongxin Wu", "affiliation": "The Hong Kong University of Science and Technology, Hong Kong, China", "firstName": "Rongxin", "lastName": "Wu", "id": "37085876454"}, {"name": "Xuan Xie", "affiliation": "Sun Yat-sen University", "firstName": "Xuan", "lastName": "Xie", "id": "37086951796"}, {"name": "Shing-Chi Cheung", "affiliation": "The Hong Kong University of Science and Technology, Hong Kong, China", "firstName": "Shing-Chi", "lastName": "Cheung", "id": "37275216500"}, {"name": "Zhendong Su", "affiliation": "ETH Zurich, Switzerland & UC Davis, USA", "firstName": "Zhendong", "lastName": "Su", "id": "37086951520"}], "abstract": "Misuses of library APIs are pervasive and often lead to software crashes and vulnerability issues. Various static analysis tools have been proposed to detect library API misuses. They often involve mining frequent patterns from a large number of correct API usage examples, which can be hard to obtain in practice. They also suffer from low precision due to an over-simplified assumption that a deviation from frequent usage patterns indicates a misuse. We make two observations on the discovery of API misuse patterns. First, API misuses can be represented as mutants of the corresponding correct usages. Second, whether a mutant will introduce a misuse can be validated via executing it against a test suite and analyzing the execution information. Based on these observations, we propose MutApi, the first approach to discovering API misuse patterns via mutation analysis. To effectively mimic API misuses based on correct usages, we first design eight effective mutation operators inspired by the common characteristics of API misuses. MutApi generates mutants by applying these mutation operators on a set of client projects and collects mutant-killing tests as well as the associated stack traces. Misuse patterns are discovered from the killed mutants that are prioritized according to their likelihood of causing API misuses based on the collected information. We applied MutApi on 16 client projects with respect to 73 popular Java APIs. The results show that MutApi is able to discover substantial API misuse patterns with a high precision of 0.78. It also achieves a recall of $0.49$ on the MuBench benchmark, which outperforms the state-of-the-art techniques.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Libraries", "Computer bugs", "Java", "Software", "Tools", "Detectors"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["application program interfaces", "data mining", "Java", "program diagnostics", "program testing", "security of data"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["substantial API misuse patterns", "library API misuses", "mutation analysis", "frequent usage patterns", "Java API", "static analysis tools", "MutApi", "mutant-killing tests", "frequent pattern mining"]}, {"type": "Author Keywords ", "kwd": ["Mutation Analysis", "Library API Misuse"]}], "publication": "2019 IEEE/ACM 41st International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2019.00093", "ref": [{"order": "1", "text": "Y. Wang, M. Wen, Z. Liu, R. Wu, R. Wang, B. Yang, H. Yu, Z. Zhu, S.-C. Cheung, \"Do the dependency conflicts in my project matter?\", <em>Proceedings of the 2018 26th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE 2018)</em>, pp. 1-12, 2018.", "title": "Do the dependency conflicts in my project matter?", "context": [{"sec": "sec1", "text": " According to a recent study [1], a Java project directly depends on 14 different libraries on average.", "part": "1"}, {"sec": "sec6a", "text": "MutApi can apply \\$N\\$ mutation operators when generating mutants (see Algorithm 1).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3236024.3236056", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Do+the+dependency+conflicts+in+my+project+matter%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "<em>Maven repository</em>, 2018,  [online]  Available: https://maven.apache.org/.", "title": "Maven repository", "context": [{"sec": "sec1", "text": " The Maven repository [2] has indexed over 8.77 millions third-party libraries.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Maven+repository&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "U. Dekel, J. D. Herbsleb, \"Improving api documentation usability with knowledge pushing\", <em>Proceedings of the 31st International Conference on Software Engineering. IEEE Computer Society</em>, pp. 320-330, 2009.", "title": "Improving api documentation usability with knowledge pushing", "context": [{"sec": "sec1", "text": " However, correct usages of Application Programming Interfaces (APIs) provided by many third-party libraries are loosely documented or left unrevised after API updates [3]\u2013[5].", "part": "1"}, {"sec": "sec2b", "text": " Unfortunately, many of such constraints are insufficiently specified by APIs' documentations [3].", "part": "1"}], "links": {"documentLink": "/document/5070532", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070532", "abstract": "The documentation of API functions typically conveys detailed specifications for the benefit of interested readers. In some cases, however, it also contains usage directives, such as rules or caveats, of which authors of invoking code must be made aware to prevent errors and inefficiencies. There is a risk that these directives may be ldquolostrdquo within the verbose text, or that the text would not be read because there are so many invoked functions. To address these concerns for Java, an Ecli...", "pdfSize": "713KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+api+documentation+usability+with+knowledge+pushing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "T. Zhang, G. Upadhyaya, A. Reinhardt, H. Rajan, M. Kim, \"Are code examples on an online q&a forum reliable?: a study of api misuse on stack overflow\", <em>Proceedings of the 40th International Conference on Software Engineering</em>, pp. 886-896, 2018.", "title": "Are code examples on an online q&a forum reliable?: a study of api misuse on stack overflow", "context": [{"sec": "sec1", "text": " However, correct usages of Application Programming Interfaces (APIs) provided by many third-party libraries are loosely documented or left unrevised after API updates [3]\u2013[4][5].", "part": "1"}, {"sec": "sec1", "text": " The design of these mutation operators can be guided by the characteristics of common API misuse patterns, which have been well investigated by existing studies [4], [6].", "part": "1"}, {"sec": "sec1", "text": " Inspired by a recent study [4], MutApi models correct API usages as structured call sequences based on a predefined grammar.", "part": "1"}, {"sec": "sec1", "text": " Specifically, it first models an API misuse as a pair of a violation type and an API usage element, following the findings of recent studies [4], [6].", "part": "1"}, {"sec": "sec1", "text": "To evaluate MutApi, we selected 73 popular Java APIs collected by recent studies [4], [6], and 16 client projects collected from popular repositories on GitHub.", "part": "1"}, {"sec": "sec2b", "text": " However, as revealed by a recent study [4], code snippets on Stack Overflow can be unreliable, even for those accepted and upvoted answers.", "part": "1"}, {"sec": "sec2c", "text": " It violates the correct usage of Float.parseFloat and follows a well-known API misuse pattern, i.e., missing exception handling [4], [6].", "part": "1"}, {"sec": "sec2c", "text": " Specifically, we selected the 100 popular APIs collected by an existing study [4].", "part": "1"}, {"sec": "sec3a", "text": " For instance, one major type of API misuses is missing control statements [4], [6], e.g., missing exception handling or if check statements.", "part": "1"}, {"sec": "sec3a", "text": "Motivated by a recent study [4], MutApi models correct API usages as structured call sequences to effectively mimic various types of API misuses.", "part": "1"}, {"sec": "sec3a", "text": " Such structured call sequences abstract away the syntactic details such as variable names, but keep the temporal ordering, control structures and checkers of API calls in a compact manner [4].", "part": "1"}, {"sec": "sec3a", "text": " We adapt the grammar defined by the study [4] to represent structured call sequences, which is shown in Table III.", "part": "1"}, {"sec": "sec3a", "text": " Note that MutApi only identifies those statements that directly depend on the variables involved in API calls because such a setting is able to achieve the best performance in modeling API usages for misuse detection according to an existing work [4].", "part": "1"}, {"sec": "sec3a", "text": " Specifically, we designed eight types of mutation operators, as shown in Table IV, guided by the common characteristics of API misuse patterns [4], [6].", "part": "1"}, {"sec": "sec3a", "text": " For the case of incorrect order of API calls [4], MutApi swaps the orders of two call sequences (Type 1), deletes an API call (Type 2) and inserts a new API call (Type 3).", "part": "1"}, {"sec": "sec3a", "text": " For the case of missing control structures [4], [6], MutApi deletes the structures but keeps the enclosing API calls (Type 5) or deletes the structures together with the enclosing API calls (Type 6).", "part": "1"}, {"sec": "sec3a", "text": " For the case of missing correct condition [4], [6], in a checker or an if statement, MutApi randomly replaces the condition expression with other condition expressions or boolean values (Type 7).", "part": "1"}, {"sec": "sec3c", "text": " Specifically, there are three violation types, missing, redundant and incorrect, according to existing studies [4], [6].", "part": "1"}, {"sec": "sec3c", "text": " An API usage element can refer to a method call, null checker, condition, exception handling, iteration, parameter and so on [4], [6].", "part": "1"}, {"sec": "sec4a", "text": "To evaluate the effectiveness of MutApi, we selected 73 popular Java APIs collected by a recent study [4] for experiments 11The prior study collected 100 popular APIs [4].", "part": "1"}, {"sec": "fn1", "text": "The prior study collected 100 popular APIs [4].", "type": "footnote"}, {"sec": "sec4c", "text": " To judge whether a detected misuse pattern is a true positive or not, we follow the strategy adopted by an existing study [4].", "part": "1"}, {"sec": "sec5c", "text": " This is in line with the findings of existing studies [4], [6].", "part": "1"}, {"sec": "sec6c", "text": " However, these APIs are popular (i.e., frequently discussed in Stack Overflow [4]) and systematically evaluated by existing studies [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180260", "abstract": "Programmers often consult an online Q&A forum such as Stack Overflow to learn new APIs. This paper presents an empirical study on the prevalence and severity of API misuse on Stack Overflow. To reduce manual assessment effort, we design ExampleCheck, an API usage mining framework that extracts patterns from over 380K Java repositories on GitHub and subsequently reports potential API usage violations in Stack Overflow posts. We analyze 217,818 Stack Overflow posts using ExampleCheck and find that...", "pdfSize": "434KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+code+examples+on+an+online+q%26a+forum+reliable%3F%3A+a+study+of+api+misuse+on+stack+overflow&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "L. Seonah, R. Wu, S.-C. Cheung, S. Kang, \"Automatic detection and update suggestion for outdated api names in documentation\", <em>IEEE Transactions on Software Engineering</em>, 2019.", "title": "Automatic detection and update suggestion for outdated api names in documentation", "context": [{"sec": "sec1", "text": " However, correct usages of Application Programming Interfaces (APIs) provided by many third-party libraries are loosely documented or left unrevised after API updates [3]\u2013[5].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+detection+and+update+suggestion+for+outdated+api+names+in+documentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "S. Amann, H. A. Nguyen, S. Nadi, T. N. Nguyen, M. Mezini, \"A systematic evaluation of static api-misuse detectors\", <em>IEEE Transactions on Software Engineering</em>, 2018.", "title": "A systematic evaluation of static api-misuse detectors", "context": [{"sec": "sec1", "text": " As a result, API misuses are pervasive and account for a major cause of software bugs (e.g., performance issues, software crashes and vulnerability issues [6]\u2013[11]).", "part": "1"}, {"sec": "sec1", "text": "A recent study reported that existing static-analysis based API misuse detectors suffer from low recall and precision in practical settings [6].", "part": "1"}, {"sec": "sec1", "text": " The design of these mutation operators can be guided by the characteristics of common API misuse patterns, which have been well investigated by existing studies [4], [6].", "part": "1"}, {"sec": "sec1", "text": " For instance, one misuse pattern is missing exception handling [6].", "part": "1"}, {"sec": "sec1", "text": " Other patterns of API misuses (e.g., missing method call [6]) can be similarly created via applying certain mutation operators (e.g., deleting method call).", "part": "1"}, {"sec": "sec1", "text": " Specifically, it first models an API misuse as a pair of a violation type and an API usage element, following the findings of recent studies [4], [6].", "part": "1"}, {"sec": "sec1", "text": "To evaluate MutApi, we selected 73 popular Java APIs collected by recent studies [4], [6], and 16 client projects collected from popular repositories on GitHub.", "part": "1"}, {"sec": "sec1", "text": " It also achieves a higher recall on the benchmark dataset MuBench [6] compared with the state-of-the-art techniques.", "part": "1"}, {"sec": "sec2b", "text": "Uses of library APIs are often subject to constraints such as call orders and call conditions [6].", "part": "1"}, {"sec": "sec2b", "text": " Violations of the constraints that should be satisfied may induce software bugs [6]\u2013[11] (e.g., crashes and security issues).", "part": "1"}, {"sec": "sec2c", "text": " It violates the correct usage of Float.parseFloat and follows a well-known API misuse pattern, i.e., missing exception handling [4], [6].", "part": "1"}, {"sec": "sec3a", "text": " For instance, one major type of API misuses is missing control statements [4], [6], e.g., missing exception handling or if check statements.", "part": "1"}, {"sec": "sec3a", "text": " Specifically, we designed eight types of mutation operators, as shown in Table IV, guided by the common characteristics of API misuse patterns [4], [6].", "part": "1"}, {"sec": "sec3a", "text": " For the case of missing checkers [6], MutApi deletes a checker if there is one (Type 4).", "part": "1"}, {"sec": "sec3a", "text": " For the case of missing control structures [4], [6], MutApi deletes the structures but keeps the enclosing API calls (Type 5) or deletes the structures together with the enclosing API calls (Type 6).", "part": "1"}, {"sec": "sec3a", "text": " For the case of missing correct condition [4], [6], in a checker or an if statement, MutApi randomly replaces the condition expression with other condition expressions or boolean values (Type 7).", "part": "1"}, {"sec": "sec3c", "text": " MutApi distills API misuse patterns from those killed mutants \\$\\mathcal{M}_{s}\\$ associated with \\$\\mathcal{K}_{s}\\$ To effectively distill API misuses, MutApi models an API misuse as a violation pair, \\$p= \\langle violation\\$ type, API usage \\$element\\rangle\\$ following a recent work [6].", "part": "1"}, {"sec": "sec3c", "text": " Specifically, there are three violation types, missing, redundant and incorrect, according to existing studies [4], [6].", "part": "1"}, {"sec": "sec3c", "text": " An API usage element can refer to a method call, null checker, condition, exception handling, iteration, parameter and so on [4], [6].", "part": "1"}, {"sec": "sec4a", "text": " The remaining 30 APIs come from MuBench [6], which is a benchmark dataset of API misuses.", "part": "1"}, {"sec": "sec4c", "text": " We applied MutApi to MuBench [6] to see if it can detect the API misuses in the benchmark dataset.", "part": "1"}, {"sec": "sec4c", "text": " Specifically, we investigate the recall of MutApi, i.e., the ratio of the API misuses that can be detected by MutApi among the 53 real instances used in the Experiment R in the MuBench work [6].", "part": "1"}, {"sec": "sec4c", "text": " To compare with existing approaches, we chose four baselines (i.e., Jadet [14], GROUPMINER [16], DMMC [7] and TIKANGA [20]) that have been systematically evaluated by existing study [6].", "part": "1"}, {"sec": "sec5a", "text": " This misuse has been confirmed by existing literature [6].", "part": "1"}, {"sec": "sec5b", "text": " The results of baselines are directly extracted from the previous study [6].", "part": "1"}, {"sec": "sec5b", "text": " The two settings are detailedly explained in the existing study [6] and we do not make further explanations in this study.", "part": "1"}, {"sec": "sec5b", "text": " We plan to evaluate MutApi on more datasets other than MuBench [6] in the future since one threat to validity of our results here is that the design of our mutation operators was partially inspired by the study of this benchmark.", "part": "1"}, {"sec": "sec5c", "text": " This is in line with the findings of existing studies [4], [6].", "part": "1"}, {"sec": "sec6c", "text": " However, these APIs are popular (i.e., frequently discussed in Stack Overflow [4]) and systematically evaluated by existing studies [6].", "part": "1"}, {"sec": "sec7", "text": " It also achieves a recall of 0.49 on the MuBench benchmark dataset [6], which significantly outperforms existing approaches.", "part": "1"}], "links": {"abstract": "Application Programming Interfaces (APIs) often have usage constraints, such as restrictions on call order or call conditions. API misuses, i.e., violations of these constraints, may lead to software crashes, bugs, and vulnerabilities. Though researchers developed many API-misuse detectors over the last two decades, recent studies show that API misuses are still prevalent. Therefore, we need to understand the capabilities and limitations of existing detectors in order to advance the state of the...", "pdfSize": "1263KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+systematic+evaluation+of+static+api-misuse+detectors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "M. Monperrus, M. Mezini, \"Detecting missing method calls as violations of the majority rule\", <em>ACM Transactions on Software Engineering and Methodology (TOSEM)</em>, vol. 22, no. 1, pp. 7, 2013.", "title": "Detecting missing method calls as violations of the majority rule", "context": [{"sec": "sec1", "text": " As a result, API misuses are pervasive and account for a major cause of software bugs (e.g., performance issues, software crashes and vulnerability issues [6]\u2013[7][11]).", "part": "1"}, {"sec": "sec2b", "text": " Violations of the constraints that should be satisfied may induce software bugs [6]\u2013[7][11] (e.g., crashes and security issues).", "part": "1"}, {"sec": "sec2b", "text": " Dmmc detects missing calls in a set of method invocations triggered by an object [7].", "part": "1"}, {"sec": "sec4c", "text": " To compare with existing approaches, we chose four baselines (i.e., Jadet [14], GROUPMINER [16], DMMC [7] and TIKANGA [20]) that have been systematically evaluated by existing study [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2430536.2430541", "abstract": "When using object-oriented frameworks it is easy to overlook certain important method calls that are required at particular places in code. In this article, we provide a comprehensive set of empirical facts on this problem, starting from traces of missing method calls in a bug repository. We propose a new system that searches for missing method calls in software based on the other method calls that are observable. Our key insight is that the voting theory concept of majority rule holds for metho...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+missing+method+calls+as+violations+of+the+majority+rule&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "J. Sushine, J. D. Herbsleb, J. Aldrich, \"Searching the state space: a qualitative study of api protocol usability\", <em>Proceedings of the 2015 IEEE 23rd International Conference on Program Comprehension</em>, pp. 82-93, 2015.", "title": "Searching the state space: a qualitative study of api protocol usability", "context": [{"sec": "sec1", "text": " As a result, API misuses are pervasive and account for a major cause of software bugs (e.g., performance issues, software crashes and vulnerability issues [6]\u2013[8][11]).", "part": "1"}, {"sec": "sec2b", "text": " Violations of the constraints that should be satisfied may induce software bugs [6]\u2013[8][11] (e.g., crashes and security issues).", "part": "1"}], "links": {"documentLink": "/document/7181435", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7181435", "abstract": "Application Programming Interfaces (APIs) often define protocols -- restrictions on the order of client calls to API methods. API protocols are common and difficult to use, which has generated tremendous research effort in alternative specification, implementation, and verification techniques. However, little is understood about the barriers programmers face when using these APIs, and therefore the research effort may be misdirected. To understand these barriers better, we perform a two-part qua...", "pdfSize": "342KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Searching+the+state+space%3A+a+qualitative+study+of+api+protocol+usability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "S. Fahl, M. Harbach, T. Muders, L. Baumg\u00e4rtner, B. Freisleben, M. Smith, \"Why eve and mallory love android: An analysis of android ssl (in) security\", <em>Proceedings of the 2012 ACM conference on Computer and communications security</em>, pp. 50-61, 2012.", "title": "Why eve and mallory love android: An analysis of android ssl (in) security", "context": [{"sec": "sec1", "text": " As a result, API misuses are pervasive and account for a major cause of software bugs (e.g., performance issues, software crashes and vulnerability issues [6]\u2013[9][11]).", "part": "1"}, {"sec": "sec2b", "text": " Violations of the constraints that should be satisfied may induce software bugs [6]\u2013[9][11] (e.g., crashes and security issues).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2382196.2382205", "abstract": "Many Android apps have a legitimate need to communicate over the Internet and are then responsible for protecting potentially sensitive data during transit. This paper seeks to better understand the potential security threats posed by benign Android apps that use the SSL/TLS protocols to protect data they transmit. Since the lack of visual security indicators for SSL/TLS usage and the inadequate use of SSL/TLS can be exploited to launch Man-in-the-Middle (MITM) attacks, an analysis of 13,500 pop...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+eve+and+mallory+love+android%3A+An+analysis+of+android+ssl+%28in%29+security&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "M. Egele, D. Brumley, Y. Fratantonio, C. Kruegel, \"An empirical study of cryptographic misuse in android applications\", <em>Proceedings of the 2013 ACM SIGSAC conference on Computer & communications security</em>, pp. 73-84, 2013.", "title": "An empirical study of cryptographic misuse in android applications", "context": [{"sec": "sec1", "text": " As a result, API misuses are pervasive and account for a major cause of software bugs (e.g., performance issues, software crashes and vulnerability issues [6]\u2013[10][11]).", "part": "1"}, {"sec": "sec2b", "text": " Violations of the constraints that should be satisfied may induce software bugs [6]\u2013[10][11] (e.g., crashes and security issues).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2508859.2516693", "abstract": "Developers use cryptographic APIs in Android with the intent of securing data such as passwords and personal information on mobile devices. In this paper, we ask whether developers use the cryptographic APIs in a fashion that provides typical cryptographic notions of security, e.g., IND-CPA security. We develop program analysis techniques to automatically check programs on the Google Play marketplace, and find that 10.327 out of 11,748 applications that use cryptographic APIs -- 88% overall -- m...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+empirical+study+of+cryptographic+misuse+in+android+applications&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "M. Georgiev, S. Iyengar, S. Jana, R. Anubhai, D. Boneh, V. Shmatikov, \"The most dangerous code in the world: validating ssl certificates in non-browser software\", <em>Proceedings of the 2012 ACM conference on Computer and communications security</em>, pp. 38-49, 2012.", "title": "The most dangerous code in the world: validating ssl certificates in non-browser software", "context": [{"sec": "sec1", "text": " As a result, API misuses are pervasive and account for a major cause of software bugs (e.g., performance issues, software crashes and vulnerability issues [6]\u2013[11]).", "part": "1"}, {"sec": "sec2b", "text": " Violations of the constraints that should be satisfied may induce software bugs [6]\u2013[11] (e.g., crashes and security issues).", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2382196.2382204", "abstract": "SSL (Secure Sockets Layer) is the de facto standard for secure Internet communications. Security of SSL connections against an active network attacker depends on correctly validating public-key certificates presented when the connection is established. We demonstrate that SSL certificate validation is completely broken in many security-critical applications and libraries. Vulnerable software includes Amazon&#39;s EC2 Java library and all cloud clients based on it; Amazon&#39;s and PayPal&#39;s merchant SDKs...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+most+dangerous+code+in+the+world%3A+validating+ssl+certificates+in+non-browser+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "Z. Li, Y. Zhou, \"Pr-miner: automatically extracting implicit programming rules and detecting violations in large software code\", <em>SIGSOFT Software Engineering Notes</em>, vol. 30, no. 5, pp. 306-315, 2005.", "title": "Pr-miner: automatically extracting implicit programming rules and detecting violations in large software code", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[20].", "part": "1"}, {"sec": "sec2b", "text": " For example, Pr-miner encodes API usages as a set of function calls invoked within the same method, and then leverages frequent itemset mining to identify patterns with a minimum support of 15 usages [12].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1095430.1081755", "abstract": "Programs usually follow many implicit programming rules, most of which are too tedious to be documented by programmers. When these rules are violated by programmers who are unaware of or forget about them, defects can be easily introduced. Therefore, it is highly desirable to have tools to automatically extract such rules and also to automatically detect violations. Previous work in this direction focuses on simple function-pair based programming rules and additionally requires programmers to pr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pr-miner%3A+automatically+extracting+implicit+programming+rules+and+detecting+violations+in+large+software+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "C. Lindig, \"Mining patterns and violations using concept analysis\" in The Art and Science of Analyzing Software Data, Elsevier, pp. 17-38, 2016.", "title": "Mining patterns and violations using concept analysis", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[13][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[13][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[13][20].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+patterns+and+violations+using+concept+analysis&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "A. Wasylkowski, A. Zeller, C. Lindig, \"Detecting object usage anomalies\", <em>Proceedings of the the 6th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering</em>, pp. 35-44, 2007.", "title": "Detecting object usage anomalies", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[14][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[14][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[14][20].", "part": "1"}, {"sec": "sec2b", "text": " Jadet builds a directed graph based on method call orders and call receivers [14].", "part": "1"}, {"sec": "sec4c", "text": " To compare with existing approaches, we chose four baselines (i.e., Jadet [14], GROUPMINER [16], DMMC [7] and TIKANGA [20]) that have been systematically evaluated by existing study [6].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1287624.1287632", "abstract": "Interacting with objects often requires following a protocol---for instance, a specific sequence of method calls. These protocols are not always documented, and violations can lead to subtle problems. Our approach takes code examples to automatically infer legal sequences of method calls. The resulting patterns can then be used to detect anomalies such as &#34;Before calling next, one normally calls hasNext&#34;. To our knowledge, this is the first fully automatic defect detection approach that learns a...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting+object+usage+anomalies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "M. K. Ramanathan, A. Grama, S. Jagannathan, \"Static specification inference using predicate mining\", <em>ACM SIGPLAN Notices</em>, vol. 42, no. 6, pp. 123-134, 2007.", "title": "Static specification inference using predicate mining", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[15][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[15][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[15][20].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1273442.1250749", "abstract": "The reliability and correctness of complex software systems can be significantly enhanced through well-defined specifications that dictate the use of various units of abstraction (e.g., modules, or procedures). Often times, however, specifications are either missing, imprecise, or simply too complex to encode within a signature, necessitating specification inference. The process of inferring specifications from complex software systems forms the focus of this paper. We describe a static inferenc...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Static+specification+inference+using+predicate+mining&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "T. T. Nguyen, H. A. Nguyen, N. H. Pham, J. M. Al-Kofahi, T. N. Nguyen, \"Graph-based mining of multiple object usage patterns\", <em>Proceedings of the the 7th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering</em>, pp. 383-392, 2009.", "title": "Graph-based mining of multiple object usage patterns", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[16][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[16][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[16][20].", "part": "1"}, {"sec": "sec2b", "text": " It then leverages subgraph mining techniques to detect frequent usage patterns with a minimum support of 6 [16].", "part": "1"}, {"sec": "sec4c", "text": " To compare with existing approaches, we chose four baselines (i.e., Jadet [14], GROUPMINER [16], DMMC [7] and TIKANGA [20]) that have been systematically evaluated by existing study [6].", "part": "1"}, {"sec": "sec5b", "text": " For instance, GROUPMINER [16] detects frequent usage patterns with a minimum support of 6 and Tikanga [14] sets the minimum support to 20.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1595696.1595767", "abstract": "The interplay of multiple objects in object-oriented programming often follows specific protocols, for example certain orders of method calls and/or control structure constraints among them that are parts of the intended object usages. Unfortunately, the information is not always documented. That creates long learning curve, and importantly, leads to subtle problems due to the misuse of objects. In this paper, we propose GrouMiner, a novel graph-based approach for mining the usage patterns of on...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Graph-based+mining+of+multiple+object+usage+patterns&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "M. Acharya, T. Xie, \"Mining api error-handling specifications from source code\", <em>International Conference on Fundamental Approaches to Software Engineering</em>, pp. 370-384, 2009.", "title": "Mining api error-handling specifications from source code", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[17][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[17][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[17][20].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-642-00593-0_25", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+api+error-handling+specifications+from+source+code&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "S. Thummalapenta, T. Xie, \"Mining exception-handling rules as sequence association rules\", <em>Proceedings of the IEEE 31st International Conference on Software Engineering 2009</em>, pp. 496-506, 2009.", "title": "Mining exception-handling rules as sequence association rules", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[18][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[18][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[18][20].", "part": "1"}], "links": {"documentLink": "/document/5070548", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5070548", "abstract": "Programming languages such as Java and C++ provide exception-handling constructs to handle exception conditions. Applications are expected to handle these exception conditions and take necessary recovery actions such as releasing opened database connections. However, exception-handling rules that describe these necessary recovery actions are often not available in practice. To address this issue, we develop a novel approach that mines exception-handling rules as sequence association rules of the...", "pdfSize": "353KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+exception-handling+rules+as+sequence+association+rules&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "S. Thummalapenta, T. Xie, \"Alattin: Mining alternative patterns for detecting neglected conditions\", <em>Proceedings of the 2009 IEEE/ACM International Conference on Automated Software Engineering. IEEE Computer Society</em>, pp. 283-294, 2009.", "title": "Alattin: Mining alternative patterns for detecting neglected conditions", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[19][20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[19][20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[19][20].", "part": "1"}], "links": {"documentLink": "/document/5431765", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5431765", "abstract": "To improve software quality, static or dynamic verification tools accept programming rules as input and detect their violations in software as defects. As these programming rules are often not well documented in practice, previous work developed various approaches that mine programming rules as frequent patterns from program source code. Then these approaches use static defect-detection techniques to detect pattern violations in source code under analysis. These existing approaches often produce...", "pdfSize": "576KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Alattin%3A+Mining+alternative+patterns+for+detecting+neglected+conditions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "A. Wasylkowski, A. Zeller, \"Mining temporal specifications from object usage\", <em>Automated Software Engineering</em>, vol. 18, no. 3\u20134, pp. 263-292, 2011.", "title": "Mining temporal specifications from object usage", "context": [{"sec": "sec1", "text": " To detect API misuses, various static analysis tools have been proposed [12]\u2013[20].", "part": "1"}, {"sec": "sec1", "text": " Unlike existing work [12]\u2013[20], our solution does not require pattern mining from a large number of correct API usages.", "part": "1"}, {"sec": "sec2b", "text": " Therefore, it motivates a wealth of researches on mining and detecting API misuses automatically [12]\u2013[20].", "part": "1"}, {"sec": "sec2b", "text": " Tikanga is built on top of Jadet [20].", "part": "1"}, {"sec": "sec4c", "text": " To compare with existing approaches, we chose four baselines (i.e., Jadet [14], GROUPMINER [16], DMMC [7] and TIKANGA [20]) that have been systematically evaluated by existing study [6].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10515-011-0084-1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mining+temporal+specifications+from+object+usage&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "Y. Jia, M. Harman, \"An analysis and survey of the development of mutation testing\", <em>IEEE transactions on software engineering</em>, vol. 37, no. 5, pp. 649-678, 2011.", "title": "An analysis and survey of the development of mutation testing", "context": [{"sec": "sec1", "text": "In this study, we propose to approach the problem of API misuse patterns' discovery from a new perspective through mutation analysis [21].", "part": "1"}, {"sec": "sec1", "text": " Mutation analysis has been widely used in software debugging and testing [21].", "part": "1"}], "links": {"documentLink": "/document/5487526", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=5487526", "abstract": "Mutation Testing is a fault-based software testing technique that has been widely studied for over three decades. The literature on Mutation Testing has contributed a set of approaches, tools, developments, and empirical results. This paper provides a comprehensive analysis and survey of Mutation Testing. The paper also presents the results of several development trend analyses. These analyses provide evidence that Mutation Testing techniques and tools are reaching a state of maturity and applic...", "pdfSize": "10712KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+analysis+and+survey+of+the+development+of+mutation+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "P. Ammann, J. Offutt, Introduction to software testing, Cambridge University Press, 2016.", "title": "Introduction to software testing", "context": [{"sec": "sec1", "text": " Second, it runs a given test suite on the mutants and collects execution information for various quality analyses [22]\u2013[26].", "part": "1"}, {"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}, {"sec": "sec2a", "text": " For instance, to evaluate the quality of a test suite \\$\\mathcal{T}\\$ [22], mutation score, the proportion of killed mutants in \\$\\mathcal{M}\\$, is computed.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1017/9781316771273", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introduction+to+software+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "S. Hong, B. Lee, T. Kwak, Y. Jeon, B. Ko, Y. Kim, M. Kim, \"Mutation-based fault localization for real-world multilingual programs (t)\", <em>Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering</em>, pp. 464-475, 2015.", "title": "Mutation-based fault localization for real-world multilingual programs (t)", "context": [{"sec": "sec1", "text": " Second, it runs a given test suite on the mutants and collects execution information for various quality analyses [22]\u2013[23][26].", "part": "1"}, {"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"documentLink": "/document/7372034", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7372034", "abstract": "Programmers maintain and evolve their software in a variety of programming languages to take advantage of various control/data abstractions and legacy libraries. The programming language ecosystem has diversified over the last few decades, and non-trivial programs are likely to be written in more than a single language. Unfortunately, language interfaces such as Java Native Interface and Python/C are difficult to use correctly and the scope of fault localization goes beyond language boundaries, ...", "pdfSize": "259KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mutation-based+fault+localization+for+real-world+multilingual+programs+%28t%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "T. Loise, X. Devroey, G. Perrouin, M. Papadakis, P. Heymans, \"Towards security-aware mutation testing\", <em>ICST Workshops</em>, pp. 97-102.", "title": "Towards security-aware mutation testing", "context": [{"sec": "sec1", "text": " Second, it runs a given test suite on the mutants and collects execution information for various quality analyses [22]\u2013[24][26].", "part": "1"}, {"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"documentLink": "/document/7899041", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7899041", "abstract": "Mutation analysis forms a popular software analysis technique that has been demonstrated to be useful in supporting multiple software engineering activities. Yet, the use of mutation analysis in tackling security issues has received little attention. In view of this, we design security aware mutation operators to support mutation analysis. Using a known set of common security vulnerability patterns, we introduce 15 security-aware mutation operators for Java. We then implement them in the PIT mut...", "pdfSize": "309KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+security-aware+mutation+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "T. Mouelhi, Y. Le Traon, B. Baudry, \"Mutation analysis for security tests qualification\", <em>Testing: Academic and Industrial Conference Practice and Research Techniques-MUTATION 2007. TAICPART-MUTATION 2007</em>, pp. 233-242, 2007.", "title": "Mutation analysis for security tests qualification", "context": [{"sec": "sec1", "text": " Second, it runs a given test suite on the mutants and collects execution information for various quality analyses [22]\u2013[25][26].", "part": "1"}, {"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[25][26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"documentLink": "/document/4344128", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4344128", "abstract": "In this paper, we study how mutation analysis can be adapted to qualify test cases aiming at testing a security policy. The objective is to make test cases efficient to reveal erroneous implementations of a security policy. The notion of security policy testing is studied and mutation operators are defined in relation with the security rules. To make the approach applicable in practice we discuss and empirically rank the security mutation operators from the most to the least difficult to kill. T...", "pdfSize": "502KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mutation+analysis+for+security+tests+qualification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "B. Baudry, F. Fleurey, Y. Le Traon, \"Improving test suites for efficient fault localization\", <em>Proceedings of the 28th international conference on Software engineering</em>, pp. 82-91, 2006.", "title": "Improving test suites for efficient fault localization", "context": [{"sec": "sec1", "text": " Second, it runs a given test suite on the mutants and collects execution information for various quality analyses [22]\u2013[26].", "part": "1"}, {"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1134285.1134299", "abstract": "The need for testing-for-diagnosis strategies has been identified for a long time, but the explicit link from testing to diagnosis (fault localization) is rare. Analyzing the type of information needed for efficient fault localization, we identify the attribute (called Dynamic Basic Block) that restricts the accuracy of a diagnosis algorithm. Based on this attribute, a test-for-diagnosis criterion is proposed and validated through rigorous case studies: it shows that a test suite can be improved...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+test+suites+for+efficient+fault+localization&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "<em>Pit</em>, 2018,  [online]  Available: http://pitest.org/quickstart/mutators/.", "title": "Pit", "context": [{"sec": "sec3a", "text": " Conventional operators focus on mutating conditional or mathmatics operators [27], and are not designed to manipulate such control statements.", "part": "1"}, {"sec": "sec4b", "text": " Our second criterion is that the mutation coverage (measured using Pit [27]) of a client project should be greater than 0.70.", "part": "1"}, {"sec": "sec4c", "text": " In this research question, we compare our proposed mutation operators with the traditional ones used in Pit [27] using two metrics: (1) efficiency (i.e., the time required for mutation analysis) and (2) effectiveness (i.e., the number of API misuse patterns detected).", "part": "1"}, {"sec": "sec5c", "text": " This is because that the conventional mutation operators focus on mutating arithmetic and conditional operators [27], which mostly result in assertion errors general to all client projects.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pit&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "R. Wu, H. Zhang, S.-C. Cheung, S. Kim, \"Crashlocator: locating crashing faults based on crash stacks\", <em>Proceedings of the 2014 International Symposium on Software Testing and Analysis</em>, pp. 204-214, 2014.", "title": "Crashlocator: locating crashing faults based on crash stacks", "context": [{"sec": "sec1", "text": " First, given a killing stack trace, the failure's root cause appears closer to the failure point [28].", "part": "1"}, {"sec": "sec3b", "text": " As revealed by existing studies, in a stack trace, functions where the root causes reside appear closer to the failure point [28].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2610384.2610386", "abstract": "Software crash is common. When a crash occurs, software developers can receive a report upon user permission. A crash report typically includes a call stack at the time of crash. An important step of debugging a crash is to identify faulty functions, which is often a tedious and labor-intensive task. In this paper, we propose CrashLocator, a method to locate faulty functions using the crash stack information in crash reports. It deduces possible crash traces (the failing execution traces that le...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Crashlocator%3A+locating+crashing+faults+based+on+crash+stacks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "W. Ying, W. Ming, W. Rongxin, L. Zhenwei, T. Shin Hwei, Z. Zhiliang, Y. Hai, C. Shing-Chi, \"Could I Have a Stack Trace to Examine the Dependency Conflict Issue?\", <em>Proceedings of the 41th International Conference on Software Engineering</em>, 2019.", "title": "Could I Have a Stack Trace to Examine the Dependency Conflict Issue?", "context": [{"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Could+I+Have+a+Stack+Trace+to+Examine+the+Dependency+Conflict+Issue%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "I. Ahmed, C. Jensen, A. Groce, P. E. McKenney, \"Applying mutation analysis on kernel test suites: an experience report\", <em>IEEE International Conference on Software Testing Verification and Validation Workshops (ICSTW)</em>, pp. 110-115, 2017.", "title": "Applying mutation analysis on kernel test suites: an experience report", "context": [{"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[30][32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"documentLink": "/document/7899043", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7899043", "abstract": "Mutation analysis is an established technique for measuring the completeness and quality of a test suite. Despite four decades of research on this technique, its use in large systems is still rare, in part due to computational requirements and high numbers of false positives. We present our experiences using mutation analysis on the Linux kernel&#39;s RCU (Read Copy Update) module, where we adapt existing techniques to constrain the complexity and computation requirements. We show that mutation anal...", "pdfSize": "366KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Applying+mutation+analysis+on+kernel+test+suites%3A+an+experience+report&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "C. S. Timperley, S. Stepney, C. Le Goues, \"An investigation into the use of mutation analysis for automated program repair\", <em>International Symposium on Search Based Software Engineering</em>, pp. 99-114, 2017.", "title": "An investigation into the use of mutation analysis for automated program repair", "context": [{"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[31][32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-3-319-66299-2_7", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+investigation+into+the+use+of+mutation+analysis+for+automated+program+repair&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "M. Wen, J. Chen, R. Wu, D. Hao, S.-C. Cheung, \"Context-aware patch generation for better automated program repair\", <em>Proceedings of the 40th International Conference on Software Engineering ser. ICSE '18</em>, pp. 1-11, 2018.", "title": "Context-aware patch generation for better automated program repair", "context": [{"sec": "sec2a", "text": " Mutation analysis has many applications (e.g., [22], [24]\u2013[26], [29]\u2013[32]), such as evaluating the quality of a test suite (e.g., [22]), test suite reduction (e.g., [30]), improving fault localization (e.g., [23], [26]), security analysis (e.g., [24], [25]), program repair (e.g., [31], [32]) and so on.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3180155.3180233", "abstract": "The effectiveness of search-based automated program repair is limited in the number of correct patches that can be successfully generated. There are two causes of such limitation. First, the search space does not contain the correct patch. Second, the search space is huge and therefore the correct patch cannot be generated (ie correct patches are either generated after incorrect plausible ones or not generated within the time budget). To increase the likelihood of including the correct patches i...", "pdfSize": "453KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Context-aware+patch+generation+for+better+automated+program+repair&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "Y. Acar, M. Backes, S. Fahl, D. Kim, M. L. Mazurek, C. Stransky, \"You get where you're looking for: The impact of information sources on code security\", <em>Proceedings of the IEEE Symposium on Security and Privacy</em>, pp. 289-305, 2016.", "title": "You get where you're looking for: The impact of information sources on code security", "context": [{"sec": "sec2b", "text": " As a result, developers also refer to informal references, such as Stack Overflow, to understand the usages of an API [33].", "part": "1"}], "links": {"documentLink": "/document/7546508", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7546508", "abstract": "Vulnerabilities in Android code -- including but not limited to insecure data storage, unprotected inter-component communication, broken TLS implementations, and violations of least privilege -- have enabled real-world privacy leaks and motivated research cataloguing their prevalence and impact. Researchers have speculated that appification promotes security problems, as it increasingly allows inexperienced laymen to develop complex and sensitive apps. Anecdotally, Internet resources such as Sta...", "pdfSize": "916KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=You+get+where+you%27re+looking+for%3A+The+impact+of+information+sources+on+code+security&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "<em>Apache lang</em>, 2018,  [online]  Available: https://github.com/apache/commons-lang.git.", "title": "Apache lang", "context": [{"sec": "sec2c", "text": " Let us illustrate this using the code snippet in Figure 1, which is from project Apache Commons Lang [34].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+lang&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "M. Weiser, \"Program slicing\", <em>Proceedings of the 5th international conference on Software engineering</em>, pp. 439-449, 1981.", "title": "Program slicing", "context": [{"sec": "sec3a", "text": " MutApi then conducts program slicing [35] (both backward and forward) to extract those structure and checker statements for each of the API call based on its receiver variables \\$v_{rev}\\$ (e.g., value is the receiver variable at line 5) and parameters \\$v_{i}\\$ As a result, the if statement at line 7 will also be included in the modeled sequence.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program+slicing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "M. Linares-V\u00e1squez, G. Bavota, M. Tufano, K. Moran, M. Di Penta, C. Vendome, C. Bernal-C\u00e1rdenas, D. Poshyvanyk, \"Enabling mutation testing for android apps\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, pp. 233-244, 2017.", "title": "Enabling mutation testing for android apps", "context": [{"sec": "fn1", "text": " We excluded 27 Android APIs in our study because the mutation analysis for Android apps is different from that for general Java projects [36]\u2013[38] (e.g., the former requires mutation operators to mutate the AndroidManifest.xml file).", "type": "footnote"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106275", "abstract": "Mutation testing has been widely used to assess the fault-detection effectiveness of a test suite, as well as to guide test case generation or prioritization. Empirical studies have shown that, while mutants are generally representative of real faults, an effective application of mutation testing requires \u201ctraditional\u201d operators designed for programming languages to be augmented with operators specific to an application domain and/or technology. This paper proposes MDroid+, a framework for effec...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enabling+mutation+testing+for+android+apps&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "K. Moran, M. Tufano, C. Bernal-C\u00e1rdenas, M. Linares-V\u00e1squez, G. Bavota, C. Vendome, M. Di Penta, D. Poshyvanyk, \"Mdroid+: a mutation testing framework for android\", <em>Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings</em>, pp. 33-36, 2018.", "title": "Mdroid+: a mutation testing framework for android", "context": [{"sec": "fn1", "text": " We excluded 27 Android APIs in our study because the mutation analysis for Android apps is different from that for general Java projects [36]\u2013[37][38] (e.g., the former requires mutation operators to mutate the AndroidManifest.xml file).", "type": "footnote"}], "links": {"acmLink": "https://doi.org/10.1145/3183440.3183492", "abstract": "Mutation testing has shown great promise in assessing the effectiveness of test suites while exhibiting additional applications to test-case generation, selection, and prioritization. Traditional mutation testing typically utilizes a set of simple language specific source code transformations, called operators, to introduce faults. However, empirical studies have shown that for mutation testing to be most effective, these simple operators must be augmented with operators specific to the domain o...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Mdroid%2B%3A+a+mutation+testing+framework+for+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "R. Jabbarvand, S. Malek, \"\u03bcdroid: an energy-aware mutation testing framework for android\", <em>Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering</em>, pp. 208-219, 2017.", "title": "\u03bcdroid: an energy-aware mutation testing framework for android", "context": [{"sec": "fn1", "text": " We excluded 27 Android APIs in our study because the mutation analysis for Android apps is different from that for general Java projects [36]\u2013[38] (e.g., the former requires mutation operators to mutate the AndroidManifest.xml file).", "type": "footnote"}], "links": {"acmLink": "https://doi.org/10.1145/3106237.3106244", "abstract": "The rising popularity of mobile apps deployed on battery-constrained devices underlines the need for effectively evaluating their energy properties. However, currently there is a lack of testing tools for evaluating the energy properties of apps. As a result, for energy testing, developers are relying on tests intended for evaluating the functional correctness of apps. Such tests may not be adequate for revealing energy defects and inefficiencies in apps. This paper presents an energy-aware muta...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=%CE%BCdroid%3A+an+energy-aware+mutation+testing+framework+for+android&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "R. Just, D. Jalali, L. Inozemtseva, M. D. Ernst, R. Holmes, G. Fraser, \"Are mutants a valid substitute for real faults in software testing?\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering</em>, pp. 654-665, 2014.", "title": "Are mutants a valid substitute for real faults in software testing?", "context": [{"sec": "sec4b", "text": " We set this threshold to ensure the test suite's quality [39] since MutApi relies on the associated test suite to validate whether a mutant introduces an API misuse.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2635929", "abstract": "A good test suite is one that detects real faults. Because the set of faults in a program is usually unknowable, this definition is not useful to practitioners who are creating test suites, nor to researchers who are creating and evaluating tools that generate test suites. In place of real faults, testing research often uses mutants, which are artificial faults -- each one a simple syntactic variation -- that are systematically seeded throughout the program under test. Mutation analysis is appea...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Are+mutants+a+valid+substitute+for+real+faults+in+software+testing%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "<em>Apache category</em>, 2018,  [online]  Available: https://projects.apache.org/projects.html?category.", "title": "Apache category", "context": [{"sec": "sec4b", "text": " The categorization of the client projects is based on the Apache official definition [40] and GitHub Topics [41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+category&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "<em>Github topics</em>, 2018,  [online]  Available: https://github.com/topics.", "title": "Github topics", "context": [{"sec": "sec4b", "text": " The categorization of the client projects is based on the Apache official definition [40] and GitHub Topics [41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Github+topics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "<em>Apache fop</em>, 2018,  [online]  Available: https://github.com/apache/fop.git.", "title": "Apache fop", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+fop&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "<em>Swingx</em>, 2018,  [online]  Available: https://github.com/ebourg/swingx.git.", "title": "Swingx", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Swingx&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "<em>Jfreechart</em>, 2018,  [online]  Available: https://github.com/jfree/jfreechart.git.", "title": "Jfreechart", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Jfreechart&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "<em>itextpdf</em>, 2018,  [online]  Available: https://github.com/itext/itextpdf.git.", "title": "itextpdf", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=itextpdf&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "<em>Apache math</em>, 2018,  [online]  Available: https://github.com/apache/commons-math.git.", "title": "Apache math", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+math&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "<em>Apache text</em>, 2018,  [online]  Available: https://github.com/apache/commons-text.git.", "title": "Apache text", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+text&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "<em>Apache bcel</em>, 2018,  [online]  Available: https://github.com/apache/commons-bcel.git.", "title": "Apache bcel", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+bcel&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "<em>Fortress core</em>, 2018,  [online]  Available: https://github.com/apache/directory-fortress-core.git.", "title": "Fortress core", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Fortress+core&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "<em>Santuario-java</em>, 2018,  [online]  Available: https://github.com/apache/santuario-java.git.", "title": "Santuario-java", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Santuario-java&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "<em>Pdfbox</em>, 2018,  [online]  Available: https://github.com/apache/pdfbox.git.", "title": "Pdfbox", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Pdfbox&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "<em>Wildfly</em>, 2018,  [online]  Available: https://github.com/wildfly-security/wildfly-elytron.git.", "title": "Wildfly", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Wildfly&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "<em>Apache jackrabbit</em>, 2018,  [online]  Available: https://github.com/apache/jackrabbit.git.", "title": "Apache jackrabbit", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Apache+jackrabbit&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "<em>H2database</em>, 2018,  [online]  Available: https://github.com/h2database/h2database.git.", "title": "H2database", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=H2database&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "<em>Curator</em>, 2018,  [online]  Available: https://github.com/apache/curator.git.", "title": "Curator", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Curator&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "<em>Messagedigest</em>, 2018,  [online]  Available: https://stackoverflow.com/questions/16133881/messagedigest-nosuchalgorithmexception.", "title": "Messagedigest", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Messagedigest&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "<em>Matcher group api</em>, 2018,  [online]  Available: https://stackoverflow.com/questions/25851293/java-regex-why-matcher-group-does-not-work-without-matcher-find.", "title": "Matcher group api", "context": [], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Matcher+group+api&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "J. Zhang, L. Zhang, M. Harman, D. Hao, Y. Jia, L. Zhang, \"Predictive mutation testing\", <em>IEEE Transactions on Software Engineering</em>, 2018.", "title": "Predictive mutation testing", "context": [{"sec": "sec5c", "text": " Mutation analysis is known to be computationally expensive since it needs to compile the mutants and execute them against the associalted test suite [58], [59].", "part": "1"}], "links": {"abstract": "Test suites play a key role in ensuring software quality. A good test suite may detect more faults than a poor-quality one. Mutation testing is a powerful methodology for evaluating the fault-detection ability of test suites. In mutation testing, a large number of mutants may be generated and need to be executed against the test suite under evaluation to check how many mutants the test suite is able to detect, as well as the kind of mutants that the current test suite fails to detect. Consequent...", "pdfSize": "2179KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Predictive+mutation+testing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "B. Wang, Y. Xiong, Y. Shi, L. Zhang, D. Hao, \"Faster mutation analysis via equivalence modulo states\", <em>Proceedings of the 26th ACM SIGSOFT International Symposium on Software Testing and Analysis</em>, pp. 295-306, 2017.", "title": "Faster mutation analysis via equivalence modulo states", "context": [{"sec": "sec5c", "text": " Mutation analysis is known to be computationally expensive since it needs to compile the mutants and execute them against the associalted test suite [58], [59].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3092703.3092714", "abstract": "Mutation analysis has many applications, such as asserting the quality of test suites and localizing faults. One important bottleneck of mutation analysis is scalability. The latest work explores the possibility of reducing the redundant execution via split-stream execution. However, split-stream execution is only able to remove redundant execution before the first mutated statement.   In this paper we try to also reduce some of the redundant execution after the execution of the first mutated st...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Faster+mutation+analysis+via+equivalence+modulo+states&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "R. Paletov, P. Tsankov, V. Raychev, M. Vechev, \"Inferring crypto api rules from code changes\", <em>Proceedings of the 39th ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, pp. 450-464, 2018.", "title": "Inferring crypto api rules from code changes", "context": [{"sec": "sec6b", "text": "Cipher(\u201cDES\u201d) is a misuse since it should not be used with the DES mode [60].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/3192366.3192403", "abstract": "Creating and maintaining an up-to-date set of security rules that match misuses of crypto APIs is challenging, as crypto APIs constantly evolve over time with new cryptographic primitives and settings, making existing ones obsolete.   To address this challenge, we present a new approach to extract security fixes from thousands of code changes. Our approach consists of: (i) identifying code changes, which often capture security fixes, (ii) an abstraction that filters irrelevant code changes (such...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Inferring+crypto+api+rules+from+code+changes&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8812114", "articleId": "8812114", "startPage": "866", "endPage": "877", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/8790403/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=8811891", "publisher": "IEEE", "confLoc": "Montreal, QC, Canada, Canada", "chronDate": "25-31 May 2019", "metrics": {"citationCountPaper": 0, "citationCountPatent": 0, "totalDownloads": 126}}
{"title": "Semantically Enhanced Software Traceability Using Deep Learning Techniques", "authors": [{"name": "Jin Guo", "affiliation": "Univ. of Notre Dame, Notre Dame, IN, USA", "firstName": "Jin", "lastName": "Guo", "id": "37077711800"}, {"name": "Jinghui Cheng", "affiliation": "Univ. of Notre Dame, Notre Dame, IN, USA", "firstName": "Jinghui", "lastName": "Cheng", "id": "37086054191"}, {"name": "Jane Cleland-Huang", "affiliation": "Univ. of Notre Dame, Notre Dame, IN, USA", "firstName": "Jane", "lastName": "Cleland-Huang", "id": "38272771600"}], "abstract": "In most safety-critical domains the need for traceability is prescribed by certifying bodies. Trace links are generally created among requirements, design, source code, test cases and other artifacts, however, creating such links manually is time consuming and error prone. Automated solutions use information retrieval and machine learning techniques to generate trace links, however, current techniques fail to understand semantics of the software artifacts or to integrate domain knowledge into the tracing process and therefore tend to deliver imprecise and inaccurate results. In this paper, we present a solution that uses deep learning to incorporate requirements artifact semantics and domain knowledge into the tracing solution. We propose a tracing network architecture that utilizes Word Embedding and Recurrent Neural Network (RNN) models to generate trace links. Word embedding learns word vectors that represent knowledge of the domain corpus and RNN uses these word vectors to learn the sentence semantics of requirements artifacts. We trained 360 different configurations of the tracing network using existing trace links in the Positive Train Control domain and identified the Bidirectional Gated Recurrent Unit (BI-GRU) as the best model for the tracing task. BI-GRU significantly out-performed state-of-the-art tracing methods including the Vector Space Model and Latent Semantic Indexing.", "keywords": [{"type": "IEEE Keywords", "kwd": ["Semantics", "Machine learning", "Recurrent neural networks", "Standards", "Training", "Natural language processing", "Software"]}, {"type": "INSPEC: Controlled Indexing", "kwd": ["information retrieval", "knowledge representation", "learning (artificial intelligence)", "program diagnostics", "program testing", "programming language semantics", "recurrent neural nets", "safety-critical software", "source code (software)", "vectors"]}, {"type": "INSPEC: Non-Controlled Indexing", "kwd": ["semantically enhanced software traceability", "deep learning techniques", "safety-critical domains", "source code", "test cases", "information retrieval technique", "machine learning technique", "trace link generation", "requirements artifact semantics", "domain knowledge", "tracing network architecture", "word embedding model", "recurrent neural network model", "word vectors", "knowledge representation", "domain corpus", "sentence semantics", "requirements artifacts", "positive train control domain", "bidirectional gated recurrent unit", "BI-GRU", "vector space model", "latent semantic indexing"]}, {"type": "Author Keywords ", "kwd": ["Traceability", "Deep Learning", "Recurrent Neural Network", "Semantic Representation"]}], "publication": "2017 IEEE/ACM 39th International Conference on Software Engineering (ICSE)", "doi": "10.1109/ICSE.2017.9", "ref": [{"order": "1", "text": "G. Antoniol, G. Canfora, G. Casazza, A. De Lucia, E. Merlo, \"Recovering traceability links between code and documentation\", <em>IEEE Trans. Softw. Eng.</em>, vol. 28, no. 10, pp. 970-983, 2002.", "title": "Recovering traceability links between code and documentation", "context": [{"sec": "sec1", "text": "To address these problems, researchers have proposed and developed solutions for automating the task of creating and maintaining trace links [1], [17], [34].", "part": "1"}], "links": {"documentLink": "/document/1041053", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1041053", "abstract": "Software system documentation is almost always expressed informally in natural language and free text. Examples include requirement specifications, design documents, manual pages, system development journals, error logs, and related maintenance reports. We propose a method based on information retrieval to recover traceability links between source code and free text documents. A premise of our work is that programmers use meaningful names for program items, such as functions, variables, types, c...", "pdfSize": "772KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Recovering+traceability+links+between+code+and+documentation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref1"}, {"order": "2", "text": "C. Arora, M. Sabetzadeh, L. C. Briand, F. Zimmer, R. Gnaga, \"Automatic checking of conformance to requirement boilerplates via text chunking: An industrial case study\", <em>2013 ACM / IEEE International Symposium on Empirical Software Engineering and Measurement</em>, pp. 35-44, October 10\u201311, 2013.", "title": "Automatic checking of conformance to requirement boilerplates via text chunking: An industrial case study", "context": [{"sec": "sec6", "text": " Researchers have also used phrase detection and chunking to search for requirements impacted by change requests [2] or to improve the trace retrieval process [70].", "part": "1"}], "links": {"abstract": "Context. Boilerplates have long been used in Requirements Engineering (RE) to increase the precision of natural language requirements and to avoid ambiguity problems caused by unrestricted natural language. When boilerplates are used, an important quality assurance task is to verify that the requirements indeed conform to the boilerplates. Objective. If done manually, checking conformance to boilerplates is laborious, presenting a particular challenge when the task has to be repeated multiple ti...", "pdfSize": "497KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatic+checking+of+conformance+to+requirement+boilerplates+via+text+chunking%3A+An+industrial+case+study&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref2"}, {"order": "3", "text": "C. Arora, M. Sabetzadeh, A. Goknil, L. C. Briand, F. Zimmer, \"Change impact analysis for natural language requirements: An NLP approach\", <em>23rd IEEE International Requirements Engineering Conference RE 2015</em>, pp. 6-15, August 24\u201328, 2015.", "title": "Change impact analysis for natural language requirements: An NLP approach", "context": [{"sec": "sec1", "text": " It would also be missed by techniques that incorporate phrasing without understanding their conceptual associations [3], [15].", "part": "1"}], "links": {"documentLink": "/document/7320403", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=7320403", "abstract": "Requirements are subject to frequent changes as a way to ensure that they reflect the current best understanding of a system, and to respond to factors such as new and evolving needs. Changing one requirement in a requirements specification may warrant further changes to the specification, so that the overall correctness and consistency of the specification can be maintained. A manual analysis of how a change to one requirement impacts other requirements is time-consuming and presents a challeng...", "pdfSize": "907KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Change+impact+analysis+for+natural+language+requirements%3A+An+NLP+approach&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref3"}, {"order": "4", "text": "N. Assawamekin, T. Sunetnanta, C. Pluempitiwiriyawej, \"Ontology-based multiperspective requirements traceability framework\", <em>Knowl. Inf. Syst.</em>, vol. 25, no. 3, pp. 493-522, 2010.", "title": "Ontology-based multiperspective requirements traceability framework", "context": [{"sec": "sec6", "text": " Traceability researchers have proposed the idea of using ontology to connect source and target artifacts [31], [4].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10115-009-0259-2", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ontology-based+multiperspective+requirements+traceability+framework&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref4"}, {"order": "5", "text": "H. U. Asuncion, A. Asuncion, R. N. Taylor, \"Software traceability with topic modeling\", <em>32nd ACM/IEEE International Conference on Software Engineering (ICSE)</em>, pp. 95-104, 2010.", "title": "Software traceability with topic modeling", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}, {"sec": "sec4a", "text": " This dataset is considerably larger than those used in most previous studies on requirements traceability [5], [44], [34] and the task of creating links across such a large dataset represents a challenging industrial-strength tracing problem.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1806799.1806817", "abstract": "Software traceability is a fundamentally important task in software engineering. The need for automated traceability increases as projects become more complex and as the number of artifacts increases. We propose an automated technique that combines traceability with a machine learning technique known as topic modeling. Our approach automatically records traceability links during the software development process and learns a probabilistic topic model over artifacts. The learned model allows for t...", "pdfSize": "540KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+traceability+with+topic+modeling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref5"}, {"order": "6", "text": "D. Bahdanau, K. Cho, Y. Bengio, Neural machine translation by jointly learning to align and translate, CoRR, vol. abs/1409.0473, 2014.", "title": "Neural machine translation by jointly learning to align and translate", "context": [{"sec": "sec1", "text": "On the other hand, deep learning techniques have successfully been applied to solve many Natural Language Processing (NLP) tasks including parsing [63], sentiment analysis [66], question answering [35], and machine translation [6].", "part": "1"}, {"sec": "sec2b", "text": " In particular, RNN and its variants have produced significant breakthroughs in many NLP tasks including language modeling [49], machine translation [6], and semantic entailment [66].", "part": "1"}, {"sec": "sec2e", "text": " Despite having a simpler structure, GRU has achieved competitive results with LSTM for many NLP tasks [6], [13], and as such no decisive conclusion has been drawn about which model is better.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Neural+machine+translation+by+jointly+learning+to+align+and+translate&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref6"}, {"order": "7", "text": "I. G. Y. Bengio, A. Courville, Deep learning, MIT Press, 2016.", "title": "Deep learning", "context": [{"sec": "sec3b", "text": " This objective function is commonly used in categorical prediction models [7] and can be written as:\n where \\$\\theta\\$ indicates the network parameters that need to be trained, \\$N\\$ is the total number of examples in the training data, \\$x^{i}\\$ is the input of the \\$ith\\$ training example, \\$y^{i}\\$ is the actual category of that example (i.e. link or non-link); as a result, \\$P(Y=y^{i}\\vert x^{i}, \\theta)\\$ represents the network's prediction on the correct category given the current input and parameters.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Deep+learning&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref7"}, {"order": "8", "text": "Y. Bengio, \"Practical recommendations for gradient-based training of deep architectures\" in Neural Networks: Tricks of the Trade, Springer, pp. 437-478, 2012.", "title": "Practical recommendations for gradient-based training of deep architectures", "context": [{"sec": "sec4b", "text": " This was accomplished by manually observing how training loss changed during early epochs and following heuristics suggested in [8].", "part": "1"}, {"sec": "sec5c", "text": " We expect additional improvements by reconfiguring the tracing network for use with a larger training set [8].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Practical+recommendations+for+gradient-based+training+of+deep+architectures&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref8"}, {"order": "9", "text": "Y. Bengio, P. Simard, P. Frasconi, \"Learning long-term dependencies with gradient descent is difficult\", <em>IEEE transactions on neural networks</em>, vol. 5, no. 2, pp. 157-166, 1994.", "title": "Learning long-term dependencies with gradient descent is difficult", "context": [{"sec": "sec2c", "text": "A prominent drawback of the standard RNN model is that the network degrades when long dependencies exist in the sequence due to the phenomenon of exploding or vanishing gradients during back-propagation [9].", "part": "1"}, {"sec": "sec2c", "text": " Gradient Clipping) [9].", "part": "1"}], "links": {"documentLink": "/document/279181", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=279181", "abstract": "Recurrent neural networks can be used to map input sequences to output sequences, such as for recognition, production or prediction problems. However, practical difficulties have been reported in training recurrent neural networks to perform tasks in which the temporal contingencies present in the input/output sequences span long intervals. We show why gradient based learning algorithms face an increasingly difficult problem as the duration of the dependencies to be captured increases. These res...", "pdfSize": "1180KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+long-term+dependencies+with+gradient+descent+is+difficult&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref9"}, {"order": "10", "text": "T. J. Biggerstaff, B. G. Mitbander, D. E. Webster, \"Program understanding and the concept assignment problem\", <em>Communications of the ACM</em>, vol. 37, no. 5, pp. 72-82, 1994.", "title": "Program understanding and the concept assignment problem", "context": [{"sec": "sec1", "text": "One of the primary reasons that automated approaches have underperformed is the term mismatch that often exists between pairs of related artifacts [10].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/175290.175300", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Program+understanding+and+the+concept+assignment+problem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref10"}, {"order": "11", "text": "M. Buckland, F. Gey, \"The relationship between recall and precision\", <em>Journal of the American society for information science</em>, vol. 45, no. 1, pp. 12, 1994.", "title": "The relationship between recall and precision", "context": [{"sec": "sec4c", "text": " The Precision-Recall Curve thus shows trade-offs between precision and recall and provides insights into where each method performs best - for example, whether a technique improves precision at higher or lower levels of recall [11].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1002/(SICI)1097-4571(199401)45:1&lt;12::AID-ASI2&gt;3.0.CO;2-L", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=The+relationship+between+recall+and+precision&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref11"}, {"order": "12", "text": "K. Cho, B. Van Merri\u00ebnboer, D. Bahdanau, Y. Bengio, <em>On the properties of neural machine translation: Encoder-decoder approaches</em>, 2014.", "title": "On the properties of neural machine translation: Encoder-decoder approaches", "context": [{"sec": "sec2e", "text": "Finally, the recently proposed Gated Recurrent Unit (GRU) model also uses a gating mechanism to control the information flow within a unit; but it has a simplified unit structure and does not have a dedicated memory cell vector [12].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=On+the+properties+of+neural+machine+translation%3A+Encoder-decoder+approaches&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref12"}, {"order": "13", "text": "J. Chung, C. Gulcehre, K. Cho, Y. Bengio, <em>Empirical evaluation of gated recurrent neural networks on sequence modeling</em>, 2014.", "title": "Empirical evaluation of gated recurrent neural networks on sequence modeling", "context": [{"sec": "sec2d", "text": " In (2b), \\$r\\$ is the reset gate and \\$u\\$ is the update gate [13].", "part": "1"}, {"sec": "sec2e", "text": " Despite having a simpler structure, GRU has achieved competitive results with LSTM for many NLP tasks [6], [13], and as such no decisive conclusion has been drawn about which model is better.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Empirical+evaluation+of+gated+recurrent+neural+networks+on+sequence+modeling&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref13"}, {"order": "14", "text": "J. Cleland-Huang, O. Gotel, J. H. Hayes, P. M\u00e4der, A. Zisman, \"Software traceability: trends and future directions\", <em>Proceedings of the on Future of Software Engineering FOSE 2014</em>, pp. 55-69, May 31\u2013June 7, 2014.", "title": "Software traceability: trends and future directions", "context": [{"sec": "sec1", "text": " Unfortunately, the tracing task is arduous to perform and error-prone [46], even when industrial tools are used to manually create links or to capture them as a byproduct of the development process [14].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2593882.2593891", "abstract": "Software traceability is a sought-after, yet often elusive quality in software-intensive systems. Required in safety-critical systems by many certifying bodies, such as the USA Federal Aviation Authority, software traceability is an essential element of the software development process. In practice, traceability is often conducted in an ad-hoc, after-the-fact manner and, therefore, its benefits are not always fully realized. Over the past decade, researchers have focused on specific areas of the...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Software+traceability%3A+trends+and+future+directions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref14"}, {"order": "15", "text": "J. Cleland-Huang, J. Guo, \"Towards more intelligent trace retrieval algorithms\", <em>(RAISE) Workshop on Realizing Artificial Intelligence Synergies in Software Engineering</em>, 2014.", "title": "Towards more intelligent trace retrieval algorithms", "context": [{"sec": "sec1", "text": " It would also be missed by techniques that incorporate phrasing without understanding their conceptual associations [3], [15].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2593801.2593802", "abstract": "Automated trace creation techniques are based on a variety of algorithms ranging from basic term matching approaches to more sophisticated expert systems. In this position paper we propose a classification scheme for categorizing the intelligence level of automated traceability techniques. We show that the vast majority of relevant work in the past decade has been focused at the lowest level of the Traceability Intelligence Quotient (tIQ) and posit that achieving high quality automated traceabil...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+more+intelligent+trace+retrieval+algorithms&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref15"}, {"order": "16", "text": "J. Cleland-Huang, M. Rahimi, P. M\u00e4der, \"Achieving lightweight trustworthy traceability\", <em>Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE-22)</em>, pp. 849-852, November 16\u201322, 2014.", "title": "Achieving lightweight trustworthy traceability", "context": [{"sec": "sec1", "text": " In practice, trace links are often incomplete and inaccurate [16], even in safety-critical systems [45], [56].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2635868.2666612", "abstract": "Despite the fact that traceability is a required element of almost all safety-critical software development processes, the trace data is often incomplete, inaccurate, redundant, conflicting, and outdated. As a result, it is neither trusted nor trustworthy. In this vision paper we propose a philosophical change in the traceability landscape which transforms traceability from a heavy-weight process producing untrusted trace links, to a light-weight results-oriented trustworthy solution. Current tr...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Achieving+lightweight+trustworthy+traceability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref16"}, {"order": "17", "text": "A. De Lucia, F. Fasano, R. Oliveto, G. Tortora, \"Enhancing an artefact management system with traceability recovery features\", <em>International Conference on Software Maintenance</em>, pp. 306-315, 2004.", "title": "Enhancing an artefact management system with traceability recovery features", "context": [{"sec": "sec1", "text": "To address these problems, researchers have proposed and developed solutions for automating the task of creating and maintaining trace links [1], [17], [34].", "part": "1"}, {"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}], "links": {"documentLink": "/document/1357816", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1357816", "abstract": "We present a traceability recovery method and tool based on latent semantic indexing (LSI) in the context of an artefact management system. The tool highlights the candidate links not identified yet by the software engineer and the links identified but missed by the tool, probably due to inconsistencies in the usage of domain terms in the traced software artefacts. We also present a case study of using the traceability recovery tool on software artefacts belonging to different categories of docu...", "pdfSize": "509KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enhancing+an+artefact+management+system+with+traceability+recovery+features&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref17"}, {"order": "18", "text": "A. Dekhtyar, J. Huffman Hayes, S. K. Sundaram, E. A. Holbrook, O. Dekhtyar, \"Technique integration for requirements assessment\", <em>15th IEEE International Requirements Engineering Conference (RE)</em>, pp. 141-150, 2007.", "title": "Technique integration for requirements assessment", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}], "links": {"documentLink": "/document/4384177", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=4384177", "abstract": "In determining whether to permit a safety-critical software system to be certified and in performing independent verification and validation (IV&V) of safety- or mission-critical systems, the requirements traceability matrix (RTM) delivered by the developer must be assessed for accuracy. The current state of the practice is to perform this work manually, or with the help of general-purpose tools such as word processors and spreadsheets Such work is error-prone and person-power intensive. In this...", "pdfSize": "190KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Technique+integration+for+requirements+assessment&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref18"}, {"order": "19", "text": "T. Dietrich, J. Cleland-Huang, Y. Shin, \"Learning effective query transformations for enhanced requirements trace retrieval\", <em>2013 28th IEEE/ACM International Conference on Automated Software Engineering ASE 2013</em>, pp. 586-591, November 11\u201315, 2013.", "title": "Learning effective query transformations for enhanced requirements trace retrieval", "context": [{"sec": "sec6", "text": " Dietrich et al. utilized validated trace links to identify frequent item sets of terms occurring across pairs of source and target artifacts, and then used these to augment the text in the trace query [19].", "part": "1"}], "links": {"documentLink": "/document/6693117", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6693117", "abstract": "In automated requirements traceability, significant improvements can be realized through incorporating user feedback into the trace retrieval process. However, existing feedback techniques are designed to improve results for individual queries. In this paper we present a novel technique designed to extend the benefits of user feedback across multiple trace queries. Our approach, named Trace Query Transformation (TQT), utilizes a novel form of Association Rule Mining to learn a set of query trans...", "pdfSize": "416KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+effective+query+transformations+for+enhanced+requirements+trace+retrieval&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref19"}, {"order": "20", "text": "B. Dit, M. Revelle, D. Poshyvanyk, \"Integrating information retrieval execution and link analysis analysis algorithms to improve feature location in software\", <em>Empirical Software Engineering</em>, vol. 18, no. 2, pp. 277-309, 2013.", "title": "Integrating information retrieval, execution and link analysis analysis algorithms to improve feature location in software", "context": [{"sec": "sec1", "text": " Other approaches, especially in the area of feature location [20], require additional information obtained from runtime execution traces.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-011-9194-4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Integrating+information+retrieval%2C+execution+and+link+analysis+analysis+algorithms+to+improve+feature+location+in+software&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref20"}, {"order": "21", "text": "D. Erhan, Y. Bengio, A. Courville, P.-A. Manzagol, P. Vincent, S. Bengio, \"Why does unsupervised pre-training help deep learning?\", <em>Journal of Machine Learning Research</em>, vol. 11, pp. 625-660, Feb 2010.", "title": "Why does unsupervised pre-training help deep learning?", "context": [{"sec": "sec2a", "text": " The use of learned word vectors is considered one of the primary reasons for the success of recent deep learning models for NLP tasks [21].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Why+does+unsupervised+pre-training+help+deep+learning%3F&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref21"}, {"order": "22", "text": "<em>DO-178B: Software Considerations in Airborne Systems and Equipment Certification</em>.", "title": "DO-178B: Software Considerations in Airborne Systems and Equipment Certification", "context": [{"sec": "sec1", "text": " In high-dependability systems, regulatory standards, such as the US Federal Aviation Authority's (FAA) DO178b/c [22], prescribe the need for trace links to be established and maintained between hazards, faults, requirements, design, code, and test cases in order to demonstrate that a system is safe for use [38], [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=DO-178B%3A+Software+Considerations+in+Airborne+Systems+and+Equipment+Certification&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref22"}, {"order": "23", "text": "<em>Guidance for the Content of Premarket Submissions for Software Contained in Medical Devices 2005</em>.", "title": "Guidance for the Content of Premarket Submissions for Software Contained in Medical Devices, 2005", "context": [{"sec": "sec1", "text": " In high-dependability systems, regulatory standards, such as the US Federal Aviation Authority's (FAA) DO178b/c [22], prescribe the need for trace links to be established and maintained between hazards, faults, requirements, design, code, and test cases in order to demonstrate that a system is safe for use [38], [23].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Guidance+for+the+Content+of+Premarket+Submissions+for+Software+Contained+in+Medical+Devices%2C+2005&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref23"}, {"order": "24", "text": "M. Gibiec, A. Czauderna, J. Cleland-Huang, \"Towards mining replacement queries for hard-to-retrieve traces\", <em>ASE '10: Proceedings of the IEEE/ACM international conference on Automated software engineering</em>, pp. 245-254, 2010.", "title": "Towards mining replacement queries for hard-to-retrieve traces", "context": [{"sec": "sec6", "text": " [24] approached trace query augmentation by acquiring related documents from the Internet, and then extracting domain related terms.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1858996.1859046", "abstract": "Automated trace retrieval methods can significantly reduce the cost and effort needed to create and maintain requirements traces. However, the set of generated traces is generally quite imprecise and must be manually evaluated by analysts. In applied settings when the retrieval algorithm is unable to find the relevant links for a given query, a human user can improve the trace results by manually adding additional search terms and filtering out unhelpful ones. However, the effectiveness of this ...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+mining+replacement+queries+for+hard-to-retrieve+traces&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref24"}, {"order": "25", "text": "O. Gotel, J. Cleland-Huang, J. H. Hayes, A. Zisman, A. Egyed, P. Gr\u00fcnbacher, A. Dekhtyar, G. Antoniol, J. I. Maletic, P. M\u00e4der, Traceability fundamentals. In Software and Systems Traceability, Springer, pp. 3-22, 2012.", "title": "Traceability fundamentals. In Software and Systems Traceability", "context": [{"sec": "sec1", "text": " Defined as \u201cthe ability to describe and follow the life of a requirement in both a forwards and backwards direction through periods of ongoing refinement and iteration\u201d [26], traceability supports a diverse set of software engineering activities including change impact analysis, regression test selection, cost prediction, and compliance verification [25].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/978-1-4471-2239-5_1", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Traceability+fundamentals.+In+Software+and+Systems+Traceability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref25"}, {"order": "26", "text": "O. C. Z. Gotel, A. Finkelstein, \"An analysis of the requirements traceability problem\", <em>Proceedings of the First IEEE International Conference on Requirements Engineering ICRE '94</em>, pp. 94-101, April 18\u201321, 1994.", "title": "An analysis of the requirements traceability problem", "context": [{"sec": "sec1", "text": " Defined as \u201cthe ability to describe and follow the life of a requirement in both a forwards and backwards direction through periods of ongoing refinement and iteration\u201d [26], traceability supports a diverse set of software engineering activities including change impact analysis, regression test selection, cost prediction, and compliance verification [25].", "part": "1"}], "links": {"abstract": "Investigates and discusses the underlying nature of the requirements traceability problem. Our work is based on empirical studies, involving over 100 practitioners, and an evaluation of current support. We introduce the distinction between pre-requirements specification (pre-RS) traceability and post-requirements specification (post-RS) traceability to demonstrate why an all-encompassing solution to the problem is unlikely, and to provide a framework through which to understand its multifaceted ...", "pdfSize": "990KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=An+analysis+of+the+requirements+traceability+problem&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref26"}, {"order": "27", "text": "T. Gruber, \"Ontology\" in Encyclopedia of Database Systems, Springer US, pp. 1963-1965, 2009.", "title": "Ontology", "context": [{"sec": "sec6", "text": "Researchers have also explored the use of knowledge bases to create and utilize semantically aware associations in the trace creation process - where a knowledge base include basic domain terms and sentences that describe the relationships between those terms [36], [27], [62].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ontology&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref27"}, {"order": "28", "text": "J. Guo, J. Cleland-Huang, B. Berenbach, \"Foundations for an expert system in domain-specific traceability\", <em>21st IEEE International Requirements Engineering Conference RE 2013</em>, pp. 42-51, July 15\u201319, 2013.", "title": "Foundations for an expert system in domain-specific traceability", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}, {"sec": "sec6", "text": "Finally, while researchers have proposed techniques that more closely mimic the way human analysts reason about trace links and perform tracing tasks [28], [46], there is very limited work in this area.", "part": "1"}, {"sec": "sec6", "text": " Our prior work with DoCIT, described in Section I, is one exception [28].", "part": "1"}], "links": {"abstract": "Attempts to utilize information retrieval techniques to fully automate the creation of traceability links have been hindered by terminology mismatches between source and target artifacts. Therefore, current trace retrieval algorithms tend to produce imprecise and incomplete results. In this paper we address this mismatch by proposing an expert system which integrates a knowledge base of domain concepts and their relationships, a set of logic rules for defining relationships between artifacts bas...", "pdfSize": "759KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Foundations+for+an+expert+system+in+domain-specific+traceability&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref28"}, {"order": "29", "text": "J. Guo, N. Monaikul, C. Plepel, J. Cleland-Huang, \"Towards an intelligent domain-specific traceability solution\", <em>Proceedings of the 29th ACM/IEEE internationalconference on Automated software engineering</em>, pp. 755-766, 2014.", "title": "Towards an intelligent domain-specific traceability solution", "context": [{"sec": "sec1", "text": "In our prior work we developed Domain-Contextualized Intelligent Traceability (DoCIT) [29] as a proof of concept solution to investigate the integration of domain knowledge into the tracing process.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2642937.2642970", "abstract": "State-of-the-art software trace retrieval techniques are unable to perform the complex reasoning that a human analyst follows in order to create accurate trace links between artifacts such as regulatory codes and requirements. As a result, current algorithms often generate imprecise links. To address this problem, we present the Domain-Contextualized Intelligent Traceability Solution (DoCIT), designed to mimic some of the higher level reasoning that a human trace analyst performs. We focus our e...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Towards+an+intelligent+domain-specific+traceability+solution&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref29"}, {"order": "30", "text": "J. Guo, M. Rahimi, J. Cleland-Huang, A. Rasin, J. H. Hayes, M. Vierhauser, \"Cold-start software analytics\", <em>Proceedings of the 13th International Conference on Mining Software Repositories MSR 2016</em>, pp. 142-153, May 14\u201322, 2016.", "title": "Cold-start software analytics", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}, {"sec": "sec4a", "text": "Software project data exhibits special characteristics that impact the training of a neural network [30].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2901739.2901740", "abstract": "Software project artifacts such as source code, requirements, and change logs represent a gold-mine of actionable information. As a result, software analytic solutions have been developed to mine repositories and answer questions such as &#34;who is the expert?,&#34; &#34;which classes are fault prone?,&#34; or even &#34;who are the domain experts for these fault-prone classes?&#34; Analytics often require training and configuring in order to maximize performance within the context of each project. A cold-start problem...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Cold-start+software+analytics&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref30"}, {"order": "31", "text": "S. Hayashi, T. Yoshikawa, M. Saeki, J. Han, T. D. Thu, \"Sentence-to-code traceability recovery with domain ontologies\", <em>APSEC</em>, pp. 385-394, 2010.", "title": "Sentence-to-code traceability recovery with domain ontologies", "context": [{"sec": "sec6", "text": " Traceability researchers have proposed the idea of using ontology to connect source and target artifacts [31], [4].", "part": "1"}], "links": {"abstract": "We propose an ontology-based technique for recovering trace ability links between a natural language sentence specifying features of a software product and the source code of the product. Some software products have been released without detailed documentation. To automatically detect code fragments associated with sentences describing a feature, the relations between source code structures and problem domains are important. We model the knowledge of the problem domains as domain ontologies havi...", "pdfSize": "616KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Sentence-to-code+traceability+recovery+with+domain+ontologies&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref31"}, {"order": "32", "text": "S. Haykin, Neural Networks: A Comprehensive Foundation, Upper Saddle River, NJ, USA:Prentice Hall PTR, 1994.", "title": "Neural Networks: A Comprehensive Foundation", "context": [{"sec": "sec2b", "text": " Feedforward networks, also referred to as multi-layer perceptrons (MLPs), represent a traditional neural network structure and lay the foundation for many other structures [32].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Neural+Networks%3A+A+Comprehensive+Foundation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref32"}, {"order": "33", "text": "S. Hochreiter, J. Schmidhuber, \"Long short-term memory\", <em>Neural computation</em>, vol. 9, no. 8, pp. 1735-1780, 1997.", "title": "Long short-term memory", "context": [{"sec": "sec2d", "text": "LSTM networks include a memory cell vector in the recurrent unit to preserve long term dependencies [33].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1162/neco.1997.9.8.1735", "abstract": "Learning to store information over extended time intervals by recurrent backpropagation takes a very long time, mostly because of insufficient, decaying error backflow. We briefly review Hochreiter&#39;s (1991) analysis of this problem, then address it by introducing a novel, efficient, gradient based method called long short-term memory (LSTM). Truncating the gradient where this does not do harm, LSTM can learn to bridge minimal time lags in excess of 1000 discrete-time steps by enforcing constant ...", "pdfSize": "237KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Long+short-term+memory&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref33"}, {"order": "34", "text": "J. Huffman Hayes, A. Dekhtyar, S. K. Sundaram, \"Advancing candidate link generation for requirements tracing: The study of methods\", <em>IEEE Transactions on Software Engineering</em>, vol. 32, no. 1, pp. 4-19, 2006.", "title": "Advancing candidate link generation for requirements tracing: The study of methods", "context": [{"sec": "sec1", "text": "To address these problems, researchers have proposed and developed solutions for automating the task of creating and maintaining trace links [1], [17], [34].", "part": "1"}, {"sec": "sec3", "text": " The process is repeated for all source artifacts [34].", "part": "1"}, {"sec": "sec4a", "text": " This dataset is considerably larger than those used in most previous studies on requirements traceability [5], [44], [34] and the task of creating links across such a large dataset represents a challenging industrial-strength tracing problem.", "part": "1"}, {"sec": "sec4c", "text": " Finally, we configured VSM to use a local Inverse Document Frequency (IDF) weighting scheme when calculating the cosine similarity [34].", "part": "1"}, {"sec": "sec6", "text": " Researchers have attempted to improve bag-of-word approaches such as the Vector Space Model (VSM) [34] by integrating matching terms, project glossaries, and other forms of thesauri [34].", "part": "1"}, {"sec": "sec6", "text": " Basic enhancements have included user feedback techniques such as Rocchio [34] or Direct Query manipulation (DQM) [61] to increase or decrease term weights.", "part": "1"}, {"sec": "sec7", "text": " MAP, Recall, and Precision) are all accepted research standards for evaluating trace results [34].", "part": "1"}], "links": {"documentLink": "/document/1583599", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1583599", "abstract": "This paper addresses the issues related to improving the overall quality of the dynamic candidate link generation for the requirements tracing process for verification and validation and independent verification and validation analysts. The contribution of the paper is four-fold: we define goals for a tracing tool based on analyst responsibilities in the tracing process, we introduce several new measures for validating that the goals have been satisfied, we implement analyst feedback in the trac...", "pdfSize": "2833KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Advancing+candidate+link+generation+for+requirements+tracing%3A+The+study+of+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref34"}, {"order": "35", "text": "M. Iyyer, J. L. Boyd-Graber, L. M. B. Claudino, R. Socher, H. Daum\u00e9, \"A neural network for factoid question answering over paragraphs\", <em>EMNLP</em>, pp. 633-644, 2014.", "title": "A neural network for factoid question answering over paragraphs", "context": [{"sec": "sec1", "text": "On the other hand, deep learning techniques have successfully been applied to solve many Natural Language Processing (NLP) tasks including parsing [63], sentiment analysis [66], question answering [35], and machine translation [6].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3115/v1/D14-1070", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+neural+network+for+factoid+question+answering+over+paragraphs&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref35"}, {"order": "36", "text": "P. Jackson, Introduction To Expert Systems (3 ed.), Addison Wesley, 1998.", "title": "Introduction To Expert Systems (3 ed.)", "context": [{"sec": "sec6", "text": "Researchers have also explored the use of knowledge bases to create and utilize semantically aware associations in the trace creation process - where a knowledge base include basic domain terms and sentences that describe the relationships between those terms [36], [27], [62].", "part": "1"}, {"sec": "sec6", "text": " Data is typically represented as an ontology in which relationships are represented using AND, OR, implication, and negation operators [36].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Introduction+To+Expert+Systems+%283+ed.%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref36"}, {"order": "37", "text": "A. Karpathy, J. Johnson, F. Li, Visualizing and understanding recurrent networks, CoRR, vol. abs/1506.02078, 2015.", "title": "Visualizing and understanding recurrent networks", "context": [{"sec": "sec5b", "text": "While it is almost impossible to completely decipher how GRU extracts a semantic vector from natural language [37], observing gate behavior when GRU processes a sentence can provide some insights into how GRU performs this task so well.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Visualizing+and+understanding+recurrent+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref37"}, {"order": "38", "text": "J. C. Knight, \"Safety critical systems: challenges and directions\", <em>24th International Conf. on Software Engineering ICSE 2002</em>, pp. 547-550, 19\u201325 May 2002.", "title": "Safety critical systems: challenges and directions", "context": [{"sec": "sec1", "text": " In high-dependability systems, regulatory standards, such as the US Federal Aviation Authority's (FAA) DO178b/c [22], prescribe the need for trace links to be established and maintained between hazards, faults, requirements, design, code, and test cases in order to demonstrate that a system is safe for use [38], [23].", "part": "1"}], "links": {"documentLink": "/document/1007998", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=1007998", "abstract": "Safety-critical systems are those systems whose failure could result in loss of life, significant property damage or damage to the environment. There are many well-known examples in application areas such as medical devices, aircraft flight control, weapons and nuclear systems. Many modern information systems are becoming safety-critical in a general sense because financial loss and even loss of life can result from their failure. Future safety-critical systems will be more common and more power...", "pdfSize": "461KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Safety+critical+systems%3A+challenges+and+directions&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref38"}, {"order": "39", "text": "A. N. Lam, A. T. Nguyen, H. A. Nguyen, T. N. Nguyen, \"Combining deep learning with information retrieval to localize buggy files for bug reports (n)\", <em>Automated Software Engineering (ASE) 2015 30th IEEE/ACM International Conference on</em>, pp. 476-481, 2015.", "title": "Combining deep learning with information retrieval to localize buggy files for bug reports (n)", "context": [{"sec": "sec6", "text": " For example, Lam et al. combined deep neural networks with information retrieval techniques to identify buggy files in bug reports [39].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Combining+deep+learning+with+information+retrieval+to+localize+buggy+files+for+bug+reports+%28n%29&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref39"}, {"order": "40", "text": "Y. LeCun, B. Boser, J. S. Denker, D. Henderson, R. E. Howard, W. Hubbard, L. D. Jackel, \"Backpropagation applied to handwritten zip code recognition\", <em>Neural computation</em>, vol. 1, no. 4, pp. 541-551, 1989.", "title": "Backpropagation applied to handwritten zip code recognition", "context": [{"sec": "sec2b", "text": " For example, convolutional neural networks (CNNs) are especially well suited for image recognition and video analysis tasks [40].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1162/neco.1989.1.4.541", "abstract": "The ability of learning networks to generalize can be greatly enhanced by providing constraints from the task domain. This paper demonstrates how such constraints can be integrated into a backpropagation network through the architecture of the network. This approach has been successfully applied to the recognition of handwritten zip code digits provided by the U.S. Postal Service. A single network learns the entire recognition operation, going from the normalized image of the character to the fi...", "pdfSize": "619KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Backpropagation+applied+to+handwritten+zip+code+recognition&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref40"}, {"order": "41", "text": "O. Levy, Y. Goldberg, I. Dagan, \"Improving distributional similarity with lessons learned from word embeddings\", <em>Transactions of the Associationfor Computational Linguistics</em>, vol. 3, pp. 211-225, 2015.", "title": "Improving distributional similarity with lessons learned from word embeddings", "context": [{"sec": "sec2a", "text": " The GloVe model uses matrix factorization; however we do not discuss it further because its performance is equivalent to the Skip-gram with negative sampling approach while it is less robust and utilizes more system resources [41].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+distributional+similarity+with+lessons+learned+from+word+embeddings&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref41"}, {"order": "42", "text": "Y. Li, J. Cleland-Huang, \"Ontology-based trace retrieval\", <em>Traceability in Emerging Forms of Software Engineering (TEFSE2013</em>, May 2009.", "title": "Ontology-based trace retrieval", "context": [{"sec": "sec6", "text": " Approaches have been proposed for weighting the evidence for a trace link according to distance between concepts in the ontology [42].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ontology-based+trace+retrieval&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref42"}, {"order": "43", "text": "S. Lohar, S. Amornborvornwong, A. Zisman, J. Cleland-Huang, \"Improving trace accuracy through data-driven configuration and composition of tracing features\", <em>9th Joint Meeting on Foundations of Software Engineering (ESEC/FSE)</em>, pp. 378-388, 2013.", "title": "Improving trace accuracy through data-driven configuration and composition of tracing features", "context": [{"sec": "sec1", "text": " Results have been mixed, especially when applied to industrial-sized datasets, where acceptable recall levels above 90% can often only be achieved at extremely low levels of precision [43].", "part": "1"}, {"sec": "sec4c", "text": " To make a fair comparison, we also optimized the configurations for the VSM and the LSI methods using a Genetic Algorithm to search through an extensive configuration space of preprocessors and parameters [43].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2491411.2491432", "abstract": "Software traceability is a sought-after, yet often elusive quality in large software-intensive systems primarily because the cost and effort of tracing can be overwhelming. State-of-the art solutions address this problem through utilizing trace retrieval techniques to automate the process of creating and maintaining trace links. However, there is no simple one- size-fits all solution to trace retrieval. As this paper will show, finding the right combination of tracing techniques can lead to sign...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+trace+accuracy+through+data-driven+configuration+and+composition+of+tracing+features&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref43"}, {"order": "44", "text": "A. D. Lucia, F. Fasano, R. Oliveto, G. Tortora, \"Recovering traceability links in software artifact management systems using information retrieval methods\", <em>ACM Transactions on Software Engineering and Methodology (TOSEM)</em>, vol. 16, no. 4, pp. 13, 2007.", "title": "Recovering traceability links in software artifact management systems using information retrieval methods", "context": [{"sec": "sec4a", "text": " This dataset is considerably larger than those used in most previous studies on requirements traceability [5], [44], [34] and the task of creating links across such a large dataset represents a challenging industrial-strength tracing problem.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/1276933.1276934", "abstract": "The main drawback of existing software artifact management systems is the lack of automatic or semi-automatic traceability link generation and maintenance. We have improved an artifact management system with a traceability recovery tool based on Latent Semantic Indexing (LSI), an information retrieval technique. We have assessed LSI to identify strengths and limitations of using information retrieval techniques for traceability recovery and devised the need for an incremental approach. The metho...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Recovering+traceability+links+in+software+artifact+management+systems+using+information+retrieval+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref44"}, {"order": "45", "text": "P. M\u00e4der, P. L. Jones, Y. Zhang, J. Cleland-Huang, \"Strategic traceability for safety-critical projects\", <em>IEEE Software</em>, vol. 30, no. 3, pp. 58-66, 2013.", "title": "Strategic traceability for safety-critical projects", "context": [{"sec": "sec1", "text": " In practice, trace links are often incomplete and inaccurate [16], even in safety-critical systems [45], [56].", "part": "1"}], "links": {"documentLink": "/document/6504885", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6504885", "abstract": "To support any claim that a product is safe for its intended use, manufacturers must establish traceability within that product&#39;s development life cycle. Unfortunately, traceability information submitted to regulators and third parties is often weak, casting doubt rather than confidence in a product&#39;s integrity. This article evaluates traceability information for 10 submissions prepared by manufacturers for review at the US Food and Drug Administration. The authors observed nine widespread trace...", "pdfSize": "1734KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Strategic+traceability+for+safety-critical+projects&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref45"}, {"order": "46", "text": "A. Mahmoud, N. Niu, S. Xu, \"A semantic relatedness approach for traceability link recovery\", <em>IEEE 20th International Conference on Program Comprehension ICPC 2012</em>, pp. 183-192, June 11\u201313, 2012.", "title": "A semantic relatedness approach for traceability link recovery", "context": [{"sec": "sec1", "text": " Unfortunately, the tracing task is arduous to perform and error-prone [46], even when industrial tools are used to manually create links or to capture them as a byproduct of the development process [14].", "part": "1"}, {"sec": "sec6", "text": "Finally, while researchers have proposed techniques that more closely mimic the way human analysts reason about trace links and perform tracing tasks [28], [46], there is very limited work in this area.", "part": "1"}], "links": {"abstract": "Human analysts working with automated tracing tools need to directly vet candidate traceability links in order to determine the true traceability information. Currently, human intervention happens at the end of the traceability process, after candidate traceability links have already been generated. This often leads to a decline in the results&#39; accuracy. In this paper, we propose an approach, based on semantic relatedness (SR), which brings human judgment to an earlier stage of the tracing proce...", "pdfSize": "1225KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+semantic+relatedness+approach+for+traceability+link+recovery&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref46"}, {"order": "47", "text": "A. Mahmoud, G. Williams, \"Detecting classifying and tracing nonfunctional software requirements\", <em>Requir. Eng.</em>, vol. 21, no. 3, pp. 357-381, 2016.", "title": "Detecting, classifying, and tracing nonfunctional software requirements", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s00766-016-0252-8", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Detecting%2C+classifying%2C+and+tracing+nonfunctional+software+requirements&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref47"}, {"order": "48", "text": "T. Mikolov, K. Chen, G. Corrado, J. Dean, Efficient estimation of word representations in vector space, CoRR, vol. abs/1301.3781, 2013.", "title": "Efficient estimation of word representations in vector space", "context": [{"sec": "sec2a", "text": " In addition, the embedded word vectors encode syntactic and semantic relationships between words as linear relationships between word vectors [48].", "part": "1"}, {"sec": "sec2a", "text": "Skip-gram with negative sampling [48], [50] and GloVe [53] are the most popular word embedding models due to the notable improvement they bring to word analogy tasks over more traditional approaches such as Latent Semantic Analysis [48], [53].", "part": "1"}, {"sec": "sec2a", "text": " The Skip-gram model scans context windows across the entire training text to train prediction models [48].", "part": "1"}, {"sec": "sec4b", "text": "For learning the word embeddings, we used the Skip-gram model provided by the Word2vec tool [48].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Efficient+estimation+of+word+representations+in+vector+space&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref48"}, {"order": "49", "text": "T. Mikolov, M. Karafi\u00e1t, L. Burget, J. Cernocky, S. Khudanpur, \"Recurrent neural network based language model\", <em>Interspeech</em>, vol. 2, pp. 3, 2010.", "title": "Recurrent neural network based language model", "context": [{"sec": "sec2b", "text": " In particular, RNN and its variants have produced significant breakthroughs in many NLP tasks including language modeling [49], machine translation [6], and semantic entailment [66].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Recurrent+neural+network+based+language+model&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref49"}, {"order": "50", "text": "T. Mikolov, I. Sutskever, K. Chen, G. Corrado, J. Dean, Distributed representations of words and phrases and their compositionality, CoRR, vol. abs/1310.4546, 2013.", "title": "Distributed representations of words and phrases and their compositionality", "context": [{"sec": "sec2a", "text": "Skip-gram with negative sampling [48], [50] and GloVe [53] are the most popular word embedding models due to the notable improvement they bring to word analogy tasks over more traditional approaches such as Latent Semantic Analysis [48], [53].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Distributed+representations+of+words+and+phrases+and+their+compositionality&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref50"}, {"order": "51", "text": "N. Niu, A. Mahmoud, \"Enhancing candidate link generation for requirements tracing: The cluster hypothesis revisited\", <em>2012 20th IEEE International Requirements Engineering Conference (RE)</em>, pp. 81-90, September 24\u201328, 2012.", "title": "Enhancing candidate link generation for requirements tracing: The cluster hypothesis revisited", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}], "links": {"documentLink": "/document/6345842", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6345842", "abstract": "Modern requirements tracing tools employ information retrieval methods to automatically generate candidate links. Due to the inherent trade-off between recall and precision, such methods cannot achieve a high coverage without also retrieving a great number of false positives, causing a significant drop in result accuracy. In this paper, we propose an approach to improving the quality of candidate link generation for the requirements tracing process. We base our research on the cluster hypothesis...", "pdfSize": "749KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Enhancing+candidate+link+generation+for+requirements+tracing%3A+The+cluster+hypothesis+revisited&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref51"}, {"order": "52", "text": "R. Pascanu, \u00c7. G\u00fcl\u00e7ehre, K. Cho, Y. Bengio, How to construct deep recurrent neural networks, CoRR, vol. abs/1312.6026, 2013.", "title": "How to construct deep recurrent neural networks", "context": [{"sec": "sec2f", "text": " For instance, multi-layered RNNs [52] stack more than one RNN unit at each time step [59] with the aim of extracting more abstract features from the input sequence.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=How+to+construct+deep+recurrent+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref52"}, {"order": "53", "text": "J. Pennington, R. Socher, C. D. Manning, \"Glove: Global vectors for word representation\", <em>Empirical Methods in Natural Language Processing (EMNLP)</em>, pp. 1532-1543, 2014.", "title": "Glove: Global vectors for word representation", "context": [{"sec": "sec1", "text": " The approach generates high dimensional word vectors that capture distributional semantics and co-occurrence statistics for each word [53].", "part": "1"}, {"sec": "sec2a", "text": "Skip-gram with negative sampling [48], [50] and GloVe [53] are the most popular word embedding models due to the notable improvement they bring to word analogy tasks over more traditional approaches such as Latent Semantic Analysis [48], [53].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.3115/v1/D14-1162", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Glove%3A+Global+vectors+for+word+representation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref53"}, {"order": "54", "text": "N. Pinto, D. Doukhan, J. J. DiCarlo, D. D. Cox, \"A high-throughput screening approach to discovering good forms of biologically inspired visual representation\", <em>PLoS Comput Biol</em>, vol. 5, no. 11, pp. e1000579, 2009.", "title": "A high-throughput screening approach to discovering good forms of biologically inspired visual representation", "context": [{"sec": "sec4b", "text": "Finding suitable network settings and a good set of hyperparameters is crucial to the success of applying deep learning methods to practical problems [54].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1371/journal.pcbi.1000579", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+high-throughput+screening+approach+to+discovering+good+forms+of+biologically+inspired+visual+representation&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref54"}, {"order": "55", "text": "V. Raychev, M. Vechev, E. Yahav, \"Code completion with statistical language models\" in ACM SIGPLAN Notices, ACM, vol. 49, pp. 419-428, 2014.", "title": "Code completion with statistical language models", "context": [{"sec": "sec6", "text": " Raychev et al. adopted RNN and N-gram to build the language model for the task of synthesizing code completions [55].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2666356.2594321", "abstract": "We address the problem of synthesizing code completions for programs using APIs. Given a program with holes, we synthesize completions for holes with the most likely sequences of method calls. Our main idea is to reduce the problem of code completion to a natural-language processing problem of predicting probabilities of sentences. We design a simple and scalable static analysis that extracts sequences of method calls from a large codebase, and index these into a statistical language model. We t...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Code+completion+with+statistical+language+models&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref55"}, {"order": "56", "text": "P. Rempel, P. M\u00e4der, T. Kuschke, J. Cleland-Huang, \"Traceability gap analysis for assessing the conformance of software traceability to relevant guidelines\" in Software Engineering & Management 2015 Multikonferenz der GI-Fachbereiche Softwaretechnik (SWT) und Wirtschaftsinformatik(WI) FA WI-MAW 17. M\u00e4rz \u2212 20. M\u00e4rz 2015, Dresden, Germany, pp. 120-121, 2015.", "title": "Traceability gap analysis for assessing the conformance of software traceability to relevant guidelines", "context": [{"sec": "sec1", "text": " In practice, trace links are often incomplete and inaccurate [16], even in safety-critical systems [45], [56].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Traceability+gap+analysis+for+assessing+the+conformance+of+software+traceability+to+relevant+guidelines&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref56"}, {"order": "57", "text": "T. Rockt\u00e4schel, E. Grefenstette, K. M. Hermann, T. Kocisk\u00fd, P. Blunsom, Reasoning about entailment with neural attention, CoRR, vol. abs/1509.06664, 2015.", "title": "Reasoning about entailment with neural attention", "context": [{"sec": "sec2d", "text": " LSTM has been repeatedly applied to solve semantic relatedness tasks and has achieved convincing performance [66], [57].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Reasoning+about+entailment+with+neural+attention&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref57"}, {"order": "58", "text": "D. E. Rumelhart, G. E. Hinton, R. J. Williams, \"Learning representations by back-propagating errors\", <em>Nature</em>, vol. 323, no. 6088, pp. 533-536, 1986.", "title": "Learning representations by back-propagating errors", "context": [{"sec": "sec2", "text": " Backpropagation [58] is widely recognized as an effective method for training deep neural networks; it indicates how the network should adapt its internal parameters to better compute the representation in each layer.", "part": "1"}, {"sec": "sec2b", "text": " For NLP tasks, Recurrent neural networks (RNNs) are widely used and are recognized as a good fit to the unique needs of NLP [58].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1038/323533a0", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+representations+by+back-propagating+errors&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref58"}, {"order": "59", "text": "J. Schmidhuber, \"Learning complex extended sequences using the principle of history compression\", <em>Neural Computation</em>, vol. 4, no. 2, pp. 234-242, 1992.", "title": "Learning complex, extended sequences using the principle of history compression", "context": [{"sec": "sec2f", "text": " For instance, multi-layered RNNs [52] stack more than one RNN unit at each time step [59] with the aim of extracting more abstract features from the input sequence.", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1162/neco.1992.4.2.234", "abstract": "Previous neural network learning algorithms for sequence processing are computationally expensive and perform poorly when it comes to long time lags. This paper first introduces a simple principle for reducing the descriptions of event sequences without loss of information. A consequence of this principle is that only unexpected inputs can be relevant. This insight leads to the construction of neural architectures that learn to \u201cdivide and conquer\u201d by recursively decomposing sequences. I describ...", "pdfSize": "512KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Learning+complex%2C+extended+sequences+using+the+principle+of+history+compression&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref59"}, {"order": "60", "text": "M. Schuster, K. K. Paliwal, \"Bidirectional recurrent neural networks\", <em>IEEE Transactions on Signal Processing</em>, vol. 45, no. 11, pp. 2673-2681, 1997.", "title": "Bidirectional recurrent neural networks", "context": [{"sec": "sec2f", "text": " In contrast, bidirectional RNNs [60] process sequential data in both forward and backward directions at the same time; this enables the output to be influenced by both past and future data in the sequence.", "part": "1"}], "links": {"documentLink": "/document/650093", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=650093", "abstract": "In the first part of this paper, a regular recurrent neural network (RNN) is extended to a bidirectional recurrent neural network (BRNN). The BRNN can be trained without the limitation of using input information just up to a preset future frame. This is accomplished by training it simultaneously in positive and negative time direction. Structure and training procedure of the proposed network are explained. In regression and classification experiments on artificial data, the proposed structure gi...", "pdfSize": "260KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Bidirectional+recurrent+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref60"}, {"order": "61", "text": "Y. Shin, J. Cleland-Huang, \"A comparative evaluation of two user feedback techniques for requirements trace retrieval\", <em>SAC</em>, pp. 1069-1074, 2012.", "title": "A comparative evaluation of two user feedback techniques for requirements trace retrieval", "context": [{"sec": "sec6", "text": " Basic enhancements have included user feedback techniques such as Rocchio [34] or Direct Query manipulation (DQM) [61] to increase or decrease term weights.", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2245276.2231943", "abstract": "In automated requirements trace retrieval, significant improvements can be realized through incorporating user feedback. In this paper we introduce a relatively new technique named Direct Query Manipulation (DQM) and compare its effectiveness against Rocchio, the current defacto standard for integrating user feedback into automated tracing methods. The two techniques are evaluated empirically through a series of simulations and a user study, conducted by tracing requirements for WorldVista, an e...", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=A+comparative+evaluation+of+two+user+feedback+techniques+for+requirements+trace+retrieval&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref61"}, {"order": "62", "text": "P. Shvaiko, J. Euzenat, \"Ontology matching: State of the art and future challenges\", <em>IEEE Trans. Knowl. Data Eng.</em>, vol. 25, no. 1, pp. 158-176, 2013.", "title": "Ontology matching: State of the art and future challenges", "context": [{"sec": "sec6", "text": "Researchers have also explored the use of knowledge bases to create and utilize semantically aware associations in the trace creation process - where a knowledge base include basic domain terms and sentences that describe the relationships between those terms [36], [27], [62].", "part": "1"}], "links": {"documentLink": "/document/6104044", "pdfLink": "/stamp/stamp.jsp?tp=&arnumber=6104044", "abstract": "After years of research on ontology matching, it is reasonable to consider several questions: is the field of ontology matching still making progress? Is this progress significant enough to pursue further research? If so, what are the particularly promising directions? To answer these questions, we review the state of the art of ontology matching and analyze the results of recent ontology matching evaluations. These results show a measurable improvement in the field, the speed of which is albeit...", "pdfSize": "1155KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Ontology+matching%3A+State+of+the+art+and+future+challenges&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref62"}, {"order": "63", "text": "R. Socher, C. C. Lin, C. Manning, A. Y. Ng, \"Parsing natural scenes and natural language with recursive neural networks\", <em>Proceedings of the 28th internationalconference on machine learning (ICML-11)</em>, pp. 129-136, 2011.", "title": "Parsing natural scenes and natural language with recursive neural networks", "context": [{"sec": "sec1", "text": "On the other hand, deep learning techniques have successfully been applied to solve many Natural Language Processing (NLP) tasks including parsing [63], sentiment analysis [66], question answering [35], and machine translation [6].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Parsing+natural+scenes+and+natural+language+with+recursive+neural+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref63"}, {"order": "64", "text": "G. Spanoudakis, A. Zisman, E. P\u00e9rez-Mi\u00f1ana, P. Krause, \"Rule-based generation of requirements traceability relations\", <em>Journal of Systems and Software</em>, vol. 72, no. 2, pp. 105-127, 2004.", "title": "Rule-based generation of requirements traceability relations", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1016/S0164-1212(03)00242-5", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Rule-based+generation+of+requirements+traceability+relations&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref64"}, {"order": "65", "text": "H. Sultanov, J. Huffman Hayes, W.-K. Kong, \"Application of swarm techniques to requirements tracing\", <em>Requirements Engineering</em>, vol. 16, no. 3, pp. 209-226, 2011.", "title": "Application of swarm techniques to requirements tracing", "context": [{"sec": "sec1", "text": " Solutions have included information retrieval approaches [17], [18], [5], machine learning [47], [30], [51], heuristic techniques [64], [28], and AI swarming algorithms [65].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s00766-011-0121-4", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Application+of+swarm+techniques+to+requirements+tracing&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref65"}, {"order": "66", "text": "K. S. Tai, R. Socher, C. D. Manning, <em>Improved semantic representations from tree-structured long short-term memory networks</em>, 2015.", "title": "Improved semantic representations from tree-structured long short-term memory networks", "context": [{"sec": "sec1", "text": "On the other hand, deep learning techniques have successfully been applied to solve many Natural Language Processing (NLP) tasks including parsing [63], sentiment analysis [66], question answering [35], and machine translation [6].", "part": "1"}, {"sec": "sec2b", "text": " In particular, RNN and its variants have produced significant breakthroughs in many NLP tasks including language modeling [49], machine translation [6], and semantic entailment [66].", "part": "1"}, {"sec": "sec2d", "text": " LSTM has been repeatedly applied to solve semantic relatedness tasks and has achieved convincing performance [66], [57].", "part": "1"}, {"sec": "sec3a", "text": " [66], targeted to perform semantic entailment classification tasks for sentence pairs.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improved+semantic+representations+from+tree-structured+long+short-term+memory+networks&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref66"}, {"order": "67", "text": "T. Tieleman, G. Hinton, \"Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude\", <em>COURSERA: Neural Networks for Machine Learning</em>, vol. 4, no. 2, 2012.", "title": "Lecture 6.5-rmsprop: Divide the gradient by a running average of its recent magnitude", "context": [{"sec": "sec3b", "text": "Based on this loss function, we used a stochastic gradient descent method [67] to update the network parameters.", "part": "1"}, {"sec": "sec3b", "text": " During training, we adopted an adaptive learning rate procedure [67] to adjust the learning rate based on the current training performance.", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Lecture+6.5-rmsprop%3A+Divide+the+gradient+by+a+running+average+of+its+recent+magnitude&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref67"}, {"order": "68", "text": "<em>Federal Railroad Administration. PTC System Information</em>,  [online]  Available: https://www.fra.dot.gov/Page/P0358.", "title": "Federal Railroad Administration. PTC System Information", "context": [{"sec": "sec1", "text": " PTC is a communication-based train control system designed to ensure that trains follow directives in order to prevent accidents from occurring [68].", "part": "1"}], "googleScholarLink": "https://scholar.google.com/scholar?as_q=Federal+Railroad+Administration.+PTC+System+Information&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref68"}, {"order": "69", "text": "S. Wang, T. Liu, L. Tan, \"Automatically learning semantic features for defect prediction\", <em>Proceedings of the 38th International Conference on Software Engineering</em>, pp. 297-308, 2016.", "title": "Automatically learning semantic features for defect prediction", "context": [{"sec": "sec6", "text": " Wang et al. utilized a deep belief network to extract semantic features from source code for the purpose of defect prediction [69].", "part": "1"}], "links": {"acmLink": "https://doi.org/10.1145/2884781.2884804", "abstract": "Software defect prediction, which predicts defective code regions, can help developers find bugs and prioritize their testing efforts. To build accurate prediction models, previous studies focus on manually designing features that encode the characteristics of programs and exploring different machine learning algorithms. Existing traditional features often fail to capture the semantic differences of programs, and such a capability is needed for building accurate prediction models. To bridge the ...", "pdfSize": "1876KB", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Automatically+learning+semantic+features+for+defect+prediction&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref69"}, {"order": "70", "text": "X. Zou, R. Settimi, J. Cleland-Huang, \"Improving automated requirements trace retrieval: a study of term-based enhancement methods\", <em>Empirical Software Engineering</em>, vol. 15, no. 2, pp. 119-146, 2010.", "title": "Improving automated requirements trace retrieval: a study of term-based enhancement methods", "context": [{"sec": "sec6", "text": " Researchers have also used phrase detection and chunking to search for requirements impacted by change requests [2] or to improve the trace retrieval process [70].", "part": "1"}], "links": {"crossRefLink": "https://doi.org/10.1007/s10664-009-9114-z", "openUrlImgLoc": "/assets/img/btn.find-in-library.png"}, "googleScholarLink": "https://scholar.google.com/scholar?as_q=Improving+automated+requirements+trace+retrieval%3A+a+study+of+term-based+enhancement+methods&as_occt=title&hl=en&as_sdt=0%2C31", "refType": "biblio", "id": "ref70"}], "pdfLink": "https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7985645", "articleId": "7985645", "startPage": "3", "endPage": "14", "pubLink": "https://ieeexplore.ieee.org/xpl/conhome/7976701/proceeding", "issueLink": "https://ieeexplore.ieee.org/xpl/tocresult.jsp?isnumber=7985634", "publisher": "IEEE", "confLoc": "Buenos Aires, Argentina", "chronDate": "20-28 May 2017", "metrics": {"citationCountPaper": 31, "citationCountPatent": 0, "totalDownloads": 1819}}
